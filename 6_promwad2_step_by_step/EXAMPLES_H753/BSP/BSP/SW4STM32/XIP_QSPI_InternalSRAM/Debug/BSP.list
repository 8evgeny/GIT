
BSP.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  90000000  90000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0001e524  900002a0  900002a0  000102a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00007188  9001e7c8  9001e7c8  0002e7c8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  90025950  90025950  00035950  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000008  90025958  90025958  00035958  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  90025960  90025960  00035960  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00001160  24000000  90025964  00040000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000a2e4  24001160  90026ac4  00041160  2**5
                  ALLOC
  8 ._user_heap_stack 00000c04  2400b444  90026ac4  0004b444  2**0
                  ALLOC
  9 .data_RAM_D3  00000000  38000000  38000000  00050200  2**0
                  CONTENTS
 10 .bss_RAM_D3   00000000  38000000  38000000  00050200  2**0
                  CONTENTS
 11 .ARM.attributes 00000032  00000000  00000000  00050200  2**0
                  CONTENTS, READONLY
 12 .RAM_D3       00000200  38000000  90026ac4  00050000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
 13 .debug_info   0005ec7a  00000000  00000000  00050232  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 00007e92  00000000  00000000  000aeeac  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00002fe8  00000000  00000000  000b6d40  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00002d88  00000000  00000000  000b9d28  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00045ee8  00000000  00000000  000bcab0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0003615f  00000000  00000000  00102998  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    001a542a  00000000  00000000  00138af7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      0000032c  00000000  00000000  002ddf21  2**0
                  CONTENTS, READONLY
 21 .iar.rtmodel  00000026  00000000  00000000  002de24d  2**0
                  CONTENTS, READONLY
 22 .iar_vfe_header 00000004  00000000  00000000  002de274  2**2
                  CONTENTS, READONLY
 23 .debug_frame  0000ea24  00000000  00000000  002de278  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

900002a0 <__do_global_dtors_aux>:
900002a0:	b510      	push	{r4, lr}
900002a2:	4c05      	ldr	r4, [pc, #20]	; (900002b8 <__do_global_dtors_aux+0x18>)
900002a4:	7823      	ldrb	r3, [r4, #0]
900002a6:	b933      	cbnz	r3, 900002b6 <__do_global_dtors_aux+0x16>
900002a8:	4b04      	ldr	r3, [pc, #16]	; (900002bc <__do_global_dtors_aux+0x1c>)
900002aa:	b113      	cbz	r3, 900002b2 <__do_global_dtors_aux+0x12>
900002ac:	4804      	ldr	r0, [pc, #16]	; (900002c0 <__do_global_dtors_aux+0x20>)
900002ae:	f3af 8000 	nop.w
900002b2:	2301      	movs	r3, #1
900002b4:	7023      	strb	r3, [r4, #0]
900002b6:	bd10      	pop	{r4, pc}
900002b8:	24001160 	.word	0x24001160
900002bc:	00000000 	.word	0x00000000
900002c0:	9001e7ac 	.word	0x9001e7ac

900002c4 <frame_dummy>:
900002c4:	b508      	push	{r3, lr}
900002c6:	4b03      	ldr	r3, [pc, #12]	; (900002d4 <frame_dummy+0x10>)
900002c8:	b11b      	cbz	r3, 900002d2 <frame_dummy+0xe>
900002ca:	4903      	ldr	r1, [pc, #12]	; (900002d8 <frame_dummy+0x14>)
900002cc:	4803      	ldr	r0, [pc, #12]	; (900002dc <frame_dummy+0x18>)
900002ce:	f3af 8000 	nop.w
900002d2:	bd08      	pop	{r3, pc}
900002d4:	00000000 	.word	0x00000000
900002d8:	24001164 	.word	0x24001164
900002dc:	9001e7ac 	.word	0x9001e7ac

900002e0 <PDM_Filter_Init>:
900002e0:	b5f0      	push	{r4, r5, r6, r7, lr}
900002e2:	4605      	mov	r5, r0
900002e4:	b081      	sub	sp, #4
900002e6:	2140      	movs	r1, #64	; 0x40
900002e8:	f105 000c 	add.w	r0, r5, #12
900002ec:	f019 fc1d 	bl	90019b2a <__aeabi_memclr>
900002f0:	f8df 0c1c 	ldr.w	r0, [pc, #3100]	; 90000f10 <.text_18>
900002f4:	f8df 1c1c 	ldr.w	r1, [pc, #3100]	; 90000f14 <.text_19>
900002f8:	6802      	ldr	r2, [r0, #0]
900002fa:	2400      	movs	r4, #0
900002fc:	f24c 2640 	movw	r6, #49728	; 0xc240
90000300:	0852      	lsrs	r2, r2, #1
90000302:	0052      	lsls	r2, r2, #1
90000304:	6002      	str	r2, [r0, #0]
90000306:	680b      	ldr	r3, [r1, #0]
90000308:	f64f 70f0 	movw	r0, #65520	; 0xfff0
9000030c:	4003      	ands	r3, r0
9000030e:	42b3      	cmp	r3, r6
90000310:	bf1f      	itttt	ne
90000312:	6809      	ldrne	r1, [r1, #0]
90000314:	4008      	andne	r0, r1
90000316:	f24c 2270 	movwne	r2, #49776	; 0xc270
9000031a:	4290      	cmpne	r0, r2
9000031c:	d135      	bne.n	9000038a <PDM_Filter_Init+0xaa>
9000031e:	f8df 3bf8 	ldr.w	r3, [pc, #3064]	; 90000f18 <.text_20>
90000322:	6818      	ldr	r0, [r3, #0]
90000324:	bb88      	cbnz	r0, 9000038a <PDM_Filter_Init+0xaa>
90000326:	f8df 0bf4 	ldr.w	r0, [pc, #3060]	; 90000f1c <.text_21>
9000032a:	6801      	ldr	r1, [r0, #0]
9000032c:	f3c1 010b 	ubfx	r1, r1, #0, #12
90000330:	f5b1 6f8a 	cmp.w	r1, #1104	; 0x450
90000334:	bf1f      	itttt	ne
90000336:	6800      	ldrne	r0, [r0, #0]
90000338:	f3c0 000b 	ubfxne	r0, r0, #0, #12
9000033c:	f240 4183 	movwne	r1, #1155	; 0x483
90000340:	4288      	cmpne	r0, r1
90000342:	d122      	bne.n	9000038a <PDM_Filter_Init+0xaa>
90000344:	f8df 1bd8 	ldr.w	r1, [pc, #3032]	; 90000f20 <.text_22>
90000348:	2201      	movs	r2, #1
9000034a:	608a      	str	r2, [r1, #8]
9000034c:	6888      	ldr	r0, [r1, #8]
9000034e:	2800      	cmp	r0, #0
90000350:	d1fc      	bne.n	9000034c <PDM_Filter_Init+0x6c>
90000352:	f8df 2bd0 	ldr.w	r2, [pc, #3024]	; 90000f24 <.text_23>
90000356:	f8df 3bd0 	ldr.w	r3, [pc, #3024]	; 90000f28 <.text_24>
9000035a:	600a      	str	r2, [r1, #0]
9000035c:	6809      	ldr	r1, [r1, #0]
9000035e:	4299      	cmp	r1, r3
90000360:	d022      	beq.n	900003a8 <PDM_Filter_Init+0xc8>
90000362:	6468      	str	r0, [r5, #68]	; 0x44
90000364:	6168      	str	r0, [r5, #20]
90000366:	896a      	ldrh	r2, [r5, #10]
90000368:	61e8      	str	r0, [r5, #28]
9000036a:	8928      	ldrh	r0, [r5, #8]
9000036c:	61ac      	str	r4, [r5, #24]
9000036e:	612c      	str	r4, [r5, #16]
90000370:	60ec      	str	r4, [r5, #12]
90000372:	626c      	str	r4, [r5, #36]	; 0x24
90000374:	622c      	str	r4, [r5, #32]
90000376:	86aa      	strh	r2, [r5, #52]	; 0x34
90000378:	86e8      	strh	r0, [r5, #54]	; 0x36
9000037a:	642c      	str	r4, [r5, #64]	; 0x40
9000037c:	8828      	ldrh	r0, [r5, #0]
9000037e:	2801      	cmp	r0, #1
90000380:	d014      	beq.n	900003ac <PDM_Filter_Init+0xcc>
90000382:	2800      	cmp	r0, #0
90000384:	d05d      	beq.n	90000442 <PDM_Filter_Init+0x162>
90000386:	2402      	movs	r4, #2
90000388:	e0a3      	b.n	900004d2 <PDM_Filter_Init+0x1f2>
9000038a:	f8df 1ba0 	ldr.w	r1, [pc, #2976]	; 90000f2c <.text_25>
9000038e:	2201      	movs	r2, #1
90000390:	608a      	str	r2, [r1, #8]
90000392:	6888      	ldr	r0, [r1, #8]
90000394:	2800      	cmp	r0, #0
90000396:	d1fc      	bne.n	90000392 <PDM_Filter_Init+0xb2>
90000398:	f8df 2b88 	ldr.w	r2, [pc, #2952]	; 90000f24 <.text_23>
9000039c:	f8df 3b88 	ldr.w	r3, [pc, #2952]	; 90000f28 <.text_24>
900003a0:	600a      	str	r2, [r1, #0]
900003a2:	6809      	ldr	r1, [r1, #0]
900003a4:	4299      	cmp	r1, r3
900003a6:	d1dc      	bne.n	90000362 <PDM_Filter_Init+0x82>
900003a8:	646b      	str	r3, [r5, #68]	; 0x44
900003aa:	e7db      	b.n	90000364 <PDM_Filter_Init+0x84>
900003ac:	f8df 1b80 	ldr.w	r1, [pc, #2944]	; 90000f30 <.text_26>
900003b0:	7808      	ldrb	r0, [r1, #0]
900003b2:	2800      	cmp	r0, #0
900003b4:	f040 808d 	bne.w	900004d2 <PDM_Filter_Init+0x1f2>
900003b8:	2300      	movs	r3, #0
900003ba:	f8df 0b78 	ldr.w	r0, [pc, #2936]	; 90000f34 <.text_27>
900003be:	f8df 2b78 	ldr.w	r2, [pc, #2936]	; 90000f38 <.text_28>
900003c2:	1d0e      	adds	r6, r1, #4
900003c4:	f856 6023 	ldr.w	r6, [r6, r3, lsl #2]
900003c8:	ea02 5706 	and.w	r7, r2, r6, lsl #20
900003cc:	ea00 0c06 	and.w	ip, r0, r6
900003d0:	f3c6 5609 	ubfx	r6, r6, #20, #10
900003d4:	4467      	add	r7, ip
900003d6:	19f7      	adds	r7, r6, r7
900003d8:	1d0e      	adds	r6, r1, #4
900003da:	f846 7023 	str.w	r7, [r6, r3, lsl #2]
900003de:	1c5b      	adds	r3, r3, #1
900003e0:	1d0f      	adds	r7, r1, #4
900003e2:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
900003e6:	ea02 5c06 	and.w	ip, r2, r6, lsl #20
900003ea:	ea00 0e06 	and.w	lr, r0, r6
900003ee:	f3c6 5609 	ubfx	r6, r6, #20, #10
900003f2:	44f4      	add	ip, lr
900003f4:	44b4      	add	ip, r6
900003f6:	1d0e      	adds	r6, r1, #4
900003f8:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
900003fc:	1c5b      	adds	r3, r3, #1
900003fe:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
90000402:	ea02 5c06 	and.w	ip, r2, r6, lsl #20
90000406:	ea00 0e06 	and.w	lr, r0, r6
9000040a:	f3c6 5609 	ubfx	r6, r6, #20, #10
9000040e:	44f4      	add	ip, lr
90000410:	44b4      	add	ip, r6
90000412:	1d0e      	adds	r6, r1, #4
90000414:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
90000418:	1c5b      	adds	r3, r3, #1
9000041a:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
9000041e:	ea02 5c06 	and.w	ip, r2, r6, lsl #20
90000422:	ea00 0e06 	and.w	lr, r0, r6
90000426:	f3c6 5609 	ubfx	r6, r6, #20, #10
9000042a:	44f4      	add	ip, lr
9000042c:	44b4      	add	ip, r6
9000042e:	1d0e      	adds	r6, r1, #4
90000430:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
90000434:	1c5b      	adds	r3, r3, #1
90000436:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
9000043a:	dbc2      	blt.n	900003c2 <PDM_Filter_Init+0xe2>
9000043c:	2001      	movs	r0, #1
9000043e:	7008      	strb	r0, [r1, #0]
90000440:	e047      	b.n	900004d2 <PDM_Filter_Init+0x1f2>
90000442:	f8df 0aec 	ldr.w	r0, [pc, #2796]	; 90000f30 <.text_26>
90000446:	7801      	ldrb	r1, [r0, #0]
90000448:	2901      	cmp	r1, #1
9000044a:	d142      	bne.n	900004d2 <PDM_Filter_Init+0x1f2>
9000044c:	2300      	movs	r3, #0
9000044e:	f8df 1ae4 	ldr.w	r1, [pc, #2788]	; 90000f34 <.text_27>
90000452:	f8df 2ae4 	ldr.w	r2, [pc, #2788]	; 90000f38 <.text_28>
90000456:	1d06      	adds	r6, r0, #4
90000458:	f856 6023 	ldr.w	r6, [r6, r3, lsl #2]
9000045c:	ea02 5706 	and.w	r7, r2, r6, lsl #20
90000460:	ea01 0c06 	and.w	ip, r1, r6
90000464:	f3c6 5609 	ubfx	r6, r6, #20, #10
90000468:	4467      	add	r7, ip
9000046a:	19f7      	adds	r7, r6, r7
9000046c:	1d06      	adds	r6, r0, #4
9000046e:	f846 7023 	str.w	r7, [r6, r3, lsl #2]
90000472:	1c5b      	adds	r3, r3, #1
90000474:	1d07      	adds	r7, r0, #4
90000476:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
9000047a:	ea02 5c06 	and.w	ip, r2, r6, lsl #20
9000047e:	ea01 0e06 	and.w	lr, r1, r6
90000482:	f3c6 5609 	ubfx	r6, r6, #20, #10
90000486:	44f4      	add	ip, lr
90000488:	44b4      	add	ip, r6
9000048a:	1d06      	adds	r6, r0, #4
9000048c:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
90000490:	1c5b      	adds	r3, r3, #1
90000492:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
90000496:	ea02 5c06 	and.w	ip, r2, r6, lsl #20
9000049a:	ea01 0e06 	and.w	lr, r1, r6
9000049e:	f3c6 5609 	ubfx	r6, r6, #20, #10
900004a2:	44f4      	add	ip, lr
900004a4:	44b4      	add	ip, r6
900004a6:	1d06      	adds	r6, r0, #4
900004a8:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
900004ac:	1c5b      	adds	r3, r3, #1
900004ae:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
900004b2:	ea02 5c06 	and.w	ip, r2, r6, lsl #20
900004b6:	ea01 0e06 	and.w	lr, r1, r6
900004ba:	f3c6 5609 	ubfx	r6, r6, #20, #10
900004be:	44f4      	add	ip, lr
900004c0:	44b4      	add	ip, r6
900004c2:	1d06      	adds	r6, r0, #4
900004c4:	f846 c023 	str.w	ip, [r6, r3, lsl #2]
900004c8:	1c5b      	adds	r3, r3, #1
900004ca:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
900004ce:	dbc2      	blt.n	90000456 <PDM_Filter_Init+0x176>
900004d0:	7004      	strb	r4, [r0, #0]
900004d2:	8868      	ldrh	r0, [r5, #2]
900004d4:	b130      	cbz	r0, 900004e4 <PDM_Filter_Init+0x204>
900004d6:	2801      	cmp	r0, #1
900004d8:	bf11      	iteee	ne
900004da:	1c64      	addne	r4, r4, #1
900004dc:	6c28      	ldreq	r0, [r5, #64]	; 0x40
900004de:	f040 0020 	orreq.w	r0, r0, #32
900004e2:	6428      	streq	r0, [r5, #64]	; 0x40
900004e4:	8ea9      	ldrh	r1, [r5, #52]	; 0x34
900004e6:	2901      	cmp	r1, #1
900004e8:	bf04      	itt	eq
900004ea:	8ee8      	ldrheq	r0, [r5, #54]	; 0x36
900004ec:	2801      	cmpeq	r0, #1
900004ee:	d103      	bne.n	900004f8 <PDM_Filter_Init+0x218>
900004f0:	6c29      	ldr	r1, [r5, #64]	; 0x40
900004f2:	f041 0140 	orr.w	r1, r1, #64	; 0x40
900004f6:	6429      	str	r1, [r5, #64]	; 0x40
900004f8:	6868      	ldr	r0, [r5, #4]
900004fa:	b128      	cbz	r0, 90000508 <PDM_Filter_Init+0x228>
900004fc:	6c29      	ldr	r1, [r5, #64]	; 0x40
900004fe:	6868      	ldr	r0, [r5, #4]
90000500:	62e8      	str	r0, [r5, #44]	; 0x2c
90000502:	f041 0110 	orr.w	r1, r1, #16
90000506:	6429      	str	r1, [r5, #64]	; 0x40
90000508:	2100      	movs	r1, #0
9000050a:	8729      	strh	r1, [r5, #56]	; 0x38
9000050c:	b914      	cbnz	r4, 90000514 <PDM_Filter_Init+0x234>
9000050e:	6c28      	ldr	r0, [r5, #64]	; 0x40
90000510:	3080      	adds	r0, #128	; 0x80
90000512:	6428      	str	r0, [r5, #64]	; 0x40
90000514:	4620      	mov	r0, r4
90000516:	b001      	add	sp, #4
90000518:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

9000051c <PDM_Filter_setConfig>:
9000051c:	b5f0      	push	{r4, r5, r6, r7, lr}
9000051e:	b081      	sub	sp, #4
90000520:	4605      	mov	r5, r0
90000522:	460e      	mov	r6, r1
90000524:	2400      	movs	r4, #0
90000526:	ed2d 8b02 	vpush	{d8}
9000052a:	6c68      	ldr	r0, [r5, #68]	; 0x44
9000052c:	f8df 19f8 	ldr.w	r1, [pc, #2552]	; 90000f28 <.text_24>
90000530:	4288      	cmp	r0, r1
90000532:	bf18      	it	ne
90000534:	2004      	movne	r0, #4
90000536:	f040 80e3 	bne.w	90000700 <PDM_Filter_setConfig+0x1e4>
9000053a:	6c29      	ldr	r1, [r5, #64]	; 0x40
9000053c:	f421 7180 	bic.w	r1, r1, #256	; 0x100
90000540:	6429      	str	r1, [r5, #64]	; 0x40
90000542:	8832      	ldrh	r2, [r6, #0]
90000544:	2a05      	cmp	r2, #5
90000546:	bf18      	it	ne
90000548:	2a06      	cmpne	r2, #6
9000054a:	d01d      	beq.n	90000588 <PDM_Filter_setConfig+0x6c>
9000054c:	2a07      	cmp	r2, #7
9000054e:	bf18      	it	ne
90000550:	2a01      	cmpne	r2, #1
90000552:	d019      	beq.n	90000588 <PDM_Filter_setConfig+0x6c>
90000554:	2a02      	cmp	r2, #2
90000556:	bf1c      	itt	ne
90000558:	2a03      	cmpne	r2, #3
9000055a:	2a04      	cmpne	r2, #4
9000055c:	d014      	beq.n	90000588 <PDM_Filter_setConfig+0x6c>
9000055e:	2408      	movs	r4, #8
90000560:	f9b5 0038 	ldrsh.w	r0, [r5, #56]	; 0x38
90000564:	f9b6 1004 	ldrsh.w	r1, [r6, #4]
90000568:	4288      	cmp	r0, r1
9000056a:	bf04      	itt	eq
9000056c:	8e2b      	ldrheq	r3, [r5, #48]	; 0x30
9000056e:	4293      	cmpeq	r3, r2
90000570:	f000 80be 	beq.w	900006f0 <PDM_Filter_setConfig+0x1d4>
90000574:	f9b6 7004 	ldrsh.w	r7, [r6, #4]
90000578:	f117 0f0c 	cmn.w	r7, #12
9000057c:	da5d      	bge.n	9000063a <PDM_Filter_setConfig+0x11e>
9000057e:	f06f 000b 	mvn.w	r0, #11
90000582:	3440      	adds	r4, #64	; 0x40
90000584:	80b0      	strh	r0, [r6, #4]
90000586:	e0b1      	b.n	900006ec <PDM_Filter_setConfig+0x1d0>
90000588:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
9000058a:	4293      	cmp	r3, r2
9000058c:	d0e8      	beq.n	90000560 <PDM_Filter_setConfig+0x44>
9000058e:	0909      	lsrs	r1, r1, #4
90000590:	ea42 1101 	orr.w	r1, r2, r1, lsl #4
90000594:	6429      	str	r1, [r5, #64]	; 0x40
90000596:	f001 000f 	and.w	r0, r1, #15
9000059a:	f001 0170 	and.w	r1, r1, #112	; 0x70
9000059e:	2970      	cmp	r1, #112	; 0x70
900005a0:	d125      	bne.n	900005ee <PDM_Filter_setConfig+0xd2>
900005a2:	1e40      	subs	r0, r0, #1
900005a4:	2806      	cmp	r0, #6
900005a6:	d8db      	bhi.n	90000560 <PDM_Filter_setConfig+0x44>
900005a8:	e8df f000 	tbb	[pc, r0]
900005ac:	1d191511 	.word	0x1d191511
900005b0:	000d0905 	.word	0x000d0905
900005b4:	e7d4      	b.n	90000560 <PDM_Filter_setConfig+0x44>
900005b6:	f8df 0c08 	ldr.w	r0, [pc, #3080]	; 900011c0 <.text_30>
900005ba:	64a8      	str	r0, [r5, #72]	; 0x48
900005bc:	e7da      	b.n	90000574 <PDM_Filter_setConfig+0x58>
900005be:	f8df 1c04 	ldr.w	r1, [pc, #3076]	; 900011c4 <.text_31>
900005c2:	64a9      	str	r1, [r5, #72]	; 0x48
900005c4:	e7d6      	b.n	90000574 <PDM_Filter_setConfig+0x58>
900005c6:	f8df 0c00 	ldr.w	r0, [pc, #3072]	; 900011c8 <.text_32>
900005ca:	64a8      	str	r0, [r5, #72]	; 0x48
900005cc:	e7d2      	b.n	90000574 <PDM_Filter_setConfig+0x58>
900005ce:	f8df 1bfc 	ldr.w	r1, [pc, #3068]	; 900011cc <.text_33>
900005d2:	64a9      	str	r1, [r5, #72]	; 0x48
900005d4:	e7ce      	b.n	90000574 <PDM_Filter_setConfig+0x58>
900005d6:	f8df 0bf8 	ldr.w	r0, [pc, #3064]	; 900011d0 <.text_34>
900005da:	64a8      	str	r0, [r5, #72]	; 0x48
900005dc:	e7ca      	b.n	90000574 <PDM_Filter_setConfig+0x58>
900005de:	f8df 1bf4 	ldr.w	r1, [pc, #3060]	; 900011d4 <.text_35>
900005e2:	64a9      	str	r1, [r5, #72]	; 0x48
900005e4:	e7c6      	b.n	90000574 <PDM_Filter_setConfig+0x58>
900005e6:	f8df 0bf0 	ldr.w	r0, [pc, #3056]	; 900011d8 <.text_36>
900005ea:	64a8      	str	r0, [r5, #72]	; 0x48
900005ec:	e7c2      	b.n	90000574 <PDM_Filter_setConfig+0x58>
900005ee:	1e40      	subs	r0, r0, #1
900005f0:	2806      	cmp	r0, #6
900005f2:	d8b5      	bhi.n	90000560 <PDM_Filter_setConfig+0x44>
900005f4:	e8df f000 	tbb	[pc, r0]
900005f8:	1d191511 	.word	0x1d191511
900005fc:	000d0905 	.word	0x000d0905
90000600:	e7ae      	b.n	90000560 <PDM_Filter_setConfig+0x44>
90000602:	f20f 1159 	addw	r1, pc, #345	; 0x159
90000606:	64a9      	str	r1, [r5, #72]	; 0x48
90000608:	e7b4      	b.n	90000574 <PDM_Filter_setConfig+0x58>
9000060a:	f20f 2069 	addw	r0, pc, #617	; 0x269
9000060e:	64a8      	str	r0, [r5, #72]	; 0x48
90000610:	e7b0      	b.n	90000574 <PDM_Filter_setConfig+0x58>
90000612:	f20f 31d1 	addw	r1, pc, #977	; 0x3d1
90000616:	64a9      	str	r1, [r5, #72]	; 0x48
90000618:	e7ac      	b.n	90000574 <PDM_Filter_setConfig+0x58>
9000061a:	f20f 5035 	addw	r0, pc, #1333	; 0x535
9000061e:	64a8      	str	r0, [r5, #72]	; 0x48
90000620:	e7a8      	b.n	90000574 <PDM_Filter_setConfig+0x58>
90000622:	f20f 61ed 	addw	r1, pc, #1773	; 0x6ed
90000626:	64a9      	str	r1, [r5, #72]	; 0x48
90000628:	e7a4      	b.n	90000574 <PDM_Filter_setConfig+0x58>
9000062a:	f60f 1011 	addw	r0, pc, #2321	; 0x911
9000062e:	64a8      	str	r0, [r5, #72]	; 0x48
90000630:	e7a0      	b.n	90000574 <PDM_Filter_setConfig+0x58>
90000632:	f60f 31b1 	addw	r1, pc, #2993	; 0xbb1
90000636:	64a9      	str	r1, [r5, #72]	; 0x48
90000638:	e79c      	b.n	90000574 <PDM_Filter_setConfig+0x58>
9000063a:	2f34      	cmp	r7, #52	; 0x34
9000063c:	db03      	blt.n	90000646 <PDM_Filter_setConfig+0x12a>
9000063e:	2033      	movs	r0, #51	; 0x33
90000640:	3440      	adds	r4, #64	; 0x40
90000642:	80b0      	strh	r0, [r6, #4]
90000644:	e052      	b.n	900006ec <PDM_Filter_setConfig+0x1d0>
90000646:	f895 0040 	ldrb.w	r0, [r5, #64]	; 0x40
9000064a:	ed9f 8a86 	vldr	s16, [pc, #536]	; 90000864 <.text_8>
9000064e:	eddf 8a85 	vldr	s17, [pc, #532]	; 90000864 <.text_8>
90000652:	f000 000f 	and.w	r0, r0, #15
90000656:	1e40      	subs	r0, r0, #1
90000658:	2806      	cmp	r0, #6
9000065a:	d827      	bhi.n	900006ac <PDM_Filter_setConfig+0x190>
9000065c:	e8df f000 	tbb	[pc, r0]
90000660:	221d1813 	.word	0x221d1813
90000664:	000e0904 	.word	0x000e0904
90000668:	eeb3 8a00 	vmov.f32	s16, #48	; 0x41800000  16.0
9000066c:	eddf 8a7e 	vldr	s17, [pc, #504]	; 90000868 <.text_9>
90000670:	e01c      	b.n	900006ac <PDM_Filter_setConfig+0x190>
90000672:	eeb2 8a0c 	vmov.f32	s16, #44	; 0x41600000  14.0
90000676:	eddf 8a7d 	vldr	s17, [pc, #500]	; 9000086c <.text_10>
9000067a:	e017      	b.n	900006ac <PDM_Filter_setConfig+0x190>
9000067c:	eeb2 8a0a 	vmov.f32	s16, #42	; 0x41500000  13.0
90000680:	eef2 8a00 	vmov.f32	s17, #32	; 0x41000000  8.0
90000684:	e012      	b.n	900006ac <PDM_Filter_setConfig+0x190>
90000686:	eeb2 8a06 	vmov.f32	s16, #38	; 0x41300000  11.0
9000068a:	eddf 8a79 	vldr	s17, [pc, #484]	; 90000870 <.text_11>
9000068e:	e00d      	b.n	900006ac <PDM_Filter_setConfig+0x190>
90000690:	eeb2 8a04 	vmov.f32	s16, #36	; 0x41200000  10.0
90000694:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
90000698:	e008      	b.n	900006ac <PDM_Filter_setConfig+0x190>
9000069a:	eeb2 8a02 	vmov.f32	s16, #34	; 0x41100000  9.0
9000069e:	eddf 8acf 	vldr	s17, [pc, #828]	; 900009dc <.text_13>
900006a2:	e003      	b.n	900006ac <PDM_Filter_setConfig+0x190>
900006a4:	eeb1 8a0c 	vmov.f32	s16, #28	; 0x40e00000  7.0
900006a8:	eef4 8a00 	vmov.f32	s17, #64	; 0x3e000000  0.125
900006ac:	4638      	mov	r0, r7
900006ae:	eef3 0a04 	vmov.f32	s1, #52	; 0x41a00000  20.0
900006b2:	ee00 0a10 	vmov	s0, r0
900006b6:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
900006ba:	eec0 0a20 	vdiv.f32	s1, s0, s1
900006be:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
900006c2:	f01d fea1 	bl	9001e408 <powf>
900006c6:	ee60 8a28 	vmul.f32	s17, s0, s17
900006ca:	ed9f 1ac5 	vldr	s2, [pc, #788]	; 900009e0 <.text_14>
900006ce:	ee71 0a48 	vsub.f32	s1, s2, s16
900006d2:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
900006d6:	f01d fe97 	bl	9001e408 <powf>
900006da:	ee28 0a80 	vmul.f32	s0, s17, s0
900006de:	f01d fff7 	bl	9001e6d0 <roundf>
900006e2:	eebc 0ac0 	vcvt.u32.f32	s0, s0
900006e6:	872f      	strh	r7, [r5, #56]	; 0x38
900006e8:	ed85 0a0f 	vstr	s0, [r5, #60]	; 0x3c
900006ec:	8830      	ldrh	r0, [r6, #0]
900006ee:	8628      	strh	r0, [r5, #48]	; 0x30
900006f0:	8871      	ldrh	r1, [r6, #2]
900006f2:	8669      	strh	r1, [r5, #50]	; 0x32
900006f4:	b91c      	cbnz	r4, 900006fe <PDM_Filter_setConfig+0x1e2>
900006f6:	6c28      	ldr	r0, [r5, #64]	; 0x40
900006f8:	f440 7080 	orr.w	r0, r0, #256	; 0x100
900006fc:	6428      	str	r0, [r5, #64]	; 0x40
900006fe:	4620      	mov	r0, r4
90000700:	ecbd 8b02 	vpop	{d8}
90000704:	b001      	add	sp, #4
90000706:	bdf0      	pop	{r4, r5, r6, r7, pc}

90000708 <PDM_Filter_getConfig>:
90000708:	6c42      	ldr	r2, [r0, #68]	; 0x44
9000070a:	f8df 381c 	ldr.w	r3, [pc, #2076]	; 90000f28 <.text_24>
9000070e:	429a      	cmp	r2, r3
90000710:	d001      	beq.n	90000716 <PDM_Filter_getConfig+0xe>
90000712:	2004      	movs	r0, #4
90000714:	4770      	bx	lr
90000716:	8e42      	ldrh	r2, [r0, #50]	; 0x32
90000718:	804a      	strh	r2, [r1, #2]
9000071a:	8e03      	ldrh	r3, [r0, #48]	; 0x30
9000071c:	800b      	strh	r3, [r1, #0]
9000071e:	8f00      	ldrh	r0, [r0, #56]	; 0x38
90000720:	8088      	strh	r0, [r1, #4]
90000722:	2000      	movs	r0, #0
90000724:	4770      	bx	lr

90000726 <PDM_Filter>:
90000726:	b410      	push	{r4}
90000728:	b081      	sub	sp, #4
9000072a:	4613      	mov	r3, r2
9000072c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
9000072e:	f8df 47f8 	ldr.w	r4, [pc, #2040]	; 90000f28 <.text_24>
90000732:	42a2      	cmp	r2, r4
90000734:	bf18      	it	ne
90000736:	2004      	movne	r0, #4
90000738:	d106      	bne.n	90000748 <PDM_Filter+0x22>
9000073a:	6c1a      	ldr	r2, [r3, #64]	; 0x40
9000073c:	05d4      	lsls	r4, r2, #23
9000073e:	d406      	bmi.n	9000074e <PDM_Filter+0x28>
90000740:	2020      	movs	r0, #32
90000742:	0613      	lsls	r3, r2, #24
90000744:	bf58      	it	pl
90000746:	2030      	movpl	r0, #48	; 0x30
90000748:	b001      	add	sp, #4
9000074a:	bc10      	pop	{r4}
9000074c:	4770      	bx	lr
9000074e:	f103 020c 	add.w	r2, r3, #12
90000752:	6c9b      	ldr	r3, [r3, #72]	; 0x48
90000754:	b001      	add	sp, #4
90000756:	bc10      	pop	{r4}

90000758 <__iar_annotation$$tailcall>:
90000758:	4718      	bx	r3
	...

9000075c <D16_GENERIC>:
9000075c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90000760:	b086      	sub	sp, #24
90000762:	4613      	mov	r3, r2
90000764:	4682      	mov	sl, r0
90000766:	f8d3 e010 	ldr.w	lr, [r3, #16]
9000076a:	f8d3 8014 	ldr.w	r8, [r3, #20]
9000076e:	6998      	ldr	r0, [r3, #24]
90000770:	460c      	mov	r4, r1
90000772:	9004      	str	r0, [sp, #16]
90000774:	69df      	ldr	r7, [r3, #28]
90000776:	f8d3 c008 	ldr.w	ip, [r3, #8]
9000077a:	68d9      	ldr	r1, [r3, #12]
9000077c:	2500      	movs	r5, #0
9000077e:	9103      	str	r1, [sp, #12]
90000780:	6b5a      	ldr	r2, [r3, #52]	; 0x34
90000782:	f8d3 9030 	ldr.w	r9, [r3, #48]	; 0x30
90000786:	f8df 0a54 	ldr.w	r0, [pc, #2644]	; 900011dc <.text_37>
9000078a:	f8df 1a54 	ldr.w	r1, [pc, #2644]	; 900011e0 <.text_38>
9000078e:	f002 0610 	and.w	r6, r2, #16
90000792:	f002 0220 	and.w	r2, r2, #32
90000796:	9602      	str	r6, [sp, #8]
90000798:	9201      	str	r2, [sp, #4]
9000079a:	8cde      	ldrh	r6, [r3, #38]	; 0x26
9000079c:	f8df 2790 	ldr.w	r2, [pc, #1936]	; 90000f30 <.text_26>
900007a0:	2e00      	cmp	r6, #0
900007a2:	d04f      	beq.n	90000844 <D16_GENERIC+0xe8>
900007a4:	9405      	str	r4, [sp, #20]
900007a6:	8d5c      	ldrh	r4, [r3, #42]	; 0x2a
900007a8:	2c01      	cmp	r4, #1
900007aa:	d105      	bne.n	900007b8 <D16_GENERIC+0x5c>
900007ac:	9c01      	ldr	r4, [sp, #4]
900007ae:	f85a 6b02 	ldr.w	r6, [sl], #2
900007b2:	b154      	cbz	r4, 900007ca <D16_GENERIC+0x6e>
900007b4:	ba76      	rev16	r6, r6
900007b6:	e008      	b.n	900007ca <D16_GENERIC+0x6e>
900007b8:	f89a b000 	ldrb.w	fp, [sl]
900007bc:	b2e4      	uxtb	r4, r4
900007be:	f81a 6004 	ldrb.w	r6, [sl, r4]
900007c2:	eb0a 0a44 	add.w	sl, sl, r4, lsl #1
900007c6:	eb0b 2606 	add.w	r6, fp, r6, lsl #8
900007ca:	1d14      	adds	r4, r2, #4
900007cc:	f006 0bff 	and.w	fp, r6, #255	; 0xff
900007d0:	f854 402b 	ldr.w	r4, [r4, fp, lsl #2]
900007d4:	f3c6 2607 	ubfx	r6, r6, #8, #8
900007d8:	19e7      	adds	r7, r4, r7
900007da:	f3c7 0409 	ubfx	r4, r7, #0, #10
900007de:	46bb      	mov	fp, r7
900007e0:	1d17      	adds	r7, r2, #4
900007e2:	f857 7026 	ldr.w	r7, [r7, r6, lsl #2]
900007e6:	eb07 279b 	add.w	r7, r7, fp, lsr #10
900007ea:	f3c7 0609 	ubfx	r6, r7, #0, #10
900007ee:	0abf      	lsrs	r7, r7, #10
900007f0:	ea46 4604 	orr.w	r6, r6, r4, lsl #16
900007f4:	9c02      	ldr	r4, [sp, #8]
900007f6:	fb26 cb01 	smlad	fp, r6, r1, ip
900007fa:	fb26 fc00 	smuad	ip, r6, r0
900007fe:	f5ab 6b00 	sub.w	fp, fp, #2048	; 0x800
90000802:	b14c      	cbz	r4, 90000818 <D16_GENERIC+0xbc>
90000804:	6a1e      	ldr	r6, [r3, #32]
90000806:	44de      	add	lr, fp
90000808:	ebae 0e08 	sub.w	lr, lr, r8
9000080c:	46d8      	mov	r8, fp
9000080e:	fb5e fe16 	smmulr	lr, lr, r6
90000812:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
90000816:	46f3      	mov	fp, lr
90000818:	9e05      	ldr	r6, [sp, #20]
9000081a:	ea4f 4b0b 	mov.w	fp, fp, lsl #16
9000081e:	9600      	str	r6, [sp, #0]
90000820:	fb5b f419 	smmulr	r4, fp, r9
90000824:	8d1e      	ldrh	r6, [r3, #40]	; 0x28
90000826:	fa1f fb85 	uxth.w	fp, r5
9000082a:	1c6d      	adds	r5, r5, #1
9000082c:	f324 048f 	ssat	r4, #16, r4, asr #2
90000830:	fb06 f60b 	mul.w	r6, r6, fp
90000834:	f8dd b000 	ldr.w	fp, [sp]
90000838:	f82b 4016 	strh.w	r4, [fp, r6, lsl #1]
9000083c:	8cde      	ldrh	r6, [r3, #38]	; 0x26
9000083e:	b2ac      	uxth	r4, r5
90000840:	42b4      	cmp	r4, r6
90000842:	d3b0      	bcc.n	900007a6 <D16_GENERIC+0x4a>
90000844:	f8c3 c008 	str.w	ip, [r3, #8]
90000848:	9803      	ldr	r0, [sp, #12]
9000084a:	60d8      	str	r0, [r3, #12]
9000084c:	61df      	str	r7, [r3, #28]
9000084e:	f8c3 e010 	str.w	lr, [r3, #16]
90000852:	f8c3 8014 	str.w	r8, [r3, #20]
90000856:	9804      	ldr	r0, [sp, #16]
90000858:	6198      	str	r0, [r3, #24]
9000085a:	2000      	movs	r0, #0
9000085c:	b006      	add	sp, #24
9000085e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

90000864 <.text_8>:
90000864:	00000000 	.word	0x00000000

90000868 <.text_9>:
90000868:	42800000 	.word	0x42800000

9000086c <.text_10>:
9000086c:	4197b426 	.word	0x4197b426

90000870 <.text_11>:
90000870:	4017b426 	.word	0x4017b426

90000874 <D24_GENERIC>:
90000874:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90000878:	b084      	sub	sp, #16
9000087a:	4607      	mov	r7, r0
9000087c:	4688      	mov	r8, r1
9000087e:	6910      	ldr	r0, [r2, #16]
90000880:	6951      	ldr	r1, [r2, #20]
90000882:	6993      	ldr	r3, [r2, #24]
90000884:	9302      	str	r3, [sp, #8]
90000886:	6b56      	ldr	r6, [r2, #52]	; 0x34
90000888:	69d3      	ldr	r3, [r2, #28]
9000088a:	f8d2 9008 	ldr.w	r9, [r2, #8]
9000088e:	f8d2 c00c 	ldr.w	ip, [r2, #12]
90000892:	f8d2 e030 	ldr.w	lr, [r2, #48]	; 0x30
90000896:	f006 0b10 	and.w	fp, r6, #16
9000089a:	f006 0620 	and.w	r6, r6, #32
9000089e:	f8cd b004 	str.w	fp, [sp, #4]
900008a2:	2500      	movs	r5, #0
900008a4:	9600      	str	r6, [sp, #0]
900008a6:	8cd6      	ldrh	r6, [r2, #38]	; 0x26
900008a8:	f8df a684 	ldr.w	sl, [pc, #1668]	; 90000f30 <.text_26>
900008ac:	2e00      	cmp	r6, #0
900008ae:	f000 8087 	beq.w	900009c0 <D24_GENERIC+0x14c>
900008b2:	f8cd 800c 	str.w	r8, [sp, #12]
900008b6:	46a8      	mov	r8, r5
900008b8:	8d55      	ldrh	r5, [r2, #42]	; 0x2a
900008ba:	2d01      	cmp	r5, #1
900008bc:	d122      	bne.n	90000904 <D24_GENERIC+0x90>
900008be:	9d00      	ldr	r5, [sp, #0]
900008c0:	783c      	ldrb	r4, [r7, #0]
900008c2:	b1bd      	cbz	r5, 900008f4 <D24_GENERIC+0x80>
900008c4:	eb08 7bd8 	add.w	fp, r8, r8, lsr #31
900008c8:	78fe      	ldrb	r6, [r7, #3]
900008ca:	ea4f 0b6b 	mov.w	fp, fp, asr #1
900008ce:	ebb8 054b 	subs.w	r5, r8, fp, lsl #1
900008d2:	d107      	bne.n	900008e4 <D24_GENERIC+0x70>
900008d4:	0224      	lsls	r4, r4, #8
900008d6:	787d      	ldrb	r5, [r7, #1]
900008d8:	eb04 4406 	add.w	r4, r4, r6, lsl #16
900008dc:	1cbf      	adds	r7, r7, #2
900008de:	1964      	adds	r4, r4, r5
900008e0:	e01e      	b.n	90000920 <D24_GENERIC+0xac>
900008e2:	bf00      	nop
900008e4:	f897 b002 	ldrb.w	fp, [r7, #2]
900008e8:	0236      	lsls	r6, r6, #8
900008ea:	eb06 460b 	add.w	r6, r6, fp, lsl #16
900008ee:	1d3f      	adds	r7, r7, #4
900008f0:	19a4      	adds	r4, r4, r6
900008f2:	e015      	b.n	90000920 <D24_GENERIC+0xac>
900008f4:	787e      	ldrb	r6, [r7, #1]
900008f6:	78bd      	ldrb	r5, [r7, #2]
900008f8:	1cff      	adds	r7, r7, #3
900008fa:	0236      	lsls	r6, r6, #8
900008fc:	eb06 4605 	add.w	r6, r6, r5, lsl #16
90000900:	19a4      	adds	r4, r4, r6
90000902:	e00d      	b.n	90000920 <D24_GENERIC+0xac>
90000904:	b2ed      	uxtb	r5, r5
90000906:	f897 b000 	ldrb.w	fp, [r7]
9000090a:	5d7e      	ldrb	r6, [r7, r5]
9000090c:	f817 4015 	ldrb.w	r4, [r7, r5, lsl #1]
90000910:	eb05 0545 	add.w	r5, r5, r5, lsl #1
90000914:	0236      	lsls	r6, r6, #8
90000916:	eb06 4604 	add.w	r6, r6, r4, lsl #16
9000091a:	442f      	add	r7, r5
9000091c:	eb06 040b 	add.w	r4, r6, fp
90000920:	f10a 0504 	add.w	r5, sl, #4
90000924:	f004 06ff 	and.w	r6, r4, #255	; 0xff
90000928:	0a24      	lsrs	r4, r4, #8
9000092a:	f855 5026 	ldr.w	r5, [r5, r6, lsl #2]
9000092e:	f10a 0b04 	add.w	fp, sl, #4
90000932:	f004 06ff 	and.w	r6, r4, #255	; 0xff
90000936:	f85b 6026 	ldr.w	r6, [fp, r6, lsl #2]
9000093a:	eb05 2593 	add.w	r5, r5, r3, lsr #10
9000093e:	0a24      	lsrs	r4, r4, #8
90000940:	eb06 2695 	add.w	r6, r6, r5, lsr #10
90000944:	f3c5 0309 	ubfx	r3, r5, #0, #10
90000948:	f3c6 0509 	ubfx	r5, r6, #0, #10
9000094c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
90000950:	f85b 3024 	ldr.w	r3, [fp, r4, lsl #2]
90000954:	f8df 4888 	ldr.w	r4, [pc, #2184]	; 900011e0 <.text_38>
90000958:	f04f 0b01 	mov.w	fp, #1
9000095c:	eb03 2396 	add.w	r3, r3, r6, lsr #10
90000960:	fb25 c404 	smlad	r4, r5, r4, ip
90000964:	f8df cdf8 	ldr.w	ip, [pc, #3576]	; 90001760 <.text_42>
90000968:	f3c3 0609 	ubfx	r6, r3, #0, #10
9000096c:	fb25 9c0c 	smlad	ip, r5, ip, r9
90000970:	eb06 0946 	add.w	r9, r6, r6, lsl #1
90000974:	eb06 0646 	add.w	r6, r6, r6, lsl #1
90000978:	f5a4 54d8 	sub.w	r4, r4, #6912	; 0x1b00
9000097c:	eb0c 0c49 	add.w	ip, ip, r9, lsl #1
90000980:	fb25 f90b 	smuad	r9, r5, fp
90000984:	9d01      	ldr	r5, [sp, #4]
90000986:	44b1      	add	r9, r6
90000988:	b13d      	cbz	r5, 9000099a <D24_GENERIC+0x126>
9000098a:	6a16      	ldr	r6, [r2, #32]
9000098c:	1820      	adds	r0, r4, r0
9000098e:	1a40      	subs	r0, r0, r1
90000990:	4621      	mov	r1, r4
90000992:	fb50 f016 	smmulr	r0, r0, r6
90000996:	0040      	lsls	r0, r0, #1
90000998:	4604      	mov	r4, r0
9000099a:	8d16      	ldrh	r6, [r2, #40]	; 0x28
9000099c:	03a4      	lsls	r4, r4, #14
9000099e:	fb54 f51e 	smmulr	r5, r4, lr
900009a2:	9c03      	ldr	r4, [sp, #12]
900009a4:	fb06 f608 	mul.w	r6, r6, r8
900009a8:	f108 0801 	add.w	r8, r8, #1
900009ac:	fa1f f888 	uxth.w	r8, r8
900009b0:	f325 058f 	ssat	r5, #16, r5, asr #2
900009b4:	f824 5016 	strh.w	r5, [r4, r6, lsl #1]
900009b8:	8cd5      	ldrh	r5, [r2, #38]	; 0x26
900009ba:	45a8      	cmp	r8, r5
900009bc:	f6ff af7c 	blt.w	900008b8 <D24_GENERIC+0x44>
900009c0:	f8c2 9008 	str.w	r9, [r2, #8]
900009c4:	f8c2 c00c 	str.w	ip, [r2, #12]
900009c8:	61d3      	str	r3, [r2, #28]
900009ca:	6110      	str	r0, [r2, #16]
900009cc:	6151      	str	r1, [r2, #20]
900009ce:	9802      	ldr	r0, [sp, #8]
900009d0:	6190      	str	r0, [r2, #24]
900009d2:	2000      	movs	r0, #0
900009d4:	b004      	add	sp, #16
900009d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

900009dc <.text_13>:
900009dc:	3f03126f 	.word	0x3f03126f

900009e0 <.text_14>:
900009e0:	42000000 	.word	0x42000000

900009e4 <D32_GENERIC>:
900009e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
900009e8:	b084      	sub	sp, #16
900009ea:	4682      	mov	sl, r0
900009ec:	4688      	mov	r8, r1
900009ee:	6910      	ldr	r0, [r2, #16]
900009f0:	6951      	ldr	r1, [r2, #20]
900009f2:	6993      	ldr	r3, [r2, #24]
900009f4:	9302      	str	r3, [sp, #8]
900009f6:	6b57      	ldr	r7, [r2, #52]	; 0x34
900009f8:	69d3      	ldr	r3, [r2, #28]
900009fa:	6894      	ldr	r4, [r2, #8]
900009fc:	f8d2 c00c 	ldr.w	ip, [r2, #12]
90000a00:	f8d2 e030 	ldr.w	lr, [r2, #48]	; 0x30
90000a04:	f007 0b10 	and.w	fp, r7, #16
90000a08:	f007 0720 	and.w	r7, r7, #32
90000a0c:	f8cd b004 	str.w	fp, [sp, #4]
90000a10:	2600      	movs	r6, #0
90000a12:	9700      	str	r7, [sp, #0]
90000a14:	8cd7      	ldrh	r7, [r2, #38]	; 0x26
90000a16:	f8df 9518 	ldr.w	r9, [pc, #1304]	; 90000f30 <.text_26>
90000a1a:	2f00      	cmp	r7, #0
90000a1c:	f000 808b 	beq.w	90000b36 <D32_GENERIC+0x152>
90000a20:	f8cd 800c 	str.w	r8, [sp, #12]
90000a24:	46f0      	mov	r8, lr
90000a26:	8d55      	ldrh	r5, [r2, #42]	; 0x2a
90000a28:	2d01      	cmp	r5, #1
90000a2a:	d106      	bne.n	90000a3a <D32_GENERIC+0x56>
90000a2c:	9d00      	ldr	r5, [sp, #0]
90000a2e:	f85a eb04 	ldr.w	lr, [sl], #4
90000a32:	b1bd      	cbz	r5, 90000a64 <D32_GENERIC+0x80>
90000a34:	fa9e fe9e 	rev16.w	lr, lr
90000a38:	e014      	b.n	90000a64 <D32_GENERIC+0x80>
90000a3a:	b2ed      	uxtb	r5, r5
90000a3c:	f81a e015 	ldrb.w	lr, [sl, r5, lsl #1]
90000a40:	eb05 0745 	add.w	r7, r5, r5, lsl #1
90000a44:	f81a b007 	ldrb.w	fp, [sl, r7]
90000a48:	f81a 7005 	ldrb.w	r7, [sl, r5]
90000a4c:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
90000a50:	eb0e 6e0b 	add.w	lr, lr, fp, lsl #24
90000a54:	f89a b000 	ldrb.w	fp, [sl]
90000a58:	eb0a 0a85 	add.w	sl, sl, r5, lsl #2
90000a5c:	eb0e 2e07 	add.w	lr, lr, r7, lsl #8
90000a60:	eb0e 0e0b 	add.w	lr, lr, fp
90000a64:	f109 0504 	add.w	r5, r9, #4
90000a68:	f00e 07ff 	and.w	r7, lr, #255	; 0xff
90000a6c:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
90000a70:	f855 5027 	ldr.w	r5, [r5, r7, lsl #2]
90000a74:	f109 0b04 	add.w	fp, r9, #4
90000a78:	eb05 2593 	add.w	r5, r5, r3, lsr #10
90000a7c:	f00e 03ff 	and.w	r3, lr, #255	; 0xff
90000a80:	f85b 3023 	ldr.w	r3, [fp, r3, lsl #2]
90000a84:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
90000a88:	f00e 0bff 	and.w	fp, lr, #255	; 0xff
90000a8c:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
90000a90:	eb03 2395 	add.w	r3, r3, r5, lsr #10
90000a94:	f3c5 0709 	ubfx	r7, r5, #0, #10
90000a98:	f3c3 0509 	ubfx	r5, r3, #0, #10
90000a9c:	ea45 4507 	orr.w	r5, r5, r7, lsl #16
90000aa0:	f109 0704 	add.w	r7, r9, #4
90000aa4:	f857 b02b 	ldr.w	fp, [r7, fp, lsl #2]
90000aa8:	eb0b 2b93 	add.w	fp, fp, r3, lsr #10
90000aac:	f109 0304 	add.w	r3, r9, #4
90000ab0:	f853 302e 	ldr.w	r3, [r3, lr, lsl #2]
90000ab4:	eb03 239b 	add.w	r3, r3, fp, lsr #10
90000ab8:	f3cb 0709 	ubfx	r7, fp, #0, #10
90000abc:	f44f 3b80 	mov.w	fp, #65536	; 0x10000
90000ac0:	f3c3 0e09 	ubfx	lr, r3, #0, #10
90000ac4:	ea4e 4e07 	orr.w	lr, lr, r7, lsl #16
90000ac8:	f8df 7c98 	ldr.w	r7, [pc, #3224]	; 90001764 <.text_43>
90000acc:	fb25 cc07 	smlad	ip, r5, r7, ip
90000ad0:	fb2e c70b 	smlad	r7, lr, fp, ip
90000ad4:	f8df cc90 	ldr.w	ip, [pc, #3216]	; 90001768 <.text_44>
90000ad8:	f8df bc90 	ldr.w	fp, [pc, #3216]	; 9000176c <.text_45>
90000adc:	fb25 440c 	smlad	r4, r5, ip, r4
90000ae0:	f8df cd90 	ldr.w	ip, [pc, #3472]	; 90001874 <.text_47>
90000ae4:	f5a7 4780 	sub.w	r7, r7, #16384	; 0x4000
90000ae8:	fb2e 4c0c 	smlad	ip, lr, ip, r4
90000aec:	2401      	movs	r4, #1
90000aee:	fb25 f404 	smuad	r4, r5, r4
90000af2:	9d01      	ldr	r5, [sp, #4]
90000af4:	fb2e 440b 	smlad	r4, lr, fp, r4
90000af8:	b145      	cbz	r5, 90000b0c <D32_GENERIC+0x128>
90000afa:	f8d2 e020 	ldr.w	lr, [r2, #32]
90000afe:	1838      	adds	r0, r7, r0
90000b00:	1a40      	subs	r0, r0, r1
90000b02:	4639      	mov	r1, r7
90000b04:	fb50 f01e 	smmulr	r0, r0, lr
90000b08:	0040      	lsls	r0, r0, #1
90000b0a:	4607      	mov	r7, r0
90000b0c:	f8b2 b028 	ldrh.w	fp, [r2, #40]	; 0x28
90000b10:	037f      	lsls	r7, r7, #13
90000b12:	fb57 f518 	smmulr	r5, r7, r8
90000b16:	b2b7      	uxth	r7, r6
90000b18:	f8dd e00c 	ldr.w	lr, [sp, #12]
90000b1c:	1c76      	adds	r6, r6, #1
90000b1e:	fb0b f707 	mul.w	r7, fp, r7
90000b22:	f325 058f 	ssat	r5, #16, r5, asr #2
90000b26:	f82e 5017 	strh.w	r5, [lr, r7, lsl #1]
90000b2a:	f8b2 e026 	ldrh.w	lr, [r2, #38]	; 0x26
90000b2e:	b2b5      	uxth	r5, r6
90000b30:	4575      	cmp	r5, lr
90000b32:	f4ff af78 	bcc.w	90000a26 <D32_GENERIC+0x42>
90000b36:	6094      	str	r4, [r2, #8]
90000b38:	f8c2 c00c 	str.w	ip, [r2, #12]
90000b3c:	61d3      	str	r3, [r2, #28]
90000b3e:	6110      	str	r0, [r2, #16]
90000b40:	6151      	str	r1, [r2, #20]
90000b42:	9802      	ldr	r0, [sp, #8]
90000b44:	6190      	str	r0, [r2, #24]
90000b46:	2000      	movs	r0, #0
90000b48:	b004      	add	sp, #16
90000b4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

90000b50 <D48_GENERIC>:
90000b50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90000b54:	b085      	sub	sp, #20
90000b56:	4607      	mov	r7, r0
90000b58:	4688      	mov	r8, r1
90000b5a:	6910      	ldr	r0, [r2, #16]
90000b5c:	6951      	ldr	r1, [r2, #20]
90000b5e:	6993      	ldr	r3, [r2, #24]
90000b60:	9303      	str	r3, [sp, #12]
90000b62:	6b56      	ldr	r6, [r2, #52]	; 0x34
90000b64:	69d3      	ldr	r3, [r2, #28]
90000b66:	f8d2 9008 	ldr.w	r9, [r2, #8]
90000b6a:	f8d2 c00c 	ldr.w	ip, [r2, #12]
90000b6e:	6b15      	ldr	r5, [r2, #48]	; 0x30
90000b70:	f006 0b10 	and.w	fp, r6, #16
90000b74:	f006 0620 	and.w	r6, r6, #32
90000b78:	f8cd b004 	str.w	fp, [sp, #4]
90000b7c:	f04f 0e00 	mov.w	lr, #0
90000b80:	9600      	str	r6, [sp, #0]
90000b82:	8cd6      	ldrh	r6, [r2, #38]	; 0x26
90000b84:	f8df a3a8 	ldr.w	sl, [pc, #936]	; 90000f30 <.text_26>
90000b88:	2e00      	cmp	r6, #0
90000b8a:	f000 80b4 	beq.w	90000cf6 <D48_GENERIC+0x1a6>
90000b8e:	f8cd 8010 	str.w	r8, [sp, #16]
90000b92:	46f0      	mov	r8, lr
90000b94:	9502      	str	r5, [sp, #8]
90000b96:	8d55      	ldrh	r5, [r2, #42]	; 0x2a
90000b98:	2d01      	cmp	r5, #1
90000b9a:	d10a      	bne.n	90000bb2 <D48_GENERIC+0x62>
90000b9c:	683c      	ldr	r4, [r7, #0]
90000b9e:	1d3d      	adds	r5, r7, #4
90000ba0:	f8d5 e000 	ldr.w	lr, [r5]
90000ba4:	1caf      	adds	r7, r5, #2
90000ba6:	9d00      	ldr	r5, [sp, #0]
90000ba8:	b305      	cbz	r5, 90000bec <D48_GENERIC+0x9c>
90000baa:	ba64      	rev16	r4, r4
90000bac:	fa9e fe9e 	rev16.w	lr, lr
90000bb0:	e01c      	b.n	90000bec <D48_GENERIC+0x9c>
90000bb2:	b2ed      	uxtb	r5, r5
90000bb4:	f817 6015 	ldrb.w	r6, [r7, r5, lsl #1]
90000bb8:	eb05 0e45 	add.w	lr, r5, r5, lsl #1
90000bbc:	f817 400e 	ldrb.w	r4, [r7, lr]
90000bc0:	f817 e005 	ldrb.w	lr, [r7, r5]
90000bc4:	eb05 0b85 	add.w	fp, r5, r5, lsl #2
90000bc8:	0436      	lsls	r6, r6, #16
90000bca:	eb06 6604 	add.w	r6, r6, r4, lsl #24
90000bce:	783c      	ldrb	r4, [r7, #0]
90000bd0:	eb06 260e 	add.w	r6, r6, lr, lsl #8
90000bd4:	f817 e025 	ldrb.w	lr, [r7, r5, lsl #2]
90000bd8:	eb16 0404 	adds.w	r4, r6, r4
90000bdc:	f817 600b 	ldrb.w	r6, [r7, fp]
90000be0:	eb0e 2e06 	add.w	lr, lr, r6, lsl #8
90000be4:	eb05 0645 	add.w	r6, r5, r5, lsl #1
90000be8:	eb07 0746 	add.w	r7, r7, r6, lsl #1
90000bec:	f10a 0b04 	add.w	fp, sl, #4
90000bf0:	f004 05ff 	and.w	r5, r4, #255	; 0xff
90000bf4:	0a24      	lsrs	r4, r4, #8
90000bf6:	f85b 5025 	ldr.w	r5, [fp, r5, lsl #2]
90000bfa:	eb05 2593 	add.w	r5, r5, r3, lsr #10
90000bfe:	f004 03ff 	and.w	r3, r4, #255	; 0xff
90000c02:	f85b 3023 	ldr.w	r3, [fp, r3, lsl #2]
90000c06:	0a24      	lsrs	r4, r4, #8
90000c08:	f004 0bff 	and.w	fp, r4, #255	; 0xff
90000c0c:	0a24      	lsrs	r4, r4, #8
90000c0e:	eb03 2395 	add.w	r3, r3, r5, lsr #10
90000c12:	f3c5 0609 	ubfx	r6, r5, #0, #10
90000c16:	f3c3 0509 	ubfx	r5, r3, #0, #10
90000c1a:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
90000c1e:	f10a 0604 	add.w	r6, sl, #4
90000c22:	f856 b02b 	ldr.w	fp, [r6, fp, lsl #2]
90000c26:	f856 6024 	ldr.w	r6, [r6, r4, lsl #2]
90000c2a:	eb0b 2b93 	add.w	fp, fp, r3, lsr #10
90000c2e:	eb06 269b 	add.w	r6, r6, fp, lsr #10
90000c32:	f3cb 0309 	ubfx	r3, fp, #0, #10
90000c36:	f10a 0b04 	add.w	fp, sl, #4
90000c3a:	f3c6 0409 	ubfx	r4, r6, #0, #10
90000c3e:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
90000c42:	f00e 03ff 	and.w	r3, lr, #255	; 0xff
90000c46:	f85b 3023 	ldr.w	r3, [fp, r3, lsl #2]
90000c4a:	f3ce 2e07 	ubfx	lr, lr, #8, #8
90000c4e:	f85b e02e 	ldr.w	lr, [fp, lr, lsl #2]
90000c52:	f8df bb10 	ldr.w	fp, [pc, #2832]	; 90001764 <.text_43>
90000c56:	eb03 2396 	add.w	r3, r3, r6, lsr #10
90000c5a:	f3c3 0609 	ubfx	r6, r3, #0, #10
90000c5e:	eb0e 2393 	add.w	r3, lr, r3, lsr #10
90000c62:	f3c3 0e09 	ubfx	lr, r3, #0, #10
90000c66:	ea4e 4e06 	orr.w	lr, lr, r6, lsl #16
90000c6a:	f8df 6c0c 	ldr.w	r6, [pc, #3084]	; 90001878 <.text_48>
90000c6e:	fb25 cc06 	smlad	ip, r5, r6, ip
90000c72:	f44f 3680 	mov.w	r6, #65536	; 0x10000
90000c76:	fb24 cc0b 	smlad	ip, r4, fp, ip
90000c7a:	f04f 1b1b 	mov.w	fp, #1769499	; 0x1b001b
90000c7e:	fb2e c606 	smlad	r6, lr, r6, ip
90000c82:	f8df cbf8 	ldr.w	ip, [pc, #3064]	; 9000187c <.text_49>
90000c86:	fb25 990c 	smlad	r9, r5, ip, r9
90000c8a:	f8df cbf4 	ldr.w	ip, [pc, #3060]	; 90001880 <.text_50>
90000c8e:	fb24 990b 	smlad	r9, r4, fp, r9
90000c92:	f5a6 4658 	sub.w	r6, r6, #55296	; 0xd800
90000c96:	fb2e 9c0c 	smlad	ip, lr, ip, r9
90000c9a:	f04f 0901 	mov.w	r9, #1
90000c9e:	fb25 f909 	smuad	r9, r5, r9
90000ca2:	f8df 5ac8 	ldr.w	r5, [pc, #2760]	; 9000176c <.text_45>
90000ca6:	fb24 9905 	smlad	r9, r4, r5, r9
90000caa:	f8df 4d30 	ldr.w	r4, [pc, #3376]	; 900019dc <.text_52>
90000cae:	9d01      	ldr	r5, [sp, #4]
90000cb0:	fb2e 9904 	smlad	r9, lr, r4, r9
90000cb4:	b145      	cbz	r5, 90000cc8 <D48_GENERIC+0x178>
90000cb6:	f8d2 e020 	ldr.w	lr, [r2, #32]
90000cba:	1830      	adds	r0, r6, r0
90000cbc:	1a40      	subs	r0, r0, r1
90000cbe:	4631      	mov	r1, r6
90000cc0:	fb50 f01e 	smmulr	r0, r0, lr
90000cc4:	0040      	lsls	r0, r0, #1
90000cc6:	4606      	mov	r6, r0
90000cc8:	9d02      	ldr	r5, [sp, #8]
90000cca:	02f6      	lsls	r6, r6, #11
90000ccc:	fa1f f488 	uxth.w	r4, r8
90000cd0:	f8dd e010 	ldr.w	lr, [sp, #16]
90000cd4:	f108 0801 	add.w	r8, r8, #1
90000cd8:	fb56 f515 	smmulr	r5, r6, r5
90000cdc:	8d16      	ldrh	r6, [r2, #40]	; 0x28
90000cde:	4374      	muls	r4, r6
90000ce0:	f325 058f 	ssat	r5, #16, r5, asr #2
90000ce4:	f82e 5014 	strh.w	r5, [lr, r4, lsl #1]
90000ce8:	f8b2 e026 	ldrh.w	lr, [r2, #38]	; 0x26
90000cec:	fa1f f588 	uxth.w	r5, r8
90000cf0:	4575      	cmp	r5, lr
90000cf2:	f4ff af50 	bcc.w	90000b96 <D48_GENERIC+0x46>
90000cf6:	f8c2 9008 	str.w	r9, [r2, #8]
90000cfa:	f8c2 c00c 	str.w	ip, [r2, #12]
90000cfe:	61d3      	str	r3, [r2, #28]
90000d00:	6110      	str	r0, [r2, #16]
90000d02:	6151      	str	r1, [r2, #20]
90000d04:	9803      	ldr	r0, [sp, #12]
90000d06:	6190      	str	r0, [r2, #24]
90000d08:	2000      	movs	r0, #0
90000d0a:	b005      	add	sp, #20
90000d0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

90000d10 <D64_GENERIC>:
90000d10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90000d14:	b084      	sub	sp, #16
90000d16:	4613      	mov	r3, r2
90000d18:	4686      	mov	lr, r0
90000d1a:	f8d3 8010 	ldr.w	r8, [r3, #16]
90000d1e:	f8d3 9014 	ldr.w	r9, [r3, #20]
90000d22:	6998      	ldr	r0, [r3, #24]
90000d24:	9002      	str	r0, [sp, #8]
90000d26:	8cde      	ldrh	r6, [r3, #38]	; 0x26
90000d28:	69dc      	ldr	r4, [r3, #28]
90000d2a:	f8d3 a008 	ldr.w	sl, [r3, #8]
90000d2e:	f8d3 b00c 	ldr.w	fp, [r3, #12]
90000d32:	6b18      	ldr	r0, [r3, #48]	; 0x30
90000d34:	f04f 0c00 	mov.w	ip, #0
90000d38:	4a7d      	ldr	r2, [pc, #500]	; (90000f30 <.text_26>)
90000d3a:	2e00      	cmp	r6, #0
90000d3c:	f000 80d8 	beq.w	90000ef0 <D64_GENERIC+0x1e0>
90000d40:	9103      	str	r1, [sp, #12]
90000d42:	9001      	str	r0, [sp, #4]
90000d44:	8d59      	ldrh	r1, [r3, #42]	; 0x2a
90000d46:	2901      	cmp	r1, #1
90000d48:	d10a      	bne.n	90000d60 <D64_GENERIC+0x50>
90000d4a:	f893 6034 	ldrb.w	r6, [r3, #52]	; 0x34
90000d4e:	e8fe 0102 	ldrd	r0, r1, [lr], #8
90000d52:	460d      	mov	r5, r1
90000d54:	06b7      	lsls	r7, r6, #26
90000d56:	d52a      	bpl.n	90000dae <D64_GENERIC+0x9e>
90000d58:	ba40      	rev16	r0, r0
90000d5a:	ba6d      	rev16	r5, r5
90000d5c:	e027      	b.n	90000dae <D64_GENERIC+0x9e>
90000d5e:	bf00      	nop
90000d60:	f81e 6011 	ldrb.w	r6, [lr, r1, lsl #1]
90000d64:	eb01 0041 	add.w	r0, r1, r1, lsl #1
90000d68:	f81e 5000 	ldrb.w	r5, [lr, r0]
90000d6c:	f81e 0001 	ldrb.w	r0, [lr, r1]
90000d70:	f89e 7000 	ldrb.w	r7, [lr]
90000d74:	0436      	lsls	r6, r6, #16
90000d76:	eb06 6605 	add.w	r6, r6, r5, lsl #24
90000d7a:	ebc1 05c1 	rsb	r5, r1, r1, lsl #3
90000d7e:	eb06 2600 	add.w	r6, r6, r0, lsl #8
90000d82:	19f0      	adds	r0, r6, r7
90000d84:	eb01 0641 	add.w	r6, r1, r1, lsl #1
90000d88:	eb01 0781 	add.w	r7, r1, r1, lsl #2
90000d8c:	f81e 5005 	ldrb.w	r5, [lr, r5]
90000d90:	0076      	lsls	r6, r6, #1
90000d92:	f81e 6006 	ldrb.w	r6, [lr, r6]
90000d96:	0436      	lsls	r6, r6, #16
90000d98:	eb06 6605 	add.w	r6, r6, r5, lsl #24
90000d9c:	f81e 5007 	ldrb.w	r5, [lr, r7]
90000da0:	eb06 2605 	add.w	r6, r6, r5, lsl #8
90000da4:	f81e 5021 	ldrb.w	r5, [lr, r1, lsl #2]
90000da8:	eb0e 0ec1 	add.w	lr, lr, r1, lsl #3
90000dac:	1975      	adds	r5, r6, r5
90000dae:	1d11      	adds	r1, r2, #4
90000db0:	f000 06ff 	and.w	r6, r0, #255	; 0xff
90000db4:	f851 7026 	ldr.w	r7, [r1, r6, lsl #2]
90000db8:	0a00      	lsrs	r0, r0, #8
90000dba:	193c      	adds	r4, r7, r4
90000dbc:	f000 07ff 	and.w	r7, r0, #255	; 0xff
90000dc0:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
90000dc4:	f3c4 0609 	ubfx	r6, r4, #0, #10
90000dc8:	eb01 2494 	add.w	r4, r1, r4, lsr #10
90000dcc:	0a01      	lsrs	r1, r0, #8
90000dce:	f001 07ff 	and.w	r7, r1, #255	; 0xff
90000dd2:	0a09      	lsrs	r1, r1, #8
90000dd4:	f3c4 0009 	ubfx	r0, r4, #0, #10
90000dd8:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
90000ddc:	1d16      	adds	r6, r2, #4
90000dde:	f856 7027 	ldr.w	r7, [r6, r7, lsl #2]
90000de2:	eb07 2794 	add.w	r7, r7, r4, lsr #10
90000de6:	1d14      	adds	r4, r2, #4
90000de8:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]
90000dec:	eb04 2497 	add.w	r4, r4, r7, lsr #10
90000df0:	f3c7 0609 	ubfx	r6, r7, #0, #10
90000df4:	1d17      	adds	r7, r2, #4
90000df6:	f3c4 0109 	ubfx	r1, r4, #0, #10
90000dfa:	ea41 4106 	orr.w	r1, r1, r6, lsl #16
90000dfe:	f005 06ff 	and.w	r6, r5, #255	; 0xff
90000e02:	f857 6026 	ldr.w	r6, [r7, r6, lsl #2]
90000e06:	eb06 2694 	add.w	r6, r6, r4, lsr #10
90000e0a:	0a2c      	lsrs	r4, r5, #8
90000e0c:	9600      	str	r6, [sp, #0]
90000e0e:	f3c6 0509 	ubfx	r5, r6, #0, #10
90000e12:	f004 06ff 	and.w	r6, r4, #255	; 0xff
90000e16:	f857 6026 	ldr.w	r6, [r7, r6, lsl #2]
90000e1a:	9f00      	ldr	r7, [sp, #0]
90000e1c:	0a24      	lsrs	r4, r4, #8
90000e1e:	eb06 2697 	add.w	r6, r6, r7, lsr #10
90000e22:	9600      	str	r6, [sp, #0]
90000e24:	f3c6 0709 	ubfx	r7, r6, #0, #10
90000e28:	f004 06ff 	and.w	r6, r4, #255	; 0xff
90000e2c:	ea47 4505 	orr.w	r5, r7, r5, lsl #16
90000e30:	1d17      	adds	r7, r2, #4
90000e32:	f857 7026 	ldr.w	r7, [r7, r6, lsl #2]
90000e36:	9e00      	ldr	r6, [sp, #0]
90000e38:	0a24      	lsrs	r4, r4, #8
90000e3a:	eb07 2796 	add.w	r7, r7, r6, lsr #10
90000e3e:	9700      	str	r7, [sp, #0]
90000e40:	f3c7 0609 	ubfx	r6, r7, #0, #10
90000e44:	1d17      	adds	r7, r2, #4
90000e46:	f857 4024 	ldr.w	r4, [r7, r4, lsl #2]
90000e4a:	9f00      	ldr	r7, [sp, #0]
90000e4c:	eb04 2497 	add.w	r4, r4, r7, lsr #10
90000e50:	f3c4 0709 	ubfx	r7, r4, #0, #10
90000e54:	0aa4      	lsrs	r4, r4, #10
90000e56:	ea47 4606 	orr.w	r6, r7, r6, lsl #16
90000e5a:	f8df 7b84 	ldr.w	r7, [pc, #2948]	; 900019e0 <.text_53>
90000e5e:	fb20 bb07 	smlad	fp, r0, r7, fp
90000e62:	f8df 7a14 	ldr.w	r7, [pc, #2580]	; 90001878 <.text_48>
90000e66:	fb21 bb07 	smlad	fp, r1, r7, fp
90000e6a:	f8df 78f8 	ldr.w	r7, [pc, #2296]	; 90001764 <.text_43>
90000e6e:	fb25 bb07 	smlad	fp, r5, r7, fp
90000e72:	f44f 3780 	mov.w	r7, #65536	; 0x10000
90000e76:	fb26 b707 	smlad	r7, r6, r7, fp
90000e7a:	f8df bb68 	ldr.w	fp, [pc, #2920]	; 900019e4 <.text_54>
90000e7e:	fb20 aa0b 	smlad	sl, r0, fp, sl
90000e82:	fb26 aa1b 	smladx	sl, r6, fp, sl
90000e86:	f8df bb60 	ldr.w	fp, [pc, #2912]	; 900019e8 <.text_55>
90000e8a:	f5a7 3700 	sub.w	r7, r7, #131072	; 0x20000
90000e8e:	fb21 aa0b 	smlad	sl, r1, fp, sl
90000e92:	fb25 ab1b 	smladx	fp, r5, fp, sl
90000e96:	f04f 0a01 	mov.w	sl, #1
90000e9a:	fb20 fa0a 	smuad	sl, r0, sl
90000e9e:	f8df 08cc 	ldr.w	r0, [pc, #2252]	; 9000176c <.text_45>
90000ea2:	fb21 a000 	smlad	r0, r1, r0, sl
90000ea6:	f8df 1b34 	ldr.w	r1, [pc, #2868]	; 900019dc <.text_52>
90000eaa:	fb25 0001 	smlad	r0, r5, r1, r0
90000eae:	f8df 5cdc 	ldr.w	r5, [pc, #3292]	; 90001b8c <.text_57>
90000eb2:	fb26 0a05 	smlad	sl, r6, r5, r0
90000eb6:	6a18      	ldr	r0, [r3, #32]
90000eb8:	b140      	cbz	r0, 90000ecc <D64_GENERIC+0x1bc>
90000eba:	44b8      	add	r8, r7
90000ebc:	eba8 0809 	sub.w	r8, r8, r9
90000ec0:	fb58 f810 	smmulr	r8, r8, r0
90000ec4:	46b9      	mov	r9, r7
90000ec6:	ea4f 0848 	mov.w	r8, r8, lsl #1
90000eca:	4647      	mov	r7, r8
90000ecc:	9801      	ldr	r0, [sp, #4]
90000ece:	8d1d      	ldrh	r5, [r3, #40]	; 0x28
90000ed0:	02bf      	lsls	r7, r7, #10
90000ed2:	9903      	ldr	r1, [sp, #12]
90000ed4:	fb57 f010 	smmulr	r0, r7, r0
90000ed8:	fb05 f50c 	mul.w	r5, r5, ip
90000edc:	f10c 0c01 	add.w	ip, ip, #1
90000ee0:	f320 008f 	ssat	r0, #16, r0, asr #2
90000ee4:	f821 0015 	strh.w	r0, [r1, r5, lsl #1]
90000ee8:	8cd8      	ldrh	r0, [r3, #38]	; 0x26
90000eea:	4584      	cmp	ip, r0
90000eec:	f6ff af2a 	blt.w	90000d44 <D64_GENERIC+0x34>
90000ef0:	f8c3 a008 	str.w	sl, [r3, #8]
90000ef4:	f8c3 b00c 	str.w	fp, [r3, #12]
90000ef8:	61dc      	str	r4, [r3, #28]
90000efa:	f8c3 8010 	str.w	r8, [r3, #16]
90000efe:	f8c3 9014 	str.w	r9, [r3, #20]
90000f02:	9802      	ldr	r0, [sp, #8]
90000f04:	6198      	str	r0, [r3, #24]
90000f06:	2000      	movs	r0, #0
90000f08:	b004      	add	sp, #16
90000f0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

90000f10 <.text_18>:
90000f10:	e0002000 	.word	0xe0002000

90000f14 <.text_19>:
90000f14:	e000ed00 	.word	0xe000ed00

90000f18 <.text_20>:
90000f18:	e0042000 	.word	0xe0042000

90000f1c <.text_21>:
90000f1c:	5c001000 	.word	0x5c001000

90000f20 <.text_22>:
90000f20:	58024c00 	.word	0x58024c00

90000f24 <.text_23>:
90000f24:	f407a5c2 	.word	0xf407a5c2

90000f28 <.text_24>:
90000f28:	b5e8b5cd 	.word	0xb5e8b5cd

90000f2c <.text_25>:
90000f2c:	40023000 	.word	0x40023000

90000f30 <.text_26>:
90000f30:	240003b0 	.word	0x240003b0

90000f34 <.text_27>:
90000f34:	000ffc00 	.word	0x000ffc00

90000f38 <.text_28>:
90000f38:	3ff00000 	.word	0x3ff00000

90000f3c <D80_GENERIC>:
90000f3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90000f40:	460c      	mov	r4, r1
90000f42:	b084      	sub	sp, #16
90000f44:	4611      	mov	r1, r2
90000f46:	f04f 0b00 	mov.w	fp, #0
90000f4a:	690b      	ldr	r3, [r1, #16]
90000f4c:	f8d1 8014 	ldr.w	r8, [r1, #20]
90000f50:	698a      	ldr	r2, [r1, #24]
90000f52:	9202      	str	r2, [sp, #8]
90000f54:	f8b1 c026 	ldrh.w	ip, [r1, #38]	; 0x26
90000f58:	69ca      	ldr	r2, [r1, #28]
90000f5a:	f8d1 9008 	ldr.w	r9, [r1, #8]
90000f5e:	f8d1 a00c 	ldr.w	sl, [r1, #12]
90000f62:	f8d1 e030 	ldr.w	lr, [r1, #48]	; 0x30
90000f66:	f1bc 0f00 	cmp.w	ip, #0
90000f6a:	f000 811a 	beq.w	900011a2 <D80_GENERIC+0x266>
90000f6e:	9403      	str	r4, [sp, #12]
90000f70:	4684      	mov	ip, r0
90000f72:	9100      	str	r1, [sp, #0]
90000f74:	f8cd e004 	str.w	lr, [sp, #4]
90000f78:	f8dd e000 	ldr.w	lr, [sp]
90000f7c:	f8be 402a 	ldrh.w	r4, [lr, #42]	; 0x2a
90000f80:	2c01      	cmp	r4, #1
90000f82:	d112      	bne.n	90000faa <D80_GENERIC+0x6e>
90000f84:	9c00      	ldr	r4, [sp, #0]
90000f86:	f8dc e000 	ldr.w	lr, [ip]
90000f8a:	f10c 0004 	add.w	r0, ip, #4
90000f8e:	f100 0c04 	add.w	ip, r0, #4
90000f92:	6801      	ldr	r1, [r0, #0]
90000f94:	f85c 0b02 	ldr.w	r0, [ip], #2
90000f98:	f894 5034 	ldrb.w	r5, [r4, #52]	; 0x34
90000f9c:	06ae      	lsls	r6, r5, #26
90000f9e:	d537      	bpl.n	90001010 <D80_GENERIC+0xd4>
90000fa0:	fa9e fe9e 	rev16.w	lr, lr
90000fa4:	ba49      	rev16	r1, r1
90000fa6:	ba40      	rev16	r0, r0
90000fa8:	e032      	b.n	90001010 <D80_GENERIC+0xd4>
90000faa:	b2e4      	uxtb	r4, r4
90000fac:	f81c e014 	ldrb.w	lr, [ip, r4, lsl #1]
90000fb0:	eb04 0044 	add.w	r0, r4, r4, lsl #1
90000fb4:	f81c 1000 	ldrb.w	r1, [ip, r0]
90000fb8:	f81c 0004 	ldrb.w	r0, [ip, r4]
90000fbc:	ebc4 05c4 	rsb	r5, r4, r4, lsl #3
90000fc0:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
90000fc4:	eb0e 6e01 	add.w	lr, lr, r1, lsl #24
90000fc8:	f89c 1000 	ldrb.w	r1, [ip]
90000fcc:	f81c 6005 	ldrb.w	r6, [ip, r5]
90000fd0:	eb0e 2e00 	add.w	lr, lr, r0, lsl #8
90000fd4:	eb04 0044 	add.w	r0, r4, r4, lsl #1
90000fd8:	0040      	lsls	r0, r0, #1
90000fda:	f81c 7000 	ldrb.w	r7, [ip, r0]
90000fde:	448e      	add	lr, r1
90000fe0:	eb04 0184 	add.w	r1, r4, r4, lsl #2
90000fe4:	f81c 0024 	ldrb.w	r0, [ip, r4, lsl #2]
90000fe8:	043f      	lsls	r7, r7, #16
90000fea:	eb07 6706 	add.w	r7, r7, r6, lsl #24
90000fee:	f81c 5001 	ldrb.w	r5, [ip, r1]
90000ff2:	eb04 06c4 	add.w	r6, r4, r4, lsl #3
90000ff6:	eb07 2705 	add.w	r7, r7, r5, lsl #8
90000ffa:	f81c 5034 	ldrb.w	r5, [ip, r4, lsl #3]
90000ffe:	1839      	adds	r1, r7, r0
90001000:	f81c 7006 	ldrb.w	r7, [ip, r6]
90001004:	eb05 2007 	add.w	r0, r5, r7, lsl #8
90001008:	eb04 0584 	add.w	r5, r4, r4, lsl #2
9000100c:	eb0c 0c45 	add.w	ip, ip, r5, lsl #1
90001010:	f8df 6b7c 	ldr.w	r6, [pc, #2940]	; 90001b90 <.text_58>
90001014:	f00e 07ff 	and.w	r7, lr, #255	; 0xff
90001018:	f856 4027 	ldr.w	r4, [r6, r7, lsl #2]
9000101c:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
90001020:	f00e 07ff 	and.w	r7, lr, #255	; 0xff
90001024:	18a2      	adds	r2, r4, r2
90001026:	f856 4027 	ldr.w	r4, [r6, r7, lsl #2]
9000102a:	f3c2 0509 	ubfx	r5, r2, #0, #10
9000102e:	eb04 2492 	add.w	r4, r4, r2, lsr #10
90001032:	ea4f 221e 	mov.w	r2, lr, lsr #8
90001036:	f3c4 0e09 	ubfx	lr, r4, #0, #10
9000103a:	ea4e 4e05 	orr.w	lr, lr, r5, lsl #16
9000103e:	4635      	mov	r5, r6
90001040:	f002 06ff 	and.w	r6, r2, #255	; 0xff
90001044:	0a12      	lsrs	r2, r2, #8
90001046:	f855 7026 	ldr.w	r7, [r5, r6, lsl #2]
9000104a:	f855 5022 	ldr.w	r5, [r5, r2, lsl #2]
9000104e:	f8df 2b40 	ldr.w	r2, [pc, #2880]	; 90001b90 <.text_58>
90001052:	eb07 2794 	add.w	r7, r7, r4, lsr #10
90001056:	eb05 2597 	add.w	r5, r5, r7, lsr #10
9000105a:	f3c7 0609 	ubfx	r6, r7, #0, #10
9000105e:	f8df 7b30 	ldr.w	r7, [pc, #2864]	; 90001b90 <.text_58>
90001062:	f3c5 0409 	ubfx	r4, r5, #0, #10
90001066:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
9000106a:	f001 06ff 	and.w	r6, r1, #255	; 0xff
9000106e:	f852 2026 	ldr.w	r2, [r2, r6, lsl #2]
90001072:	0a09      	lsrs	r1, r1, #8
90001074:	f001 06ff 	and.w	r6, r1, #255	; 0xff
90001078:	eb02 2295 	add.w	r2, r2, r5, lsr #10
9000107c:	f857 6026 	ldr.w	r6, [r7, r6, lsl #2]
90001080:	f3c2 0509 	ubfx	r5, r2, #0, #10
90001084:	eb06 2692 	add.w	r6, r6, r2, lsr #10
90001088:	0a0a      	lsrs	r2, r1, #8
9000108a:	f3c6 0109 	ubfx	r1, r6, #0, #10
9000108e:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
90001092:	f002 05ff 	and.w	r5, r2, #255	; 0xff
90001096:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
9000109a:	0a12      	lsrs	r2, r2, #8
9000109c:	eb05 2596 	add.w	r5, r5, r6, lsr #10
900010a0:	f8df 6aec 	ldr.w	r6, [pc, #2796]	; 90001b90 <.text_58>
900010a4:	f856 6022 	ldr.w	r6, [r6, r2, lsl #2]
900010a8:	f8df 2ae4 	ldr.w	r2, [pc, #2788]	; 90001b90 <.text_58>
900010ac:	eb06 2695 	add.w	r6, r6, r5, lsr #10
900010b0:	f3c5 0709 	ubfx	r7, r5, #0, #10
900010b4:	f3c6 0509 	ubfx	r5, r6, #0, #10
900010b8:	ea45 4507 	orr.w	r5, r5, r7, lsl #16
900010bc:	f000 07ff 	and.w	r7, r0, #255	; 0xff
900010c0:	f3c0 2007 	ubfx	r0, r0, #8, #8
900010c4:	f852 7027 	ldr.w	r7, [r2, r7, lsl #2]
900010c8:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
900010cc:	eb07 2796 	add.w	r7, r7, r6, lsr #10
900010d0:	eb02 2297 	add.w	r2, r2, r7, lsr #10
900010d4:	f3c7 0609 	ubfx	r6, r7, #0, #10
900010d8:	f8df 7904 	ldr.w	r7, [pc, #2308]	; 900019e0 <.text_53>
900010dc:	f3c2 0009 	ubfx	r0, r2, #0, #10
900010e0:	0a92      	lsrs	r2, r2, #10
900010e2:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
900010e6:	f8df 6aac 	ldr.w	r6, [pc, #2732]	; 90001b94 <.text_59>
900010ea:	fb2e aa06 	smlad	sl, lr, r6, sl
900010ee:	f8df 6788 	ldr.w	r6, [pc, #1928]	; 90001878 <.text_48>
900010f2:	fb24 aa07 	smlad	sl, r4, r7, sl
900010f6:	f44f 3780 	mov.w	r7, #65536	; 0x10000
900010fa:	fb21 aa06 	smlad	sl, r1, r6, sl
900010fe:	f8df 6664 	ldr.w	r6, [pc, #1636]	; 90001764 <.text_43>
90001102:	fb25 aa06 	smlad	sl, r5, r6, sl
90001106:	fb20 a607 	smlad	r6, r0, r7, sl
9000110a:	f8df aa8c 	ldr.w	sl, [pc, #2700]	; 90001b98 <.text_60>
9000110e:	f04f 174b 	mov.w	r7, #4915275	; 0x4b004b
90001112:	fb2e 990a 	smlad	r9, lr, sl, r9
90001116:	f8df aca4 	ldr.w	sl, [pc, #3236]	; 90001dbc <.text_62>
9000111a:	f5a6 367a 	sub.w	r6, r6, #256000	; 0x3e800
9000111e:	fb24 990a 	smlad	r9, r4, sl, r9
90001122:	f8df ac9c 	ldr.w	sl, [pc, #3228]	; 90001dc0 <.text_63>
90001126:	fb21 9907 	smlad	r9, r1, r7, r9
9000112a:	fb25 990a 	smlad	r9, r5, sl, r9
9000112e:	f8df ac94 	ldr.w	sl, [pc, #3220]	; 90001dc4 <.text_64>
90001132:	fb20 9a0a 	smlad	sl, r0, sl, r9
90001136:	f04f 0901 	mov.w	r9, #1
9000113a:	fb2e f909 	smuad	r9, lr, r9
9000113e:	f8df e62c 	ldr.w	lr, [pc, #1580]	; 9000176c <.text_45>
90001142:	fb24 990e 	smlad	r9, r4, lr, r9
90001146:	f8df 4894 	ldr.w	r4, [pc, #2196]	; 900019dc <.text_52>
9000114a:	f8df ec7c 	ldr.w	lr, [pc, #3196]	; 90001dc8 <.text_65>
9000114e:	fb21 9104 	smlad	r1, r1, r4, r9
90001152:	f8df 9a38 	ldr.w	r9, [pc, #2616]	; 90001b8c <.text_57>
90001156:	fb25 1109 	smlad	r1, r5, r9, r1
9000115a:	fb20 190e 	smlad	r9, r0, lr, r1
9000115e:	9800      	ldr	r0, [sp, #0]
90001160:	6a00      	ldr	r0, [r0, #32]
90001162:	b138      	cbz	r0, 90001174 <D80_GENERIC+0x238>
90001164:	18f3      	adds	r3, r6, r3
90001166:	eba3 0308 	sub.w	r3, r3, r8
9000116a:	fb53 f310 	smmulr	r3, r3, r0
9000116e:	46b0      	mov	r8, r6
90001170:	005b      	lsls	r3, r3, #1
90001172:	461e      	mov	r6, r3
90001174:	f8dd e000 	ldr.w	lr, [sp]
90001178:	9801      	ldr	r0, [sp, #4]
9000117a:	0276      	lsls	r6, r6, #9
9000117c:	9903      	ldr	r1, [sp, #12]
9000117e:	f8be 4028 	ldrh.w	r4, [lr, #40]	; 0x28
90001182:	fb56 f010 	smmulr	r0, r6, r0
90001186:	fb04 f40b 	mul.w	r4, r4, fp
9000118a:	f10b 0b01 	add.w	fp, fp, #1
9000118e:	f320 008f 	ssat	r0, #16, r0, asr #2
90001192:	f821 0014 	strh.w	r0, [r1, r4, lsl #1]
90001196:	9800      	ldr	r0, [sp, #0]
90001198:	8cc1      	ldrh	r1, [r0, #38]	; 0x26
9000119a:	458b      	cmp	fp, r1
9000119c:	f6ff aeec 	blt.w	90000f78 <D80_GENERIC+0x3c>
900011a0:	4601      	mov	r1, r0
900011a2:	f8c1 9008 	str.w	r9, [r1, #8]
900011a6:	f8c1 a00c 	str.w	sl, [r1, #12]
900011aa:	61ca      	str	r2, [r1, #28]
900011ac:	610b      	str	r3, [r1, #16]
900011ae:	f8c1 8014 	str.w	r8, [r1, #20]
900011b2:	9802      	ldr	r0, [sp, #8]
900011b4:	6188      	str	r0, [r1, #24]
900011b6:	2000      	movs	r0, #0
900011b8:	b004      	add	sp, #16
900011ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

900011c0 <.text_30>:
900011c0:	90001589 	.word	0x90001589

900011c4 <.text_31>:
900011c4:	90001641 	.word	0x90001641

900011c8 <.text_32>:
900011c8:	90001771 	.word	0x90001771

900011cc <.text_33>:
900011cc:	90001885 	.word	0x90001885

900011d0 <.text_34>:
900011d0:	900019ed 	.word	0x900019ed

900011d4 <.text_35>:
900011d4:	90001b9d 	.word	0x90001b9d

900011d8 <.text_36>:
900011d8:	90001ddd 	.word	0x90001ddd

900011dc <.text_37>:
900011dc:	00010003 	.word	0x00010003

900011e0 <.text_38>:
900011e0:	00030001 	.word	0x00030001

900011e4 <D128_GENERIC>:
900011e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
900011e8:	b089      	sub	sp, #36	; 0x24
900011ea:	4681      	mov	r9, r0
900011ec:	f8d2 a010 	ldr.w	sl, [r2, #16]
900011f0:	f8d2 b014 	ldr.w	fp, [r2, #20]
900011f4:	6990      	ldr	r0, [r2, #24]
900011f6:	f04f 0800 	mov.w	r8, #0
900011fa:	9007      	str	r0, [sp, #28]
900011fc:	8cd6      	ldrh	r6, [r2, #38]	; 0x26
900011fe:	69d5      	ldr	r5, [r2, #28]
90001200:	f8d2 c008 	ldr.w	ip, [r2, #8]
90001204:	f8d2 e00c 	ldr.w	lr, [r2, #12]
90001208:	6b10      	ldr	r0, [r2, #48]	; 0x30
9000120a:	f8df 4bc0 	ldr.w	r4, [pc, #3008]	; 90001dcc <.text_66>
9000120e:	2e00      	cmp	r6, #0
90001210:	f000 81aa 	beq.w	90001568 <D128_GENERIC+0x384>
90001214:	9108      	str	r1, [sp, #32]
90001216:	9201      	str	r2, [sp, #4]
90001218:	9006      	str	r0, [sp, #24]
9000121a:	9801      	ldr	r0, [sp, #4]
9000121c:	8d46      	ldrh	r6, [r0, #42]	; 0x2a
9000121e:	2e01      	cmp	r6, #1
90001220:	d10d      	bne.n	9000123e <D128_GENERIC+0x5a>
90001222:	9e01      	ldr	r6, [sp, #4]
90001224:	e8f9 0102 	ldrd	r0, r1, [r9], #8
90001228:	e8f9 2302 	ldrd	r2, r3, [r9], #8
9000122c:	f896 7034 	ldrb.w	r7, [r6, #52]	; 0x34
90001230:	06be      	lsls	r6, r7, #26
90001232:	d55b      	bpl.n	900012ec <D128_GENERIC+0x108>
90001234:	ba40      	rev16	r0, r0
90001236:	ba49      	rev16	r1, r1
90001238:	ba52      	rev16	r2, r2
9000123a:	ba5b      	rev16	r3, r3
9000123c:	e056      	b.n	900012ec <D128_GENERIC+0x108>
9000123e:	b2f6      	uxtb	r6, r6
90001240:	f899 3000 	ldrb.w	r3, [r9]
90001244:	f819 2016 	ldrb.w	r2, [r9, r6, lsl #1]
90001248:	eb06 0046 	add.w	r0, r6, r6, lsl #1
9000124c:	f819 1000 	ldrb.w	r1, [r9, r0]
90001250:	f819 0006 	ldrb.w	r0, [r9, r6]
90001254:	ebc6 07c6 	rsb	r7, r6, r6, lsl #3
90001258:	0412      	lsls	r2, r2, #16
9000125a:	eb02 6201 	add.w	r2, r2, r1, lsl #24
9000125e:	eb06 0146 	add.w	r1, r6, r6, lsl #1
90001262:	eb02 2200 	add.w	r2, r2, r0, lsl #8
90001266:	0049      	lsls	r1, r1, #1
90001268:	f819 1001 	ldrb.w	r1, [r9, r1]
9000126c:	18d0      	adds	r0, r2, r3
9000126e:	eb06 0386 	add.w	r3, r6, r6, lsl #2
90001272:	f819 2007 	ldrb.w	r2, [r9, r7]
90001276:	0409      	lsls	r1, r1, #16
90001278:	eb01 6102 	add.w	r1, r1, r2, lsl #24
9000127c:	f819 7003 	ldrb.w	r7, [r9, r3]
90001280:	f819 2026 	ldrb.w	r2, [r9, r6, lsl #2]
90001284:	eb01 2107 	add.w	r1, r1, r7, lsl #8
90001288:	eb06 0786 	add.w	r7, r6, r6, lsl #2
9000128c:	1889      	adds	r1, r1, r2
9000128e:	220b      	movs	r2, #11
90001290:	fb12 f206 	smulbb	r2, r2, r6
90001294:	007f      	lsls	r7, r7, #1
90001296:	f819 3007 	ldrb.w	r3, [r9, r7]
9000129a:	f819 7036 	ldrb.w	r7, [r9, r6, lsl #3]
9000129e:	f819 2002 	ldrb.w	r2, [r9, r2]
900012a2:	041b      	lsls	r3, r3, #16
900012a4:	eb03 6302 	add.w	r3, r3, r2, lsl #24
900012a8:	eb06 02c6 	add.w	r2, r6, r6, lsl #3
900012ac:	f819 2002 	ldrb.w	r2, [r9, r2]
900012b0:	eb03 2302 	add.w	r3, r3, r2, lsl #8
900012b4:	19da      	adds	r2, r3, r7
900012b6:	ebc6 07c6 	rsb	r7, r6, r6, lsl #3
900012ba:	ebc6 1306 	rsb	r3, r6, r6, lsl #4
900012be:	007f      	lsls	r7, r7, #1
900012c0:	f819 7007 	ldrb.w	r7, [r9, r7]
900012c4:	f819 3003 	ldrb.w	r3, [r9, r3]
900012c8:	043f      	lsls	r7, r7, #16
900012ca:	eb07 6703 	add.w	r7, r7, r3, lsl #24
900012ce:	230d      	movs	r3, #13
900012d0:	fb13 f306 	smulbb	r3, r3, r6
900012d4:	f819 3003 	ldrb.w	r3, [r9, r3]
900012d8:	eb07 2703 	add.w	r7, r7, r3, lsl #8
900012dc:	eb06 0346 	add.w	r3, r6, r6, lsl #1
900012e0:	009b      	lsls	r3, r3, #2
900012e2:	f819 3003 	ldrb.w	r3, [r9, r3]
900012e6:	eb09 1906 	add.w	r9, r9, r6, lsl #4
900012ea:	18fb      	adds	r3, r7, r3
900012ec:	1d26      	adds	r6, r4, #4
900012ee:	f000 07ff 	and.w	r7, r0, #255	; 0xff
900012f2:	f856 7027 	ldr.w	r7, [r6, r7, lsl #2]
900012f6:	0a00      	lsrs	r0, r0, #8
900012f8:	197e      	adds	r6, r7, r5
900012fa:	f3c6 0509 	ubfx	r5, r6, #0, #10
900012fe:	9600      	str	r6, [sp, #0]
90001300:	1d27      	adds	r7, r4, #4
90001302:	f000 06ff 	and.w	r6, r0, #255	; 0xff
90001306:	0a00      	lsrs	r0, r0, #8
90001308:	f857 6026 	ldr.w	r6, [r7, r6, lsl #2]
9000130c:	9f00      	ldr	r7, [sp, #0]
9000130e:	eb06 2697 	add.w	r6, r6, r7, lsr #10
90001312:	f3c6 0709 	ubfx	r7, r6, #0, #10
90001316:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
9000131a:	1d25      	adds	r5, r4, #4
9000131c:	9705      	str	r7, [sp, #20]
9000131e:	f000 07ff 	and.w	r7, r0, #255	; 0xff
90001322:	f855 5027 	ldr.w	r5, [r5, r7, lsl #2]
90001326:	0a00      	lsrs	r0, r0, #8
90001328:	eb05 2596 	add.w	r5, r5, r6, lsr #10
9000132c:	1d26      	adds	r6, r4, #4
9000132e:	f856 6020 	ldr.w	r6, [r6, r0, lsl #2]
90001332:	f001 00ff 	and.w	r0, r1, #255	; 0xff
90001336:	0a09      	lsrs	r1, r1, #8
90001338:	eb06 2695 	add.w	r6, r6, r5, lsr #10
9000133c:	f3c5 0709 	ubfx	r7, r5, #0, #10
90001340:	f3c6 0509 	ubfx	r5, r6, #0, #10
90001344:	ea45 4507 	orr.w	r5, r5, r7, lsl #16
90001348:	1d27      	adds	r7, r4, #4
9000134a:	9504      	str	r5, [sp, #16]
9000134c:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
90001350:	eb00 2096 	add.w	r0, r0, r6, lsr #10
90001354:	f001 06ff 	and.w	r6, r1, #255	; 0xff
90001358:	f857 6026 	ldr.w	r6, [r7, r6, lsl #2]
9000135c:	0a09      	lsrs	r1, r1, #8
9000135e:	eb06 2690 	add.w	r6, r6, r0, lsr #10
90001362:	f3c0 0509 	ubfx	r5, r0, #0, #10
90001366:	f001 00ff 	and.w	r0, r1, #255	; 0xff
9000136a:	0a09      	lsrs	r1, r1, #8
9000136c:	f3c6 0709 	ubfx	r7, r6, #0, #10
90001370:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
90001374:	1d25      	adds	r5, r4, #4
90001376:	9703      	str	r7, [sp, #12]
90001378:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
9000137c:	eb00 2096 	add.w	r0, r0, r6, lsr #10
90001380:	1d26      	adds	r6, r4, #4
90001382:	f856 1021 	ldr.w	r1, [r6, r1, lsl #2]
90001386:	f002 06ff 	and.w	r6, r2, #255	; 0xff
9000138a:	0a12      	lsrs	r2, r2, #8
9000138c:	eb01 2190 	add.w	r1, r1, r0, lsr #10
90001390:	f3c0 0509 	ubfx	r5, r0, #0, #10
90001394:	f3c1 0709 	ubfx	r7, r1, #0, #10
90001398:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
9000139c:	1d25      	adds	r5, r4, #4
9000139e:	9702      	str	r7, [sp, #8]
900013a0:	f855 0026 	ldr.w	r0, [r5, r6, lsl #2]
900013a4:	f002 06ff 	and.w	r6, r2, #255	; 0xff
900013a8:	0a12      	lsrs	r2, r2, #8
900013aa:	eb00 2091 	add.w	r0, r0, r1, lsr #10
900013ae:	1d21      	adds	r1, r4, #4
900013b0:	f851 1026 	ldr.w	r1, [r1, r6, lsl #2]
900013b4:	f002 06ff 	and.w	r6, r2, #255	; 0xff
900013b8:	0a12      	lsrs	r2, r2, #8
900013ba:	eb01 2190 	add.w	r1, r1, r0, lsr #10
900013be:	f3c0 0509 	ubfx	r5, r0, #0, #10
900013c2:	f3c1 0709 	ubfx	r7, r1, #0, #10
900013c6:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
900013ca:	1d25      	adds	r5, r4, #4
900013cc:	9700      	str	r7, [sp, #0]
900013ce:	f855 0026 	ldr.w	r0, [r5, r6, lsl #2]
900013d2:	1d27      	adds	r7, r4, #4
900013d4:	eb00 2091 	add.w	r0, r0, r1, lsr #10
900013d8:	1d21      	adds	r1, r4, #4
900013da:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
900013de:	1d22      	adds	r2, r4, #4
900013e0:	eb01 2190 	add.w	r1, r1, r0, lsr #10
900013e4:	f3c0 0509 	ubfx	r5, r0, #0, #10
900013e8:	f3c1 0009 	ubfx	r0, r1, #0, #10
900013ec:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
900013f0:	f003 05ff 	and.w	r5, r3, #255	; 0xff
900013f4:	0a1b      	lsrs	r3, r3, #8
900013f6:	f852 6025 	ldr.w	r6, [r2, r5, lsl #2]
900013fa:	eb06 2691 	add.w	r6, r6, r1, lsr #10
900013fe:	f003 01ff 	and.w	r1, r3, #255	; 0xff
90001402:	f857 2021 	ldr.w	r2, [r7, r1, lsl #2]
90001406:	0a1b      	lsrs	r3, r3, #8
90001408:	eb02 2296 	add.w	r2, r2, r6, lsr #10
9000140c:	f3c6 0509 	ubfx	r5, r6, #0, #10
90001410:	f003 06ff 	and.w	r6, r3, #255	; 0xff
90001414:	0a1b      	lsrs	r3, r3, #8
90001416:	f3c2 0109 	ubfx	r1, r2, #0, #10
9000141a:	ea41 4105 	orr.w	r1, r1, r5, lsl #16
9000141e:	1d25      	adds	r5, r4, #4
90001420:	f855 7026 	ldr.w	r7, [r5, r6, lsl #2]
90001424:	eb07 2792 	add.w	r7, r7, r2, lsr #10
90001428:	1d22      	adds	r2, r4, #4
9000142a:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
9000142e:	f8df 39a0 	ldr.w	r3, [pc, #2464]	; 90001dd0 <.text_67>
90001432:	eb05 2597 	add.w	r5, r5, r7, lsr #10
90001436:	f3c7 0609 	ubfx	r6, r7, #0, #10
9000143a:	9f04      	ldr	r7, [sp, #16]
9000143c:	f3c5 0209 	ubfx	r2, r5, #0, #10
90001440:	0aad      	lsrs	r5, r5, #10
90001442:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
90001446:	9e05      	ldr	r6, [sp, #20]
90001448:	fb26 e303 	smlad	r3, r6, r3, lr
9000144c:	f8df e984 	ldr.w	lr, [pc, #2436]	; 90001dd4 <.text_68>
90001450:	f8df 6984 	ldr.w	r6, [pc, #2436]	; 90001dd8 <.text_69>
90001454:	fb27 330e 	smlad	r3, r7, lr, r3
90001458:	f8dd e00c 	ldr.w	lr, [sp, #12]
9000145c:	f8df 7734 	ldr.w	r7, [pc, #1844]	; 90001b94 <.text_59>
90001460:	fb2e 3306 	smlad	r3, lr, r6, r3
90001464:	9e02      	ldr	r6, [sp, #8]
90001466:	f8df e578 	ldr.w	lr, [pc, #1400]	; 900019e0 <.text_53>
9000146a:	fb26 3307 	smlad	r3, r6, r7, r3
9000146e:	9f00      	ldr	r7, [sp, #0]
90001470:	f8df 6404 	ldr.w	r6, [pc, #1028]	; 90001878 <.text_48>
90001474:	fb27 330e 	smlad	r3, r7, lr, r3
90001478:	f8df e2e8 	ldr.w	lr, [pc, #744]	; 90001764 <.text_43>
9000147c:	f44f 3780 	mov.w	r7, #65536	; 0x10000
90001480:	fb20 3306 	smlad	r3, r0, r6, r3
90001484:	f8df 6c2c 	ldr.w	r6, [pc, #3116]	; 900020b4 <.text_71>
90001488:	fb21 330e 	smlad	r3, r1, lr, r3
9000148c:	f8dd e014 	ldr.w	lr, [sp, #20]
90001490:	fb22 3307 	smlad	r3, r2, r7, r3
90001494:	f8df 7c20 	ldr.w	r7, [pc, #3104]	; 900020b8 <.text_72>
90001498:	fb2e cc06 	smlad	ip, lr, r6, ip
9000149c:	9e04      	ldr	r6, [sp, #16]
9000149e:	f8df ec1c 	ldr.w	lr, [pc, #3100]	; 900020bc <.text_73>
900014a2:	f5a3 1380 	sub.w	r3, r3, #1048576	; 0x100000
900014a6:	fb26 cc07 	smlad	ip, r6, r7, ip
900014aa:	9f03      	ldr	r7, [sp, #12]
900014ac:	f8df 6c10 	ldr.w	r6, [pc, #3088]	; 900020c0 <.text_74>
900014b0:	fb27 cc0e 	smlad	ip, r7, lr, ip
900014b4:	f8dd e008 	ldr.w	lr, [sp, #8]
900014b8:	f8df 7c08 	ldr.w	r7, [pc, #3080]	; 900020c4 <.text_75>
900014bc:	fb2e cc06 	smlad	ip, lr, r6, ip
900014c0:	9e00      	ldr	r6, [sp, #0]
900014c2:	f8df ec04 	ldr.w	lr, [pc, #3076]	; 900020c8 <.text_76>
900014c6:	fb26 cc07 	smlad	ip, r6, r7, ip
900014ca:	f8df 7c00 	ldr.w	r7, [pc, #3072]	; 900020cc <.text_77>
900014ce:	f8df 6c00 	ldr.w	r6, [pc, #3072]	; 900020d0 <.text_78>
900014d2:	fb20 cc0e 	smlad	ip, r0, lr, ip
900014d6:	fb21 cc07 	smlad	ip, r1, r7, ip
900014da:	9f05      	ldr	r7, [sp, #20]
900014dc:	fb22 ce06 	smlad	lr, r2, r6, ip
900014e0:	f04f 0c01 	mov.w	ip, #1
900014e4:	4ea1      	ldr	r6, [pc, #644]	; (9000176c <.text_45>)
900014e6:	fb27 fc0c 	smuad	ip, r7, ip
900014ea:	9f04      	ldr	r7, [sp, #16]
900014ec:	fb27 cc06 	smlad	ip, r7, r6, ip
900014f0:	9f03      	ldr	r7, [sp, #12]
900014f2:	f8df 64e8 	ldr.w	r6, [pc, #1256]	; 900019dc <.text_52>
900014f6:	fb27 cc06 	smlad	ip, r7, r6, ip
900014fa:	9f02      	ldr	r7, [sp, #8]
900014fc:	f8df 668c 	ldr.w	r6, [pc, #1676]	; 90001b8c <.text_57>
90001500:	fb27 cc06 	smlad	ip, r7, r6, ip
90001504:	9f00      	ldr	r7, [sp, #0]
90001506:	f8df 68c0 	ldr.w	r6, [pc, #2240]	; 90001dc8 <.text_65>
9000150a:	fb27 cc06 	smlad	ip, r7, r6, ip
9000150e:	f8df 6bc4 	ldr.w	r6, [pc, #3012]	; 900020d4 <.text_79>
90001512:	fb20 c006 	smlad	r0, r0, r6, ip
90001516:	f8df cbc0 	ldr.w	ip, [pc, #3008]	; 900020d8 <.text_80>
9000151a:	fb21 000c 	smlad	r0, r1, ip, r0
9000151e:	f8df 1bbc 	ldr.w	r1, [pc, #3004]	; 900020dc <.text_81>
90001522:	fb22 0c01 	smlad	ip, r2, r1, r0
90001526:	9801      	ldr	r0, [sp, #4]
90001528:	6a00      	ldr	r0, [r0, #32]
9000152a:	b140      	cbz	r0, 9000153e <D128_GENERIC+0x35a>
9000152c:	449a      	add	sl, r3
9000152e:	ebaa 0a0b 	sub.w	sl, sl, fp
90001532:	fb5a fa10 	smmulr	sl, sl, r0
90001536:	469b      	mov	fp, r3
90001538:	ea4f 0a4a 	mov.w	sl, sl, lsl #1
9000153c:	4653      	mov	r3, sl
9000153e:	9a01      	ldr	r2, [sp, #4]
90001540:	9806      	ldr	r0, [sp, #24]
90001542:	01db      	lsls	r3, r3, #7
90001544:	9908      	ldr	r1, [sp, #32]
90001546:	fb53 f010 	smmulr	r0, r3, r0
9000154a:	8d13      	ldrh	r3, [r2, #40]	; 0x28
9000154c:	fb03 f308 	mul.w	r3, r3, r8
90001550:	f108 0801 	add.w	r8, r8, #1
90001554:	f320 008f 	ssat	r0, #16, r0, asr #2
90001558:	f821 0013 	strh.w	r0, [r1, r3, lsl #1]
9000155c:	9801      	ldr	r0, [sp, #4]
9000155e:	8cc1      	ldrh	r1, [r0, #38]	; 0x26
90001560:	4588      	cmp	r8, r1
90001562:	f6ff ae5a 	blt.w	9000121a <D128_GENERIC+0x36>
90001566:	4602      	mov	r2, r0
90001568:	f8c2 c008 	str.w	ip, [r2, #8]
9000156c:	f8c2 e00c 	str.w	lr, [r2, #12]
90001570:	61d5      	str	r5, [r2, #28]
90001572:	f8c2 a010 	str.w	sl, [r2, #16]
90001576:	f8c2 b014 	str.w	fp, [r2, #20]
9000157a:	9807      	ldr	r0, [sp, #28]
9000157c:	6190      	str	r0, [r2, #24]
9000157e:	2000      	movs	r0, #0
90001580:	b009      	add	sp, #36	; 0x24
90001582:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

90001588 <D16_1CH_HTONS_VOL_HP>:
90001588:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
9000158c:	b083      	sub	sp, #12
9000158e:	4616      	mov	r6, r2
90001590:	4681      	mov	r9, r0
90001592:	6934      	ldr	r4, [r6, #16]
90001594:	6975      	ldr	r5, [r6, #20]
90001596:	69b0      	ldr	r0, [r6, #24]
90001598:	4688      	mov	r8, r1
9000159a:	9002      	str	r0, [sp, #8]
9000159c:	69f1      	ldr	r1, [r6, #28]
9000159e:	68b3      	ldr	r3, [r6, #8]
900015a0:	68f0      	ldr	r0, [r6, #12]
900015a2:	9001      	str	r0, [sp, #4]
900015a4:	8cf0      	ldrh	r0, [r6, #38]	; 0x26
900015a6:	f8d6 c030 	ldr.w	ip, [r6, #48]	; 0x30
900015aa:	f8d6 e020 	ldr.w	lr, [r6, #32]
900015ae:	2801      	cmp	r0, #1
900015b0:	db39      	blt.n	90001626 <D16_1CH_HTONS_VOL_HP+0x9e>
900015b2:	f8df 7b2c 	ldr.w	r7, [pc, #2860]	; 900020e0 <.text_82>
900015b6:	464a      	mov	r2, r9
900015b8:	9700      	str	r7, [sp, #0]
900015ba:	f8df 7810 	ldr.w	r7, [pc, #2064]	; 90001dcc <.text_66>
900015be:	46e1      	mov	r9, ip
900015c0:	f852 cb02 	ldr.w	ip, [r2], #2
900015c4:	fa9c fb9c 	rev16.w	fp, ip
900015c8:	f107 0c04 	add.w	ip, r7, #4
900015cc:	f00b 0aff 	and.w	sl, fp, #255	; 0xff
900015d0:	f3cb 2b07 	ubfx	fp, fp, #8, #8
900015d4:	f85c a02a 	ldr.w	sl, [ip, sl, lsl #2]
900015d8:	eb0a 0c01 	add.w	ip, sl, r1
900015dc:	1d39      	adds	r1, r7, #4
900015de:	f851 102b 	ldr.w	r1, [r1, fp, lsl #2]
900015e2:	f3cc 0a09 	ubfx	sl, ip, #0, #10
900015e6:	eb01 219c 	add.w	r1, r1, ip, lsr #10
900015ea:	f3c1 0c09 	ubfx	ip, r1, #0, #10
900015ee:	0a89      	lsrs	r1, r1, #10
900015f0:	ea4c 4c0a 	orr.w	ip, ip, sl, lsl #16
900015f4:	f8df aaec 	ldr.w	sl, [pc, #2796]	; 900020e4 <.text_83>
900015f8:	fb2c 3a0a 	smlad	sl, ip, sl, r3
900015fc:	9b00      	ldr	r3, [sp, #0]
900015fe:	f5aa 6a00 	sub.w	sl, sl, #2048	; 0x800
90001602:	4454      	add	r4, sl
90001604:	1b64      	subs	r4, r4, r5
90001606:	4655      	mov	r5, sl
90001608:	fb54 f41e 	smmulr	r4, r4, lr
9000160c:	fb2c f303 	smuad	r3, ip, r3
90001610:	0064      	lsls	r4, r4, #1
90001612:	ea4f 4c04 	mov.w	ip, r4, lsl #16
90001616:	fb5c fc19 	smmulr	ip, ip, r9
9000161a:	1e40      	subs	r0, r0, #1
9000161c:	f32c 0c8f 	ssat	ip, #16, ip, asr #2
90001620:	f828 cb02 	strh.w	ip, [r8], #2
90001624:	d1cc      	bne.n	900015c0 <D16_1CH_HTONS_VOL_HP+0x38>
90001626:	60b3      	str	r3, [r6, #8]
90001628:	9801      	ldr	r0, [sp, #4]
9000162a:	60f0      	str	r0, [r6, #12]
9000162c:	61f1      	str	r1, [r6, #28]
9000162e:	6134      	str	r4, [r6, #16]
90001630:	6175      	str	r5, [r6, #20]
90001632:	9802      	ldr	r0, [sp, #8]
90001634:	61b0      	str	r0, [r6, #24]
90001636:	2000      	movs	r0, #0
90001638:	b003      	add	sp, #12
9000163a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

90001640 <D24_1CH_HTONS_VOL_HP>:
90001640:	e92d 4ff4 	stmdb	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
90001644:	b082      	sub	sp, #8
90001646:	4686      	mov	lr, r0
90001648:	468c      	mov	ip, r1
9000164a:	9d02      	ldr	r5, [sp, #8]
9000164c:	6910      	ldr	r0, [r2, #16]
9000164e:	6951      	ldr	r1, [r2, #20]
90001650:	6994      	ldr	r4, [r2, #24]
90001652:	f8dd 8008 	ldr.w	r8, [sp, #8]
90001656:	9401      	str	r4, [sp, #4]
90001658:	69ee      	ldr	r6, [r5, #28]
9000165a:	68aa      	ldr	r2, [r5, #8]
9000165c:	68eb      	ldr	r3, [r5, #12]
9000165e:	6b2c      	ldr	r4, [r5, #48]	; 0x30
90001660:	8ced      	ldrh	r5, [r5, #38]	; 0x26
90001662:	f8d8 8020 	ldr.w	r8, [r8, #32]
90001666:	f04f 0a00 	mov.w	sl, #0
9000166a:	2d00      	cmp	r5, #0
9000166c:	f340 8067 	ble.w	9000173e <D24_1CH_HTONS_VOL_HP+0xfe>
90001670:	eb0a 79da 	add.w	r9, sl, sl, lsr #31
90001674:	f89e 7003 	ldrb.w	r7, [lr, #3]
90001678:	f89e b000 	ldrb.w	fp, [lr]
9000167c:	ea4f 0969 	mov.w	r9, r9, asr #1
90001680:	ebba 0949 	subs.w	r9, sl, r9, lsl #1
90001684:	d10a      	bne.n	9000169c <D24_1CH_HTONS_VOL_HP+0x5c>
90001686:	ea4f 2b0b 	mov.w	fp, fp, lsl #8
9000168a:	f89e 9001 	ldrb.w	r9, [lr, #1]
9000168e:	eb0b 4b07 	add.w	fp, fp, r7, lsl #16
90001692:	f10e 0e02 	add.w	lr, lr, #2
90001696:	eb0b 0709 	add.w	r7, fp, r9
9000169a:	e007      	b.n	900016ac <D24_1CH_HTONS_VOL_HP+0x6c>
9000169c:	f89e 9002 	ldrb.w	r9, [lr, #2]
900016a0:	023f      	lsls	r7, r7, #8
900016a2:	eb07 4709 	add.w	r7, r7, r9, lsl #16
900016a6:	f10e 0e04 	add.w	lr, lr, #4
900016aa:	445f      	add	r7, fp
900016ac:	f8df 94e0 	ldr.w	r9, [pc, #1248]	; 90001b90 <.text_58>
900016b0:	f007 0bff 	and.w	fp, r7, #255	; 0xff
900016b4:	f859 b02b 	ldr.w	fp, [r9, fp, lsl #2]
900016b8:	f10a 0a01 	add.w	sl, sl, #1
900016bc:	eb0b 2b96 	add.w	fp, fp, r6, lsr #10
900016c0:	0a3e      	lsrs	r6, r7, #8
900016c2:	f8cd b000 	str.w	fp, [sp]
900016c6:	f006 07ff 	and.w	r7, r6, #255	; 0xff
900016ca:	0a36      	lsrs	r6, r6, #8
900016cc:	f3cb 0909 	ubfx	r9, fp, #0, #10
900016d0:	f8df b4bc 	ldr.w	fp, [pc, #1212]	; 90001b90 <.text_58>
900016d4:	f85b 7027 	ldr.w	r7, [fp, r7, lsl #2]
900016d8:	f8dd b000 	ldr.w	fp, [sp]
900016dc:	eb07 279b 	add.w	r7, r7, fp, lsr #10
900016e0:	f3c7 0b09 	ubfx	fp, r7, #0, #10
900016e4:	ea4b 4909 	orr.w	r9, fp, r9, lsl #16
900016e8:	f8df b4a4 	ldr.w	fp, [pc, #1188]	; 90001b90 <.text_58>
900016ec:	f85b 6026 	ldr.w	r6, [fp, r6, lsl #2]
900016f0:	f8df b9f0 	ldr.w	fp, [pc, #2544]	; 900020e4 <.text_83>
900016f4:	eb06 2697 	add.w	r6, r6, r7, lsr #10
900016f8:	fb29 3b0b 	smlad	fp, r9, fp, r3
900016fc:	4b18      	ldr	r3, [pc, #96]	; (90001760 <.text_42>)
900016fe:	f5ab 5bd8 	sub.w	fp, fp, #6912	; 0x1b00
90001702:	4458      	add	r0, fp
90001704:	f3c6 0709 	ubfx	r7, r6, #0, #10
90001708:	1a40      	subs	r0, r0, r1
9000170a:	fb29 2303 	smlad	r3, r9, r3, r2
9000170e:	eb07 0247 	add.w	r2, r7, r7, lsl #1
90001712:	fb50 f018 	smmulr	r0, r0, r8
90001716:	eb07 0747 	add.w	r7, r7, r7, lsl #1
9000171a:	eb03 0342 	add.w	r3, r3, r2, lsl #1
9000171e:	2201      	movs	r2, #1
90001720:	fb29 f202 	smuad	r2, r9, r2
90001724:	4659      	mov	r1, fp
90001726:	0040      	lsls	r0, r0, #1
90001728:	ea4f 3980 	mov.w	r9, r0, lsl #14
9000172c:	fb59 f914 	smmulr	r9, r9, r4
90001730:	18ba      	adds	r2, r7, r2
90001732:	45aa      	cmp	sl, r5
90001734:	f329 098f 	ssat	r9, #16, r9, asr #2
90001738:	f82c 9b02 	strh.w	r9, [ip], #2
9000173c:	db98      	blt.n	90001670 <D24_1CH_HTONS_VOL_HP+0x30>
9000173e:	9c02      	ldr	r4, [sp, #8]
90001740:	60a2      	str	r2, [r4, #8]
90001742:	9a02      	ldr	r2, [sp, #8]
90001744:	60d3      	str	r3, [r2, #12]
90001746:	9b02      	ldr	r3, [sp, #8]
90001748:	61de      	str	r6, [r3, #28]
9000174a:	9a02      	ldr	r2, [sp, #8]
9000174c:	6110      	str	r0, [r2, #16]
9000174e:	9802      	ldr	r0, [sp, #8]
90001750:	6141      	str	r1, [r0, #20]
90001752:	9a02      	ldr	r2, [sp, #8]
90001754:	9901      	ldr	r1, [sp, #4]
90001756:	2000      	movs	r0, #0
90001758:	6191      	str	r1, [r2, #24]
9000175a:	b003      	add	sp, #12
9000175c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

90001760 <.text_42>:
90001760:	00060007 	.word	0x00060007

90001764 <.text_43>:
90001764:	00060003 	.word	0x00060003

90001768 <.text_44>:
90001768:	000a000c 	.word	0x000a000c

9000176c <.text_45>:
9000176c:	00030006 	.word	0x00030006

90001770 <D32_1CH_HTONS_VOL_HP>:
90001770:	e92d 4ff4 	stmdb	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
90001774:	b083      	sub	sp, #12
90001776:	4684      	mov	ip, r0
90001778:	4689      	mov	r9, r1
9000177a:	9d03      	ldr	r5, [sp, #12]
9000177c:	6910      	ldr	r0, [r2, #16]
9000177e:	6951      	ldr	r1, [r2, #20]
90001780:	6994      	ldr	r4, [r2, #24]
90001782:	9402      	str	r4, [sp, #8]
90001784:	69ea      	ldr	r2, [r5, #28]
90001786:	68ab      	ldr	r3, [r5, #8]
90001788:	f8d5 e00c 	ldr.w	lr, [r5, #12]
9000178c:	6b2c      	ldr	r4, [r5, #48]	; 0x30
9000178e:	8cee      	ldrh	r6, [r5, #38]	; 0x26
90001790:	6a2d      	ldr	r5, [r5, #32]
90001792:	2e01      	cmp	r6, #1
90001794:	db5c      	blt.n	90001850 <D32_1CH_HTONS_VOL_HP+0xe0>
90001796:	9401      	str	r4, [sp, #4]
90001798:	f8df 894c 	ldr.w	r8, [pc, #2380]	; 900020e8 <.text_84>
9000179c:	f8df 762c 	ldr.w	r7, [pc, #1580]	; 90001dcc <.text_66>
900017a0:	9500      	str	r5, [sp, #0]
900017a2:	4634      	mov	r4, r6
900017a4:	f85c 5b04 	ldr.w	r5, [ip], #4
900017a8:	1d3e      	adds	r6, r7, #4
900017aa:	f107 0b04 	add.w	fp, r7, #4
900017ae:	ba6d      	rev16	r5, r5
900017b0:	f005 0aff 	and.w	sl, r5, #255	; 0xff
900017b4:	0a2d      	lsrs	r5, r5, #8
900017b6:	f856 602a 	ldr.w	r6, [r6, sl, lsl #2]
900017ba:	eb06 2692 	add.w	r6, r6, r2, lsr #10
900017be:	f005 02ff 	and.w	r2, r5, #255	; 0xff
900017c2:	f85b 2022 	ldr.w	r2, [fp, r2, lsl #2]
900017c6:	0a2d      	lsrs	r5, r5, #8
900017c8:	f005 0bff 	and.w	fp, r5, #255	; 0xff
900017cc:	0a2d      	lsrs	r5, r5, #8
900017ce:	eb02 2296 	add.w	r2, r2, r6, lsr #10
900017d2:	f3c6 0a09 	ubfx	sl, r6, #0, #10
900017d6:	f3c2 0609 	ubfx	r6, r2, #0, #10
900017da:	ea46 460a 	orr.w	r6, r6, sl, lsl #16
900017de:	f107 0a04 	add.w	sl, r7, #4
900017e2:	f85a b02b 	ldr.w	fp, [sl, fp, lsl #2]
900017e6:	eb0b 2b92 	add.w	fp, fp, r2, lsr #10
900017ea:	1d3a      	adds	r2, r7, #4
900017ec:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
900017f0:	fb26 ee08 	smlad	lr, r6, r8, lr
900017f4:	eb02 229b 	add.w	r2, r2, fp, lsr #10
900017f8:	f3cb 0a09 	ubfx	sl, fp, #0, #10
900017fc:	f8df b074 	ldr.w	fp, [pc, #116]	; 90001874 <.text_47>
90001800:	f3c2 0509 	ubfx	r5, r2, #0, #10
90001804:	ea45 450a 	orr.w	r5, r5, sl, lsl #16
90001808:	f44f 3a80 	mov.w	sl, #65536	; 0x10000
9000180c:	fb25 ea0a 	smlad	sl, r5, sl, lr
90001810:	f8df e8d8 	ldr.w	lr, [pc, #2264]	; 900020ec <.text_85>
90001814:	fb26 330e 	smlad	r3, r6, lr, r3
90001818:	fb25 3e0b 	smlad	lr, r5, fp, r3
9000181c:	2301      	movs	r3, #1
9000181e:	f5aa 4a80 	sub.w	sl, sl, #16384	; 0x4000
90001822:	4450      	add	r0, sl
90001824:	1a40      	subs	r0, r0, r1
90001826:	4651      	mov	r1, sl
90001828:	fb26 f303 	smuad	r3, r6, r3
9000182c:	f8df 68c0 	ldr.w	r6, [pc, #2240]	; 900020f0 <.text_86>
90001830:	fb25 3306 	smlad	r3, r5, r6, r3
90001834:	9d00      	ldr	r5, [sp, #0]
90001836:	9e01      	ldr	r6, [sp, #4]
90001838:	fb50 f015 	smmulr	r0, r0, r5
9000183c:	0040      	lsls	r0, r0, #1
9000183e:	0345      	lsls	r5, r0, #13
90001840:	fb55 f516 	smmulr	r5, r5, r6
90001844:	1e64      	subs	r4, r4, #1
90001846:	f325 058f 	ssat	r5, #16, r5, asr #2
9000184a:	f829 5b02 	strh.w	r5, [r9], #2
9000184e:	d1a9      	bne.n	900017a4 <D32_1CH_HTONS_VOL_HP+0x34>
90001850:	9c03      	ldr	r4, [sp, #12]
90001852:	60a3      	str	r3, [r4, #8]
90001854:	9b03      	ldr	r3, [sp, #12]
90001856:	f8c3 e00c 	str.w	lr, [r3, #12]
9000185a:	9c03      	ldr	r4, [sp, #12]
9000185c:	61e2      	str	r2, [r4, #28]
9000185e:	9a03      	ldr	r2, [sp, #12]
90001860:	6110      	str	r0, [r2, #16]
90001862:	9803      	ldr	r0, [sp, #12]
90001864:	6141      	str	r1, [r0, #20]
90001866:	9a03      	ldr	r2, [sp, #12]
90001868:	9902      	ldr	r1, [sp, #8]
9000186a:	2000      	movs	r0, #0
9000186c:	6191      	str	r1, [r2, #24]
9000186e:	b004      	add	sp, #16
90001870:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

90001874 <.text_47>:
90001874:	000c000a 	.word	0x000c000a

90001878 <.text_48>:
90001878:	000f000a 	.word	0x000f000a

9000187c <.text_49>:
9000187c:	00150019 	.word	0x00150019

90001880 <.text_50>:
90001880:	00190015 	.word	0x00190015

90001884 <D48_1CH_HTONS_VOL_HP>:
90001884:	e92d 4ff4 	stmdb	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
90001888:	b083      	sub	sp, #12
9000188a:	4684      	mov	ip, r0
9000188c:	4688      	mov	r8, r1
9000188e:	9d03      	ldr	r5, [sp, #12]
90001890:	6910      	ldr	r0, [r2, #16]
90001892:	6951      	ldr	r1, [r2, #20]
90001894:	6994      	ldr	r4, [r2, #24]
90001896:	9402      	str	r4, [sp, #8]
90001898:	69ea      	ldr	r2, [r5, #28]
9000189a:	68ab      	ldr	r3, [r5, #8]
9000189c:	f8d5 e00c 	ldr.w	lr, [r5, #12]
900018a0:	6b2c      	ldr	r4, [r5, #48]	; 0x30
900018a2:	8cee      	ldrh	r6, [r5, #38]	; 0x26
900018a4:	6a2d      	ldr	r5, [r5, #32]
900018a6:	2e01      	cmp	r6, #1
900018a8:	f2c0 8085 	blt.w	900019b6 <D48_1CH_HTONS_VOL_HP+0x132>
900018ac:	f8df 951c 	ldr.w	r9, [pc, #1308]	; 90001dcc <.text_66>
900018b0:	9401      	str	r4, [sp, #4]
900018b2:	9500      	str	r5, [sp, #0]
900018b4:	f10c 0404 	add.w	r4, ip, #4
900018b8:	f8dc 5000 	ldr.w	r5, [ip]
900018bc:	6827      	ldr	r7, [r4, #0]
900018be:	f104 0c02 	add.w	ip, r4, #2
900018c2:	ba6d      	rev16	r5, r5
900018c4:	f005 0aff 	and.w	sl, r5, #255	; 0xff
900018c8:	0a2d      	lsrs	r5, r5, #8
900018ca:	ba7c      	rev16	r4, r7
900018cc:	f109 0704 	add.w	r7, r9, #4
900018d0:	f857 b02a 	ldr.w	fp, [r7, sl, lsl #2]
900018d4:	f005 0aff 	and.w	sl, r5, #255	; 0xff
900018d8:	eb0b 2b92 	add.w	fp, fp, r2, lsr #10
900018dc:	f109 0204 	add.w	r2, r9, #4
900018e0:	f852 a02a 	ldr.w	sl, [r2, sl, lsl #2]
900018e4:	0a2a      	lsrs	r2, r5, #8
900018e6:	eb0a 2a9b 	add.w	sl, sl, fp, lsr #10
900018ea:	f3cb 0709 	ubfx	r7, fp, #0, #10
900018ee:	f109 0b04 	add.w	fp, r9, #4
900018f2:	f3ca 0509 	ubfx	r5, sl, #0, #10
900018f6:	ea45 4507 	orr.w	r5, r5, r7, lsl #16
900018fa:	f002 07ff 	and.w	r7, r2, #255	; 0xff
900018fe:	f85b 7027 	ldr.w	r7, [fp, r7, lsl #2]
90001902:	0a12      	lsrs	r2, r2, #8
90001904:	eb07 279a 	add.w	r7, r7, sl, lsr #10
90001908:	f109 0a04 	add.w	sl, r9, #4
9000190c:	f85a a022 	ldr.w	sl, [sl, r2, lsl #2]
90001910:	f004 02ff 	and.w	r2, r4, #255	; 0xff
90001914:	f3c4 2407 	ubfx	r4, r4, #8, #8
90001918:	eb0a 2a97 	add.w	sl, sl, r7, lsr #10
9000191c:	f3c7 0b09 	ubfx	fp, r7, #0, #10
90001920:	f3ca 0709 	ubfx	r7, sl, #0, #10
90001924:	ea47 470b 	orr.w	r7, r7, fp, lsl #16
90001928:	f109 0b04 	add.w	fp, r9, #4
9000192c:	f85b 2022 	ldr.w	r2, [fp, r2, lsl #2]
90001930:	f85b 4024 	ldr.w	r4, [fp, r4, lsl #2]
90001934:	f8df b7b0 	ldr.w	fp, [pc, #1968]	; 900020e8 <.text_84>
90001938:	eb02 229a 	add.w	r2, r2, sl, lsr #10
9000193c:	f3c2 0a09 	ubfx	sl, r2, #0, #10
90001940:	eb04 2292 	add.w	r2, r4, r2, lsr #10
90001944:	f3c2 0409 	ubfx	r4, r2, #0, #10
90001948:	ea44 440a 	orr.w	r4, r4, sl, lsl #16
9000194c:	f8df a7a4 	ldr.w	sl, [pc, #1956]	; 900020f4 <.text_87>
90001950:	fb25 ee0a 	smlad	lr, r5, sl, lr
90001954:	f44f 3a80 	mov.w	sl, #65536	; 0x10000
90001958:	fb27 ee0b 	smlad	lr, r7, fp, lr
9000195c:	f04f 1b1b 	mov.w	fp, #1769499	; 0x1b001b
90001960:	fb24 ea0a 	smlad	sl, r4, sl, lr
90001964:	f8df e790 	ldr.w	lr, [pc, #1936]	; 900020f8 <.text_88>
90001968:	fb25 330e 	smlad	r3, r5, lr, r3
9000196c:	f8df e78c 	ldr.w	lr, [pc, #1932]	; 900020fc <.text_89>
90001970:	fb27 330b 	smlad	r3, r7, fp, r3
90001974:	f5aa 4a58 	sub.w	sl, sl, #55296	; 0xd800
90001978:	4450      	add	r0, sl
9000197a:	1a40      	subs	r0, r0, r1
9000197c:	4651      	mov	r1, sl
9000197e:	fb24 3e0e 	smlad	lr, r4, lr, r3
90001982:	2301      	movs	r3, #1
90001984:	fb25 f303 	smuad	r3, r5, r3
90001988:	f8df 5764 	ldr.w	r5, [pc, #1892]	; 900020f0 <.text_86>
9000198c:	fb27 3305 	smlad	r3, r7, r5, r3
90001990:	f8df 776c 	ldr.w	r7, [pc, #1900]	; 90002100 <.text_90>
90001994:	9d01      	ldr	r5, [sp, #4]
90001996:	fb24 3307 	smlad	r3, r4, r7, r3
9000199a:	9c00      	ldr	r4, [sp, #0]
9000199c:	fb50 f014 	smmulr	r0, r0, r4
900019a0:	0040      	lsls	r0, r0, #1
900019a2:	02c4      	lsls	r4, r0, #11
900019a4:	fb54 f415 	smmulr	r4, r4, r5
900019a8:	1e76      	subs	r6, r6, #1
900019aa:	f324 048f 	ssat	r4, #16, r4, asr #2
900019ae:	f828 4b02 	strh.w	r4, [r8], #2
900019b2:	f47f af7f 	bne.w	900018b4 <D48_1CH_HTONS_VOL_HP+0x30>
900019b6:	9c03      	ldr	r4, [sp, #12]
900019b8:	60a3      	str	r3, [r4, #8]
900019ba:	9b03      	ldr	r3, [sp, #12]
900019bc:	f8c3 e00c 	str.w	lr, [r3, #12]
900019c0:	9c03      	ldr	r4, [sp, #12]
900019c2:	61e2      	str	r2, [r4, #28]
900019c4:	9a03      	ldr	r2, [sp, #12]
900019c6:	6110      	str	r0, [r2, #16]
900019c8:	9803      	ldr	r0, [sp, #12]
900019ca:	6141      	str	r1, [r0, #20]
900019cc:	9a03      	ldr	r2, [sp, #12]
900019ce:	9902      	ldr	r1, [sp, #8]
900019d0:	2000      	movs	r0, #0
900019d2:	6191      	str	r1, [r2, #24]
900019d4:	b004      	add	sp, #16
900019d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

900019dc <.text_52>:
900019dc:	000a000f 	.word	0x000a000f

900019e0 <.text_53>:
900019e0:	001c0015 	.word	0x001c0015

900019e4 <.text_54>:
900019e4:	0024002a 	.word	0x0024002a

900019e8 <.text_55>:
900019e8:	002e0030 	.word	0x002e0030

900019ec <D64_1CH_HTONS_VOL_HP>:
900019ec:	e92d 4ff4 	stmdb	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
900019f0:	b084      	sub	sp, #16
900019f2:	468e      	mov	lr, r1
900019f4:	6916      	ldr	r6, [r2, #16]
900019f6:	f8d2 b014 	ldr.w	fp, [r2, #20]
900019fa:	6991      	ldr	r1, [r2, #24]
900019fc:	9a04      	ldr	r2, [sp, #16]
900019fe:	4604      	mov	r4, r0
90001a00:	9102      	str	r1, [sp, #8]
90001a02:	69d1      	ldr	r1, [r2, #28]
90001a04:	4610      	mov	r0, r2
90001a06:	f8d2 800c 	ldr.w	r8, [r2, #12]
90001a0a:	6885      	ldr	r5, [r0, #8]
90001a0c:	6b02      	ldr	r2, [r0, #48]	; 0x30
90001a0e:	4603      	mov	r3, r0
90001a10:	8cd8      	ldrh	r0, [r3, #38]	; 0x26
90001a12:	6a1b      	ldr	r3, [r3, #32]
90001a14:	2801      	cmp	r0, #1
90001a16:	f2c0 80a6 	blt.w	90001b66 <D64_1CH_HTONS_VOL_HP+0x17a>
90001a1a:	9403      	str	r4, [sp, #12]
90001a1c:	f8df c3ac 	ldr.w	ip, [pc, #940]	; 90001dcc <.text_66>
90001a20:	9201      	str	r2, [sp, #4]
90001a22:	9300      	str	r3, [sp, #0]
90001a24:	9f03      	ldr	r7, [sp, #12]
90001a26:	f10c 0904 	add.w	r9, ip, #4
90001a2a:	3708      	adds	r7, #8
90001a2c:	9703      	str	r7, [sp, #12]
90001a2e:	3f08      	subs	r7, #8
90001a30:	e9d7 2300 	ldrd	r2, r3, [r7]
90001a34:	ba54      	rev16	r4, r2
90001a36:	ba5a      	rev16	r2, r3
90001a38:	f10c 0304 	add.w	r3, ip, #4
90001a3c:	f004 0aff 	and.w	sl, r4, #255	; 0xff
90001a40:	0a24      	lsrs	r4, r4, #8
90001a42:	f859 702a 	ldr.w	r7, [r9, sl, lsl #2]
90001a46:	f004 09ff 	and.w	r9, r4, #255	; 0xff
90001a4a:	0a24      	lsrs	r4, r4, #8
90001a4c:	f853 9029 	ldr.w	r9, [r3, r9, lsl #2]
90001a50:	1879      	adds	r1, r7, r1
90001a52:	f3c1 0a09 	ubfx	sl, r1, #0, #10
90001a56:	eb09 2991 	add.w	r9, r9, r1, lsr #10
90001a5a:	f10c 0104 	add.w	r1, ip, #4
90001a5e:	f10c 0704 	add.w	r7, ip, #4
90001a62:	f3c9 0309 	ubfx	r3, r9, #0, #10
90001a66:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
90001a6a:	f004 0aff 	and.w	sl, r4, #255	; 0xff
90001a6e:	0a24      	lsrs	r4, r4, #8
90001a70:	f851 a02a 	ldr.w	sl, [r1, sl, lsl #2]
90001a74:	f857 1024 	ldr.w	r1, [r7, r4, lsl #2]
90001a78:	eb0a 2a99 	add.w	sl, sl, r9, lsr #10
90001a7c:	eb01 219a 	add.w	r1, r1, sl, lsr #10
90001a80:	f3ca 0909 	ubfx	r9, sl, #0, #10
90001a84:	f002 0aff 	and.w	sl, r2, #255	; 0xff
90001a88:	0a12      	lsrs	r2, r2, #8
90001a8a:	f3c1 0409 	ubfx	r4, r1, #0, #10
90001a8e:	ea44 4409 	orr.w	r4, r4, r9, lsl #16
90001a92:	f10c 0904 	add.w	r9, ip, #4
90001a96:	f859 902a 	ldr.w	r9, [r9, sl, lsl #2]
90001a9a:	eb09 2991 	add.w	r9, r9, r1, lsr #10
90001a9e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
90001aa2:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
90001aa6:	0a12      	lsrs	r2, r2, #8
90001aa8:	f002 07ff 	and.w	r7, r2, #255	; 0xff
90001aac:	0a12      	lsrs	r2, r2, #8
90001aae:	eb01 2199 	add.w	r1, r1, r9, lsr #10
90001ab2:	f3c9 0a09 	ubfx	sl, r9, #0, #10
90001ab6:	f3c1 0909 	ubfx	r9, r1, #0, #10
90001aba:	ea49 490a 	orr.w	r9, r9, sl, lsl #16
90001abe:	f10c 0a04 	add.w	sl, ip, #4
90001ac2:	f85a 7027 	ldr.w	r7, [sl, r7, lsl #2]
90001ac6:	eb07 2791 	add.w	r7, r7, r1, lsr #10
90001aca:	f10c 0104 	add.w	r1, ip, #4
90001ace:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
90001ad2:	eb01 2197 	add.w	r1, r1, r7, lsr #10
90001ad6:	f3c7 0a09 	ubfx	sl, r7, #0, #10
90001ada:	f8df 7618 	ldr.w	r7, [pc, #1560]	; 900020f4 <.text_87>
90001ade:	f3c1 0209 	ubfx	r2, r1, #0, #10
90001ae2:	0a89      	lsrs	r1, r1, #10
90001ae4:	ea42 420a 	orr.w	r2, r2, sl, lsl #16
90001ae8:	f8df a618 	ldr.w	sl, [pc, #1560]	; 90002104 <.text_91>
90001aec:	fb23 880a 	smlad	r8, r3, sl, r8
90001af0:	f8df a5f4 	ldr.w	sl, [pc, #1524]	; 900020e8 <.text_84>
90001af4:	fb24 8807 	smlad	r8, r4, r7, r8
90001af8:	f8df 760c 	ldr.w	r7, [pc, #1548]	; 90002108 <.text_92>
90001afc:	fb29 880a 	smlad	r8, r9, sl, r8
90001b00:	f44f 3a80 	mov.w	sl, #65536	; 0x10000
90001b04:	fb22 8a0a 	smlad	sl, r2, sl, r8
90001b08:	f8df 8600 	ldr.w	r8, [pc, #1536]	; 9000210c <.text_93>
90001b0c:	fb23 5808 	smlad	r8, r3, r8, r5
90001b10:	f8df 55f8 	ldr.w	r5, [pc, #1528]	; 9000210c <.text_93>
90001b14:	fb22 8815 	smladx	r8, r2, r5, r8
90001b18:	2501      	movs	r5, #1
90001b1a:	f5aa 3a00 	sub.w	sl, sl, #131072	; 0x20000
90001b1e:	4456      	add	r6, sl
90001b20:	eba6 060b 	sub.w	r6, r6, fp
90001b24:	46d3      	mov	fp, sl
90001b26:	fb24 8807 	smlad	r8, r4, r7, r8
90001b2a:	fb29 8817 	smladx	r8, r9, r7, r8
90001b2e:	f8df 75c0 	ldr.w	r7, [pc, #1472]	; 900020f0 <.text_86>
90001b32:	fb23 f305 	smuad	r3, r3, r5
90001b36:	4d15      	ldr	r5, [pc, #84]	; (90001b8c <.text_57>)
90001b38:	fb24 3307 	smlad	r3, r4, r7, r3
90001b3c:	f8df 45c0 	ldr.w	r4, [pc, #1472]	; 90002100 <.text_90>
90001b40:	fb29 3304 	smlad	r3, r9, r4, r3
90001b44:	fb22 3505 	smlad	r5, r2, r5, r3
90001b48:	9a00      	ldr	r2, [sp, #0]
90001b4a:	9b01      	ldr	r3, [sp, #4]
90001b4c:	fb56 f612 	smmulr	r6, r6, r2
90001b50:	0076      	lsls	r6, r6, #1
90001b52:	02b2      	lsls	r2, r6, #10
90001b54:	fb52 f213 	smmulr	r2, r2, r3
90001b58:	1e40      	subs	r0, r0, #1
90001b5a:	f322 028f 	ssat	r2, #16, r2, asr #2
90001b5e:	f82e 2b02 	strh.w	r2, [lr], #2
90001b62:	f47f af5f 	bne.w	90001a24 <D64_1CH_HTONS_VOL_HP+0x38>
90001b66:	9804      	ldr	r0, [sp, #16]
90001b68:	6085      	str	r5, [r0, #8]
90001b6a:	9a04      	ldr	r2, [sp, #16]
90001b6c:	f8c2 800c 	str.w	r8, [r2, #12]
90001b70:	9804      	ldr	r0, [sp, #16]
90001b72:	61c1      	str	r1, [r0, #28]
90001b74:	9904      	ldr	r1, [sp, #16]
90001b76:	610e      	str	r6, [r1, #16]
90001b78:	9804      	ldr	r0, [sp, #16]
90001b7a:	f8c0 b014 	str.w	fp, [r0, #20]
90001b7e:	9a04      	ldr	r2, [sp, #16]
90001b80:	9902      	ldr	r1, [sp, #8]
90001b82:	2000      	movs	r0, #0
90001b84:	6191      	str	r1, [r2, #24]
90001b86:	b005      	add	sp, #20
90001b88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

90001b8c <.text_57>:
90001b8c:	0015001c 	.word	0x0015001c

90001b90 <.text_58>:
90001b90:	240003b4 	.word	0x240003b4

90001b94 <.text_59>:
90001b94:	002d0024 	.word	0x002d0024

90001b98 <.text_60>:
90001b98:	0037003f 	.word	0x0037003f

90001b9c <D80_1CH_HTONS_VOL_HP>:
90001b9c:	e92d 4ff4 	stmdb	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
90001ba0:	4683      	mov	fp, r0
90001ba2:	b085      	sub	sp, #20
90001ba4:	4610      	mov	r0, r2
90001ba6:	f8dd a014 	ldr.w	sl, [sp, #20]
90001baa:	9f05      	ldr	r7, [sp, #20]
90001bac:	6902      	ldr	r2, [r0, #16]
90001bae:	6943      	ldr	r3, [r0, #20]
90001bb0:	6984      	ldr	r4, [r0, #24]
90001bb2:	9404      	str	r4, [sp, #16]
90001bb4:	4650      	mov	r0, sl
90001bb6:	f8da 501c 	ldr.w	r5, [sl, #28]
90001bba:	6884      	ldr	r4, [r0, #8]
90001bbc:	f8b7 e026 	ldrh.w	lr, [r7, #38]	; 0x26
90001bc0:	f8da a00c 	ldr.w	sl, [sl, #12]
90001bc4:	6b00      	ldr	r0, [r0, #48]	; 0x30
90001bc6:	6a3f      	ldr	r7, [r7, #32]
90001bc8:	f1be 0f01 	cmp.w	lr, #1
90001bcc:	f2c0 80e4 	blt.w	90001d98 <D80_1CH_HTONS_VOL_HP+0x1fc>
90001bd0:	468c      	mov	ip, r1
90001bd2:	9003      	str	r0, [sp, #12]
90001bd4:	497d      	ldr	r1, [pc, #500]	; (90001dcc <.text_66>)
90001bd6:	9702      	str	r7, [sp, #8]
90001bd8:	f8cd c004 	str.w	ip, [sp, #4]
90001bdc:	ea4f 000e 	mov.w	r0, lr
90001be0:	f8db 7000 	ldr.w	r7, [fp]
90001be4:	f8db c004 	ldr.w	ip, [fp, #4]
90001be8:	f8db 8008 	ldr.w	r8, [fp, #8]
90001bec:	f10b 0b0a 	add.w	fp, fp, #10
90001bf0:	fa97 fe97 	rev16.w	lr, r7
90001bf4:	fa9c f99c 	rev16.w	r9, ip
90001bf8:	f101 0c04 	add.w	ip, r1, #4
90001bfc:	fa98 f798 	rev16.w	r7, r8
90001c00:	f00e 08ff 	and.w	r8, lr, #255	; 0xff
90001c04:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
90001c08:	f85c 6028 	ldr.w	r6, [ip, r8, lsl #2]
90001c0c:	f101 0804 	add.w	r8, r1, #4
90001c10:	1975      	adds	r5, r6, r5
90001c12:	f00e 06ff 	and.w	r6, lr, #255	; 0xff
90001c16:	f858 8026 	ldr.w	r8, [r8, r6, lsl #2]
90001c1a:	f3c5 0c09 	ubfx	ip, r5, #0, #10
90001c1e:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
90001c22:	f00e 06ff 	and.w	r6, lr, #255	; 0xff
90001c26:	eb08 2895 	add.w	r8, r8, r5, lsr #10
90001c2a:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
90001c2e:	f3c8 0509 	ubfx	r5, r8, #0, #10
90001c32:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
90001c36:	1d0d      	adds	r5, r1, #4
90001c38:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
90001c3c:	eb06 2698 	add.w	r6, r6, r8, lsr #10
90001c40:	f101 0804 	add.w	r8, r1, #4
90001c44:	f858 802e 	ldr.w	r8, [r8, lr, lsl #2]
90001c48:	eb08 2896 	add.w	r8, r8, r6, lsr #10
90001c4c:	f3c6 0509 	ubfx	r5, r6, #0, #10
90001c50:	1d0e      	adds	r6, r1, #4
90001c52:	f3c8 0e09 	ubfx	lr, r8, #0, #10
90001c56:	ea4e 4e05 	orr.w	lr, lr, r5, lsl #16
90001c5a:	f009 05ff 	and.w	r5, r9, #255	; 0xff
90001c5e:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
90001c62:	ea4f 2919 	mov.w	r9, r9, lsr #8
90001c66:	eb05 2598 	add.w	r5, r5, r8, lsr #10
90001c6a:	9500      	str	r5, [sp, #0]
90001c6c:	f3c5 0809 	ubfx	r8, r5, #0, #10
90001c70:	f009 05ff 	and.w	r5, r9, #255	; 0xff
90001c74:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
90001c78:	9e00      	ldr	r6, [sp, #0]
90001c7a:	ea4f 2919 	mov.w	r9, r9, lsr #8
90001c7e:	eb05 2596 	add.w	r5, r5, r6, lsr #10
90001c82:	9500      	str	r5, [sp, #0]
90001c84:	f3c5 0609 	ubfx	r6, r5, #0, #10
90001c88:	f009 05ff 	and.w	r5, r9, #255	; 0xff
90001c8c:	ea46 4808 	orr.w	r8, r6, r8, lsl #16
90001c90:	1d0e      	adds	r6, r1, #4
90001c92:	f856 6025 	ldr.w	r6, [r6, r5, lsl #2]
90001c96:	9d00      	ldr	r5, [sp, #0]
90001c98:	ea4f 2919 	mov.w	r9, r9, lsr #8
90001c9c:	eb06 2695 	add.w	r6, r6, r5, lsr #10
90001ca0:	9600      	str	r6, [sp, #0]
90001ca2:	f3c6 0509 	ubfx	r5, r6, #0, #10
90001ca6:	1d0e      	adds	r6, r1, #4
90001ca8:	f856 6029 	ldr.w	r6, [r6, r9, lsl #2]
90001cac:	f8dd 9000 	ldr.w	r9, [sp]
90001cb0:	eb06 2699 	add.w	r6, r6, r9, lsr #10
90001cb4:	9600      	str	r6, [sp, #0]
90001cb6:	f3c6 0909 	ubfx	r9, r6, #0, #10
90001cba:	1d0e      	adds	r6, r1, #4
90001cbc:	ea49 4905 	orr.w	r9, r9, r5, lsl #16
90001cc0:	f007 05ff 	and.w	r5, r7, #255	; 0xff
90001cc4:	f856 6025 	ldr.w	r6, [r6, r5, lsl #2]
90001cc8:	9d00      	ldr	r5, [sp, #0]
90001cca:	f3c7 2707 	ubfx	r7, r7, #8, #8
90001cce:	eb06 2695 	add.w	r6, r6, r5, lsr #10
90001cd2:	9600      	str	r6, [sp, #0]
90001cd4:	f3c6 0509 	ubfx	r5, r6, #0, #10
90001cd8:	1d0e      	adds	r6, r1, #4
90001cda:	f856 6027 	ldr.w	r6, [r6, r7, lsl #2]
90001cde:	9f00      	ldr	r7, [sp, #0]
90001ce0:	eb06 2697 	add.w	r6, r6, r7, lsr #10
90001ce4:	f3c6 0709 	ubfx	r7, r6, #0, #10
90001ce8:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
90001cec:	0ab5      	lsrs	r5, r6, #10
90001cee:	f8df 6420 	ldr.w	r6, [pc, #1056]	; 90002110 <.text_94>
90001cf2:	fb2c aa06 	smlad	sl, ip, r6, sl
90001cf6:	f8df 640c 	ldr.w	r6, [pc, #1036]	; 90002104 <.text_91>
90001cfa:	fb2e aa06 	smlad	sl, lr, r6, sl
90001cfe:	f8df 63f4 	ldr.w	r6, [pc, #1012]	; 900020f4 <.text_87>
90001d02:	fb28 aa06 	smlad	sl, r8, r6, sl
90001d06:	f8df 63e0 	ldr.w	r6, [pc, #992]	; 900020e8 <.text_84>
90001d0a:	fb29 aa06 	smlad	sl, r9, r6, sl
90001d0e:	f44f 3680 	mov.w	r6, #65536	; 0x10000
90001d12:	fb27 a606 	smlad	r6, r7, r6, sl
90001d16:	f8df a3fc 	ldr.w	sl, [pc, #1020]	; 90002114 <.text_95>
90001d1a:	fb2c 440a 	smlad	r4, ip, sl, r4
90001d1e:	f8df a09c 	ldr.w	sl, [pc, #156]	; 90001dbc <.text_62>
90001d22:	fb2e 440a 	smlad	r4, lr, sl, r4
90001d26:	f04f 1a4b 	mov.w	sl, #4915275	; 0x4b004b
90001d2a:	f5a6 367a 	sub.w	r6, r6, #256000	; 0x3e800
90001d2e:	18b2      	adds	r2, r6, r2
90001d30:	1ad2      	subs	r2, r2, r3
90001d32:	4633      	mov	r3, r6
90001d34:	fb28 440a 	smlad	r4, r8, sl, r4
90001d38:	f8df a084 	ldr.w	sl, [pc, #132]	; 90001dc0 <.text_63>
90001d3c:	fb29 440a 	smlad	r4, r9, sl, r4
90001d40:	f8df a080 	ldr.w	sl, [pc, #128]	; 90001dc4 <.text_64>
90001d44:	fb27 4a0a 	smlad	sl, r7, sl, r4
90001d48:	2401      	movs	r4, #1
90001d4a:	fb2c fc04 	smuad	ip, ip, r4
90001d4e:	4ce8      	ldr	r4, [pc, #928]	; (900020f0 <.text_86>)
90001d50:	fb2e c404 	smlad	r4, lr, r4, ip
90001d54:	f8df c3a8 	ldr.w	ip, [pc, #936]	; 90002100 <.text_90>
90001d58:	f8df e06c 	ldr.w	lr, [pc, #108]	; 90001dc8 <.text_65>
90001d5c:	fb28 440c 	smlad	r4, r8, ip, r4
90001d60:	f8df 83b4 	ldr.w	r8, [pc, #948]	; 90002118 <.text_96>
90001d64:	f8dd c00c 	ldr.w	ip, [sp, #12]
90001d68:	fb29 4408 	smlad	r4, r9, r8, r4
90001d6c:	fb27 440e 	smlad	r4, r7, lr, r4
90001d70:	9f02      	ldr	r7, [sp, #8]
90001d72:	f8dd e004 	ldr.w	lr, [sp, #4]
90001d76:	fb52 f217 	smmulr	r2, r2, r7
90001d7a:	0052      	lsls	r2, r2, #1
90001d7c:	0257      	lsls	r7, r2, #9
90001d7e:	fb57 f71c 	smmulr	r7, r7, ip
90001d82:	f10e 0e02 	add.w	lr, lr, #2
90001d86:	1e40      	subs	r0, r0, #1
90001d88:	f8cd e004 	str.w	lr, [sp, #4]
90001d8c:	f327 078f 	ssat	r7, #16, r7, asr #2
90001d90:	f82e 7d02 	strh.w	r7, [lr, #-2]!
90001d94:	f47f af24 	bne.w	90001be0 <D80_1CH_HTONS_VOL_HP+0x44>
90001d98:	9805      	ldr	r0, [sp, #20]
90001d9a:	6084      	str	r4, [r0, #8]
90001d9c:	9905      	ldr	r1, [sp, #20]
90001d9e:	f8c1 a00c 	str.w	sl, [r1, #12]
90001da2:	9805      	ldr	r0, [sp, #20]
90001da4:	61c5      	str	r5, [r0, #28]
90001da6:	9905      	ldr	r1, [sp, #20]
90001da8:	610a      	str	r2, [r1, #16]
90001daa:	9805      	ldr	r0, [sp, #20]
90001dac:	6143      	str	r3, [r0, #20]
90001dae:	9a05      	ldr	r2, [sp, #20]
90001db0:	9904      	ldr	r1, [sp, #16]
90001db2:	2000      	movs	r0, #0
90001db4:	6191      	str	r1, [r2, #24]
90001db6:	b006      	add	sp, #24
90001db8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

90001dbc <.text_62>:
90001dbc:	00450049 	.word	0x00450049

90001dc0 <.text_63>:
90001dc0:	00490045 	.word	0x00490045

90001dc4 <.text_64>:
90001dc4:	003f0037 	.word	0x003f0037

90001dc8 <.text_65>:
90001dc8:	0024002d 	.word	0x0024002d

90001dcc <.text_66>:
90001dcc:	240003b0 	.word	0x240003b0

90001dd0 <.text_67>:
90001dd0:	00780069 	.word	0x00780069

90001dd4 <.text_68>:
90001dd4:	005b004e 	.word	0x005b004e

90001dd8 <.text_69>:
90001dd8:	00420037 	.word	0x00420037

90001ddc <D128_1CH_HTONS_VOL_HP>:
90001ddc:	e92d 4ff4 	stmdb	sp!, {r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
90001de0:	b088      	sub	sp, #32
90001de2:	460c      	mov	r4, r1
90001de4:	9b08      	ldr	r3, [sp, #32]
90001de6:	f8d2 b010 	ldr.w	fp, [r2, #16]
90001dea:	f8d2 c014 	ldr.w	ip, [r2, #20]
90001dee:	6991      	ldr	r1, [r2, #24]
90001df0:	4681      	mov	r9, r0
90001df2:	9107      	str	r1, [sp, #28]
90001df4:	69d9      	ldr	r1, [r3, #28]
90001df6:	f8d3 e008 	ldr.w	lr, [r3, #8]
90001dfa:	f8d3 800c 	ldr.w	r8, [r3, #12]
90001dfe:	6b1a      	ldr	r2, [r3, #48]	; 0x30
90001e00:	8cd8      	ldrh	r0, [r3, #38]	; 0x26
90001e02:	6a1b      	ldr	r3, [r3, #32]
90001e04:	2801      	cmp	r0, #1
90001e06:	f2c0 813f 	blt.w	90002088 <D128_1CH_HTONS_VOL_HP+0x2ac>
90001e0a:	f8df a310 	ldr.w	sl, [pc, #784]	; 9000211c <.text_97>
90001e0e:	f8cd 900c 	str.w	r9, [sp, #12]
90001e12:	9206      	str	r2, [sp, #24]
90001e14:	9305      	str	r3, [sp, #20]
90001e16:	9404      	str	r4, [sp, #16]
90001e18:	9c03      	ldr	r4, [sp, #12]
90001e1a:	f10a 0604 	add.w	r6, sl, #4
90001e1e:	3408      	adds	r4, #8
90001e20:	9403      	str	r4, [sp, #12]
90001e22:	3c08      	subs	r4, #8
90001e24:	9d03      	ldr	r5, [sp, #12]
90001e26:	e9d4 2300 	ldrd	r2, r3, [r4]
90001e2a:	3508      	adds	r5, #8
90001e2c:	9503      	str	r5, [sp, #12]
90001e2e:	3d08      	subs	r5, #8
90001e30:	e9d5 4900 	ldrd	r4, r9, [r5]
90001e34:	ba55      	rev16	r5, r2
90001e36:	ba5a      	rev16	r2, r3
90001e38:	ba63      	rev16	r3, r4
90001e3a:	fa99 f499 	rev16.w	r4, r9
90001e3e:	f005 07ff 	and.w	r7, r5, #255	; 0xff
90001e42:	0a2d      	lsrs	r5, r5, #8
90001e44:	f856 9027 	ldr.w	r9, [r6, r7, lsl #2]
90001e48:	f005 07ff 	and.w	r7, r5, #255	; 0xff
90001e4c:	f856 7027 	ldr.w	r7, [r6, r7, lsl #2]
90001e50:	0a2d      	lsrs	r5, r5, #8
90001e52:	4449      	add	r1, r9
90001e54:	f3c1 0909 	ubfx	r9, r1, #0, #10
90001e58:	eb07 2191 	add.w	r1, r7, r1, lsr #10
90001e5c:	f005 07ff 	and.w	r7, r5, #255	; 0xff
90001e60:	0a2d      	lsrs	r5, r5, #8
90001e62:	f3c1 0609 	ubfx	r6, r1, #0, #10
90001e66:	ea46 4909 	orr.w	r9, r6, r9, lsl #16
90001e6a:	f10a 0604 	add.w	r6, sl, #4
90001e6e:	f856 6027 	ldr.w	r6, [r6, r7, lsl #2]
90001e72:	f10a 0704 	add.w	r7, sl, #4
90001e76:	f857 5025 	ldr.w	r5, [r7, r5, lsl #2]
90001e7a:	eb06 2691 	add.w	r6, r6, r1, lsr #10
90001e7e:	eb05 2596 	add.w	r5, r5, r6, lsr #10
90001e82:	f3c6 0109 	ubfx	r1, r6, #0, #10
90001e86:	f3c5 0609 	ubfx	r6, r5, #0, #10
90001e8a:	ea46 4601 	orr.w	r6, r6, r1, lsl #16
90001e8e:	f002 01ff 	and.w	r1, r2, #255	; 0xff
90001e92:	0a12      	lsrs	r2, r2, #8
90001e94:	9602      	str	r6, [sp, #8]
90001e96:	f002 06ff 	and.w	r6, r2, #255	; 0xff
90001e9a:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
90001e9e:	f857 6026 	ldr.w	r6, [r7, r6, lsl #2]
90001ea2:	0a12      	lsrs	r2, r2, #8
90001ea4:	eb01 2195 	add.w	r1, r1, r5, lsr #10
90001ea8:	eb06 2691 	add.w	r6, r6, r1, lsr #10
90001eac:	f3c1 0509 	ubfx	r5, r1, #0, #10
90001eb0:	f002 01ff 	and.w	r1, r2, #255	; 0xff
90001eb4:	0a12      	lsrs	r2, r2, #8
90001eb6:	f3c6 0709 	ubfx	r7, r6, #0, #10
90001eba:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
90001ebe:	f10a 0504 	add.w	r5, sl, #4
90001ec2:	9701      	str	r7, [sp, #4]
90001ec4:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
90001ec8:	eb01 2196 	add.w	r1, r1, r6, lsr #10
90001ecc:	f10a 0604 	add.w	r6, sl, #4
90001ed0:	f856 2022 	ldr.w	r2, [r6, r2, lsl #2]
90001ed4:	f003 06ff 	and.w	r6, r3, #255	; 0xff
90001ed8:	0a1b      	lsrs	r3, r3, #8
90001eda:	eb02 2291 	add.w	r2, r2, r1, lsr #10
90001ede:	f3c1 0509 	ubfx	r5, r1, #0, #10
90001ee2:	f003 01ff 	and.w	r1, r3, #255	; 0xff
90001ee6:	0a1b      	lsrs	r3, r3, #8
90001ee8:	f3c2 0709 	ubfx	r7, r2, #0, #10
90001eec:	ea47 4705 	orr.w	r7, r7, r5, lsl #16
90001ef0:	f10a 0504 	add.w	r5, sl, #4
90001ef4:	9700      	str	r7, [sp, #0]
90001ef6:	f10a 0704 	add.w	r7, sl, #4
90001efa:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
90001efe:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
90001f02:	eb06 2692 	add.w	r6, r6, r2, lsr #10
90001f06:	eb01 2196 	add.w	r1, r1, r6, lsr #10
90001f0a:	f3c6 0509 	ubfx	r5, r6, #0, #10
90001f0e:	f003 06ff 	and.w	r6, r3, #255	; 0xff
90001f12:	0a1b      	lsrs	r3, r3, #8
90001f14:	f3c1 0209 	ubfx	r2, r1, #0, #10
90001f18:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
90001f1c:	f10a 0504 	add.w	r5, sl, #4
90001f20:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
90001f24:	eb06 2691 	add.w	r6, r6, r1, lsr #10
90001f28:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
90001f2c:	eb01 2196 	add.w	r1, r1, r6, lsr #10
90001f30:	f3c6 0509 	ubfx	r5, r6, #0, #10
90001f34:	f004 06ff 	and.w	r6, r4, #255	; 0xff
90001f38:	0a24      	lsrs	r4, r4, #8
90001f3a:	f3c1 0309 	ubfx	r3, r1, #0, #10
90001f3e:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
90001f42:	f10a 0504 	add.w	r5, sl, #4
90001f46:	f855 5026 	ldr.w	r5, [r5, r6, lsl #2]
90001f4a:	eb05 2591 	add.w	r5, r5, r1, lsr #10
90001f4e:	f004 01ff 	and.w	r1, r4, #255	; 0xff
90001f52:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
90001f56:	0a24      	lsrs	r4, r4, #8
90001f58:	f004 07ff 	and.w	r7, r4, #255	; 0xff
90001f5c:	0a24      	lsrs	r4, r4, #8
90001f5e:	eb01 2195 	add.w	r1, r1, r5, lsr #10
90001f62:	f3c5 0609 	ubfx	r6, r5, #0, #10
90001f66:	f3c1 0509 	ubfx	r5, r1, #0, #10
90001f6a:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
90001f6e:	f10a 0604 	add.w	r6, sl, #4
90001f72:	f856 7027 	ldr.w	r7, [r6, r7, lsl #2]
90001f76:	eb07 2791 	add.w	r7, r7, r1, lsr #10
90001f7a:	f10a 0104 	add.w	r1, sl, #4
90001f7e:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
90001f82:	eb01 2197 	add.w	r1, r1, r7, lsr #10
90001f86:	f3c7 0609 	ubfx	r6, r7, #0, #10
90001f8a:	4f65      	ldr	r7, [pc, #404]	; (90002120 <.text_98>)
90001f8c:	f3c1 0409 	ubfx	r4, r1, #0, #10
90001f90:	0a89      	lsrs	r1, r1, #10
90001f92:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
90001f96:	4e63      	ldr	r6, [pc, #396]	; (90002124 <.text_99>)
90001f98:	fb29 8806 	smlad	r8, r9, r6, r8
90001f9c:	9e02      	ldr	r6, [sp, #8]
90001f9e:	fb26 8807 	smlad	r8, r6, r7, r8
90001fa2:	9f01      	ldr	r7, [sp, #4]
90001fa4:	4e60      	ldr	r6, [pc, #384]	; (90002128 <.text_100>)
90001fa6:	fb27 8806 	smlad	r8, r7, r6, r8
90001faa:	9f00      	ldr	r7, [sp, #0]
90001fac:	4e58      	ldr	r6, [pc, #352]	; (90002110 <.text_94>)
90001fae:	fb27 8806 	smlad	r8, r7, r6, r8
90001fb2:	4e54      	ldr	r6, [pc, #336]	; (90002104 <.text_91>)
90001fb4:	4f4c      	ldr	r7, [pc, #304]	; (900020e8 <.text_84>)
90001fb6:	fb22 8806 	smlad	r8, r2, r6, r8
90001fba:	4e4e      	ldr	r6, [pc, #312]	; (900020f4 <.text_87>)
90001fbc:	fb23 8806 	smlad	r8, r3, r6, r8
90001fc0:	f44f 3680 	mov.w	r6, #65536	; 0x10000
90001fc4:	fb25 8807 	smlad	r8, r5, r7, r8
90001fc8:	fb24 8606 	smlad	r6, r4, r6, r8
90001fcc:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 900020b4 <.text_71>
90001fd0:	4f39      	ldr	r7, [pc, #228]	; (900020b8 <.text_72>)
90001fd2:	fb29 ee08 	smlad	lr, r9, r8, lr
90001fd6:	f8dd 8008 	ldr.w	r8, [sp, #8]
90001fda:	f5a6 1680 	sub.w	r6, r6, #1048576	; 0x100000
90001fde:	44b3      	add	fp, r6
90001fe0:	ebab 0b0c 	sub.w	fp, fp, ip
90001fe4:	46b4      	mov	ip, r6
90001fe6:	fb28 ee07 	smlad	lr, r8, r7, lr
90001fea:	9f01      	ldr	r7, [sp, #4]
90001fec:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 900020bc <.text_73>
90001ff0:	fb27 ee08 	smlad	lr, r7, r8, lr
90001ff4:	9f00      	ldr	r7, [sp, #0]
90001ff6:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 900020c0 <.text_74>
90001ffa:	fb27 ee08 	smlad	lr, r7, r8, lr
90001ffe:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 900020c4 <.text_75>
90002002:	4f32      	ldr	r7, [pc, #200]	; (900020cc <.text_77>)
90002004:	fb22 ee08 	smlad	lr, r2, r8, lr
90002008:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 900020c8 <.text_76>
9000200c:	fb23 ee08 	smlad	lr, r3, r8, lr
90002010:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 900020d0 <.text_78>
90002014:	fb25 ee07 	smlad	lr, r5, r7, lr
90002018:	4f35      	ldr	r7, [pc, #212]	; (900020f0 <.text_86>)
9000201a:	fb24 e808 	smlad	r8, r4, r8, lr
9000201e:	f04f 0e01 	mov.w	lr, #1
90002022:	fb29 f90e 	smuad	r9, r9, lr
90002026:	f8dd e008 	ldr.w	lr, [sp, #8]
9000202a:	fb2e 9907 	smlad	r9, lr, r7, r9
9000202e:	9f01      	ldr	r7, [sp, #4]
90002030:	f8df e0cc 	ldr.w	lr, [pc, #204]	; 90002100 <.text_90>
90002034:	fb27 990e 	smlad	r9, r7, lr, r9
90002038:	9f00      	ldr	r7, [sp, #0]
9000203a:	f8df e0dc 	ldr.w	lr, [pc, #220]	; 90002118 <.text_96>
9000203e:	fb27 990e 	smlad	r9, r7, lr, r9
90002042:	f8df e0e8 	ldr.w	lr, [pc, #232]	; 9000212c <.text_101>
90002046:	fb22 920e 	smlad	r2, r2, lr, r9
9000204a:	f8df 9088 	ldr.w	r9, [pc, #136]	; 900020d4 <.text_79>
9000204e:	f8df e08c 	ldr.w	lr, [pc, #140]	; 900020dc <.text_81>
90002052:	fb23 2209 	smlad	r2, r3, r9, r2
90002056:	4b20      	ldr	r3, [pc, #128]	; (900020d8 <.text_80>)
90002058:	fb25 2203 	smlad	r2, r5, r3, r2
9000205c:	9b06      	ldr	r3, [sp, #24]
9000205e:	fb24 2e0e 	smlad	lr, r4, lr, r2
90002062:	9a05      	ldr	r2, [sp, #20]
90002064:	9c04      	ldr	r4, [sp, #16]
90002066:	fb5b fb12 	smmulr	fp, fp, r2
9000206a:	ea4f 0b4b 	mov.w	fp, fp, lsl #1
9000206e:	ea4f 12cb 	mov.w	r2, fp, lsl #7
90002072:	fb52 f213 	smmulr	r2, r2, r3
90002076:	1ca4      	adds	r4, r4, #2
90002078:	1e40      	subs	r0, r0, #1
9000207a:	9404      	str	r4, [sp, #16]
9000207c:	f322 028f 	ssat	r2, #16, r2, asr #2
90002080:	f824 2d02 	strh.w	r2, [r4, #-2]!
90002084:	f47f aec8 	bne.w	90001e18 <D128_1CH_HTONS_VOL_HP+0x3c>
90002088:	9808      	ldr	r0, [sp, #32]
9000208a:	f8c0 e008 	str.w	lr, [r0, #8]
9000208e:	9a08      	ldr	r2, [sp, #32]
90002090:	f8c2 800c 	str.w	r8, [r2, #12]
90002094:	9808      	ldr	r0, [sp, #32]
90002096:	61c1      	str	r1, [r0, #28]
90002098:	9908      	ldr	r1, [sp, #32]
9000209a:	f8c1 b010 	str.w	fp, [r1, #16]
9000209e:	9808      	ldr	r0, [sp, #32]
900020a0:	f8c0 c014 	str.w	ip, [r0, #20]
900020a4:	9a08      	ldr	r2, [sp, #32]
900020a6:	9907      	ldr	r1, [sp, #28]
900020a8:	2000      	movs	r0, #0
900020aa:	6191      	str	r1, [r2, #24]
900020ac:	b009      	add	sp, #36	; 0x24
900020ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

900020b4 <.text_71>:
900020b4:	00880096 	.word	0x00880096

900020b8 <.text_72>:
900020b8:	00a200ac 	.word	0x00a200ac

900020bc <.text_73>:
900020bc:	00b400ba 	.word	0x00b400ba

900020c0 <.text_74>:
900020c0:	00be00c0 	.word	0x00be00c0

900020c4 <.text_75>:
900020c4:	00c000be 	.word	0x00c000be

900020c8 <.text_76>:
900020c8:	00ba00b4 	.word	0x00ba00b4

900020cc <.text_77>:
900020cc:	00ac00a2 	.word	0x00ac00a2

900020d0 <.text_78>:
900020d0:	00960088 	.word	0x00960088

900020d4 <.text_79>:
900020d4:	00370042 	.word	0x00370042

900020d8 <.text_80>:
900020d8:	004e005b 	.word	0x004e005b

900020dc <.text_81>:
900020dc:	00690078 	.word	0x00690078

900020e0 <.text_82>:
900020e0:	00010003 	.word	0x00010003

900020e4 <.text_83>:
900020e4:	00030001 	.word	0x00030001

900020e8 <.text_84>:
900020e8:	00060003 	.word	0x00060003

900020ec <.text_85>:
900020ec:	000a000c 	.word	0x000a000c

900020f0 <.text_86>:
900020f0:	00030006 	.word	0x00030006

900020f4 <.text_87>:
900020f4:	000f000a 	.word	0x000f000a

900020f8 <.text_88>:
900020f8:	00150019 	.word	0x00150019

900020fc <.text_89>:
900020fc:	00190015 	.word	0x00190015

90002100 <.text_90>:
90002100:	000a000f 	.word	0x000a000f

90002104 <.text_91>:
90002104:	001c0015 	.word	0x001c0015

90002108 <.text_92>:
90002108:	002e0030 	.word	0x002e0030

9000210c <.text_93>:
9000210c:	0024002a 	.word	0x0024002a

90002110 <.text_94>:
90002110:	002d0024 	.word	0x002d0024

90002114 <.text_95>:
90002114:	0037003f 	.word	0x0037003f

90002118 <.text_96>:
90002118:	0015001c 	.word	0x0015001c

9000211c <.text_97>:
9000211c:	240003b0 	.word	0x240003b0

90002120 <.text_98>:
90002120:	005b004e 	.word	0x005b004e

90002124 <.text_99>:
90002124:	00780069 	.word	0x00780069

90002128 <.text_100>:
90002128:	00420037 	.word	0x00420037

9000212c <.text_101>:
9000212c:	0024002d 	.word	0x0024002d

90002130 <__aeabi_memset>:
90002130:	b470      	push	{r4, r5, r6}
90002132:	0784      	lsls	r4, r0, #30
90002134:	d046      	beq.n	900021c4 <__aeabi_memset+0x94>
90002136:	1e4c      	subs	r4, r1, #1
90002138:	2900      	cmp	r1, #0
9000213a:	d041      	beq.n	900021c0 <__aeabi_memset+0x90>
9000213c:	b2d5      	uxtb	r5, r2
9000213e:	4603      	mov	r3, r0
90002140:	e002      	b.n	90002148 <__aeabi_memset+0x18>
90002142:	1e61      	subs	r1, r4, #1
90002144:	b3e4      	cbz	r4, 900021c0 <__aeabi_memset+0x90>
90002146:	460c      	mov	r4, r1
90002148:	f803 5b01 	strb.w	r5, [r3], #1
9000214c:	0799      	lsls	r1, r3, #30
9000214e:	d1f8      	bne.n	90002142 <__aeabi_memset+0x12>
90002150:	2c03      	cmp	r4, #3
90002152:	d92e      	bls.n	900021b2 <__aeabi_memset+0x82>
90002154:	b2d5      	uxtb	r5, r2
90002156:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
9000215a:	2c0f      	cmp	r4, #15
9000215c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
90002160:	d919      	bls.n	90002196 <__aeabi_memset+0x66>
90002162:	4626      	mov	r6, r4
90002164:	f103 0110 	add.w	r1, r3, #16
90002168:	3e10      	subs	r6, #16
9000216a:	2e0f      	cmp	r6, #15
9000216c:	f841 5c10 	str.w	r5, [r1, #-16]
90002170:	f841 5c0c 	str.w	r5, [r1, #-12]
90002174:	f841 5c08 	str.w	r5, [r1, #-8]
90002178:	f841 5c04 	str.w	r5, [r1, #-4]
9000217c:	f101 0110 	add.w	r1, r1, #16
90002180:	d8f2      	bhi.n	90002168 <__aeabi_memset+0x38>
90002182:	f1a4 0110 	sub.w	r1, r4, #16
90002186:	f021 010f 	bic.w	r1, r1, #15
9000218a:	f004 040f 	and.w	r4, r4, #15
9000218e:	3110      	adds	r1, #16
90002190:	2c03      	cmp	r4, #3
90002192:	440b      	add	r3, r1
90002194:	d90d      	bls.n	900021b2 <__aeabi_memset+0x82>
90002196:	461e      	mov	r6, r3
90002198:	4621      	mov	r1, r4
9000219a:	3904      	subs	r1, #4
9000219c:	2903      	cmp	r1, #3
9000219e:	f846 5b04 	str.w	r5, [r6], #4
900021a2:	d8fa      	bhi.n	9000219a <__aeabi_memset+0x6a>
900021a4:	1f21      	subs	r1, r4, #4
900021a6:	f021 0103 	bic.w	r1, r1, #3
900021aa:	3104      	adds	r1, #4
900021ac:	440b      	add	r3, r1
900021ae:	f004 0403 	and.w	r4, r4, #3
900021b2:	b12c      	cbz	r4, 900021c0 <__aeabi_memset+0x90>
900021b4:	b2d2      	uxtb	r2, r2
900021b6:	441c      	add	r4, r3
900021b8:	f803 2b01 	strb.w	r2, [r3], #1
900021bc:	42a3      	cmp	r3, r4
900021be:	d1fb      	bne.n	900021b8 <__aeabi_memset+0x88>
900021c0:	bc70      	pop	{r4, r5, r6}
900021c2:	4770      	bx	lr
900021c4:	460c      	mov	r4, r1
900021c6:	4603      	mov	r3, r0
900021c8:	e7c2      	b.n	90002150 <__aeabi_memset+0x20>
900021ca:	0000      	movs	r0, r0
900021cc:	0000      	movs	r0, r0
	...

900021d0 <memchr>:
900021d0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
900021d4:	2a10      	cmp	r2, #16
900021d6:	db2b      	blt.n	90002230 <memchr+0x60>
900021d8:	f010 0f07 	tst.w	r0, #7
900021dc:	d008      	beq.n	900021f0 <memchr+0x20>
900021de:	f810 3b01 	ldrb.w	r3, [r0], #1
900021e2:	3a01      	subs	r2, #1
900021e4:	428b      	cmp	r3, r1
900021e6:	d02d      	beq.n	90002244 <memchr+0x74>
900021e8:	f010 0f07 	tst.w	r0, #7
900021ec:	b342      	cbz	r2, 90002240 <memchr+0x70>
900021ee:	d1f6      	bne.n	900021de <memchr+0xe>
900021f0:	b4f0      	push	{r4, r5, r6, r7}
900021f2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
900021f6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
900021fa:	f022 0407 	bic.w	r4, r2, #7
900021fe:	f07f 0700 	mvns.w	r7, #0
90002202:	2300      	movs	r3, #0
90002204:	e8f0 5602 	ldrd	r5, r6, [r0], #8
90002208:	3c08      	subs	r4, #8
9000220a:	ea85 0501 	eor.w	r5, r5, r1
9000220e:	ea86 0601 	eor.w	r6, r6, r1
90002212:	fa85 f547 	uadd8	r5, r5, r7
90002216:	faa3 f587 	sel	r5, r3, r7
9000221a:	fa86 f647 	uadd8	r6, r6, r7
9000221e:	faa5 f687 	sel	r6, r5, r7
90002222:	b98e      	cbnz	r6, 90002248 <memchr+0x78>
90002224:	d1ee      	bne.n	90002204 <memchr+0x34>
90002226:	bcf0      	pop	{r4, r5, r6, r7}
90002228:	f001 01ff 	and.w	r1, r1, #255	; 0xff
9000222c:	f002 0207 	and.w	r2, r2, #7
90002230:	b132      	cbz	r2, 90002240 <memchr+0x70>
90002232:	f810 3b01 	ldrb.w	r3, [r0], #1
90002236:	3a01      	subs	r2, #1
90002238:	ea83 0301 	eor.w	r3, r3, r1
9000223c:	b113      	cbz	r3, 90002244 <memchr+0x74>
9000223e:	d1f8      	bne.n	90002232 <memchr+0x62>
90002240:	2000      	movs	r0, #0
90002242:	4770      	bx	lr
90002244:	3801      	subs	r0, #1
90002246:	4770      	bx	lr
90002248:	2d00      	cmp	r5, #0
9000224a:	bf06      	itte	eq
9000224c:	4635      	moveq	r5, r6
9000224e:	3803      	subeq	r0, #3
90002250:	3807      	subne	r0, #7
90002252:	f015 0f01 	tst.w	r5, #1
90002256:	d107      	bne.n	90002268 <memchr+0x98>
90002258:	3001      	adds	r0, #1
9000225a:	f415 7f80 	tst.w	r5, #256	; 0x100
9000225e:	bf02      	ittt	eq
90002260:	3001      	addeq	r0, #1
90002262:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
90002266:	3001      	addeq	r0, #1
90002268:	bcf0      	pop	{r4, r5, r6, r7}
9000226a:	3801      	subs	r0, #1
9000226c:	4770      	bx	lr
9000226e:	bf00      	nop

90002270 <strlen>:
90002270:	4603      	mov	r3, r0
90002272:	f813 2b01 	ldrb.w	r2, [r3], #1
90002276:	2a00      	cmp	r2, #0
90002278:	d1fb      	bne.n	90002272 <strlen+0x2>
9000227a:	1a18      	subs	r0, r3, r0
9000227c:	3801      	subs	r0, #1
9000227e:	4770      	bx	lr

90002280 <__aeabi_uldivmod>:
90002280:	b953      	cbnz	r3, 90002298 <__aeabi_uldivmod+0x18>
90002282:	b94a      	cbnz	r2, 90002298 <__aeabi_uldivmod+0x18>
90002284:	2900      	cmp	r1, #0
90002286:	bf08      	it	eq
90002288:	2800      	cmpeq	r0, #0
9000228a:	bf1c      	itt	ne
9000228c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
90002290:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
90002294:	f000 b96e 	b.w	90002574 <__aeabi_idiv0>
90002298:	f1ad 0c08 	sub.w	ip, sp, #8
9000229c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
900022a0:	f000 f806 	bl	900022b0 <__udivmoddi4>
900022a4:	f8dd e004 	ldr.w	lr, [sp, #4]
900022a8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
900022ac:	b004      	add	sp, #16
900022ae:	4770      	bx	lr

900022b0 <__udivmoddi4>:
900022b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
900022b4:	9d08      	ldr	r5, [sp, #32]
900022b6:	4604      	mov	r4, r0
900022b8:	468c      	mov	ip, r1
900022ba:	2b00      	cmp	r3, #0
900022bc:	f040 8083 	bne.w	900023c6 <__udivmoddi4+0x116>
900022c0:	428a      	cmp	r2, r1
900022c2:	4617      	mov	r7, r2
900022c4:	d947      	bls.n	90002356 <__udivmoddi4+0xa6>
900022c6:	fab2 f282 	clz	r2, r2
900022ca:	b142      	cbz	r2, 900022de <__udivmoddi4+0x2e>
900022cc:	f1c2 0020 	rsb	r0, r2, #32
900022d0:	fa24 f000 	lsr.w	r0, r4, r0
900022d4:	4091      	lsls	r1, r2
900022d6:	4097      	lsls	r7, r2
900022d8:	ea40 0c01 	orr.w	ip, r0, r1
900022dc:	4094      	lsls	r4, r2
900022de:	ea4f 4817 	mov.w	r8, r7, lsr #16
900022e2:	0c23      	lsrs	r3, r4, #16
900022e4:	fbbc f6f8 	udiv	r6, ip, r8
900022e8:	fa1f fe87 	uxth.w	lr, r7
900022ec:	fb08 c116 	mls	r1, r8, r6, ip
900022f0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
900022f4:	fb06 f10e 	mul.w	r1, r6, lr
900022f8:	4299      	cmp	r1, r3
900022fa:	d909      	bls.n	90002310 <__udivmoddi4+0x60>
900022fc:	18fb      	adds	r3, r7, r3
900022fe:	f106 30ff 	add.w	r0, r6, #4294967295	; 0xffffffff
90002302:	f080 8119 	bcs.w	90002538 <__udivmoddi4+0x288>
90002306:	4299      	cmp	r1, r3
90002308:	f240 8116 	bls.w	90002538 <__udivmoddi4+0x288>
9000230c:	3e02      	subs	r6, #2
9000230e:	443b      	add	r3, r7
90002310:	1a5b      	subs	r3, r3, r1
90002312:	b2a4      	uxth	r4, r4
90002314:	fbb3 f0f8 	udiv	r0, r3, r8
90002318:	fb08 3310 	mls	r3, r8, r0, r3
9000231c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
90002320:	fb00 fe0e 	mul.w	lr, r0, lr
90002324:	45a6      	cmp	lr, r4
90002326:	d909      	bls.n	9000233c <__udivmoddi4+0x8c>
90002328:	193c      	adds	r4, r7, r4
9000232a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
9000232e:	f080 8105 	bcs.w	9000253c <__udivmoddi4+0x28c>
90002332:	45a6      	cmp	lr, r4
90002334:	f240 8102 	bls.w	9000253c <__udivmoddi4+0x28c>
90002338:	3802      	subs	r0, #2
9000233a:	443c      	add	r4, r7
9000233c:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
90002340:	eba4 040e 	sub.w	r4, r4, lr
90002344:	2600      	movs	r6, #0
90002346:	b11d      	cbz	r5, 90002350 <__udivmoddi4+0xa0>
90002348:	40d4      	lsrs	r4, r2
9000234a:	2300      	movs	r3, #0
9000234c:	e9c5 4300 	strd	r4, r3, [r5]
90002350:	4631      	mov	r1, r6
90002352:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
90002356:	b902      	cbnz	r2, 9000235a <__udivmoddi4+0xaa>
90002358:	deff      	udf	#255	; 0xff
9000235a:	fab2 f282 	clz	r2, r2
9000235e:	2a00      	cmp	r2, #0
90002360:	d150      	bne.n	90002404 <__udivmoddi4+0x154>
90002362:	1bcb      	subs	r3, r1, r7
90002364:	ea4f 4e17 	mov.w	lr, r7, lsr #16
90002368:	fa1f f887 	uxth.w	r8, r7
9000236c:	2601      	movs	r6, #1
9000236e:	fbb3 fcfe 	udiv	ip, r3, lr
90002372:	0c21      	lsrs	r1, r4, #16
90002374:	fb0e 331c 	mls	r3, lr, ip, r3
90002378:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
9000237c:	fb08 f30c 	mul.w	r3, r8, ip
90002380:	428b      	cmp	r3, r1
90002382:	d907      	bls.n	90002394 <__udivmoddi4+0xe4>
90002384:	1879      	adds	r1, r7, r1
90002386:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
9000238a:	d202      	bcs.n	90002392 <__udivmoddi4+0xe2>
9000238c:	428b      	cmp	r3, r1
9000238e:	f200 80e9 	bhi.w	90002564 <__udivmoddi4+0x2b4>
90002392:	4684      	mov	ip, r0
90002394:	1ac9      	subs	r1, r1, r3
90002396:	b2a3      	uxth	r3, r4
90002398:	fbb1 f0fe 	udiv	r0, r1, lr
9000239c:	fb0e 1110 	mls	r1, lr, r0, r1
900023a0:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
900023a4:	fb08 f800 	mul.w	r8, r8, r0
900023a8:	45a0      	cmp	r8, r4
900023aa:	d907      	bls.n	900023bc <__udivmoddi4+0x10c>
900023ac:	193c      	adds	r4, r7, r4
900023ae:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
900023b2:	d202      	bcs.n	900023ba <__udivmoddi4+0x10a>
900023b4:	45a0      	cmp	r8, r4
900023b6:	f200 80d9 	bhi.w	9000256c <__udivmoddi4+0x2bc>
900023ba:	4618      	mov	r0, r3
900023bc:	eba4 0408 	sub.w	r4, r4, r8
900023c0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
900023c4:	e7bf      	b.n	90002346 <__udivmoddi4+0x96>
900023c6:	428b      	cmp	r3, r1
900023c8:	d909      	bls.n	900023de <__udivmoddi4+0x12e>
900023ca:	2d00      	cmp	r5, #0
900023cc:	f000 80b1 	beq.w	90002532 <__udivmoddi4+0x282>
900023d0:	2600      	movs	r6, #0
900023d2:	e9c5 0100 	strd	r0, r1, [r5]
900023d6:	4630      	mov	r0, r6
900023d8:	4631      	mov	r1, r6
900023da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
900023de:	fab3 f683 	clz	r6, r3
900023e2:	2e00      	cmp	r6, #0
900023e4:	d14a      	bne.n	9000247c <__udivmoddi4+0x1cc>
900023e6:	428b      	cmp	r3, r1
900023e8:	d302      	bcc.n	900023f0 <__udivmoddi4+0x140>
900023ea:	4282      	cmp	r2, r0
900023ec:	f200 80b8 	bhi.w	90002560 <__udivmoddi4+0x2b0>
900023f0:	1a84      	subs	r4, r0, r2
900023f2:	eb61 0103 	sbc.w	r1, r1, r3
900023f6:	2001      	movs	r0, #1
900023f8:	468c      	mov	ip, r1
900023fa:	2d00      	cmp	r5, #0
900023fc:	d0a8      	beq.n	90002350 <__udivmoddi4+0xa0>
900023fe:	e9c5 4c00 	strd	r4, ip, [r5]
90002402:	e7a5      	b.n	90002350 <__udivmoddi4+0xa0>
90002404:	f1c2 0320 	rsb	r3, r2, #32
90002408:	fa20 f603 	lsr.w	r6, r0, r3
9000240c:	4097      	lsls	r7, r2
9000240e:	fa01 f002 	lsl.w	r0, r1, r2
90002412:	ea4f 4e17 	mov.w	lr, r7, lsr #16
90002416:	40d9      	lsrs	r1, r3
90002418:	4330      	orrs	r0, r6
9000241a:	0c03      	lsrs	r3, r0, #16
9000241c:	fbb1 f6fe 	udiv	r6, r1, lr
90002420:	fa1f f887 	uxth.w	r8, r7
90002424:	fb0e 1116 	mls	r1, lr, r6, r1
90002428:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
9000242c:	fb06 f108 	mul.w	r1, r6, r8
90002430:	4299      	cmp	r1, r3
90002432:	fa04 f402 	lsl.w	r4, r4, r2
90002436:	d909      	bls.n	9000244c <__udivmoddi4+0x19c>
90002438:	18fb      	adds	r3, r7, r3
9000243a:	f106 3cff 	add.w	ip, r6, #4294967295	; 0xffffffff
9000243e:	f080 808d 	bcs.w	9000255c <__udivmoddi4+0x2ac>
90002442:	4299      	cmp	r1, r3
90002444:	f240 808a 	bls.w	9000255c <__udivmoddi4+0x2ac>
90002448:	3e02      	subs	r6, #2
9000244a:	443b      	add	r3, r7
9000244c:	1a5b      	subs	r3, r3, r1
9000244e:	b281      	uxth	r1, r0
90002450:	fbb3 f0fe 	udiv	r0, r3, lr
90002454:	fb0e 3310 	mls	r3, lr, r0, r3
90002458:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
9000245c:	fb00 f308 	mul.w	r3, r0, r8
90002460:	428b      	cmp	r3, r1
90002462:	d907      	bls.n	90002474 <__udivmoddi4+0x1c4>
90002464:	1879      	adds	r1, r7, r1
90002466:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
9000246a:	d273      	bcs.n	90002554 <__udivmoddi4+0x2a4>
9000246c:	428b      	cmp	r3, r1
9000246e:	d971      	bls.n	90002554 <__udivmoddi4+0x2a4>
90002470:	3802      	subs	r0, #2
90002472:	4439      	add	r1, r7
90002474:	1acb      	subs	r3, r1, r3
90002476:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
9000247a:	e778      	b.n	9000236e <__udivmoddi4+0xbe>
9000247c:	f1c6 0c20 	rsb	ip, r6, #32
90002480:	fa03 f406 	lsl.w	r4, r3, r6
90002484:	fa22 f30c 	lsr.w	r3, r2, ip
90002488:	431c      	orrs	r4, r3
9000248a:	fa20 f70c 	lsr.w	r7, r0, ip
9000248e:	fa01 f306 	lsl.w	r3, r1, r6
90002492:	ea4f 4e14 	mov.w	lr, r4, lsr #16
90002496:	fa21 f10c 	lsr.w	r1, r1, ip
9000249a:	431f      	orrs	r7, r3
9000249c:	0c3b      	lsrs	r3, r7, #16
9000249e:	fbb1 f9fe 	udiv	r9, r1, lr
900024a2:	fa1f f884 	uxth.w	r8, r4
900024a6:	fb0e 1119 	mls	r1, lr, r9, r1
900024aa:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
900024ae:	fb09 fa08 	mul.w	sl, r9, r8
900024b2:	458a      	cmp	sl, r1
900024b4:	fa02 f206 	lsl.w	r2, r2, r6
900024b8:	fa00 f306 	lsl.w	r3, r0, r6
900024bc:	d908      	bls.n	900024d0 <__udivmoddi4+0x220>
900024be:	1861      	adds	r1, r4, r1
900024c0:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
900024c4:	d248      	bcs.n	90002558 <__udivmoddi4+0x2a8>
900024c6:	458a      	cmp	sl, r1
900024c8:	d946      	bls.n	90002558 <__udivmoddi4+0x2a8>
900024ca:	f1a9 0902 	sub.w	r9, r9, #2
900024ce:	4421      	add	r1, r4
900024d0:	eba1 010a 	sub.w	r1, r1, sl
900024d4:	b2bf      	uxth	r7, r7
900024d6:	fbb1 f0fe 	udiv	r0, r1, lr
900024da:	fb0e 1110 	mls	r1, lr, r0, r1
900024de:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
900024e2:	fb00 f808 	mul.w	r8, r0, r8
900024e6:	45b8      	cmp	r8, r7
900024e8:	d907      	bls.n	900024fa <__udivmoddi4+0x24a>
900024ea:	19e7      	adds	r7, r4, r7
900024ec:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
900024f0:	d22e      	bcs.n	90002550 <__udivmoddi4+0x2a0>
900024f2:	45b8      	cmp	r8, r7
900024f4:	d92c      	bls.n	90002550 <__udivmoddi4+0x2a0>
900024f6:	3802      	subs	r0, #2
900024f8:	4427      	add	r7, r4
900024fa:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
900024fe:	eba7 0708 	sub.w	r7, r7, r8
90002502:	fba0 8902 	umull	r8, r9, r0, r2
90002506:	454f      	cmp	r7, r9
90002508:	46c6      	mov	lr, r8
9000250a:	4649      	mov	r1, r9
9000250c:	d31a      	bcc.n	90002544 <__udivmoddi4+0x294>
9000250e:	d017      	beq.n	90002540 <__udivmoddi4+0x290>
90002510:	b15d      	cbz	r5, 9000252a <__udivmoddi4+0x27a>
90002512:	ebb3 020e 	subs.w	r2, r3, lr
90002516:	eb67 0701 	sbc.w	r7, r7, r1
9000251a:	fa07 fc0c 	lsl.w	ip, r7, ip
9000251e:	40f2      	lsrs	r2, r6
90002520:	ea4c 0202 	orr.w	r2, ip, r2
90002524:	40f7      	lsrs	r7, r6
90002526:	e9c5 2700 	strd	r2, r7, [r5]
9000252a:	2600      	movs	r6, #0
9000252c:	4631      	mov	r1, r6
9000252e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
90002532:	462e      	mov	r6, r5
90002534:	4628      	mov	r0, r5
90002536:	e70b      	b.n	90002350 <__udivmoddi4+0xa0>
90002538:	4606      	mov	r6, r0
9000253a:	e6e9      	b.n	90002310 <__udivmoddi4+0x60>
9000253c:	4618      	mov	r0, r3
9000253e:	e6fd      	b.n	9000233c <__udivmoddi4+0x8c>
90002540:	4543      	cmp	r3, r8
90002542:	d2e5      	bcs.n	90002510 <__udivmoddi4+0x260>
90002544:	ebb8 0e02 	subs.w	lr, r8, r2
90002548:	eb69 0104 	sbc.w	r1, r9, r4
9000254c:	3801      	subs	r0, #1
9000254e:	e7df      	b.n	90002510 <__udivmoddi4+0x260>
90002550:	4608      	mov	r0, r1
90002552:	e7d2      	b.n	900024fa <__udivmoddi4+0x24a>
90002554:	4660      	mov	r0, ip
90002556:	e78d      	b.n	90002474 <__udivmoddi4+0x1c4>
90002558:	4681      	mov	r9, r0
9000255a:	e7b9      	b.n	900024d0 <__udivmoddi4+0x220>
9000255c:	4666      	mov	r6, ip
9000255e:	e775      	b.n	9000244c <__udivmoddi4+0x19c>
90002560:	4630      	mov	r0, r6
90002562:	e74a      	b.n	900023fa <__udivmoddi4+0x14a>
90002564:	f1ac 0c02 	sub.w	ip, ip, #2
90002568:	4439      	add	r1, r7
9000256a:	e713      	b.n	90002394 <__udivmoddi4+0xe4>
9000256c:	3802      	subs	r0, #2
9000256e:	443c      	add	r4, r7
90002570:	e724      	b.n	900023bc <__udivmoddi4+0x10c>
90002572:	bf00      	nop

90002574 <__aeabi_idiv0>:
90002574:	4770      	bx	lr
90002576:	bf00      	nop

90002578 <FT5336_RegisterBusIO>:
  * @brief  Register IO bus to component object
  * @param  Component object pointer
  * @retval error status
  */
int32_t FT5336_RegisterBusIO (FT5336_Object_t *pObj, FT5336_IO_t *pIO)
{
90002578:	b580      	push	{r7, lr}
9000257a:	b084      	sub	sp, #16
9000257c:	af00      	add	r7, sp, #0
9000257e:	6078      	str	r0, [r7, #4]
90002580:	6039      	str	r1, [r7, #0]
  int32_t ret;

  if (pObj == NULL)
90002582:	687b      	ldr	r3, [r7, #4]
90002584:	2b00      	cmp	r3, #0
90002586:	d103      	bne.n	90002590 <FT5336_RegisterBusIO+0x18>
  {
    ret = FT5336_ERROR;
90002588:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9000258c:	60fb      	str	r3, [r7, #12]
9000258e:	e02c      	b.n	900025ea <FT5336_RegisterBusIO+0x72>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
90002590:	683b      	ldr	r3, [r7, #0]
90002592:	681a      	ldr	r2, [r3, #0]
90002594:	687b      	ldr	r3, [r7, #4]
90002596:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
90002598:	683b      	ldr	r3, [r7, #0]
9000259a:	685a      	ldr	r2, [r3, #4]
9000259c:	687b      	ldr	r3, [r7, #4]
9000259e:	605a      	str	r2, [r3, #4]
    pObj->IO.Address   = pIO->Address;
900025a0:	683b      	ldr	r3, [r7, #0]
900025a2:	891a      	ldrh	r2, [r3, #8]
900025a4:	687b      	ldr	r3, [r7, #4]
900025a6:	811a      	strh	r2, [r3, #8]
    pObj->IO.WriteReg  = pIO->WriteReg;
900025a8:	683b      	ldr	r3, [r7, #0]
900025aa:	68da      	ldr	r2, [r3, #12]
900025ac:	687b      	ldr	r3, [r7, #4]
900025ae:	60da      	str	r2, [r3, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
900025b0:	683b      	ldr	r3, [r7, #0]
900025b2:	691a      	ldr	r2, [r3, #16]
900025b4:	687b      	ldr	r3, [r7, #4]
900025b6:	611a      	str	r2, [r3, #16]
    pObj->IO.GetTick   = pIO->GetTick;
900025b8:	683b      	ldr	r3, [r7, #0]
900025ba:	695a      	ldr	r2, [r3, #20]
900025bc:	687b      	ldr	r3, [r7, #4]
900025be:	615a      	str	r2, [r3, #20]

    pObj->Ctx.ReadReg  = ReadRegWrap;
900025c0:	687b      	ldr	r3, [r7, #4]
900025c2:	4a0c      	ldr	r2, [pc, #48]	; (900025f4 <FT5336_RegisterBusIO+0x7c>)
900025c4:	61da      	str	r2, [r3, #28]
    pObj->Ctx.WriteReg = WriteRegWrap;
900025c6:	687b      	ldr	r3, [r7, #4]
900025c8:	4a0b      	ldr	r2, [pc, #44]	; (900025f8 <FT5336_RegisterBusIO+0x80>)
900025ca:	619a      	str	r2, [r3, #24]
    pObj->Ctx.handle   = pObj;
900025cc:	687b      	ldr	r3, [r7, #4]
900025ce:	687a      	ldr	r2, [r7, #4]
900025d0:	621a      	str	r2, [r3, #32]

    if(pObj->IO.Init != NULL)
900025d2:	687b      	ldr	r3, [r7, #4]
900025d4:	681b      	ldr	r3, [r3, #0]
900025d6:	2b00      	cmp	r3, #0
900025d8:	d004      	beq.n	900025e4 <FT5336_RegisterBusIO+0x6c>
    {
      ret = pObj->IO.Init();
900025da:	687b      	ldr	r3, [r7, #4]
900025dc:	681b      	ldr	r3, [r3, #0]
900025de:	4798      	blx	r3
900025e0:	60f8      	str	r0, [r7, #12]
900025e2:	e002      	b.n	900025ea <FT5336_RegisterBusIO+0x72>
    }
    else
    {
      ret = FT5336_ERROR;
900025e4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900025e8:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
900025ea:	68fb      	ldr	r3, [r7, #12]
}
900025ec:	4618      	mov	r0, r3
900025ee:	3710      	adds	r7, #16
900025f0:	46bd      	mov	sp, r7
900025f2:	bd80      	pop	{r7, pc}
900025f4:	900029ff 	.word	0x900029ff
900025f8:	90002a33 	.word	0x90002a33

900025fc <FT5336_GetCapabilities>:
  * @param  pObj Component object pointer
  * @param  Capabilities pointer to FT5336 sensor capabilities
  * @retval Component status
  */
int32_t FT5336_GetCapabilities(FT5336_Object_t *pObj, FT5336_Capabilities_t *Capabilities)
{
900025fc:	b480      	push	{r7}
900025fe:	b083      	sub	sp, #12
90002600:	af00      	add	r7, sp, #0
90002602:	6078      	str	r0, [r7, #4]
90002604:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  /* Store component's capabilities */
  Capabilities->MultiTouch = 1;
90002606:	683b      	ldr	r3, [r7, #0]
90002608:	2201      	movs	r2, #1
9000260a:	701a      	strb	r2, [r3, #0]
  Capabilities->Gesture    = 1;
9000260c:	683b      	ldr	r3, [r7, #0]
9000260e:	2201      	movs	r2, #1
90002610:	705a      	strb	r2, [r3, #1]
  Capabilities->MaxTouch   = FT5336_MAX_NB_TOUCH;
90002612:	683b      	ldr	r3, [r7, #0]
90002614:	2205      	movs	r2, #5
90002616:	709a      	strb	r2, [r3, #2]
  Capabilities->MaxXl      = FT5336_MAX_X_LENGTH;
90002618:	683b      	ldr	r3, [r7, #0]
9000261a:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
9000261e:	605a      	str	r2, [r3, #4]
  Capabilities->MaxYl      = FT5336_MAX_Y_LENGTH;
90002620:	683b      	ldr	r3, [r7, #0]
90002622:	f44f 7288 	mov.w	r2, #272	; 0x110
90002626:	609a      	str	r2, [r3, #8]

  return FT5336_OK;
90002628:	2300      	movs	r3, #0
}
9000262a:	4618      	mov	r0, r3
9000262c:	370c      	adds	r7, #12
9000262e:	46bd      	mov	sp, r7
90002630:	f85d 7b04 	ldr.w	r7, [sp], #4
90002634:	4770      	bx	lr

90002636 <FT5336_Init>:
  * @param  pObj Component object pointer
  * @param  GestureInit: Gesture init structure
  * @retval FT5336_OK
  */
int32_t FT5336_Init(FT5336_Object_t *pObj)
{
90002636:	b580      	push	{r7, lr}
90002638:	b084      	sub	sp, #16
9000263a:	af00      	add	r7, sp, #0
9000263c:	6078      	str	r0, [r7, #4]
  int32_t ret = FT5336_OK;
9000263e:	2300      	movs	r3, #0
90002640:	60fb      	str	r3, [r7, #12]

  if(pObj->IsInitialized == 0U)
90002642:	687b      	ldr	r3, [r7, #4]
90002644:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
90002648:	2b00      	cmp	r3, #0
9000264a:	d10d      	bne.n	90002668 <FT5336_Init+0x32>
  {
    /* Initialize IO BUS layer */
    pObj->IO.Init();
9000264c:	687b      	ldr	r3, [r7, #4]
9000264e:	681b      	ldr	r3, [r3, #0]
90002650:	4798      	blx	r3
    /* This is called internal calibration of the touch screen                 */
    ret += FT5336_TS_Calibration(pObj);
#endif /* (FT5336_AUTO_CALIBRATION_ENABLED == 1) */
    /* By default set FT5336 IC in Polling mode : no INT generation on FT5336 for new touch available */
    /* Note TS_INT is active low                                                                      */
    ret += FT5336_DisableIT(pObj);
90002652:	6878      	ldr	r0, [r7, #4]
90002654:	f000 f98e 	bl	90002974 <FT5336_DisableIT>
90002658:	4602      	mov	r2, r0
9000265a:	68fb      	ldr	r3, [r7, #12]
9000265c:	4413      	add	r3, r2
9000265e:	60fb      	str	r3, [r7, #12]

    pObj->IsInitialized = 1;
90002660:	687b      	ldr	r3, [r7, #4]
90002662:	2201      	movs	r2, #1
90002664:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  }

  if(ret != FT5336_OK)
90002668:	68fb      	ldr	r3, [r7, #12]
9000266a:	2b00      	cmp	r3, #0
9000266c:	d002      	beq.n	90002674 <FT5336_Init+0x3e>
  {
    ret = FT5336_ERROR;
9000266e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90002672:	60fb      	str	r3, [r7, #12]
  }

  return ret;
90002674:	68fb      	ldr	r3, [r7, #12]
}
90002676:	4618      	mov	r0, r3
90002678:	3710      	adds	r7, #16
9000267a:	46bd      	mov	sp, r7
9000267c:	bd80      	pop	{r7, pc}

9000267e <FT5336_DeInit>:
  *         from MCU to FT5336 : ie I2C channel initialization (if required).
  * @param  pObj Component object pointer
  * @retval FT5336_OK
  */
int32_t FT5336_DeInit(FT5336_Object_t *pObj)
{
9000267e:	b480      	push	{r7}
90002680:	b085      	sub	sp, #20
90002682:	af00      	add	r7, sp, #0
90002684:	6078      	str	r0, [r7, #4]
  int32_t ret = FT5336_OK;
90002686:	2300      	movs	r3, #0
90002688:	60fb      	str	r3, [r7, #12]

  if(pObj->IsInitialized == 1U)
9000268a:	687b      	ldr	r3, [r7, #4]
9000268c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
90002690:	2b01      	cmp	r3, #1
90002692:	d103      	bne.n	9000269c <FT5336_DeInit+0x1e>
  {
    pObj->IsInitialized = 0;
90002694:	687b      	ldr	r3, [r7, #4]
90002696:	2200      	movs	r2, #0
90002698:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  }

  return ret;
9000269c:	68fb      	ldr	r3, [r7, #12]
}
9000269e:	4618      	mov	r0, r3
900026a0:	3714      	adds	r7, #20
900026a2:	46bd      	mov	sp, r7
900026a4:	f85d 7b04 	ldr.w	r7, [sp], #4
900026a8:	4770      	bx	lr

900026aa <FT5336_GestureConfig>:
  * @param  pObj  Component object pointer
  * @param  GestureInit Gesture init structure
  * @retval FT5336_OK
  */
int32_t FT5336_GestureConfig(FT5336_Object_t *pObj, FT5336_Gesture_Init_t *GestureInit)
{
900026aa:	b580      	push	{r7, lr}
900026ac:	b084      	sub	sp, #16
900026ae:	af00      	add	r7, sp, #0
900026b0:	6078      	str	r0, [r7, #4]
900026b2:	6039      	str	r1, [r7, #0]
  int32_t ret;

  ret = ft5336_radian_value(&pObj->Ctx, (uint8_t)GestureInit->Radian);
900026b4:	687b      	ldr	r3, [r7, #4]
900026b6:	f103 0218 	add.w	r2, r3, #24
900026ba:	683b      	ldr	r3, [r7, #0]
900026bc:	681b      	ldr	r3, [r3, #0]
900026be:	b2db      	uxtb	r3, r3
900026c0:	4619      	mov	r1, r3
900026c2:	4610      	mov	r0, r2
900026c4:	f000 fa2c 	bl	90002b20 <ft5336_radian_value>
900026c8:	60f8      	str	r0, [r7, #12]
  ret += ft5336_offset_left_right(&pObj->Ctx, (uint8_t)GestureInit->OffsetLeftRight);
900026ca:	687b      	ldr	r3, [r7, #4]
900026cc:	f103 0218 	add.w	r2, r3, #24
900026d0:	683b      	ldr	r3, [r7, #0]
900026d2:	685b      	ldr	r3, [r3, #4]
900026d4:	b2db      	uxtb	r3, r3
900026d6:	4619      	mov	r1, r3
900026d8:	4610      	mov	r0, r2
900026da:	f000 fa32 	bl	90002b42 <ft5336_offset_left_right>
900026de:	4602      	mov	r2, r0
900026e0:	68fb      	ldr	r3, [r7, #12]
900026e2:	4413      	add	r3, r2
900026e4:	60fb      	str	r3, [r7, #12]
  ret += ft5336_offset_up_down(&pObj->Ctx, (uint8_t)GestureInit->OffsetUpDown);
900026e6:	687b      	ldr	r3, [r7, #4]
900026e8:	f103 0218 	add.w	r2, r3, #24
900026ec:	683b      	ldr	r3, [r7, #0]
900026ee:	689b      	ldr	r3, [r3, #8]
900026f0:	b2db      	uxtb	r3, r3
900026f2:	4619      	mov	r1, r3
900026f4:	4610      	mov	r0, r2
900026f6:	f000 fa35 	bl	90002b64 <ft5336_offset_up_down>
900026fa:	4602      	mov	r2, r0
900026fc:	68fb      	ldr	r3, [r7, #12]
900026fe:	4413      	add	r3, r2
90002700:	60fb      	str	r3, [r7, #12]
  ret += ft5336_disatnce_left_right(&pObj->Ctx, (uint8_t)GestureInit->DistanceLeftRight);
90002702:	687b      	ldr	r3, [r7, #4]
90002704:	f103 0218 	add.w	r2, r3, #24
90002708:	683b      	ldr	r3, [r7, #0]
9000270a:	68db      	ldr	r3, [r3, #12]
9000270c:	b2db      	uxtb	r3, r3
9000270e:	4619      	mov	r1, r3
90002710:	4610      	mov	r0, r2
90002712:	f000 fa38 	bl	90002b86 <ft5336_disatnce_left_right>
90002716:	4602      	mov	r2, r0
90002718:	68fb      	ldr	r3, [r7, #12]
9000271a:	4413      	add	r3, r2
9000271c:	60fb      	str	r3, [r7, #12]
  ret += ft5336_distance_up_down(&pObj->Ctx, (uint8_t)GestureInit->DistanceUpDown);
9000271e:	687b      	ldr	r3, [r7, #4]
90002720:	f103 0218 	add.w	r2, r3, #24
90002724:	683b      	ldr	r3, [r7, #0]
90002726:	691b      	ldr	r3, [r3, #16]
90002728:	b2db      	uxtb	r3, r3
9000272a:	4619      	mov	r1, r3
9000272c:	4610      	mov	r0, r2
9000272e:	f000 fa3b 	bl	90002ba8 <ft5336_distance_up_down>
90002732:	4602      	mov	r2, r0
90002734:	68fb      	ldr	r3, [r7, #12]
90002736:	4413      	add	r3, r2
90002738:	60fb      	str	r3, [r7, #12]
  ret += ft5336_distance_zoom(&pObj->Ctx, (uint8_t)GestureInit->DistanceZoom);
9000273a:	687b      	ldr	r3, [r7, #4]
9000273c:	f103 0218 	add.w	r2, r3, #24
90002740:	683b      	ldr	r3, [r7, #0]
90002742:	695b      	ldr	r3, [r3, #20]
90002744:	b2db      	uxtb	r3, r3
90002746:	4619      	mov	r1, r3
90002748:	4610      	mov	r0, r2
9000274a:	f000 fa3e 	bl	90002bca <ft5336_distance_zoom>
9000274e:	4602      	mov	r2, r0
90002750:	68fb      	ldr	r3, [r7, #12]
90002752:	4413      	add	r3, r2
90002754:	60fb      	str	r3, [r7, #12]

  if(ret != FT5336_OK)
90002756:	68fb      	ldr	r3, [r7, #12]
90002758:	2b00      	cmp	r3, #0
9000275a:	d002      	beq.n	90002762 <FT5336_GestureConfig+0xb8>
  {
    ret = FT5336_ERROR;
9000275c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90002760:	60fb      	str	r3, [r7, #12]
  }

  return ret;
90002762:	68fb      	ldr	r3, [r7, #12]
}
90002764:	4618      	mov	r0, r3
90002766:	3710      	adds	r7, #16
90002768:	46bd      	mov	sp, r7
9000276a:	bd80      	pop	{r7, pc}

9000276c <FT5336_ReadID>:
  *         able to read the FT5336 device ID, and verify this is a FT5336.
  * @param  pObj Component object pointer
  * @retval The Device ID (two bytes).
  */
int32_t FT5336_ReadID(FT5336_Object_t *pObj, uint32_t *Id)
{
9000276c:	b580      	push	{r7, lr}
9000276e:	b082      	sub	sp, #8
90002770:	af00      	add	r7, sp, #0
90002772:	6078      	str	r0, [r7, #4]
90002774:	6039      	str	r1, [r7, #0]
  return ft5336_chip_id(&pObj->Ctx, (uint8_t *)Id);
90002776:	687b      	ldr	r3, [r7, #4]
90002778:	3318      	adds	r3, #24
9000277a:	6839      	ldr	r1, [r7, #0]
9000277c:	4618      	mov	r0, r3
9000277e:	f000 fa46 	bl	90002c0e <ft5336_chip_id>
90002782:	4603      	mov	r3, r0
}
90002784:	4618      	mov	r0, r3
90002786:	3708      	adds	r7, #8
90002788:	46bd      	mov	sp, r7
9000278a:	bd80      	pop	{r7, pc}

9000278c <FT5336_GetState>:
  * @param  pObj Component object pointer
  * @param  State: Single Touch stucture pointer
  * @retval FT5336_OK.
  */
int32_t FT5336_GetState(FT5336_Object_t *pObj, FT5336_State_t *State)
{
9000278c:	b580      	push	{r7, lr}
9000278e:	b084      	sub	sp, #16
90002790:	af00      	add	r7, sp, #0
90002792:	6078      	str	r0, [r7, #4]
90002794:	6039      	str	r1, [r7, #0]
  int32_t ret = FT5336_OK;
90002796:	2300      	movs	r3, #0
90002798:	60fb      	str	r3, [r7, #12]
  uint8_t  data[4];

  State->TouchDetected = (uint32_t)FT5336_DetectTouch(pObj);
9000279a:	6878      	ldr	r0, [r7, #4]
9000279c:	f000 f90f 	bl	900029be <FT5336_DetectTouch>
900027a0:	4603      	mov	r3, r0
900027a2:	461a      	mov	r2, r3
900027a4:	683b      	ldr	r3, [r7, #0]
900027a6:	601a      	str	r2, [r3, #0]
  if(ft5336_read_reg(&pObj->Ctx, FT5336_P1_XH_REG, data, (uint16_t)sizeof(data)) != FT5336_OK)
900027a8:	687b      	ldr	r3, [r7, #4]
900027aa:	f103 0018 	add.w	r0, r3, #24
900027ae:	f107 0208 	add.w	r2, r7, #8
900027b2:	2304      	movs	r3, #4
900027b4:	2103      	movs	r1, #3
900027b6:	f000 f956 	bl	90002a66 <ft5336_read_reg>
900027ba:	4603      	mov	r3, r0
900027bc:	2b00      	cmp	r3, #0
900027be:	d003      	beq.n	900027c8 <FT5336_GetState+0x3c>
  {
    ret = FT5336_ERROR;
900027c0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900027c4:	60fb      	str	r3, [r7, #12]
900027c6:	e00f      	b.n	900027e8 <FT5336_GetState+0x5c>
  }
  else
  {
    /* Send back first ready X position to caller */
    State->TouchX = (((uint32_t)data[0] & FT5336_P1_XH_TP_BIT_MASK) << 8) | ((uint32_t)data[1] & FT5336_P1_XL_TP_BIT_MASK);
900027c8:	7a3b      	ldrb	r3, [r7, #8]
900027ca:	021b      	lsls	r3, r3, #8
900027cc:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
900027d0:	7a7a      	ldrb	r2, [r7, #9]
900027d2:	431a      	orrs	r2, r3
900027d4:	683b      	ldr	r3, [r7, #0]
900027d6:	605a      	str	r2, [r3, #4]
    /* Send back first ready Y position to caller */
    State->TouchY = (((uint32_t)data[2] & FT5336_P1_YH_TP_BIT_MASK) << 8) | ((uint32_t)data[3] & FT5336_P1_YL_TP_BIT_MASK);
900027d8:	7abb      	ldrb	r3, [r7, #10]
900027da:	021b      	lsls	r3, r3, #8
900027dc:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
900027e0:	7afa      	ldrb	r2, [r7, #11]
900027e2:	431a      	orrs	r2, r3
900027e4:	683b      	ldr	r3, [r7, #0]
900027e6:	609a      	str	r2, [r3, #8]
  }

  return ret;
900027e8:	68fb      	ldr	r3, [r7, #12]
}
900027ea:	4618      	mov	r0, r3
900027ec:	3710      	adds	r7, #16
900027ee:	46bd      	mov	sp, r7
900027f0:	bd80      	pop	{r7, pc}

900027f2 <FT5336_GetMultiTouchState>:
  * @param  pObj Component object pointer
  * @param  State Multi Touch structure pointer
  * @retval FT5336_OK.
  */
int32_t FT5336_GetMultiTouchState(FT5336_Object_t *pObj, FT5336_MultiTouch_State_t *State)
{
900027f2:	b580      	push	{r7, lr}
900027f4:	b08c      	sub	sp, #48	; 0x30
900027f6:	af00      	add	r7, sp, #0
900027f8:	6078      	str	r0, [r7, #4]
900027fa:	6039      	str	r1, [r7, #0]
  int32_t ret = FT5336_OK;
900027fc:	2300      	movs	r3, #0
900027fe:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint8_t  data[30];
  uint32_t i;

  State->TouchDetected = (uint32_t)FT5336_DetectTouch(pObj);
90002800:	6878      	ldr	r0, [r7, #4]
90002802:	f000 f8dc 	bl	900029be <FT5336_DetectTouch>
90002806:	4603      	mov	r3, r0
90002808:	461a      	mov	r2, r3
9000280a:	683b      	ldr	r3, [r7, #0]
9000280c:	601a      	str	r2, [r3, #0]

  if(ft5336_read_reg(&pObj->Ctx, FT5336_P1_XH_REG, data, (uint16_t)sizeof(data)) != FT5336_OK)
9000280e:	687b      	ldr	r3, [r7, #4]
90002810:	f103 0018 	add.w	r0, r3, #24
90002814:	f107 0208 	add.w	r2, r7, #8
90002818:	231e      	movs	r3, #30
9000281a:	2103      	movs	r1, #3
9000281c:	f000 f923 	bl	90002a66 <ft5336_read_reg>
90002820:	4603      	mov	r3, r0
90002822:	2b00      	cmp	r3, #0
90002824:	d003      	beq.n	9000282e <FT5336_GetMultiTouchState+0x3c>
  {
    ret = FT5336_ERROR;
90002826:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9000282a:	62fb      	str	r3, [r7, #44]	; 0x2c
9000282c:	e07e      	b.n	9000292c <FT5336_GetMultiTouchState+0x13a>
  }
  else
  {
    for(i = 0; i < FT5336_MAX_NB_TOUCH; i++)
9000282e:	2300      	movs	r3, #0
90002830:	62bb      	str	r3, [r7, #40]	; 0x28
90002832:	e078      	b.n	90002926 <FT5336_GetMultiTouchState+0x134>
    {
    /* Send back first ready X position to caller */
    State->TouchX[i] = (((uint32_t)data[i*6U] & FT5336_P1_XH_TP_BIT_MASK) << 8U) | ((uint32_t)data[(i*6U) + 1U] & FT5336_P1_XL_TP_BIT_MASK);
90002834:	6aba      	ldr	r2, [r7, #40]	; 0x28
90002836:	4613      	mov	r3, r2
90002838:	005b      	lsls	r3, r3, #1
9000283a:	4413      	add	r3, r2
9000283c:	005b      	lsls	r3, r3, #1
9000283e:	f107 0230 	add.w	r2, r7, #48	; 0x30
90002842:	4413      	add	r3, r2
90002844:	f813 3c28 	ldrb.w	r3, [r3, #-40]
90002848:	021b      	lsls	r3, r3, #8
9000284a:	f403 6170 	and.w	r1, r3, #3840	; 0xf00
9000284e:	6aba      	ldr	r2, [r7, #40]	; 0x28
90002850:	4613      	mov	r3, r2
90002852:	005b      	lsls	r3, r3, #1
90002854:	4413      	add	r3, r2
90002856:	005b      	lsls	r3, r3, #1
90002858:	3301      	adds	r3, #1
9000285a:	f107 0230 	add.w	r2, r7, #48	; 0x30
9000285e:	4413      	add	r3, r2
90002860:	f813 3c28 	ldrb.w	r3, [r3, #-40]
90002864:	ea41 0203 	orr.w	r2, r1, r3
90002868:	6839      	ldr	r1, [r7, #0]
9000286a:	6abb      	ldr	r3, [r7, #40]	; 0x28
9000286c:	009b      	lsls	r3, r3, #2
9000286e:	440b      	add	r3, r1
90002870:	605a      	str	r2, [r3, #4]
    /* Send back first ready Y position to caller */
    State->TouchY[i] = (((uint32_t)data[(i*6U) + 2U] & FT5336_P1_YH_TP_BIT_MASK) << 8U) | ((uint32_t)data[(i*6U) + 3U] & FT5336_P1_YL_TP_BIT_MASK);
90002872:	6aba      	ldr	r2, [r7, #40]	; 0x28
90002874:	4613      	mov	r3, r2
90002876:	005b      	lsls	r3, r3, #1
90002878:	4413      	add	r3, r2
9000287a:	005b      	lsls	r3, r3, #1
9000287c:	3302      	adds	r3, #2
9000287e:	f107 0230 	add.w	r2, r7, #48	; 0x30
90002882:	4413      	add	r3, r2
90002884:	f813 3c28 	ldrb.w	r3, [r3, #-40]
90002888:	021b      	lsls	r3, r3, #8
9000288a:	f403 6170 	and.w	r1, r3, #3840	; 0xf00
9000288e:	6aba      	ldr	r2, [r7, #40]	; 0x28
90002890:	4613      	mov	r3, r2
90002892:	005b      	lsls	r3, r3, #1
90002894:	4413      	add	r3, r2
90002896:	005b      	lsls	r3, r3, #1
90002898:	3303      	adds	r3, #3
9000289a:	f107 0230 	add.w	r2, r7, #48	; 0x30
9000289e:	4413      	add	r3, r2
900028a0:	f813 3c28 	ldrb.w	r3, [r3, #-40]
900028a4:	4319      	orrs	r1, r3
900028a6:	683b      	ldr	r3, [r7, #0]
900028a8:	6aba      	ldr	r2, [r7, #40]	; 0x28
900028aa:	3206      	adds	r2, #6
900028ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    /* Send back first ready Event to caller */
    State->TouchEvent[i] = (((uint32_t)data[i*6U] & FT5336_P1_XH_EF_BIT_MASK) >> FT5336_P1_XH_EF_BIT_POSITION);
900028b0:	6aba      	ldr	r2, [r7, #40]	; 0x28
900028b2:	4613      	mov	r3, r2
900028b4:	005b      	lsls	r3, r3, #1
900028b6:	4413      	add	r3, r2
900028b8:	005b      	lsls	r3, r3, #1
900028ba:	f107 0230 	add.w	r2, r7, #48	; 0x30
900028be:	4413      	add	r3, r2
900028c0:	f813 3c28 	ldrb.w	r3, [r3, #-40]
900028c4:	099b      	lsrs	r3, r3, #6
900028c6:	b2db      	uxtb	r3, r3
900028c8:	4619      	mov	r1, r3
900028ca:	683b      	ldr	r3, [r7, #0]
900028cc:	6aba      	ldr	r2, [r7, #40]	; 0x28
900028ce:	3210      	adds	r2, #16
900028d0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    /* Send back first ready Weight to caller */
    State->TouchWeight[i] = ((uint32_t)data[(i*6U) + 4U] & FT5336_P1_WEIGHT_BIT_MASK);
900028d4:	6aba      	ldr	r2, [r7, #40]	; 0x28
900028d6:	4613      	mov	r3, r2
900028d8:	005b      	lsls	r3, r3, #1
900028da:	4413      	add	r3, r2
900028dc:	005b      	lsls	r3, r3, #1
900028de:	3304      	adds	r3, #4
900028e0:	f107 0230 	add.w	r2, r7, #48	; 0x30
900028e4:	4413      	add	r3, r2
900028e6:	f813 3c28 	ldrb.w	r3, [r3, #-40]
900028ea:	4619      	mov	r1, r3
900028ec:	683a      	ldr	r2, [r7, #0]
900028ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
900028f0:	330a      	adds	r3, #10
900028f2:	009b      	lsls	r3, r3, #2
900028f4:	4413      	add	r3, r2
900028f6:	6059      	str	r1, [r3, #4]
    /* Send back first ready Area to caller */
    State->TouchArea[i] = ((uint32_t)data[(i*6U) + 5U] & FT5336_P1_MISC_BIT_MASK) >> FT5336_P1_MISC_BIT_POSITION;
900028f8:	6aba      	ldr	r2, [r7, #40]	; 0x28
900028fa:	4613      	mov	r3, r2
900028fc:	005b      	lsls	r3, r3, #1
900028fe:	4413      	add	r3, r2
90002900:	005b      	lsls	r3, r3, #1
90002902:	3305      	adds	r3, #5
90002904:	f107 0230 	add.w	r2, r7, #48	; 0x30
90002908:	4413      	add	r3, r2
9000290a:	f813 3c28 	ldrb.w	r3, [r3, #-40]
9000290e:	091b      	lsrs	r3, r3, #4
90002910:	b2db      	uxtb	r3, r3
90002912:	4619      	mov	r1, r3
90002914:	683a      	ldr	r2, [r7, #0]
90002916:	6abb      	ldr	r3, [r7, #40]	; 0x28
90002918:	3314      	adds	r3, #20
9000291a:	009b      	lsls	r3, r3, #2
9000291c:	4413      	add	r3, r2
9000291e:	6059      	str	r1, [r3, #4]
    for(i = 0; i < FT5336_MAX_NB_TOUCH; i++)
90002920:	6abb      	ldr	r3, [r7, #40]	; 0x28
90002922:	3301      	adds	r3, #1
90002924:	62bb      	str	r3, [r7, #40]	; 0x28
90002926:	6abb      	ldr	r3, [r7, #40]	; 0x28
90002928:	2b04      	cmp	r3, #4
9000292a:	d983      	bls.n	90002834 <FT5336_GetMultiTouchState+0x42>
    }
  }

  return ret;
9000292c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
9000292e:	4618      	mov	r0, r3
90002930:	3730      	adds	r7, #48	; 0x30
90002932:	46bd      	mov	sp, r7
90002934:	bd80      	pop	{r7, pc}

90002936 <FT5336_GetGesture>:
  * @param  pObj Component object pointer
  * @param  GestureId: gesture ID
  * @retval Gesture ID.
  */
int32_t FT5336_GetGesture(FT5336_Object_t *pObj, uint8_t *GestureId)
{
90002936:	b580      	push	{r7, lr}
90002938:	b082      	sub	sp, #8
9000293a:	af00      	add	r7, sp, #0
9000293c:	6078      	str	r0, [r7, #4]
9000293e:	6039      	str	r1, [r7, #0]
  return ft5336_gest_id(&pObj->Ctx, GestureId);
90002940:	687b      	ldr	r3, [r7, #4]
90002942:	3318      	adds	r3, #24
90002944:	6839      	ldr	r1, [r7, #0]
90002946:	4618      	mov	r0, r3
90002948:	f000 f8bb 	bl	90002ac2 <ft5336_gest_id>
9000294c:	4603      	mov	r3, r0
}
9000294e:	4618      	mov	r0, r3
90002950:	3708      	adds	r7, #8
90002952:	46bd      	mov	sp, r7
90002954:	bd80      	pop	{r7, pc}

90002956 <FT5336_EnableIT>:
  *         connected to MCU as EXTI.
  * @param  pObj Component object pointer
  * @retval None
  */
int32_t FT5336_EnableIT(FT5336_Object_t *pObj)
{
90002956:	b580      	push	{r7, lr}
90002958:	b082      	sub	sp, #8
9000295a:	af00      	add	r7, sp, #0
9000295c:	6078      	str	r0, [r7, #4]
  return ft5336_g_mode(&pObj->Ctx, FT5336_G_MODE_INTERRUPT_TRIGGER);
9000295e:	687b      	ldr	r3, [r7, #4]
90002960:	3318      	adds	r3, #24
90002962:	2101      	movs	r1, #1
90002964:	4618      	mov	r0, r3
90002966:	f000 f941 	bl	90002bec <ft5336_g_mode>
9000296a:	4603      	mov	r3, r0
}
9000296c:	4618      	mov	r0, r3
9000296e:	3708      	adds	r7, #8
90002970:	46bd      	mov	sp, r7
90002972:	bd80      	pop	{r7, pc}

90002974 <FT5336_DisableIT>:
  *         connected to MCU as EXTI.
  * @param  pObj Component object pointer
  * @retval None
  */
int32_t FT5336_DisableIT(FT5336_Object_t *pObj)
{
90002974:	b580      	push	{r7, lr}
90002976:	b082      	sub	sp, #8
90002978:	af00      	add	r7, sp, #0
9000297a:	6078      	str	r0, [r7, #4]
  return ft5336_g_mode(&pObj->Ctx, FT5336_G_MODE_INTERRUPT_POLLING);
9000297c:	687b      	ldr	r3, [r7, #4]
9000297e:	3318      	adds	r3, #24
90002980:	2100      	movs	r1, #0
90002982:	4618      	mov	r0, r3
90002984:	f000 f932 	bl	90002bec <ft5336_g_mode>
90002988:	4603      	mov	r3, r0
}
9000298a:	4618      	mov	r0, r3
9000298c:	3708      	adds	r7, #8
9000298e:	46bd      	mov	sp, r7
90002990:	bd80      	pop	{r7, pc}

90002992 <FT5336_ITStatus>:
  *         @note : This feature is not applicable to FT5336.
  * @param  pObj Component object pointer
  * @retval TS interrupts status : always return 0 here
  */
int32_t FT5336_ITStatus(FT5336_Object_t *pObj)
{
90002992:	b480      	push	{r7}
90002994:	b083      	sub	sp, #12
90002996:	af00      	add	r7, sp, #0
90002998:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  /* Always return FT5336_OK as feature not applicable to FT5336 */
  return FT5336_OK;
9000299a:	2300      	movs	r3, #0
}
9000299c:	4618      	mov	r0, r3
9000299e:	370c      	adds	r7, #12
900029a0:	46bd      	mov	sp, r7
900029a2:	f85d 7b04 	ldr.w	r7, [sp], #4
900029a6:	4770      	bx	lr

900029a8 <FT5336_ClearIT>:
  *         @note : This feature is not applicable to FT5336.
  * @param  pObj Component object pointer
  * @retval None
  */
int32_t FT5336_ClearIT(FT5336_Object_t *pObj)
{
900029a8:	b480      	push	{r7}
900029aa:	b083      	sub	sp, #12
900029ac:	af00      	add	r7, sp, #0
900029ae:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  (void)(pObj);

  /* Always return FT5336_OK as feature not applicable to FT5336 */
  return FT5336_OK;
900029b0:	2300      	movs	r3, #0
}
900029b2:	4618      	mov	r0, r3
900029b4:	370c      	adds	r7, #12
900029b6:	46bd      	mov	sp, r7
900029b8:	f85d 7b04 	ldr.w	r7, [sp], #4
900029bc:	4770      	bx	lr

900029be <FT5336_DetectTouch>:
  * @param  pObj Component object pointer
  * @retval Number of active touches detected (can be 0, 1 or 2) or FT5336_ERROR
  *         in case of error
  */
static int32_t FT5336_DetectTouch(FT5336_Object_t *pObj)
{
900029be:	b580      	push	{r7, lr}
900029c0:	b084      	sub	sp, #16
900029c2:	af00      	add	r7, sp, #0
900029c4:	6078      	str	r0, [r7, #4]
  int32_t ret;
  uint8_t nb_touch;

  /* Read register FT5336_TD_STAT_REG to check number of touches detection */
  if(ft5336_td_status(&pObj->Ctx, &nb_touch) != FT5336_OK)
900029c6:	687b      	ldr	r3, [r7, #4]
900029c8:	3318      	adds	r3, #24
900029ca:	f107 020b 	add.w	r2, r7, #11
900029ce:	4611      	mov	r1, r2
900029d0:	4618      	mov	r0, r3
900029d2:	f000 f886 	bl	90002ae2 <ft5336_td_status>
900029d6:	4603      	mov	r3, r0
900029d8:	2b00      	cmp	r3, #0
900029da:	d003      	beq.n	900029e4 <FT5336_DetectTouch+0x26>
  {
    ret = FT5336_ERROR;
900029dc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900029e0:	60fb      	str	r3, [r7, #12]
900029e2:	e007      	b.n	900029f4 <FT5336_DetectTouch+0x36>
  }
  else
  {
    if(nb_touch > FT5336_MAX_NB_TOUCH)
900029e4:	7afb      	ldrb	r3, [r7, #11]
900029e6:	2b05      	cmp	r3, #5
900029e8:	d902      	bls.n	900029f0 <FT5336_DetectTouch+0x32>
    {
      /* If invalid number of touch detected, set it to zero */
      ret = 0;
900029ea:	2300      	movs	r3, #0
900029ec:	60fb      	str	r3, [r7, #12]
900029ee:	e001      	b.n	900029f4 <FT5336_DetectTouch+0x36>
    }
    else
    {
      ret = (int32_t)nb_touch;
900029f0:	7afb      	ldrb	r3, [r7, #11]
900029f2:	60fb      	str	r3, [r7, #12]
    }
  }
  return ret;
900029f4:	68fb      	ldr	r3, [r7, #12]
}
900029f6:	4618      	mov	r0, r3
900029f8:	3710      	adds	r7, #16
900029fa:	46bd      	mov	sp, r7
900029fc:	bd80      	pop	{r7, pc}

900029fe <ReadRegWrap>:
  * @param  pData: The target register value to be written
  * @param  Length: buffer size to be written
  * @retval error status
  */
static int32_t ReadRegWrap(void *handle, uint8_t Reg, uint8_t* pData, uint16_t Length)
{
900029fe:	b590      	push	{r4, r7, lr}
90002a00:	b087      	sub	sp, #28
90002a02:	af00      	add	r7, sp, #0
90002a04:	60f8      	str	r0, [r7, #12]
90002a06:	607a      	str	r2, [r7, #4]
90002a08:	461a      	mov	r2, r3
90002a0a:	460b      	mov	r3, r1
90002a0c:	72fb      	strb	r3, [r7, #11]
90002a0e:	4613      	mov	r3, r2
90002a10:	813b      	strh	r3, [r7, #8]
  FT5336_Object_t *pObj = (FT5336_Object_t *)handle;
90002a12:	68fb      	ldr	r3, [r7, #12]
90002a14:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
90002a16:	697b      	ldr	r3, [r7, #20]
90002a18:	691c      	ldr	r4, [r3, #16]
90002a1a:	697b      	ldr	r3, [r7, #20]
90002a1c:	8918      	ldrh	r0, [r3, #8]
90002a1e:	7afb      	ldrb	r3, [r7, #11]
90002a20:	b299      	uxth	r1, r3
90002a22:	893b      	ldrh	r3, [r7, #8]
90002a24:	687a      	ldr	r2, [r7, #4]
90002a26:	47a0      	blx	r4
90002a28:	4603      	mov	r3, r0
}
90002a2a:	4618      	mov	r0, r3
90002a2c:	371c      	adds	r7, #28
90002a2e:	46bd      	mov	sp, r7
90002a30:	bd90      	pop	{r4, r7, pc}

90002a32 <WriteRegWrap>:
  * @param  pData: The target register value to be written
  * @param  Length: buffer size to be written
  * @retval error status
  */
static int32_t WriteRegWrap(void *handle, uint8_t Reg, uint8_t* pData, uint16_t Length)
{
90002a32:	b590      	push	{r4, r7, lr}
90002a34:	b087      	sub	sp, #28
90002a36:	af00      	add	r7, sp, #0
90002a38:	60f8      	str	r0, [r7, #12]
90002a3a:	607a      	str	r2, [r7, #4]
90002a3c:	461a      	mov	r2, r3
90002a3e:	460b      	mov	r3, r1
90002a40:	72fb      	strb	r3, [r7, #11]
90002a42:	4613      	mov	r3, r2
90002a44:	813b      	strh	r3, [r7, #8]
  FT5336_Object_t *pObj = (FT5336_Object_t *)handle;
90002a46:	68fb      	ldr	r3, [r7, #12]
90002a48:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
90002a4a:	697b      	ldr	r3, [r7, #20]
90002a4c:	68dc      	ldr	r4, [r3, #12]
90002a4e:	697b      	ldr	r3, [r7, #20]
90002a50:	8918      	ldrh	r0, [r3, #8]
90002a52:	7afb      	ldrb	r3, [r7, #11]
90002a54:	b299      	uxth	r1, r3
90002a56:	893b      	ldrh	r3, [r7, #8]
90002a58:	687a      	ldr	r2, [r7, #4]
90002a5a:	47a0      	blx	r4
90002a5c:	4603      	mov	r3, r0
}
90002a5e:	4618      	mov	r0, r3
90002a60:	371c      	adds	r7, #28
90002a62:	46bd      	mov	sp, r7
90002a64:	bd90      	pop	{r4, r7, pc}

90002a66 <ft5336_read_reg>:
  * @param  pdata pointer to data to be read
  * @param  length Length of data to read   
  * @retval Component status
  */
int32_t ft5336_read_reg(ft5336_ctx_t *ctx, uint8_t reg, uint8_t* pdata, uint16_t length)
{
90002a66:	b590      	push	{r4, r7, lr}
90002a68:	b085      	sub	sp, #20
90002a6a:	af00      	add	r7, sp, #0
90002a6c:	60f8      	str	r0, [r7, #12]
90002a6e:	607a      	str	r2, [r7, #4]
90002a70:	461a      	mov	r2, r3
90002a72:	460b      	mov	r3, r1
90002a74:	72fb      	strb	r3, [r7, #11]
90002a76:	4613      	mov	r3, r2
90002a78:	813b      	strh	r3, [r7, #8]
  return ctx->ReadReg(ctx->handle, reg, pdata, length);
90002a7a:	68fb      	ldr	r3, [r7, #12]
90002a7c:	685c      	ldr	r4, [r3, #4]
90002a7e:	68fb      	ldr	r3, [r7, #12]
90002a80:	6898      	ldr	r0, [r3, #8]
90002a82:	893b      	ldrh	r3, [r7, #8]
90002a84:	7af9      	ldrb	r1, [r7, #11]
90002a86:	687a      	ldr	r2, [r7, #4]
90002a88:	47a0      	blx	r4
90002a8a:	4603      	mov	r3, r0
}
90002a8c:	4618      	mov	r0, r3
90002a8e:	3714      	adds	r7, #20
90002a90:	46bd      	mov	sp, r7
90002a92:	bd90      	pop	{r4, r7, pc}

90002a94 <ft5336_write_reg>:
  * @param  pdata pointer to data to be written
  * @param  length Length of data to write   
  * @retval Component status
  */
int32_t ft5336_write_reg(ft5336_ctx_t *ctx, uint8_t reg, uint8_t *pdata, uint16_t length)
{
90002a94:	b590      	push	{r4, r7, lr}
90002a96:	b085      	sub	sp, #20
90002a98:	af00      	add	r7, sp, #0
90002a9a:	60f8      	str	r0, [r7, #12]
90002a9c:	607a      	str	r2, [r7, #4]
90002a9e:	461a      	mov	r2, r3
90002aa0:	460b      	mov	r3, r1
90002aa2:	72fb      	strb	r3, [r7, #11]
90002aa4:	4613      	mov	r3, r2
90002aa6:	813b      	strh	r3, [r7, #8]
  return ctx->WriteReg(ctx->handle, reg, pdata, length);
90002aa8:	68fb      	ldr	r3, [r7, #12]
90002aaa:	681c      	ldr	r4, [r3, #0]
90002aac:	68fb      	ldr	r3, [r7, #12]
90002aae:	6898      	ldr	r0, [r3, #8]
90002ab0:	893b      	ldrh	r3, [r7, #8]
90002ab2:	7af9      	ldrb	r1, [r7, #11]
90002ab4:	687a      	ldr	r2, [r7, #4]
90002ab6:	47a0      	blx	r4
90002ab8:	4603      	mov	r3, r0
}
90002aba:	4618      	mov	r0, r3
90002abc:	3714      	adds	r7, #20
90002abe:	46bd      	mov	sp, r7
90002ac0:	bd90      	pop	{r4, r7, pc}

90002ac2 <ft5336_gest_id>:
  * @param  ctx Component context 
  * @param  value pointer to the value of FT5336_GEST_ID_REG register
  * @retval Component status
  */
int32_t  ft5336_gest_id(ft5336_ctx_t *ctx, uint8_t *value)
{
90002ac2:	b580      	push	{r7, lr}
90002ac4:	b082      	sub	sp, #8
90002ac6:	af00      	add	r7, sp, #0
90002ac8:	6078      	str	r0, [r7, #4]
90002aca:	6039      	str	r1, [r7, #0]
  return ft5336_read_reg(ctx, FT5336_GEST_ID_REG, (uint8_t *)value, 1);
90002acc:	2301      	movs	r3, #1
90002ace:	683a      	ldr	r2, [r7, #0]
90002ad0:	2101      	movs	r1, #1
90002ad2:	6878      	ldr	r0, [r7, #4]
90002ad4:	f7ff ffc7 	bl	90002a66 <ft5336_read_reg>
90002ad8:	4603      	mov	r3, r0
}
90002ada:	4618      	mov	r0, r3
90002adc:	3708      	adds	r7, #8
90002ade:	46bd      	mov	sp, r7
90002ae0:	bd80      	pop	{r7, pc}

90002ae2 <ft5336_td_status>:
  * @param  ctx Component context 
  * @param  value pointer to the value of Touch Data Status register
  * @retval Component status
  */
int32_t  ft5336_td_status(ft5336_ctx_t *ctx, uint8_t *value)
{
90002ae2:	b580      	push	{r7, lr}
90002ae4:	b084      	sub	sp, #16
90002ae6:	af00      	add	r7, sp, #0
90002ae8:	6078      	str	r0, [r7, #4]
90002aea:	6039      	str	r1, [r7, #0]
  int32_t ret;
  
  ret = ft5336_read_reg(ctx, FT5336_TD_STAT_REG, (uint8_t *)value, 1);
90002aec:	2301      	movs	r3, #1
90002aee:	683a      	ldr	r2, [r7, #0]
90002af0:	2102      	movs	r1, #2
90002af2:	6878      	ldr	r0, [r7, #4]
90002af4:	f7ff ffb7 	bl	90002a66 <ft5336_read_reg>
90002af8:	60f8      	str	r0, [r7, #12]
  
  if(ret == 0)
90002afa:	68fb      	ldr	r3, [r7, #12]
90002afc:	2b00      	cmp	r3, #0
90002afe:	d10a      	bne.n	90002b16 <ft5336_td_status+0x34>
  {
    *value &= FT5336_TD_STATUS_BIT_MASK; 
90002b00:	683b      	ldr	r3, [r7, #0]
90002b02:	781b      	ldrb	r3, [r3, #0]
90002b04:	f003 030f 	and.w	r3, r3, #15
90002b08:	b2da      	uxtb	r2, r3
90002b0a:	683b      	ldr	r3, [r7, #0]
90002b0c:	701a      	strb	r2, [r3, #0]
    *value = *value >> FT5336_TD_STATUS_BIT_POSITION; 
90002b0e:	683b      	ldr	r3, [r7, #0]
90002b10:	781a      	ldrb	r2, [r3, #0]
90002b12:	683b      	ldr	r3, [r7, #0]
90002b14:	701a      	strb	r2, [r3, #0]
  }
  
  return ret;
90002b16:	68fb      	ldr	r3, [r7, #12]
}
90002b18:	4618      	mov	r0, r3
90002b1a:	3710      	adds	r7, #16
90002b1c:	46bd      	mov	sp, r7
90002b1e:	bd80      	pop	{r7, pc}

90002b20 <ft5336_radian_value>:
  * @param  ctx Component context 
  * @param  value Value to write to FT5336_RADIAN_VALUE_REG register
  * @retval Component status
  */
int32_t  ft5336_radian_value(ft5336_ctx_t *ctx, uint8_t value)
{
90002b20:	b580      	push	{r7, lr}
90002b22:	b082      	sub	sp, #8
90002b24:	af00      	add	r7, sp, #0
90002b26:	6078      	str	r0, [r7, #4]
90002b28:	460b      	mov	r3, r1
90002b2a:	70fb      	strb	r3, [r7, #3]
  return ft5336_write_reg(ctx, FT5336_RADIAN_VALUE_REG, &value, 1);
90002b2c:	1cfa      	adds	r2, r7, #3
90002b2e:	2301      	movs	r3, #1
90002b30:	2191      	movs	r1, #145	; 0x91
90002b32:	6878      	ldr	r0, [r7, #4]
90002b34:	f7ff ffae 	bl	90002a94 <ft5336_write_reg>
90002b38:	4603      	mov	r3, r0
}
90002b3a:	4618      	mov	r0, r3
90002b3c:	3708      	adds	r7, #8
90002b3e:	46bd      	mov	sp, r7
90002b40:	bd80      	pop	{r7, pc}

90002b42 <ft5336_offset_left_right>:
  * @param  ctx Component context 
  * @param  value Value to write to FT5336_OFFSET_LR_REG register
  * @retval Component status
  */
int32_t  ft5336_offset_left_right(ft5336_ctx_t *ctx, uint8_t value)
{
90002b42:	b580      	push	{r7, lr}
90002b44:	b082      	sub	sp, #8
90002b46:	af00      	add	r7, sp, #0
90002b48:	6078      	str	r0, [r7, #4]
90002b4a:	460b      	mov	r3, r1
90002b4c:	70fb      	strb	r3, [r7, #3]
  return ft5336_write_reg(ctx, FT5336_OFFSET_LR_REG, &value, 1);
90002b4e:	1cfa      	adds	r2, r7, #3
90002b50:	2301      	movs	r3, #1
90002b52:	2192      	movs	r1, #146	; 0x92
90002b54:	6878      	ldr	r0, [r7, #4]
90002b56:	f7ff ff9d 	bl	90002a94 <ft5336_write_reg>
90002b5a:	4603      	mov	r3, r0
}
90002b5c:	4618      	mov	r0, r3
90002b5e:	3708      	adds	r7, #8
90002b60:	46bd      	mov	sp, r7
90002b62:	bd80      	pop	{r7, pc}

90002b64 <ft5336_offset_up_down>:
  * @param  ctx Component context 
  * @param  value Value to write to FT5336_OFFSET_UD_REG register
  * @retval Component status
  */
int32_t  ft5336_offset_up_down(ft5336_ctx_t *ctx, uint8_t value)
{
90002b64:	b580      	push	{r7, lr}
90002b66:	b082      	sub	sp, #8
90002b68:	af00      	add	r7, sp, #0
90002b6a:	6078      	str	r0, [r7, #4]
90002b6c:	460b      	mov	r3, r1
90002b6e:	70fb      	strb	r3, [r7, #3]
  return ft5336_write_reg(ctx, FT5336_OFFSET_UD_REG, &value, 1);
90002b70:	1cfa      	adds	r2, r7, #3
90002b72:	2301      	movs	r3, #1
90002b74:	2193      	movs	r1, #147	; 0x93
90002b76:	6878      	ldr	r0, [r7, #4]
90002b78:	f7ff ff8c 	bl	90002a94 <ft5336_write_reg>
90002b7c:	4603      	mov	r3, r0
}
90002b7e:	4618      	mov	r0, r3
90002b80:	3708      	adds	r7, #8
90002b82:	46bd      	mov	sp, r7
90002b84:	bd80      	pop	{r7, pc}

90002b86 <ft5336_disatnce_left_right>:
  * @param  ctx Component context 
  * @param  value Value to write to FT5336_DISTANCE_LR_REG register
  * @retval Component status
  */
int32_t  ft5336_disatnce_left_right(ft5336_ctx_t *ctx, uint8_t value)
{
90002b86:	b580      	push	{r7, lr}
90002b88:	b082      	sub	sp, #8
90002b8a:	af00      	add	r7, sp, #0
90002b8c:	6078      	str	r0, [r7, #4]
90002b8e:	460b      	mov	r3, r1
90002b90:	70fb      	strb	r3, [r7, #3]
  return ft5336_write_reg(ctx, FT5336_DISTANCE_LR_REG, &value, 1);
90002b92:	1cfa      	adds	r2, r7, #3
90002b94:	2301      	movs	r3, #1
90002b96:	2194      	movs	r1, #148	; 0x94
90002b98:	6878      	ldr	r0, [r7, #4]
90002b9a:	f7ff ff7b 	bl	90002a94 <ft5336_write_reg>
90002b9e:	4603      	mov	r3, r0
}
90002ba0:	4618      	mov	r0, r3
90002ba2:	3708      	adds	r7, #8
90002ba4:	46bd      	mov	sp, r7
90002ba6:	bd80      	pop	{r7, pc}

90002ba8 <ft5336_distance_up_down>:
  * @param  ctx Component context 
  * @param  value Value to write to FT5336_DISTANCE_UD_REG register
  * @retval Component status
  */
int32_t  ft5336_distance_up_down(ft5336_ctx_t *ctx, uint8_t value)
{
90002ba8:	b580      	push	{r7, lr}
90002baa:	b082      	sub	sp, #8
90002bac:	af00      	add	r7, sp, #0
90002bae:	6078      	str	r0, [r7, #4]
90002bb0:	460b      	mov	r3, r1
90002bb2:	70fb      	strb	r3, [r7, #3]
  return ft5336_write_reg(ctx, FT5336_DISTANCE_UD_REG, &value, 1);
90002bb4:	1cfa      	adds	r2, r7, #3
90002bb6:	2301      	movs	r3, #1
90002bb8:	2195      	movs	r1, #149	; 0x95
90002bba:	6878      	ldr	r0, [r7, #4]
90002bbc:	f7ff ff6a 	bl	90002a94 <ft5336_write_reg>
90002bc0:	4603      	mov	r3, r0
}
90002bc2:	4618      	mov	r0, r3
90002bc4:	3708      	adds	r7, #8
90002bc6:	46bd      	mov	sp, r7
90002bc8:	bd80      	pop	{r7, pc}

90002bca <ft5336_distance_zoom>:
  * @param  ctx Component context 
  * @param  value Value to write to FT5336_DISTANCE_ZOOM_REG register
  * @retval Component status
  */
int32_t  ft5336_distance_zoom(ft5336_ctx_t *ctx, uint8_t value)
{
90002bca:	b580      	push	{r7, lr}
90002bcc:	b082      	sub	sp, #8
90002bce:	af00      	add	r7, sp, #0
90002bd0:	6078      	str	r0, [r7, #4]
90002bd2:	460b      	mov	r3, r1
90002bd4:	70fb      	strb	r3, [r7, #3]
  return ft5336_write_reg(ctx, FT5336_DISTANCE_ZOOM_REG, &value, 1);
90002bd6:	1cfa      	adds	r2, r7, #3
90002bd8:	2301      	movs	r3, #1
90002bda:	2196      	movs	r1, #150	; 0x96
90002bdc:	6878      	ldr	r0, [r7, #4]
90002bde:	f7ff ff59 	bl	90002a94 <ft5336_write_reg>
90002be2:	4603      	mov	r3, r0
}
90002be4:	4618      	mov	r0, r3
90002be6:	3708      	adds	r7, #8
90002be8:	46bd      	mov	sp, r7
90002bea:	bd80      	pop	{r7, pc}

90002bec <ft5336_g_mode>:
  * @param  ctx Component context 
  * @param  value Value to write to FT5336_GMODE_REG register
  * @retval Component status
  */
int32_t  ft5336_g_mode(ft5336_ctx_t *ctx, uint8_t value)
{
90002bec:	b580      	push	{r7, lr}
90002bee:	b082      	sub	sp, #8
90002bf0:	af00      	add	r7, sp, #0
90002bf2:	6078      	str	r0, [r7, #4]
90002bf4:	460b      	mov	r3, r1
90002bf6:	70fb      	strb	r3, [r7, #3]
  return ft5336_write_reg(ctx, FT5336_GMODE_REG, &value, 1);
90002bf8:	1cfa      	adds	r2, r7, #3
90002bfa:	2301      	movs	r3, #1
90002bfc:	21a4      	movs	r1, #164	; 0xa4
90002bfe:	6878      	ldr	r0, [r7, #4]
90002c00:	f7ff ff48 	bl	90002a94 <ft5336_write_reg>
90002c04:	4603      	mov	r3, r0
}
90002c06:	4618      	mov	r0, r3
90002c08:	3708      	adds	r7, #8
90002c0a:	46bd      	mov	sp, r7
90002c0c:	bd80      	pop	{r7, pc}

90002c0e <ft5336_chip_id>:
  * @param  ctx Component context 
  * @param  value Pointer to FT5336_CHIP_ID_REG register value
  * @retval Component status
  */
int32_t  ft5336_chip_id(ft5336_ctx_t *ctx, uint8_t *value)
{
90002c0e:	b580      	push	{r7, lr}
90002c10:	b084      	sub	sp, #16
90002c12:	af00      	add	r7, sp, #0
90002c14:	6078      	str	r0, [r7, #4]
90002c16:	6039      	str	r1, [r7, #0]
  int32_t ret;
  
  ret = ft5336_read_reg(ctx, FT5336_CHIP_ID_REG, (uint8_t *)value, 1);
90002c18:	2301      	movs	r3, #1
90002c1a:	683a      	ldr	r2, [r7, #0]
90002c1c:	21a8      	movs	r1, #168	; 0xa8
90002c1e:	6878      	ldr	r0, [r7, #4]
90002c20:	f7ff ff21 	bl	90002a66 <ft5336_read_reg>
90002c24:	60f8      	str	r0, [r7, #12]
  
  if(ret == 0)
90002c26:	68fb      	ldr	r3, [r7, #12]
90002c28:	2b00      	cmp	r3, #0
90002c2a:	d107      	bne.n	90002c3c <ft5336_chip_id+0x2e>
  {
    *value &= FT5336_CHIP_ID_BIT_MASK; 
90002c2c:	683b      	ldr	r3, [r7, #0]
90002c2e:	781a      	ldrb	r2, [r3, #0]
90002c30:	683b      	ldr	r3, [r7, #0]
90002c32:	701a      	strb	r2, [r3, #0]
    *value = *value >> FT5336_CHIP_ID_BIT_POSITION; 
90002c34:	683b      	ldr	r3, [r7, #0]
90002c36:	781a      	ldrb	r2, [r3, #0]
90002c38:	683b      	ldr	r3, [r7, #0]
90002c3a:	701a      	strb	r2, [r3, #0]
  }
  
  return ret;
90002c3c:	68fb      	ldr	r3, [r7, #12]
}
90002c3e:	4618      	mov	r0, r3
90002c40:	3710      	adds	r7, #16
90002c42:	46bd      	mov	sp, r7
90002c44:	bd80      	pop	{r7, pc}

90002c46 <MT48LC4M32B2_Init>:
  * @param  Ctx : Component object pointer
  * @param  pRegMode : Pointer to Register Mode stucture
  * @retval error status
  */
int32_t MT48LC4M32B2_Init(SDRAM_HandleTypeDef *Ctx, MT48LC4M32B2_Context_t *pRegMode) 
{
90002c46:	b580      	push	{r7, lr}
90002c48:	b084      	sub	sp, #16
90002c4a:	af00      	add	r7, sp, #0
90002c4c:	6078      	str	r0, [r7, #4]
90002c4e:	6039      	str	r1, [r7, #0]
  int32_t ret = MT48LC4M32B2_ERROR;
90002c50:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90002c54:	60fb      	str	r3, [r7, #12]
  
  /* Step 1: Configure a clock configuration enable command */
  if(MT48LC4M32B2_ClockEnable(Ctx, pRegMode->TargetBank) == MT48LC4M32B2_OK)
90002c56:	683b      	ldr	r3, [r7, #0]
90002c58:	681b      	ldr	r3, [r3, #0]
90002c5a:	4619      	mov	r1, r3
90002c5c:	6878      	ldr	r0, [r7, #4]
90002c5e:	f000 f831 	bl	90002cc4 <MT48LC4M32B2_ClockEnable>
90002c62:	4603      	mov	r3, r0
90002c64:	2b00      	cmp	r3, #0
90002c66:	d128      	bne.n	90002cba <MT48LC4M32B2_Init+0x74>
  {
    /* Step 2: Insert 100 us minimum delay */ 
    /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
    (void)MT48LC4M32B2_Delay(1);
90002c68:	2001      	movs	r0, #1
90002c6a:	f000 f8e1 	bl	90002e30 <MT48LC4M32B2_Delay>
    
    /* Step 3: Configure a PALL (precharge all) command */ 
    if(MT48LC4M32B2_Precharge(Ctx, pRegMode->TargetBank) == MT48LC4M32B2_OK)
90002c6e:	683b      	ldr	r3, [r7, #0]
90002c70:	681b      	ldr	r3, [r3, #0]
90002c72:	4619      	mov	r1, r3
90002c74:	6878      	ldr	r0, [r7, #4]
90002c76:	f000 f849 	bl	90002d0c <MT48LC4M32B2_Precharge>
90002c7a:	4603      	mov	r3, r0
90002c7c:	2b00      	cmp	r3, #0
90002c7e:	d11c      	bne.n	90002cba <MT48LC4M32B2_Init+0x74>
    {
      /* Step 4: Configure a Refresh command */ 
      if(MT48LC4M32B2_RefreshMode(Ctx, pRegMode->TargetBank, pRegMode->RefreshMode) == MT48LC4M32B2_OK)
90002c80:	683b      	ldr	r3, [r7, #0]
90002c82:	6819      	ldr	r1, [r3, #0]
90002c84:	683b      	ldr	r3, [r7, #0]
90002c86:	685b      	ldr	r3, [r3, #4]
90002c88:	461a      	mov	r2, r3
90002c8a:	6878      	ldr	r0, [r7, #4]
90002c8c:	f000 f896 	bl	90002dbc <MT48LC4M32B2_RefreshMode>
90002c90:	4603      	mov	r3, r0
90002c92:	2b00      	cmp	r3, #0
90002c94:	d111      	bne.n	90002cba <MT48LC4M32B2_Init+0x74>
      {
        /* Step 5: Program the external memory mode register */
        if(MT48LC4M32B2_ModeRegConfig(Ctx, pRegMode) == MT48LC4M32B2_OK)
90002c96:	6839      	ldr	r1, [r7, #0]
90002c98:	6878      	ldr	r0, [r7, #4]
90002c9a:	f000 f85b 	bl	90002d54 <MT48LC4M32B2_ModeRegConfig>
90002c9e:	4603      	mov	r3, r0
90002ca0:	2b00      	cmp	r3, #0
90002ca2:	d10a      	bne.n	90002cba <MT48LC4M32B2_Init+0x74>
        {
          /* Step 6: Set the refresh rate counter */
          if(MT48LC4M32B2_RefreshRate(Ctx, pRegMode->RefreshRate) == MT48LC4M32B2_OK)
90002ca4:	683b      	ldr	r3, [r7, #0]
90002ca6:	689b      	ldr	r3, [r3, #8]
90002ca8:	4619      	mov	r1, r3
90002caa:	6878      	ldr	r0, [r7, #4]
90002cac:	f000 f8ac 	bl	90002e08 <MT48LC4M32B2_RefreshRate>
90002cb0:	4603      	mov	r3, r0
90002cb2:	2b00      	cmp	r3, #0
90002cb4:	d101      	bne.n	90002cba <MT48LC4M32B2_Init+0x74>
          {
            ret = MT48LC4M32B2_OK;
90002cb6:	2300      	movs	r3, #0
90002cb8:	60fb      	str	r3, [r7, #12]
          }
        }
      }
    }
  } 
  return ret;
90002cba:	68fb      	ldr	r3, [r7, #12]
}
90002cbc:	4618      	mov	r0, r3
90002cbe:	3710      	adds	r7, #16
90002cc0:	46bd      	mov	sp, r7
90002cc2:	bd80      	pop	{r7, pc}

90002cc4 <MT48LC4M32B2_ClockEnable>:
  * @param  Ctx : Component object pointer
  * @param  Interface : Could be FMC_SDRAM_CMD_TARGET_BANK1 or FMC_SDRAM_CMD_TARGET_BANK2
  * @retval error status
  */
int32_t MT48LC4M32B2_ClockEnable(SDRAM_HandleTypeDef *Ctx, uint32_t Interface) 
{
90002cc4:	b580      	push	{r7, lr}
90002cc6:	b082      	sub	sp, #8
90002cc8:	af00      	add	r7, sp, #0
90002cca:	6078      	str	r0, [r7, #4]
90002ccc:	6039      	str	r1, [r7, #0]
  Command.CommandMode            = MT48LC4M32B2_CLK_ENABLE_CMD;
90002cce:	4b0e      	ldr	r3, [pc, #56]	; (90002d08 <MT48LC4M32B2_ClockEnable+0x44>)
90002cd0:	2201      	movs	r2, #1
90002cd2:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = Interface;
90002cd4:	4a0c      	ldr	r2, [pc, #48]	; (90002d08 <MT48LC4M32B2_ClockEnable+0x44>)
90002cd6:	683b      	ldr	r3, [r7, #0]
90002cd8:	6053      	str	r3, [r2, #4]
  Command.AutoRefreshNumber      = 1;
90002cda:	4b0b      	ldr	r3, [pc, #44]	; (90002d08 <MT48LC4M32B2_ClockEnable+0x44>)
90002cdc:	2201      	movs	r2, #1
90002cde:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
90002ce0:	4b09      	ldr	r3, [pc, #36]	; (90002d08 <MT48LC4M32B2_ClockEnable+0x44>)
90002ce2:	2200      	movs	r2, #0
90002ce4:	60da      	str	r2, [r3, #12]

  /* Send the command */
  if(HAL_SDRAM_SendCommand(Ctx, &Command, MT48LC4M32B2_TIMEOUT) != HAL_OK)
90002ce6:	f64f 72ff 	movw	r2, #65535	; 0xffff
90002cea:	4907      	ldr	r1, [pc, #28]	; (90002d08 <MT48LC4M32B2_ClockEnable+0x44>)
90002cec:	6878      	ldr	r0, [r7, #4]
90002cee:	f011 fdb5 	bl	9001485c <HAL_SDRAM_SendCommand>
90002cf2:	4603      	mov	r3, r0
90002cf4:	2b00      	cmp	r3, #0
90002cf6:	d002      	beq.n	90002cfe <MT48LC4M32B2_ClockEnable+0x3a>
  {
    return MT48LC4M32B2_ERROR;
90002cf8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90002cfc:	e000      	b.n	90002d00 <MT48LC4M32B2_ClockEnable+0x3c>
  }
  else
  {
    return MT48LC4M32B2_OK;
90002cfe:	2300      	movs	r3, #0
  }
}
90002d00:	4618      	mov	r0, r3
90002d02:	3708      	adds	r7, #8
90002d04:	46bd      	mov	sp, r7
90002d06:	bd80      	pop	{r7, pc}
90002d08:	2400117c 	.word	0x2400117c

90002d0c <MT48LC4M32B2_Precharge>:
  * @param  Ctx : Component object pointer
  * @param  Interface : Could be FMC_SDRAM_CMD_TARGET_BANK1 or FMC_SDRAM_CMD_TARGET_BANK2
  * @retval error status
  */
int32_t MT48LC4M32B2_Precharge(SDRAM_HandleTypeDef *Ctx, uint32_t Interface) 
{
90002d0c:	b580      	push	{r7, lr}
90002d0e:	b082      	sub	sp, #8
90002d10:	af00      	add	r7, sp, #0
90002d12:	6078      	str	r0, [r7, #4]
90002d14:	6039      	str	r1, [r7, #0]
  Command.CommandMode            = MT48LC4M32B2_PALL_CMD;
90002d16:	4b0e      	ldr	r3, [pc, #56]	; (90002d50 <MT48LC4M32B2_Precharge+0x44>)
90002d18:	2202      	movs	r2, #2
90002d1a:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = Interface;
90002d1c:	4a0c      	ldr	r2, [pc, #48]	; (90002d50 <MT48LC4M32B2_Precharge+0x44>)
90002d1e:	683b      	ldr	r3, [r7, #0]
90002d20:	6053      	str	r3, [r2, #4]
  Command.AutoRefreshNumber      = 1;
90002d22:	4b0b      	ldr	r3, [pc, #44]	; (90002d50 <MT48LC4M32B2_Precharge+0x44>)
90002d24:	2201      	movs	r2, #1
90002d26:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
90002d28:	4b09      	ldr	r3, [pc, #36]	; (90002d50 <MT48LC4M32B2_Precharge+0x44>)
90002d2a:	2200      	movs	r2, #0
90002d2c:	60da      	str	r2, [r3, #12]

  /* Send the command */
  if(HAL_SDRAM_SendCommand(Ctx, &Command, MT48LC4M32B2_TIMEOUT) != HAL_OK)
90002d2e:	f64f 72ff 	movw	r2, #65535	; 0xffff
90002d32:	4907      	ldr	r1, [pc, #28]	; (90002d50 <MT48LC4M32B2_Precharge+0x44>)
90002d34:	6878      	ldr	r0, [r7, #4]
90002d36:	f011 fd91 	bl	9001485c <HAL_SDRAM_SendCommand>
90002d3a:	4603      	mov	r3, r0
90002d3c:	2b00      	cmp	r3, #0
90002d3e:	d002      	beq.n	90002d46 <MT48LC4M32B2_Precharge+0x3a>
  {
    return MT48LC4M32B2_ERROR;
90002d40:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90002d44:	e000      	b.n	90002d48 <MT48LC4M32B2_Precharge+0x3c>
  }
  else
  {
    return MT48LC4M32B2_OK;
90002d46:	2300      	movs	r3, #0
  }
}
90002d48:	4618      	mov	r0, r3
90002d4a:	3708      	adds	r7, #8
90002d4c:	46bd      	mov	sp, r7
90002d4e:	bd80      	pop	{r7, pc}
90002d50:	2400117c 	.word	0x2400117c

90002d54 <MT48LC4M32B2_ModeRegConfig>:
  * @param  Ctx : Component object pointer
  * @param  pRegMode : Pointer to Register Mode stucture
  * @retval error status
  */
int32_t MT48LC4M32B2_ModeRegConfig(SDRAM_HandleTypeDef *Ctx, MT48LC4M32B2_Context_t *pRegMode) 
{
90002d54:	b580      	push	{r7, lr}
90002d56:	b084      	sub	sp, #16
90002d58:	af00      	add	r7, sp, #0
90002d5a:	6078      	str	r0, [r7, #4]
90002d5c:	6039      	str	r1, [r7, #0]
  uint32_t tmpmrd;

  /* Program the external memory mode register */
  tmpmrd = (uint32_t)pRegMode->BurstLength   |\
90002d5e:	683b      	ldr	r3, [r7, #0]
90002d60:	68da      	ldr	r2, [r3, #12]
                     pRegMode->BurstType     |\
90002d62:	683b      	ldr	r3, [r7, #0]
90002d64:	691b      	ldr	r3, [r3, #16]
  tmpmrd = (uint32_t)pRegMode->BurstLength   |\
90002d66:	431a      	orrs	r2, r3
                     pRegMode->CASLatency    |\
90002d68:	683b      	ldr	r3, [r7, #0]
90002d6a:	695b      	ldr	r3, [r3, #20]
                     pRegMode->BurstType     |\
90002d6c:	431a      	orrs	r2, r3
                     pRegMode->OperationMode |\
90002d6e:	683b      	ldr	r3, [r7, #0]
90002d70:	699b      	ldr	r3, [r3, #24]
                     pRegMode->CASLatency    |\
90002d72:	431a      	orrs	r2, r3
                     pRegMode->WriteBurstMode;
90002d74:	683b      	ldr	r3, [r7, #0]
90002d76:	69db      	ldr	r3, [r3, #28]
  tmpmrd = (uint32_t)pRegMode->BurstLength   |\
90002d78:	4313      	orrs	r3, r2
90002d7a:	60fb      	str	r3, [r7, #12]
  
  Command.CommandMode            = MT48LC4M32B2_LOAD_MODE_CMD;
90002d7c:	4b0e      	ldr	r3, [pc, #56]	; (90002db8 <MT48LC4M32B2_ModeRegConfig+0x64>)
90002d7e:	2204      	movs	r2, #4
90002d80:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = pRegMode->TargetBank;
90002d82:	683b      	ldr	r3, [r7, #0]
90002d84:	681b      	ldr	r3, [r3, #0]
90002d86:	4a0c      	ldr	r2, [pc, #48]	; (90002db8 <MT48LC4M32B2_ModeRegConfig+0x64>)
90002d88:	6053      	str	r3, [r2, #4]
  Command.AutoRefreshNumber      = 1;
90002d8a:	4b0b      	ldr	r3, [pc, #44]	; (90002db8 <MT48LC4M32B2_ModeRegConfig+0x64>)
90002d8c:	2201      	movs	r2, #1
90002d8e:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = tmpmrd;
90002d90:	4a09      	ldr	r2, [pc, #36]	; (90002db8 <MT48LC4M32B2_ModeRegConfig+0x64>)
90002d92:	68fb      	ldr	r3, [r7, #12]
90002d94:	60d3      	str	r3, [r2, #12]
  
  /* Send the command */
  if(HAL_SDRAM_SendCommand(Ctx, &Command, MT48LC4M32B2_TIMEOUT) != HAL_OK)
90002d96:	f64f 72ff 	movw	r2, #65535	; 0xffff
90002d9a:	4907      	ldr	r1, [pc, #28]	; (90002db8 <MT48LC4M32B2_ModeRegConfig+0x64>)
90002d9c:	6878      	ldr	r0, [r7, #4]
90002d9e:	f011 fd5d 	bl	9001485c <HAL_SDRAM_SendCommand>
90002da2:	4603      	mov	r3, r0
90002da4:	2b00      	cmp	r3, #0
90002da6:	d002      	beq.n	90002dae <MT48LC4M32B2_ModeRegConfig+0x5a>
  {
    return MT48LC4M32B2_ERROR;
90002da8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90002dac:	e000      	b.n	90002db0 <MT48LC4M32B2_ModeRegConfig+0x5c>
  }
  else
  {
    return MT48LC4M32B2_OK;
90002dae:	2300      	movs	r3, #0
  }
}
90002db0:	4618      	mov	r0, r3
90002db2:	3710      	adds	r7, #16
90002db4:	46bd      	mov	sp, r7
90002db6:	bd80      	pop	{r7, pc}
90002db8:	2400117c 	.word	0x2400117c

90002dbc <MT48LC4M32B2_RefreshMode>:
  * @param  RefreshMode : Could be MT48LC4M32B2_CMD_AUTOREFRESH_MODE or
  *                      MT48LC4M32B2_CMD_SELFREFRESH_MODE
  * @retval error status
  */
int32_t MT48LC4M32B2_RefreshMode(SDRAM_HandleTypeDef *Ctx, uint32_t Interface, uint32_t RefreshMode) 
{
90002dbc:	b580      	push	{r7, lr}
90002dbe:	b084      	sub	sp, #16
90002dc0:	af00      	add	r7, sp, #0
90002dc2:	60f8      	str	r0, [r7, #12]
90002dc4:	60b9      	str	r1, [r7, #8]
90002dc6:	607a      	str	r2, [r7, #4]
  Command.CommandMode            = RefreshMode;
90002dc8:	4a0e      	ldr	r2, [pc, #56]	; (90002e04 <MT48LC4M32B2_RefreshMode+0x48>)
90002dca:	687b      	ldr	r3, [r7, #4]
90002dcc:	6013      	str	r3, [r2, #0]
  Command.CommandTarget          = Interface;
90002dce:	4a0d      	ldr	r2, [pc, #52]	; (90002e04 <MT48LC4M32B2_RefreshMode+0x48>)
90002dd0:	68bb      	ldr	r3, [r7, #8]
90002dd2:	6053      	str	r3, [r2, #4]
  Command.AutoRefreshNumber      = 8;
90002dd4:	4b0b      	ldr	r3, [pc, #44]	; (90002e04 <MT48LC4M32B2_RefreshMode+0x48>)
90002dd6:	2208      	movs	r2, #8
90002dd8:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
90002dda:	4b0a      	ldr	r3, [pc, #40]	; (90002e04 <MT48LC4M32B2_RefreshMode+0x48>)
90002ddc:	2200      	movs	r2, #0
90002dde:	60da      	str	r2, [r3, #12]

  /* Send the command */
  if(HAL_SDRAM_SendCommand(Ctx, &Command, MT48LC4M32B2_TIMEOUT) != HAL_OK)
90002de0:	f64f 72ff 	movw	r2, #65535	; 0xffff
90002de4:	4907      	ldr	r1, [pc, #28]	; (90002e04 <MT48LC4M32B2_RefreshMode+0x48>)
90002de6:	68f8      	ldr	r0, [r7, #12]
90002de8:	f011 fd38 	bl	9001485c <HAL_SDRAM_SendCommand>
90002dec:	4603      	mov	r3, r0
90002dee:	2b00      	cmp	r3, #0
90002df0:	d002      	beq.n	90002df8 <MT48LC4M32B2_RefreshMode+0x3c>
  {
    return MT48LC4M32B2_ERROR;
90002df2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90002df6:	e000      	b.n	90002dfa <MT48LC4M32B2_RefreshMode+0x3e>
  }
  else
  {
    return MT48LC4M32B2_OK;
90002df8:	2300      	movs	r3, #0
  }
}
90002dfa:	4618      	mov	r0, r3
90002dfc:	3710      	adds	r7, #16
90002dfe:	46bd      	mov	sp, r7
90002e00:	bd80      	pop	{r7, pc}
90002e02:	bf00      	nop
90002e04:	2400117c 	.word	0x2400117c

90002e08 <MT48LC4M32B2_RefreshRate>:
  * @param  Ctx : Component object pointer
  * @param  RefreshCount : The refresh rate to be programmed
  * @retval error status
  */
int32_t MT48LC4M32B2_RefreshRate(SDRAM_HandleTypeDef *Ctx, uint32_t RefreshCount) 
{
90002e08:	b580      	push	{r7, lr}
90002e0a:	b082      	sub	sp, #8
90002e0c:	af00      	add	r7, sp, #0
90002e0e:	6078      	str	r0, [r7, #4]
90002e10:	6039      	str	r1, [r7, #0]
  /* Set the device refresh rate */
  if(HAL_SDRAM_ProgramRefreshRate(Ctx, RefreshCount) != HAL_OK)
90002e12:	6839      	ldr	r1, [r7, #0]
90002e14:	6878      	ldr	r0, [r7, #4]
90002e16:	f011 fd56 	bl	900148c6 <HAL_SDRAM_ProgramRefreshRate>
90002e1a:	4603      	mov	r3, r0
90002e1c:	2b00      	cmp	r3, #0
90002e1e:	d002      	beq.n	90002e26 <MT48LC4M32B2_RefreshRate+0x1e>
  {
    return MT48LC4M32B2_ERROR;
90002e20:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90002e24:	e000      	b.n	90002e28 <MT48LC4M32B2_RefreshRate+0x20>
  }
  else
  {
    return MT48LC4M32B2_OK;
90002e26:	2300      	movs	r3, #0
  }
}
90002e28:	4618      	mov	r0, r3
90002e2a:	3708      	adds	r7, #8
90002e2c:	46bd      	mov	sp, r7
90002e2e:	bd80      	pop	{r7, pc}

90002e30 <MT48LC4M32B2_Delay>:
  * @brief This function provides accurate delay (in milliseconds)
  * @param Delay: specifies the delay time length, in milliseconds
  * @retval MT48LC4M32B2_OK
  */
static int32_t MT48LC4M32B2_Delay(uint32_t Delay)
{  
90002e30:	b580      	push	{r7, lr}
90002e32:	b084      	sub	sp, #16
90002e34:	af00      	add	r7, sp, #0
90002e36:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  tickstart = HAL_GetTick();
90002e38:	f006 fac4 	bl	900093c4 <HAL_GetTick>
90002e3c:	60f8      	str	r0, [r7, #12]
  while((HAL_GetTick() - tickstart) < Delay)
90002e3e:	bf00      	nop
90002e40:	f006 fac0 	bl	900093c4 <HAL_GetTick>
90002e44:	4602      	mov	r2, r0
90002e46:	68fb      	ldr	r3, [r7, #12]
90002e48:	1ad3      	subs	r3, r2, r3
90002e4a:	687a      	ldr	r2, [r7, #4]
90002e4c:	429a      	cmp	r2, r3
90002e4e:	d8f7      	bhi.n	90002e40 <MT48LC4M32B2_Delay+0x10>
  {
  }
  return MT48LC4M32B2_OK;
90002e50:	2300      	movs	r3, #0
}
90002e52:	4618      	mov	r0, r3
90002e54:	3710      	adds	r7, #16
90002e56:	46bd      	mov	sp, r7
90002e58:	bd80      	pop	{r7, pc}
	...

90002e5c <WM8994_Init>:
  * @param pObj pointer to component object
  * @param pInit pointer de component init structure
  * @retval 0 if correct communication, else wrong communication
  */
int32_t WM8994_Init(WM8994_Object_t *pObj, WM8994_Init_t *pInit)
{
90002e5c:	b580      	push	{r7, lr}
90002e5e:	b084      	sub	sp, #16
90002e60:	af00      	add	r7, sp, #0
90002e62:	6078      	str	r0, [r7, #4]
90002e64:	6039      	str	r1, [r7, #0]
  int32_t ret;
  static uint8_t ColdStartup = 1;
  uint16_t tmp;
  
  /* wm8994 Errata Work-Arounds */
  tmp = 0x0003;
90002e66:	2303      	movs	r3, #3
90002e68:	817b      	strh	r3, [r7, #10]
  ret = wm8994_write_reg(&pObj->Ctx, 0x102, &tmp, 2);
90002e6a:	687b      	ldr	r3, [r7, #4]
90002e6c:	f103 0018 	add.w	r0, r3, #24
90002e70:	f107 020a 	add.w	r2, r7, #10
90002e74:	2302      	movs	r3, #2
90002e76:	f44f 7181 	mov.w	r1, #258	; 0x102
90002e7a:	f001 fdb9 	bl	900049f0 <wm8994_write_reg>
90002e7e:	60f8      	str	r0, [r7, #12]
  tmp = 0x0000;
90002e80:	2300      	movs	r3, #0
90002e82:	817b      	strh	r3, [r7, #10]
  ret += wm8994_write_reg(&pObj->Ctx, 0x817, &tmp, 2);
90002e84:	687b      	ldr	r3, [r7, #4]
90002e86:	f103 0018 	add.w	r0, r3, #24
90002e8a:	f107 020a 	add.w	r2, r7, #10
90002e8e:	2302      	movs	r3, #2
90002e90:	f640 0117 	movw	r1, #2071	; 0x817
90002e94:	f001 fdac 	bl	900049f0 <wm8994_write_reg>
90002e98:	4602      	mov	r2, r0
90002e9a:	68fb      	ldr	r3, [r7, #12]
90002e9c:	4413      	add	r3, r2
90002e9e:	60fb      	str	r3, [r7, #12]
  ret += wm8994_write_reg(&pObj->Ctx, 0x102, &tmp, 2);
90002ea0:	687b      	ldr	r3, [r7, #4]
90002ea2:	f103 0018 	add.w	r0, r3, #24
90002ea6:	f107 020a 	add.w	r2, r7, #10
90002eaa:	2302      	movs	r3, #2
90002eac:	f44f 7181 	mov.w	r1, #258	; 0x102
90002eb0:	f001 fd9e 	bl	900049f0 <wm8994_write_reg>
90002eb4:	4602      	mov	r2, r0
90002eb6:	68fb      	ldr	r3, [r7, #12]
90002eb8:	4413      	add	r3, r2
90002eba:	60fb      	str	r3, [r7, #12]
  
  /* Enable VMID soft start (fast), Start-up Bias Current Enabled: 0x006C at reg 0x39 */
  /* Bias Enable */
  tmp = 0x006C;
90002ebc:	236c      	movs	r3, #108	; 0x6c
90002ebe:	817b      	strh	r3, [r7, #10]
  ret += wm8994_write_reg(&pObj->Ctx, WM8994_ANTIPOP2, &tmp, 2);
90002ec0:	687b      	ldr	r3, [r7, #4]
90002ec2:	f103 0018 	add.w	r0, r3, #24
90002ec6:	f107 020a 	add.w	r2, r7, #10
90002eca:	2302      	movs	r3, #2
90002ecc:	2139      	movs	r1, #57	; 0x39
90002ece:	f001 fd8f 	bl	900049f0 <wm8994_write_reg>
90002ed2:	4602      	mov	r2, r0
90002ed4:	68fb      	ldr	r3, [r7, #12]
90002ed6:	4413      	add	r3, r2
90002ed8:	60fb      	str	r3, [r7, #12]
  
  /* Enable bias generator, Enable VMID */
  if (pInit->InputDevice != WM8994_IN_NONE)
90002eda:	683b      	ldr	r3, [r7, #0]
90002edc:	681b      	ldr	r3, [r3, #0]
90002ede:	2b00      	cmp	r3, #0
90002ee0:	d00f      	beq.n	90002f02 <WM8994_Init+0xa6>
  {
    tmp = 0x0013;
90002ee2:	2313      	movs	r3, #19
90002ee4:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_1, &tmp, 2);  
90002ee6:	687b      	ldr	r3, [r7, #4]
90002ee8:	f103 0018 	add.w	r0, r3, #24
90002eec:	f107 020a 	add.w	r2, r7, #10
90002ef0:	2302      	movs	r3, #2
90002ef2:	2101      	movs	r1, #1
90002ef4:	f001 fd7c 	bl	900049f0 <wm8994_write_reg>
90002ef8:	4602      	mov	r2, r0
90002efa:	68fb      	ldr	r3, [r7, #12]
90002efc:	4413      	add	r3, r2
90002efe:	60fb      	str	r3, [r7, #12]
90002f00:	e00e      	b.n	90002f20 <WM8994_Init+0xc4>
  }
  else
  { 
    tmp = 0x0003;
90002f02:	2303      	movs	r3, #3
90002f04:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_1, &tmp, 2);
90002f06:	687b      	ldr	r3, [r7, #4]
90002f08:	f103 0018 	add.w	r0, r3, #24
90002f0c:	f107 020a 	add.w	r2, r7, #10
90002f10:	2302      	movs	r3, #2
90002f12:	2101      	movs	r1, #1
90002f14:	f001 fd6c 	bl	900049f0 <wm8994_write_reg>
90002f18:	4602      	mov	r2, r0
90002f1a:	68fb      	ldr	r3, [r7, #12]
90002f1c:	4413      	add	r3, r2
90002f1e:	60fb      	str	r3, [r7, #12]
  }
  
  /* Add Delay */
  (void)WM8994_Delay(pObj, 50);
90002f20:	2132      	movs	r1, #50	; 0x32
90002f22:	6878      	ldr	r0, [r7, #4]
90002f24:	f001 fcec 	bl	90004900 <WM8994_Delay>
  
  /* Path Configurations for output */
  switch (pInit->OutputDevice)
90002f28:	683b      	ldr	r3, [r7, #0]
90002f2a:	685b      	ldr	r3, [r3, #4]
90002f2c:	2b03      	cmp	r3, #3
90002f2e:	f200 8141 	bhi.w	900031b4 <WM8994_Init+0x358>
90002f32:	a201      	add	r2, pc, #4	; (adr r2, 90002f38 <WM8994_Init+0xdc>)
90002f34:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90002f38:	9000324f 	.word	0x9000324f
90002f3c:	90002f49 	.word	0x90002f49
90002f40:	90002fe3 	.word	0x90002fe3
90002f44:	9000307d 	.word	0x9000307d
  {
  case WM8994_OUT_SPEAKER: 
    /* Enable DAC1 (Left), Enable DAC1 (Right),
    Disable DAC2 (Left), Disable DAC2 (Right)*/
    tmp = 0x0C0C;
90002f48:	f640 430c 	movw	r3, #3084	; 0xc0c
90002f4c:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_5, &tmp, 2);
90002f4e:	687b      	ldr	r3, [r7, #4]
90002f50:	f103 0018 	add.w	r0, r3, #24
90002f54:	f107 020a 	add.w	r2, r7, #10
90002f58:	2302      	movs	r3, #2
90002f5a:	2105      	movs	r1, #5
90002f5c:	f001 fd48 	bl	900049f0 <wm8994_write_reg>
90002f60:	4602      	mov	r2, r0
90002f62:	68fb      	ldr	r3, [r7, #12]
90002f64:	4413      	add	r3, r2
90002f66:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
    tmp = 0x0000;
90002f68:	2300      	movs	r3, #0
90002f6a:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_LMR, &tmp, 2);
90002f6c:	687b      	ldr	r3, [r7, #4]
90002f6e:	f103 0018 	add.w	r0, r3, #24
90002f72:	f107 020a 	add.w	r2, r7, #10
90002f76:	2302      	movs	r3, #2
90002f78:	f240 6101 	movw	r1, #1537	; 0x601
90002f7c:	f001 fd38 	bl	900049f0 <wm8994_write_reg>
90002f80:	4602      	mov	r2, r0
90002f82:	68fb      	ldr	r3, [r7, #12]
90002f84:	4413      	add	r3, r2
90002f86:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_RMR, &tmp, 2);
90002f88:	687b      	ldr	r3, [r7, #4]
90002f8a:	f103 0018 	add.w	r0, r3, #24
90002f8e:	f107 020a 	add.w	r2, r7, #10
90002f92:	2302      	movs	r3, #2
90002f94:	f240 6102 	movw	r1, #1538	; 0x602
90002f98:	f001 fd2a 	bl	900049f0 <wm8994_write_reg>
90002f9c:	4602      	mov	r2, r0
90002f9e:	68fb      	ldr	r3, [r7, #12]
90002fa0:	4413      	add	r3, r2
90002fa2:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
    tmp = 0x0002;
90002fa4:	2302      	movs	r3, #2
90002fa6:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_LMR, &tmp, 2);
90002fa8:	687b      	ldr	r3, [r7, #4]
90002faa:	f103 0018 	add.w	r0, r3, #24
90002fae:	f107 020a 	add.w	r2, r7, #10
90002fb2:	2302      	movs	r3, #2
90002fb4:	f240 6104 	movw	r1, #1540	; 0x604
90002fb8:	f001 fd1a 	bl	900049f0 <wm8994_write_reg>
90002fbc:	4602      	mov	r2, r0
90002fbe:	68fb      	ldr	r3, [r7, #12]
90002fc0:	4413      	add	r3, r2
90002fc2:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_RMR, &tmp, 2);
90002fc4:	687b      	ldr	r3, [r7, #4]
90002fc6:	f103 0018 	add.w	r0, r3, #24
90002fca:	f107 020a 	add.w	r2, r7, #10
90002fce:	2302      	movs	r3, #2
90002fd0:	f240 6105 	movw	r1, #1541	; 0x605
90002fd4:	f001 fd0c 	bl	900049f0 <wm8994_write_reg>
90002fd8:	4602      	mov	r2, r0
90002fda:	68fb      	ldr	r3, [r7, #12]
90002fdc:	4413      	add	r3, r2
90002fde:	60fb      	str	r3, [r7, #12]
    break;
90002fe0:	e136      	b.n	90003250 <WM8994_Init+0x3f4>
    
  case WM8994_OUT_HEADPHONE:    
    /* Disable DAC1 (Left), Disable DAC1 (Right),
    Enable DAC2 (Left), Enable DAC2 (Right)*/
    tmp = 0x0303;
90002fe2:	f240 3303 	movw	r3, #771	; 0x303
90002fe6:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_5, &tmp, 2);
90002fe8:	687b      	ldr	r3, [r7, #4]
90002fea:	f103 0018 	add.w	r0, r3, #24
90002fee:	f107 020a 	add.w	r2, r7, #10
90002ff2:	2302      	movs	r3, #2
90002ff4:	2105      	movs	r1, #5
90002ff6:	f001 fcfb 	bl	900049f0 <wm8994_write_reg>
90002ffa:	4602      	mov	r2, r0
90002ffc:	68fb      	ldr	r3, [r7, #12]
90002ffe:	4413      	add	r3, r2
90003000:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
    tmp = 0x0001;
90003002:	2301      	movs	r3, #1
90003004:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_LMR, &tmp, 2);
90003006:	687b      	ldr	r3, [r7, #4]
90003008:	f103 0018 	add.w	r0, r3, #24
9000300c:	f107 020a 	add.w	r2, r7, #10
90003010:	2302      	movs	r3, #2
90003012:	f240 6101 	movw	r1, #1537	; 0x601
90003016:	f001 fceb 	bl	900049f0 <wm8994_write_reg>
9000301a:	4602      	mov	r2, r0
9000301c:	68fb      	ldr	r3, [r7, #12]
9000301e:	4413      	add	r3, r2
90003020:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_RMR, &tmp, 2);
90003022:	687b      	ldr	r3, [r7, #4]
90003024:	f103 0018 	add.w	r0, r3, #24
90003028:	f107 020a 	add.w	r2, r7, #10
9000302c:	2302      	movs	r3, #2
9000302e:	f240 6102 	movw	r1, #1538	; 0x602
90003032:	f001 fcdd 	bl	900049f0 <wm8994_write_reg>
90003036:	4602      	mov	r2, r0
90003038:	68fb      	ldr	r3, [r7, #12]
9000303a:	4413      	add	r3, r2
9000303c:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
    tmp = 0x0000;
9000303e:	2300      	movs	r3, #0
90003040:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_LMR, &tmp, 2);
90003042:	687b      	ldr	r3, [r7, #4]
90003044:	f103 0018 	add.w	r0, r3, #24
90003048:	f107 020a 	add.w	r2, r7, #10
9000304c:	2302      	movs	r3, #2
9000304e:	f240 6104 	movw	r1, #1540	; 0x604
90003052:	f001 fccd 	bl	900049f0 <wm8994_write_reg>
90003056:	4602      	mov	r2, r0
90003058:	68fb      	ldr	r3, [r7, #12]
9000305a:	4413      	add	r3, r2
9000305c:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_RMR, &tmp, 2);
9000305e:	687b      	ldr	r3, [r7, #4]
90003060:	f103 0018 	add.w	r0, r3, #24
90003064:	f107 020a 	add.w	r2, r7, #10
90003068:	2302      	movs	r3, #2
9000306a:	f240 6105 	movw	r1, #1541	; 0x605
9000306e:	f001 fcbf 	bl	900049f0 <wm8994_write_reg>
90003072:	4602      	mov	r2, r0
90003074:	68fb      	ldr	r3, [r7, #12]
90003076:	4413      	add	r3, r2
90003078:	60fb      	str	r3, [r7, #12]
    break;
9000307a:	e0e9      	b.n	90003250 <WM8994_Init+0x3f4>
    
  case WM8994_OUT_BOTH:
    if (pInit->InputDevice == WM8994_IN_MIC1_MIC2)
9000307c:	683b      	ldr	r3, [r7, #0]
9000307e:	681b      	ldr	r3, [r3, #0]
90003080:	2b05      	cmp	r3, #5
90003082:	d14a      	bne.n	9000311a <WM8994_Init+0x2be>
    {
      /* Enable DAC1 (Left), Enable DAC1 (Right),
      also Enable DAC2 (Left), Enable DAC2 (Right)*/
      tmp = 0x0F0F;
90003084:	f640 730f 	movw	r3, #3855	; 0xf0f
90003088:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_5, &tmp, 2);
9000308a:	687b      	ldr	r3, [r7, #4]
9000308c:	f103 0018 	add.w	r0, r3, #24
90003090:	f107 020a 	add.w	r2, r7, #10
90003094:	2302      	movs	r3, #2
90003096:	2105      	movs	r1, #5
90003098:	f001 fcaa 	bl	900049f0 <wm8994_write_reg>
9000309c:	4602      	mov	r2, r0
9000309e:	68fb      	ldr	r3, [r7, #12]
900030a0:	4413      	add	r3, r2
900030a2:	60fb      	str	r3, [r7, #12]
      
      /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path
      Enable the AIF1 Timeslot 1 (Left) to DAC 1 (Left) mixer path */
      tmp = 0x0003;
900030a4:	2303      	movs	r3, #3
900030a6:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_LMR, &tmp, 2);
900030a8:	687b      	ldr	r3, [r7, #4]
900030aa:	f103 0018 	add.w	r0, r3, #24
900030ae:	f107 020a 	add.w	r2, r7, #10
900030b2:	2302      	movs	r3, #2
900030b4:	f240 6101 	movw	r1, #1537	; 0x601
900030b8:	f001 fc9a 	bl	900049f0 <wm8994_write_reg>
900030bc:	4602      	mov	r2, r0
900030be:	68fb      	ldr	r3, [r7, #12]
900030c0:	4413      	add	r3, r2
900030c2:	60fb      	str	r3, [r7, #12]
      
      /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path
      Enable the AIF1 Timeslot 1 (Right) to DAC 1 (Right) mixer path */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_RMR, &tmp, 2);
900030c4:	687b      	ldr	r3, [r7, #4]
900030c6:	f103 0018 	add.w	r0, r3, #24
900030ca:	f107 020a 	add.w	r2, r7, #10
900030ce:	2302      	movs	r3, #2
900030d0:	f240 6102 	movw	r1, #1538	; 0x602
900030d4:	f001 fc8c 	bl	900049f0 <wm8994_write_reg>
900030d8:	4602      	mov	r2, r0
900030da:	68fb      	ldr	r3, [r7, #12]
900030dc:	4413      	add	r3, r2
900030de:	60fb      	str	r3, [r7, #12]
      
      /* Enable the AIF1 Timeslot 0 (Left) to DAC 2 (Left) mixer path
      Enable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path  */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_LMR, &tmp, 2);
900030e0:	687b      	ldr	r3, [r7, #4]
900030e2:	f103 0018 	add.w	r0, r3, #24
900030e6:	f107 020a 	add.w	r2, r7, #10
900030ea:	2302      	movs	r3, #2
900030ec:	f240 6104 	movw	r1, #1540	; 0x604
900030f0:	f001 fc7e 	bl	900049f0 <wm8994_write_reg>
900030f4:	4602      	mov	r2, r0
900030f6:	68fb      	ldr	r3, [r7, #12]
900030f8:	4413      	add	r3, r2
900030fa:	60fb      	str	r3, [r7, #12]
      
      /* Enable the AIF1 Timeslot 0 (Right) to DAC 2 (Right) mixer path
      Enable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */       
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_RMR, &tmp, 2);
900030fc:	687b      	ldr	r3, [r7, #4]
900030fe:	f103 0018 	add.w	r0, r3, #24
90003102:	f107 020a 	add.w	r2, r7, #10
90003106:	2302      	movs	r3, #2
90003108:	f240 6105 	movw	r1, #1541	; 0x605
9000310c:	f001 fc70 	bl	900049f0 <wm8994_write_reg>
90003110:	4602      	mov	r2, r0
90003112:	68fb      	ldr	r3, [r7, #12]
90003114:	4413      	add	r3, r2
90003116:	60fb      	str	r3, [r7, #12]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_LMR, &tmp, 2);
      
      /* Enable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_RMR, &tmp, 2);
    }
    break;
90003118:	e09a      	b.n	90003250 <WM8994_Init+0x3f4>
      tmp = 0x0F0F;
9000311a:	f640 730f 	movw	r3, #3855	; 0xf0f
9000311e:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_5, &tmp, 2);
90003120:	687b      	ldr	r3, [r7, #4]
90003122:	f103 0018 	add.w	r0, r3, #24
90003126:	f107 020a 	add.w	r2, r7, #10
9000312a:	2302      	movs	r3, #2
9000312c:	2105      	movs	r1, #5
9000312e:	f001 fc5f 	bl	900049f0 <wm8994_write_reg>
90003132:	4602      	mov	r2, r0
90003134:	68fb      	ldr	r3, [r7, #12]
90003136:	4413      	add	r3, r2
90003138:	60fb      	str	r3, [r7, #12]
      tmp = 0x0001;
9000313a:	2301      	movs	r3, #1
9000313c:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_LMR, &tmp, 2);
9000313e:	687b      	ldr	r3, [r7, #4]
90003140:	f103 0018 	add.w	r0, r3, #24
90003144:	f107 020a 	add.w	r2, r7, #10
90003148:	2302      	movs	r3, #2
9000314a:	f240 6101 	movw	r1, #1537	; 0x601
9000314e:	f001 fc4f 	bl	900049f0 <wm8994_write_reg>
90003152:	4602      	mov	r2, r0
90003154:	68fb      	ldr	r3, [r7, #12]
90003156:	4413      	add	r3, r2
90003158:	60fb      	str	r3, [r7, #12]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_RMR, &tmp, 2);
9000315a:	687b      	ldr	r3, [r7, #4]
9000315c:	f103 0018 	add.w	r0, r3, #24
90003160:	f107 020a 	add.w	r2, r7, #10
90003164:	2302      	movs	r3, #2
90003166:	f240 6102 	movw	r1, #1538	; 0x602
9000316a:	f001 fc41 	bl	900049f0 <wm8994_write_reg>
9000316e:	4602      	mov	r2, r0
90003170:	68fb      	ldr	r3, [r7, #12]
90003172:	4413      	add	r3, r2
90003174:	60fb      	str	r3, [r7, #12]
      tmp = 0x0002;
90003176:	2302      	movs	r3, #2
90003178:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_LMR, &tmp, 2);
9000317a:	687b      	ldr	r3, [r7, #4]
9000317c:	f103 0018 	add.w	r0, r3, #24
90003180:	f107 020a 	add.w	r2, r7, #10
90003184:	2302      	movs	r3, #2
90003186:	f240 6104 	movw	r1, #1540	; 0x604
9000318a:	f001 fc31 	bl	900049f0 <wm8994_write_reg>
9000318e:	4602      	mov	r2, r0
90003190:	68fb      	ldr	r3, [r7, #12]
90003192:	4413      	add	r3, r2
90003194:	60fb      	str	r3, [r7, #12]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_RMR, &tmp, 2);
90003196:	687b      	ldr	r3, [r7, #4]
90003198:	f103 0018 	add.w	r0, r3, #24
9000319c:	f107 020a 	add.w	r2, r7, #10
900031a0:	2302      	movs	r3, #2
900031a2:	f240 6105 	movw	r1, #1541	; 0x605
900031a6:	f001 fc23 	bl	900049f0 <wm8994_write_reg>
900031aa:	4602      	mov	r2, r0
900031ac:	68fb      	ldr	r3, [r7, #12]
900031ae:	4413      	add	r3, r2
900031b0:	60fb      	str	r3, [r7, #12]
    break;
900031b2:	e04d      	b.n	90003250 <WM8994_Init+0x3f4>
    break;
  case WM8994_OUT_AUTO :
  default:
    /* Disable DAC1 (Left), Disable DAC1 (Right),
    Enable DAC2 (Left), Enable DAC2 (Right)*/
    tmp = 0x0303;
900031b4:	f240 3303 	movw	r3, #771	; 0x303
900031b8:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_5, &tmp, 2);
900031ba:	687b      	ldr	r3, [r7, #4]
900031bc:	f103 0018 	add.w	r0, r3, #24
900031c0:	f107 020a 	add.w	r2, r7, #10
900031c4:	2302      	movs	r3, #2
900031c6:	2105      	movs	r1, #5
900031c8:	f001 fc12 	bl	900049f0 <wm8994_write_reg>
900031cc:	4602      	mov	r2, r0
900031ce:	68fb      	ldr	r3, [r7, #12]
900031d0:	4413      	add	r3, r2
900031d2:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
    tmp = 0x0001;
900031d4:	2301      	movs	r3, #1
900031d6:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_LMR, &tmp, 2);
900031d8:	687b      	ldr	r3, [r7, #4]
900031da:	f103 0018 	add.w	r0, r3, #24
900031de:	f107 020a 	add.w	r2, r7, #10
900031e2:	2302      	movs	r3, #2
900031e4:	f240 6101 	movw	r1, #1537	; 0x601
900031e8:	f001 fc02 	bl	900049f0 <wm8994_write_reg>
900031ec:	4602      	mov	r2, r0
900031ee:	68fb      	ldr	r3, [r7, #12]
900031f0:	4413      	add	r3, r2
900031f2:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_RMR, &tmp, 2);
900031f4:	687b      	ldr	r3, [r7, #4]
900031f6:	f103 0018 	add.w	r0, r3, #24
900031fa:	f107 020a 	add.w	r2, r7, #10
900031fe:	2302      	movs	r3, #2
90003200:	f240 6102 	movw	r1, #1538	; 0x602
90003204:	f001 fbf4 	bl	900049f0 <wm8994_write_reg>
90003208:	4602      	mov	r2, r0
9000320a:	68fb      	ldr	r3, [r7, #12]
9000320c:	4413      	add	r3, r2
9000320e:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
    tmp = 0x0000;
90003210:	2300      	movs	r3, #0
90003212:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_LMR, &tmp, 2);
90003214:	687b      	ldr	r3, [r7, #4]
90003216:	f103 0018 	add.w	r0, r3, #24
9000321a:	f107 020a 	add.w	r2, r7, #10
9000321e:	2302      	movs	r3, #2
90003220:	f240 6104 	movw	r1, #1540	; 0x604
90003224:	f001 fbe4 	bl	900049f0 <wm8994_write_reg>
90003228:	4602      	mov	r2, r0
9000322a:	68fb      	ldr	r3, [r7, #12]
9000322c:	4413      	add	r3, r2
9000322e:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_RMR, &tmp, 2);
90003230:	687b      	ldr	r3, [r7, #4]
90003232:	f103 0018 	add.w	r0, r3, #24
90003236:	f107 020a 	add.w	r2, r7, #10
9000323a:	2302      	movs	r3, #2
9000323c:	f240 6105 	movw	r1, #1541	; 0x605
90003240:	f001 fbd6 	bl	900049f0 <wm8994_write_reg>
90003244:	4602      	mov	r2, r0
90003246:	68fb      	ldr	r3, [r7, #12]
90003248:	4413      	add	r3, r2
9000324a:	60fb      	str	r3, [r7, #12]
    break;
9000324c:	e000      	b.n	90003250 <WM8994_Init+0x3f4>
    break;
9000324e:	bf00      	nop
  }
  
  /* Path Configurations for input */
  switch (pInit->InputDevice)
90003250:	683b      	ldr	r3, [r7, #0]
90003252:	681b      	ldr	r3, [r3, #0]
90003254:	3b01      	subs	r3, #1
90003256:	2b04      	cmp	r3, #4
90003258:	f200 81e0 	bhi.w	9000361c <WM8994_Init+0x7c0>
9000325c:	a201      	add	r2, pc, #4	; (adr r2, 90003264 <WM8994_Init+0x408>)
9000325e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90003262:	bf00      	nop
90003264:	9000344d 	.word	0x9000344d
90003268:	90003279 	.word	0x90003279
9000326c:	90003337 	.word	0x90003337
90003270:	9000361d 	.word	0x9000361d
90003274:	9000350b 	.word	0x9000350b
  {
  case WM8994_IN_MIC2 :
    /* Enable AIF1ADC2 (Left), Enable AIF1ADC2 (Right)
    * Enable DMICDAT2 (Left), Enable DMICDAT2 (Right)
    * Enable Left ADC, Enable Right ADC */
    tmp = 0x0C30;
90003278:	f44f 6343 	mov.w	r3, #3120	; 0xc30
9000327c:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_4, &tmp, 2);
9000327e:	687b      	ldr	r3, [r7, #4]
90003280:	f103 0018 	add.w	r0, r3, #24
90003284:	f107 020a 	add.w	r2, r7, #10
90003288:	2302      	movs	r3, #2
9000328a:	2104      	movs	r1, #4
9000328c:	f001 fbb0 	bl	900049f0 <wm8994_write_reg>
90003290:	4602      	mov	r2, r0
90003292:	68fb      	ldr	r3, [r7, #12]
90003294:	4413      	add	r3, r2
90003296:	60fb      	str	r3, [r7, #12]
    
    /* Enable AIF1 DRC2 Signal Detect & DRC in AIF1ADC2 Left/Right Timeslot 1 */
    tmp = 0x00DB;
90003298:	23db      	movs	r3, #219	; 0xdb
9000329a:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DRC2, &tmp, 2);
9000329c:	687b      	ldr	r3, [r7, #4]
9000329e:	f103 0018 	add.w	r0, r3, #24
900032a2:	f107 020a 	add.w	r2, r7, #10
900032a6:	2302      	movs	r3, #2
900032a8:	f44f 618a 	mov.w	r1, #1104	; 0x450
900032ac:	f001 fba0 	bl	900049f0 <wm8994_write_reg>
900032b0:	4602      	mov	r2, r0
900032b2:	68fb      	ldr	r3, [r7, #12]
900032b4:	4413      	add	r3, r2
900032b6:	60fb      	str	r3, [r7, #12]
    
    /* Disable IN1L, IN1R, IN2L, IN2R, Enable Thermal sensor & shutdown */
    tmp = 0x6000;
900032b8:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
900032bc:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_2, &tmp, 2);
900032be:	687b      	ldr	r3, [r7, #4]
900032c0:	f103 0018 	add.w	r0, r3, #24
900032c4:	f107 020a 	add.w	r2, r7, #10
900032c8:	2302      	movs	r3, #2
900032ca:	2102      	movs	r1, #2
900032cc:	f001 fb90 	bl	900049f0 <wm8994_write_reg>
900032d0:	4602      	mov	r2, r0
900032d2:	68fb      	ldr	r3, [r7, #12]
900032d4:	4413      	add	r3, r2
900032d6:	60fb      	str	r3, [r7, #12]
    
    /* Enable the DMIC2(Left) to AIF1 Timeslot 1 (Left) mixer path */
    tmp = 0x0002;
900032d8:	2302      	movs	r3, #2
900032da:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC2_LMR, &tmp, 2);
900032dc:	687b      	ldr	r3, [r7, #4]
900032de:	f103 0018 	add.w	r0, r3, #24
900032e2:	f107 020a 	add.w	r2, r7, #10
900032e6:	2302      	movs	r3, #2
900032e8:	f44f 61c1 	mov.w	r1, #1544	; 0x608
900032ec:	f001 fb80 	bl	900049f0 <wm8994_write_reg>
900032f0:	4602      	mov	r2, r0
900032f2:	68fb      	ldr	r3, [r7, #12]
900032f4:	4413      	add	r3, r2
900032f6:	60fb      	str	r3, [r7, #12]
    
    /* Enable the DMIC2(Right) to AIF1 Timeslot 1 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC2_RMR, &tmp, 2);
900032f8:	687b      	ldr	r3, [r7, #4]
900032fa:	f103 0018 	add.w	r0, r3, #24
900032fe:	f107 020a 	add.w	r2, r7, #10
90003302:	2302      	movs	r3, #2
90003304:	f240 6109 	movw	r1, #1545	; 0x609
90003308:	f001 fb72 	bl	900049f0 <wm8994_write_reg>
9000330c:	4602      	mov	r2, r0
9000330e:	68fb      	ldr	r3, [r7, #12]
90003310:	4413      	add	r3, r2
90003312:	60fb      	str	r3, [r7, #12]
    
    /* GPIO1 pin configuration GP1_DIR = output, GP1_FN = AIF1 DRC2 signal detect */
    tmp = 0x000E;
90003314:	230e      	movs	r3, #14
90003316:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_GPIO1, &tmp, 2);
90003318:	687b      	ldr	r3, [r7, #4]
9000331a:	f103 0018 	add.w	r0, r3, #24
9000331e:	f107 020a 	add.w	r2, r7, #10
90003322:	2302      	movs	r3, #2
90003324:	f44f 61e0 	mov.w	r1, #1792	; 0x700
90003328:	f001 fb62 	bl	900049f0 <wm8994_write_reg>
9000332c:	4602      	mov	r2, r0
9000332e:	68fb      	ldr	r3, [r7, #12]
90003330:	4413      	add	r3, r2
90003332:	60fb      	str	r3, [r7, #12]
    break;
90003334:	e173      	b.n	9000361e <WM8994_Init+0x7c2>
    
  case WM8994_IN_LINE1 :
    /* IN1LN_TO_IN1L, IN1RN_TO_IN1R */
    tmp = 0x0011;
90003336:	2311      	movs	r3, #17
90003338:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_INPUT_MIXER_2, &tmp, 2);
9000333a:	687b      	ldr	r3, [r7, #4]
9000333c:	f103 0018 	add.w	r0, r3, #24
90003340:	f107 020a 	add.w	r2, r7, #10
90003344:	2302      	movs	r3, #2
90003346:	2128      	movs	r1, #40	; 0x28
90003348:	f001 fb52 	bl	900049f0 <wm8994_write_reg>
9000334c:	4602      	mov	r2, r0
9000334e:	68fb      	ldr	r3, [r7, #12]
90003350:	4413      	add	r3, r2
90003352:	60fb      	str	r3, [r7, #12]
    
    /* Disable mute on IN1L_TO_MIXINL and +30dB on IN1L PGA output */
    tmp = 0x0035;
90003354:	2335      	movs	r3, #53	; 0x35
90003356:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_INPUT_MIXER_3, &tmp, 2);
90003358:	687b      	ldr	r3, [r7, #4]
9000335a:	f103 0018 	add.w	r0, r3, #24
9000335e:	f107 020a 	add.w	r2, r7, #10
90003362:	2302      	movs	r3, #2
90003364:	2129      	movs	r1, #41	; 0x29
90003366:	f001 fb43 	bl	900049f0 <wm8994_write_reg>
9000336a:	4602      	mov	r2, r0
9000336c:	68fb      	ldr	r3, [r7, #12]
9000336e:	4413      	add	r3, r2
90003370:	60fb      	str	r3, [r7, #12]
    
    /* Disable mute on IN1R_TO_MIXINL, Gain = +30dB */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_INPUT_MIXER_4, &tmp, 2);
90003372:	687b      	ldr	r3, [r7, #4]
90003374:	f103 0018 	add.w	r0, r3, #24
90003378:	f107 020a 	add.w	r2, r7, #10
9000337c:	2302      	movs	r3, #2
9000337e:	212a      	movs	r1, #42	; 0x2a
90003380:	f001 fb36 	bl	900049f0 <wm8994_write_reg>
90003384:	4602      	mov	r2, r0
90003386:	68fb      	ldr	r3, [r7, #12]
90003388:	4413      	add	r3, r2
9000338a:	60fb      	str	r3, [r7, #12]
    
    /* Enable AIF1ADC1 (Left), Enable AIF1ADC1 (Right)
    * Enable Left ADC, Enable Right ADC */
    tmp = 0x0303;
9000338c:	f240 3303 	movw	r3, #771	; 0x303
90003390:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_4, &tmp, 2);
90003392:	687b      	ldr	r3, [r7, #4]
90003394:	f103 0018 	add.w	r0, r3, #24
90003398:	f107 020a 	add.w	r2, r7, #10
9000339c:	2302      	movs	r3, #2
9000339e:	2104      	movs	r1, #4
900033a0:	f001 fb26 	bl	900049f0 <wm8994_write_reg>
900033a4:	4602      	mov	r2, r0
900033a6:	68fb      	ldr	r3, [r7, #12]
900033a8:	4413      	add	r3, r2
900033aa:	60fb      	str	r3, [r7, #12]
    
    /* Enable AIF1 DRC1 Signal Detect & DRC in AIF1ADC1 Left/Right Timeslot 0 */
    tmp = 0x00DB;
900033ac:	23db      	movs	r3, #219	; 0xdb
900033ae:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DRC1, &tmp, 2);
900033b0:	687b      	ldr	r3, [r7, #4]
900033b2:	f103 0018 	add.w	r0, r3, #24
900033b6:	f107 020a 	add.w	r2, r7, #10
900033ba:	2302      	movs	r3, #2
900033bc:	f44f 6188 	mov.w	r1, #1088	; 0x440
900033c0:	f001 fb16 	bl	900049f0 <wm8994_write_reg>
900033c4:	4602      	mov	r2, r0
900033c6:	68fb      	ldr	r3, [r7, #12]
900033c8:	4413      	add	r3, r2
900033ca:	60fb      	str	r3, [r7, #12]
    
    /* Enable IN1L and IN1R, Disable IN2L and IN2R, Enable Thermal sensor & shutdown */
    tmp = 0x6350;
900033cc:	f246 3350 	movw	r3, #25424	; 0x6350
900033d0:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_2, &tmp, 2);
900033d2:	687b      	ldr	r3, [r7, #4]
900033d4:	f103 0018 	add.w	r0, r3, #24
900033d8:	f107 020a 	add.w	r2, r7, #10
900033dc:	2302      	movs	r3, #2
900033de:	2102      	movs	r1, #2
900033e0:	f001 fb06 	bl	900049f0 <wm8994_write_reg>
900033e4:	4602      	mov	r2, r0
900033e6:	68fb      	ldr	r3, [r7, #12]
900033e8:	4413      	add	r3, r2
900033ea:	60fb      	str	r3, [r7, #12]
    
    /* Enable the ADCL(Left) to AIF1 Timeslot 0 (Left) mixer path */
    tmp = 0x0002;
900033ec:	2302      	movs	r3, #2
900033ee:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC1_LMR, &tmp, 2);
900033f0:	687b      	ldr	r3, [r7, #4]
900033f2:	f103 0018 	add.w	r0, r3, #24
900033f6:	f107 020a 	add.w	r2, r7, #10
900033fa:	2302      	movs	r3, #2
900033fc:	f240 6106 	movw	r1, #1542	; 0x606
90003400:	f001 faf6 	bl	900049f0 <wm8994_write_reg>
90003404:	4602      	mov	r2, r0
90003406:	68fb      	ldr	r3, [r7, #12]
90003408:	4413      	add	r3, r2
9000340a:	60fb      	str	r3, [r7, #12]
    
    /* Enable the ADCR(Right) to AIF1 Timeslot 0 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC1_RMR, &tmp, 2);
9000340c:	687b      	ldr	r3, [r7, #4]
9000340e:	f103 0018 	add.w	r0, r3, #24
90003412:	f107 020a 	add.w	r2, r7, #10
90003416:	2302      	movs	r3, #2
90003418:	f240 6107 	movw	r1, #1543	; 0x607
9000341c:	f001 fae8 	bl	900049f0 <wm8994_write_reg>
90003420:	4602      	mov	r2, r0
90003422:	68fb      	ldr	r3, [r7, #12]
90003424:	4413      	add	r3, r2
90003426:	60fb      	str	r3, [r7, #12]
    
    /* GPIO1 pin configuration GP1_DIR = output, GP1_FN = AIF1 DRC1 signal detect */
    tmp = 0x800D;
90003428:	f248 030d 	movw	r3, #32781	; 0x800d
9000342c:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_GPIO1, &tmp, 2);
9000342e:	687b      	ldr	r3, [r7, #4]
90003430:	f103 0018 	add.w	r0, r3, #24
90003434:	f107 020a 	add.w	r2, r7, #10
90003438:	2302      	movs	r3, #2
9000343a:	f44f 61e0 	mov.w	r1, #1792	; 0x700
9000343e:	f001 fad7 	bl	900049f0 <wm8994_write_reg>
90003442:	4602      	mov	r2, r0
90003444:	68fb      	ldr	r3, [r7, #12]
90003446:	4413      	add	r3, r2
90003448:	60fb      	str	r3, [r7, #12]
    break;
9000344a:	e0e8      	b.n	9000361e <WM8994_Init+0x7c2>
    
  case WM8994_IN_MIC1 :
    /* Enable AIF1ADC1 (Left), Enable AIF1ADC1 (Right)
    * Enable DMICDAT1 (Left), Enable DMICDAT1 (Right)
    * Enable Left ADC, Enable Right ADC */
    tmp = 0x030C;
9000344c:	f44f 7343 	mov.w	r3, #780	; 0x30c
90003450:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_4, &tmp, 2);
90003452:	687b      	ldr	r3, [r7, #4]
90003454:	f103 0018 	add.w	r0, r3, #24
90003458:	f107 020a 	add.w	r2, r7, #10
9000345c:	2302      	movs	r3, #2
9000345e:	2104      	movs	r1, #4
90003460:	f001 fac6 	bl	900049f0 <wm8994_write_reg>
90003464:	4602      	mov	r2, r0
90003466:	68fb      	ldr	r3, [r7, #12]
90003468:	4413      	add	r3, r2
9000346a:	60fb      	str	r3, [r7, #12]
    
    /* Enable AIF1 DRC1 Signal Detect & DRC in AIF1ADC1 Left/Right Timeslot 0 */
    tmp = 0x00DB;
9000346c:	23db      	movs	r3, #219	; 0xdb
9000346e:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DRC1, &tmp, 2);
90003470:	687b      	ldr	r3, [r7, #4]
90003472:	f103 0018 	add.w	r0, r3, #24
90003476:	f107 020a 	add.w	r2, r7, #10
9000347a:	2302      	movs	r3, #2
9000347c:	f44f 6188 	mov.w	r1, #1088	; 0x440
90003480:	f001 fab6 	bl	900049f0 <wm8994_write_reg>
90003484:	4602      	mov	r2, r0
90003486:	68fb      	ldr	r3, [r7, #12]
90003488:	4413      	add	r3, r2
9000348a:	60fb      	str	r3, [r7, #12]
    
    /* Enable IN1L and IN1R, Disable IN2L and IN2R, Enable Thermal sensor & shutdown */
    tmp = 0x6350;
9000348c:	f246 3350 	movw	r3, #25424	; 0x6350
90003490:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_2, &tmp, 2);
90003492:	687b      	ldr	r3, [r7, #4]
90003494:	f103 0018 	add.w	r0, r3, #24
90003498:	f107 020a 	add.w	r2, r7, #10
9000349c:	2302      	movs	r3, #2
9000349e:	2102      	movs	r1, #2
900034a0:	f001 faa6 	bl	900049f0 <wm8994_write_reg>
900034a4:	4602      	mov	r2, r0
900034a6:	68fb      	ldr	r3, [r7, #12]
900034a8:	4413      	add	r3, r2
900034aa:	60fb      	str	r3, [r7, #12]
    
    /* Enable the ADCL(Left) to AIF1 Timeslot 0 (Left) mixer path */
    tmp = 0x0002;
900034ac:	2302      	movs	r3, #2
900034ae:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC1_LMR, &tmp, 2);
900034b0:	687b      	ldr	r3, [r7, #4]
900034b2:	f103 0018 	add.w	r0, r3, #24
900034b6:	f107 020a 	add.w	r2, r7, #10
900034ba:	2302      	movs	r3, #2
900034bc:	f240 6106 	movw	r1, #1542	; 0x606
900034c0:	f001 fa96 	bl	900049f0 <wm8994_write_reg>
900034c4:	4602      	mov	r2, r0
900034c6:	68fb      	ldr	r3, [r7, #12]
900034c8:	4413      	add	r3, r2
900034ca:	60fb      	str	r3, [r7, #12]
    
    /* Enable the ADCR(Right) to AIF1 Timeslot 0 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC1_RMR, &tmp, 2);
900034cc:	687b      	ldr	r3, [r7, #4]
900034ce:	f103 0018 	add.w	r0, r3, #24
900034d2:	f107 020a 	add.w	r2, r7, #10
900034d6:	2302      	movs	r3, #2
900034d8:	f240 6107 	movw	r1, #1543	; 0x607
900034dc:	f001 fa88 	bl	900049f0 <wm8994_write_reg>
900034e0:	4602      	mov	r2, r0
900034e2:	68fb      	ldr	r3, [r7, #12]
900034e4:	4413      	add	r3, r2
900034e6:	60fb      	str	r3, [r7, #12]
    
    /* GPIO1 pin configuration GP1_DIR = output, GP1_FN = AIF1 DRC1 signal detect */
    tmp = 0x000D;
900034e8:	230d      	movs	r3, #13
900034ea:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_GPIO1, &tmp, 2);
900034ec:	687b      	ldr	r3, [r7, #4]
900034ee:	f103 0018 	add.w	r0, r3, #24
900034f2:	f107 020a 	add.w	r2, r7, #10
900034f6:	2302      	movs	r3, #2
900034f8:	f44f 61e0 	mov.w	r1, #1792	; 0x700
900034fc:	f001 fa78 	bl	900049f0 <wm8994_write_reg>
90003500:	4602      	mov	r2, r0
90003502:	68fb      	ldr	r3, [r7, #12]
90003504:	4413      	add	r3, r2
90003506:	60fb      	str	r3, [r7, #12]
    break;
90003508:	e089      	b.n	9000361e <WM8994_Init+0x7c2>
    
  case WM8994_IN_MIC1_MIC2 :
    /* Enable AIF1ADC1 (Left), Enable AIF1ADC1 (Right)
    * Enable DMICDAT1 (Left), Enable DMICDAT1 (Right)
    * Enable Left ADC, Enable Right ADC */
    tmp = 0x0F3C;
9000350a:	f640 733c 	movw	r3, #3900	; 0xf3c
9000350e:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_4, &tmp, 2);
90003510:	687b      	ldr	r3, [r7, #4]
90003512:	f103 0018 	add.w	r0, r3, #24
90003516:	f107 020a 	add.w	r2, r7, #10
9000351a:	2302      	movs	r3, #2
9000351c:	2104      	movs	r1, #4
9000351e:	f001 fa67 	bl	900049f0 <wm8994_write_reg>
90003522:	4602      	mov	r2, r0
90003524:	68fb      	ldr	r3, [r7, #12]
90003526:	4413      	add	r3, r2
90003528:	60fb      	str	r3, [r7, #12]
    
    /* Enable AIF1 DRC2 Signal Detect & DRC in AIF1ADC2 Left/Right Timeslot 1 */
    tmp = 0x00DB;
9000352a:	23db      	movs	r3, #219	; 0xdb
9000352c:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DRC2, &tmp, 2);
9000352e:	687b      	ldr	r3, [r7, #4]
90003530:	f103 0018 	add.w	r0, r3, #24
90003534:	f107 020a 	add.w	r2, r7, #10
90003538:	2302      	movs	r3, #2
9000353a:	f44f 618a 	mov.w	r1, #1104	; 0x450
9000353e:	f001 fa57 	bl	900049f0 <wm8994_write_reg>
90003542:	4602      	mov	r2, r0
90003544:	68fb      	ldr	r3, [r7, #12]
90003546:	4413      	add	r3, r2
90003548:	60fb      	str	r3, [r7, #12]
    
    /* Enable AIF1 DRC2 Signal Detect & DRC in AIF1ADC1 Left/Right Timeslot 0 */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DRC1, &tmp, 2);
9000354a:	687b      	ldr	r3, [r7, #4]
9000354c:	f103 0018 	add.w	r0, r3, #24
90003550:	f107 020a 	add.w	r2, r7, #10
90003554:	2302      	movs	r3, #2
90003556:	f44f 6188 	mov.w	r1, #1088	; 0x440
9000355a:	f001 fa49 	bl	900049f0 <wm8994_write_reg>
9000355e:	4602      	mov	r2, r0
90003560:	68fb      	ldr	r3, [r7, #12]
90003562:	4413      	add	r3, r2
90003564:	60fb      	str	r3, [r7, #12]
    
    /* Disable IN1L, IN1R, Enable IN2L, IN2R, Thermal sensor & shutdown */
    tmp = 0x63A0;
90003566:	f246 33a0 	movw	r3, #25504	; 0x63a0
9000356a:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_2, &tmp, 2);
9000356c:	687b      	ldr	r3, [r7, #4]
9000356e:	f103 0018 	add.w	r0, r3, #24
90003572:	f107 020a 	add.w	r2, r7, #10
90003576:	2302      	movs	r3, #2
90003578:	2102      	movs	r1, #2
9000357a:	f001 fa39 	bl	900049f0 <wm8994_write_reg>
9000357e:	4602      	mov	r2, r0
90003580:	68fb      	ldr	r3, [r7, #12]
90003582:	4413      	add	r3, r2
90003584:	60fb      	str	r3, [r7, #12]
    
    /* Enable the ADCL(Left) to AIF1 Timeslot 0 (Left) mixer path */
    tmp = 0x0002;
90003586:	2302      	movs	r3, #2
90003588:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC1_LMR, &tmp, 2);
9000358a:	687b      	ldr	r3, [r7, #4]
9000358c:	f103 0018 	add.w	r0, r3, #24
90003590:	f107 020a 	add.w	r2, r7, #10
90003594:	2302      	movs	r3, #2
90003596:	f240 6106 	movw	r1, #1542	; 0x606
9000359a:	f001 fa29 	bl	900049f0 <wm8994_write_reg>
9000359e:	4602      	mov	r2, r0
900035a0:	68fb      	ldr	r3, [r7, #12]
900035a2:	4413      	add	r3, r2
900035a4:	60fb      	str	r3, [r7, #12]
    
    /* Enable the ADCR(Right) to AIF1 Timeslot 0 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC1_RMR, &tmp, 2);
900035a6:	687b      	ldr	r3, [r7, #4]
900035a8:	f103 0018 	add.w	r0, r3, #24
900035ac:	f107 020a 	add.w	r2, r7, #10
900035b0:	2302      	movs	r3, #2
900035b2:	f240 6107 	movw	r1, #1543	; 0x607
900035b6:	f001 fa1b 	bl	900049f0 <wm8994_write_reg>
900035ba:	4602      	mov	r2, r0
900035bc:	68fb      	ldr	r3, [r7, #12]
900035be:	4413      	add	r3, r2
900035c0:	60fb      	str	r3, [r7, #12]
    
    /* Enable the DMIC2(Left) to AIF1 Timeslot 1 (Left) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC2_LMR, &tmp, 2);
900035c2:	687b      	ldr	r3, [r7, #4]
900035c4:	f103 0018 	add.w	r0, r3, #24
900035c8:	f107 020a 	add.w	r2, r7, #10
900035cc:	2302      	movs	r3, #2
900035ce:	f44f 61c1 	mov.w	r1, #1544	; 0x608
900035d2:	f001 fa0d 	bl	900049f0 <wm8994_write_reg>
900035d6:	4602      	mov	r2, r0
900035d8:	68fb      	ldr	r3, [r7, #12]
900035da:	4413      	add	r3, r2
900035dc:	60fb      	str	r3, [r7, #12]
    
    /* Enable the DMIC2(Right) to AIF1 Timeslot 1 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC2_RMR, &tmp, 2);
900035de:	687b      	ldr	r3, [r7, #4]
900035e0:	f103 0018 	add.w	r0, r3, #24
900035e4:	f107 020a 	add.w	r2, r7, #10
900035e8:	2302      	movs	r3, #2
900035ea:	f240 6109 	movw	r1, #1545	; 0x609
900035ee:	f001 f9ff 	bl	900049f0 <wm8994_write_reg>
900035f2:	4602      	mov	r2, r0
900035f4:	68fb      	ldr	r3, [r7, #12]
900035f6:	4413      	add	r3, r2
900035f8:	60fb      	str	r3, [r7, #12]
    
    /* GPIO1 pin configuration GP1_DIR = output, GP1_FN = AIF1 DRC1 signal detect */
    tmp = 0x000D;
900035fa:	230d      	movs	r3, #13
900035fc:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_GPIO1, &tmp, 2);
900035fe:	687b      	ldr	r3, [r7, #4]
90003600:	f103 0018 	add.w	r0, r3, #24
90003604:	f107 020a 	add.w	r2, r7, #10
90003608:	2302      	movs	r3, #2
9000360a:	f44f 61e0 	mov.w	r1, #1792	; 0x700
9000360e:	f001 f9ef 	bl	900049f0 <wm8994_write_reg>
90003612:	4602      	mov	r2, r0
90003614:	68fb      	ldr	r3, [r7, #12]
90003616:	4413      	add	r3, r2
90003618:	60fb      	str	r3, [r7, #12]
    
    break;    
9000361a:	e000      	b.n	9000361e <WM8994_Init+0x7c2>
  case WM8994_IN_LINE2 :
  case WM8994_IN_NONE:      
  default:
    /* Actually, no other input devices supported */
    break;
9000361c:	bf00      	nop
  }
  
  /*  Clock Configurations */
  ret += WM8994_SetFrequency(pObj, pInit->Frequency);
9000361e:	683b      	ldr	r3, [r7, #0]
90003620:	689b      	ldr	r3, [r3, #8]
90003622:	4619      	mov	r1, r3
90003624:	6878      	ldr	r0, [r7, #4]
90003626:	f000 fff9 	bl	9000461c <WM8994_SetFrequency>
9000362a:	4602      	mov	r2, r0
9000362c:	68fb      	ldr	r3, [r7, #12]
9000362e:	4413      	add	r3, r2
90003630:	60fb      	str	r3, [r7, #12]
  
  if(pInit->InputDevice == WM8994_IN_MIC1_MIC2)
90003632:	683b      	ldr	r3, [r7, #0]
90003634:	681b      	ldr	r3, [r3, #0]
90003636:	2b05      	cmp	r3, #5
90003638:	d11a      	bne.n	90003670 <WM8994_Init+0x814>
  {
    /* AIF1 Word Length = 16-bits, AIF1 Format = DSP mode */
    ret += WM8994_SetResolution(pObj, WM8994_RESOLUTION_16b);
9000363a:	2100      	movs	r1, #0
9000363c:	6878      	ldr	r0, [r7, #4]
9000363e:	f000 ff59 	bl	900044f4 <WM8994_SetResolution>
90003642:	4602      	mov	r2, r0
90003644:	68fb      	ldr	r3, [r7, #12]
90003646:	4413      	add	r3, r2
90003648:	60fb      	str	r3, [r7, #12]
    ret += WM8994_SetProtocol(pObj, WM8994_PROTOCOL_DSP);
9000364a:	2103      	movs	r1, #3
9000364c:	6878      	ldr	r0, [r7, #4]
9000364e:	f000 ffab 	bl	900045a8 <WM8994_SetProtocol>
90003652:	4602      	mov	r2, r0
90003654:	68fb      	ldr	r3, [r7, #12]
90003656:	4413      	add	r3, r2
90003658:	60fb      	str	r3, [r7, #12]
    ret += wm8994_aif1_control1_adcr_src(&pObj->Ctx, 1);
9000365a:	687b      	ldr	r3, [r7, #4]
9000365c:	3318      	adds	r3, #24
9000365e:	2101      	movs	r1, #1
90003660:	4618      	mov	r0, r3
90003662:	f001 faf3 	bl	90004c4c <wm8994_aif1_control1_adcr_src>
90003666:	4602      	mov	r2, r0
90003668:	68fb      	ldr	r3, [r7, #12]
9000366a:	4413      	add	r3, r2
9000366c:	60fb      	str	r3, [r7, #12]
9000366e:	e01b      	b.n	900036a8 <WM8994_Init+0x84c>
  }
  else
  {
    /* AIF1 Word Length = 16-bits, AIF1 Format = I2S (Default Register Value) */
    ret += WM8994_SetResolution(pObj, pInit->Resolution);
90003670:	683b      	ldr	r3, [r7, #0]
90003672:	68db      	ldr	r3, [r3, #12]
90003674:	4619      	mov	r1, r3
90003676:	6878      	ldr	r0, [r7, #4]
90003678:	f000 ff3c 	bl	900044f4 <WM8994_SetResolution>
9000367c:	4602      	mov	r2, r0
9000367e:	68fb      	ldr	r3, [r7, #12]
90003680:	4413      	add	r3, r2
90003682:	60fb      	str	r3, [r7, #12]
    ret += WM8994_SetProtocol(pObj, WM8994_PROTOCOL_I2S);
90003684:	2102      	movs	r1, #2
90003686:	6878      	ldr	r0, [r7, #4]
90003688:	f000 ff8e 	bl	900045a8 <WM8994_SetProtocol>
9000368c:	4602      	mov	r2, r0
9000368e:	68fb      	ldr	r3, [r7, #12]
90003690:	4413      	add	r3, r2
90003692:	60fb      	str	r3, [r7, #12]
    ret += wm8994_aif1_control1_adcr_src(&pObj->Ctx, 1);
90003694:	687b      	ldr	r3, [r7, #4]
90003696:	3318      	adds	r3, #24
90003698:	2101      	movs	r1, #1
9000369a:	4618      	mov	r0, r3
9000369c:	f001 fad6 	bl	90004c4c <wm8994_aif1_control1_adcr_src>
900036a0:	4602      	mov	r2, r0
900036a2:	68fb      	ldr	r3, [r7, #12]
900036a4:	4413      	add	r3, r2
900036a6:	60fb      	str	r3, [r7, #12]
  }
  
  /* slave mode */
  tmp = 0x0000;
900036a8:	2300      	movs	r3, #0
900036aa:	817b      	strh	r3, [r7, #10]
  ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_MASTER_SLAVE, &tmp, 2);
900036ac:	687b      	ldr	r3, [r7, #4]
900036ae:	f103 0018 	add.w	r0, r3, #24
900036b2:	f107 020a 	add.w	r2, r7, #10
900036b6:	2302      	movs	r3, #2
900036b8:	f240 3102 	movw	r1, #770	; 0x302
900036bc:	f001 f998 	bl	900049f0 <wm8994_write_reg>
900036c0:	4602      	mov	r2, r0
900036c2:	68fb      	ldr	r3, [r7, #12]
900036c4:	4413      	add	r3, r2
900036c6:	60fb      	str	r3, [r7, #12]
  
  /* Enable the DSP processing clock for AIF1, Enable the core clock */
  tmp = 0x000A;
900036c8:	230a      	movs	r3, #10
900036ca:	817b      	strh	r3, [r7, #10]
  ret += wm8994_write_reg(&pObj->Ctx, WM8994_CLOCKING1, &tmp, 2);
900036cc:	687b      	ldr	r3, [r7, #4]
900036ce:	f103 0018 	add.w	r0, r3, #24
900036d2:	f107 020a 	add.w	r2, r7, #10
900036d6:	2302      	movs	r3, #2
900036d8:	f44f 7102 	mov.w	r1, #520	; 0x208
900036dc:	f001 f988 	bl	900049f0 <wm8994_write_reg>
900036e0:	4602      	mov	r2, r0
900036e2:	68fb      	ldr	r3, [r7, #12]
900036e4:	4413      	add	r3, r2
900036e6:	60fb      	str	r3, [r7, #12]
  
  /* Enable AIF1 Clock, AIF1 Clock Source = MCLK1 pin */
  tmp = 0x0001;
900036e8:	2301      	movs	r3, #1
900036ea:	817b      	strh	r3, [r7, #10]
  ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_CLOCKING1, &tmp, 2);
900036ec:	687b      	ldr	r3, [r7, #4]
900036ee:	f103 0018 	add.w	r0, r3, #24
900036f2:	f107 020a 	add.w	r2, r7, #10
900036f6:	2302      	movs	r3, #2
900036f8:	f44f 7100 	mov.w	r1, #512	; 0x200
900036fc:	f001 f978 	bl	900049f0 <wm8994_write_reg>
90003700:	4602      	mov	r2, r0
90003702:	68fb      	ldr	r3, [r7, #12]
90003704:	4413      	add	r3, r2
90003706:	60fb      	str	r3, [r7, #12]
  
  if (pInit->OutputDevice != WM8994_OUT_NONE)  /* Audio output selected */  
90003708:	683b      	ldr	r3, [r7, #0]
9000370a:	685b      	ldr	r3, [r3, #4]
9000370c:	2b00      	cmp	r3, #0
9000370e:	f000 81c6 	beq.w	90003a9e <WM8994_Init+0xc42>
  {  
    if ((pInit->OutputDevice == WM8994_OUT_HEADPHONE) && (pInit->InputDevice == WM8994_IN_NONE))
90003712:	683b      	ldr	r3, [r7, #0]
90003714:	685b      	ldr	r3, [r3, #4]
90003716:	2b02      	cmp	r3, #2
90003718:	d164      	bne.n	900037e4 <WM8994_Init+0x988>
9000371a:	683b      	ldr	r3, [r7, #0]
9000371c:	681b      	ldr	r3, [r3, #0]
9000371e:	2b00      	cmp	r3, #0
90003720:	d160      	bne.n	900037e4 <WM8994_Init+0x988>
    {    
      tmp = 0x0100;
90003722:	f44f 7380 	mov.w	r3, #256	; 0x100
90003726:	817b      	strh	r3, [r7, #10]
      /* Select DAC1 (Left) to Left Headphone Output PGA (HPOUT1LVOL) path */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_OUTPUT_MIXER_1, &tmp, 2);
90003728:	687b      	ldr	r3, [r7, #4]
9000372a:	f103 0018 	add.w	r0, r3, #24
9000372e:	f107 020a 	add.w	r2, r7, #10
90003732:	2302      	movs	r3, #2
90003734:	212d      	movs	r1, #45	; 0x2d
90003736:	f001 f95b 	bl	900049f0 <wm8994_write_reg>
9000373a:	4602      	mov	r2, r0
9000373c:	68fb      	ldr	r3, [r7, #12]
9000373e:	4413      	add	r3, r2
90003740:	60fb      	str	r3, [r7, #12]
      
      /* Select DAC1 (Right) to Right Headphone Output PGA (HPOUT1RVOL) path */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_OUTPUT_MIXER_2, &tmp, 2);
90003742:	687b      	ldr	r3, [r7, #4]
90003744:	f103 0018 	add.w	r0, r3, #24
90003748:	f107 020a 	add.w	r2, r7, #10
9000374c:	2302      	movs	r3, #2
9000374e:	212e      	movs	r1, #46	; 0x2e
90003750:	f001 f94e 	bl	900049f0 <wm8994_write_reg>
90003754:	4602      	mov	r2, r0
90003756:	68fb      	ldr	r3, [r7, #12]
90003758:	4413      	add	r3, r2
9000375a:	60fb      	str	r3, [r7, #12]
      
      /* Startup sequence for Headphone */
      if(ColdStartup == 1U)
9000375c:	4b52      	ldr	r3, [pc, #328]	; (900038a8 <WM8994_Init+0xa4c>)
9000375e:	781b      	ldrb	r3, [r3, #0]
90003760:	2b01      	cmp	r3, #1
90003762:	d119      	bne.n	90003798 <WM8994_Init+0x93c>
      {
        /* Enable/Start the write sequencer */
        tmp = 0x8100;
90003764:	f44f 4301 	mov.w	r3, #33024	; 0x8100
90003768:	817b      	strh	r3, [r7, #10]
        ret += wm8994_write_reg(&pObj->Ctx, WM8994_WRITE_SEQ_CTRL1, &tmp, 2);
9000376a:	687b      	ldr	r3, [r7, #4]
9000376c:	f103 0018 	add.w	r0, r3, #24
90003770:	f107 020a 	add.w	r2, r7, #10
90003774:	2302      	movs	r3, #2
90003776:	f44f 7188 	mov.w	r1, #272	; 0x110
9000377a:	f001 f939 	bl	900049f0 <wm8994_write_reg>
9000377e:	4602      	mov	r2, r0
90003780:	68fb      	ldr	r3, [r7, #12]
90003782:	4413      	add	r3, r2
90003784:	60fb      	str	r3, [r7, #12]
        
        ColdStartup=0;
90003786:	4b48      	ldr	r3, [pc, #288]	; (900038a8 <WM8994_Init+0xa4c>)
90003788:	2200      	movs	r2, #0
9000378a:	701a      	strb	r2, [r3, #0]
        /* Add Delay */
        (void)WM8994_Delay(pObj, 325);
9000378c:	f240 1145 	movw	r1, #325	; 0x145
90003790:	6878      	ldr	r0, [r7, #4]
90003792:	f001 f8b5 	bl	90004900 <WM8994_Delay>
90003796:	e014      	b.n	900037c2 <WM8994_Init+0x966>
      }
      else 
      { 
        /* Headphone Warm Start-Up */
        tmp = 0x8108;
90003798:	f248 1308 	movw	r3, #33032	; 0x8108
9000379c:	817b      	strh	r3, [r7, #10]
        ret += wm8994_write_reg(&pObj->Ctx, WM8994_WRITE_SEQ_CTRL1, &tmp, 2);
9000379e:	687b      	ldr	r3, [r7, #4]
900037a0:	f103 0018 	add.w	r0, r3, #24
900037a4:	f107 020a 	add.w	r2, r7, #10
900037a8:	2302      	movs	r3, #2
900037aa:	f44f 7188 	mov.w	r1, #272	; 0x110
900037ae:	f001 f91f 	bl	900049f0 <wm8994_write_reg>
900037b2:	4602      	mov	r2, r0
900037b4:	68fb      	ldr	r3, [r7, #12]
900037b6:	4413      	add	r3, r2
900037b8:	60fb      	str	r3, [r7, #12]
        
        /* Add Delay */
        (void)WM8994_Delay(pObj, 50);
900037ba:	2132      	movs	r1, #50	; 0x32
900037bc:	6878      	ldr	r0, [r7, #4]
900037be:	f001 f89f 	bl	90004900 <WM8994_Delay>
      }
      
      /* Soft un-Mute the AIF1 Timeslot 0 DAC1 path L&R */
      tmp = 0x0000;
900037c2:	2300      	movs	r3, #0
900037c4:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_FILTER1, &tmp, 2);
900037c6:	687b      	ldr	r3, [r7, #4]
900037c8:	f103 0018 	add.w	r0, r3, #24
900037cc:	f107 020a 	add.w	r2, r7, #10
900037d0:	2302      	movs	r3, #2
900037d2:	f44f 6184 	mov.w	r1, #1056	; 0x420
900037d6:	f001 f90b 	bl	900049f0 <wm8994_write_reg>
900037da:	4602      	mov	r2, r0
900037dc:	68fb      	ldr	r3, [r7, #12]
900037de:	4413      	add	r3, r2
900037e0:	60fb      	str	r3, [r7, #12]
900037e2:	e0f4      	b.n	900039ce <WM8994_Init+0xb72>
    else
    {
      /* Analog Output Configuration */
      
      /* Enable SPKRVOL PGA, Enable SPKMIXR, Enable SPKLVOL PGA, Enable SPKMIXL */
      tmp = 0x0300;
900037e4:	f44f 7340 	mov.w	r3, #768	; 0x300
900037e8:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_3, &tmp, 2);
900037ea:	687b      	ldr	r3, [r7, #4]
900037ec:	f103 0018 	add.w	r0, r3, #24
900037f0:	f107 020a 	add.w	r2, r7, #10
900037f4:	2302      	movs	r3, #2
900037f6:	2103      	movs	r1, #3
900037f8:	f001 f8fa 	bl	900049f0 <wm8994_write_reg>
900037fc:	4602      	mov	r2, r0
900037fe:	68fb      	ldr	r3, [r7, #12]
90003800:	4413      	add	r3, r2
90003802:	60fb      	str	r3, [r7, #12]
      
      /* Left Speaker Mixer Volume = 0dB */
      tmp = 0x0000;
90003804:	2300      	movs	r3, #0
90003806:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_SPKMIXL_ATT, &tmp, 2);
90003808:	687b      	ldr	r3, [r7, #4]
9000380a:	f103 0018 	add.w	r0, r3, #24
9000380e:	f107 020a 	add.w	r2, r7, #10
90003812:	2302      	movs	r3, #2
90003814:	2122      	movs	r1, #34	; 0x22
90003816:	f001 f8eb 	bl	900049f0 <wm8994_write_reg>
9000381a:	4602      	mov	r2, r0
9000381c:	68fb      	ldr	r3, [r7, #12]
9000381e:	4413      	add	r3, r2
90003820:	60fb      	str	r3, [r7, #12]
      
      /* Speaker output mode = Class D, Right Speaker Mixer Volume = 0dB ((0x23, 0x0100) = class AB)*/
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_SPKMIXR_ATT, &tmp, 2);
90003822:	687b      	ldr	r3, [r7, #4]
90003824:	f103 0018 	add.w	r0, r3, #24
90003828:	f107 020a 	add.w	r2, r7, #10
9000382c:	2302      	movs	r3, #2
9000382e:	2123      	movs	r1, #35	; 0x23
90003830:	f001 f8de 	bl	900049f0 <wm8994_write_reg>
90003834:	4602      	mov	r2, r0
90003836:	68fb      	ldr	r3, [r7, #12]
90003838:	4413      	add	r3, r2
9000383a:	60fb      	str	r3, [r7, #12]
      
      /* Unmute DAC2 (Left) to Left Speaker Mixer (SPKMIXL) path,
      Unmute DAC2 (Right) to Right Speaker Mixer (SPKMIXR) path */
      tmp = 0x0300;
9000383c:	f44f 7340 	mov.w	r3, #768	; 0x300
90003840:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_SPEAKER_MIXER, &tmp, 2);
90003842:	687b      	ldr	r3, [r7, #4]
90003844:	f103 0018 	add.w	r0, r3, #24
90003848:	f107 020a 	add.w	r2, r7, #10
9000384c:	2302      	movs	r3, #2
9000384e:	2136      	movs	r1, #54	; 0x36
90003850:	f001 f8ce 	bl	900049f0 <wm8994_write_reg>
90003854:	4602      	mov	r2, r0
90003856:	68fb      	ldr	r3, [r7, #12]
90003858:	4413      	add	r3, r2
9000385a:	60fb      	str	r3, [r7, #12]
      
      /* Enable bias generator, Enable VMID, Enable SPKOUTL, Enable SPKOUTR */
      tmp = 0x3003;
9000385c:	f243 0303 	movw	r3, #12291	; 0x3003
90003860:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_1, &tmp, 2);
90003862:	687b      	ldr	r3, [r7, #4]
90003864:	f103 0018 	add.w	r0, r3, #24
90003868:	f107 020a 	add.w	r2, r7, #10
9000386c:	2302      	movs	r3, #2
9000386e:	2101      	movs	r1, #1
90003870:	f001 f8be 	bl	900049f0 <wm8994_write_reg>
90003874:	4602      	mov	r2, r0
90003876:	68fb      	ldr	r3, [r7, #12]
90003878:	4413      	add	r3, r2
9000387a:	60fb      	str	r3, [r7, #12]
      /* Headphone/Speaker Enable */
      
      if (pInit->InputDevice == WM8994_IN_MIC1_MIC2)
9000387c:	683b      	ldr	r3, [r7, #0]
9000387e:	681b      	ldr	r3, [r3, #0]
90003880:	2b05      	cmp	r3, #5
90003882:	d113      	bne.n	900038ac <WM8994_Init+0xa50>
      {
        /* Enable Class W, Class W Envelope Tracking = AIF1 Timeslots 0 and 1 */
        tmp = 0x0205;
90003884:	f240 2305 	movw	r3, #517	; 0x205
90003888:	817b      	strh	r3, [r7, #10]
        ret += wm8994_write_reg(&pObj->Ctx, WM8994_CLASS_W, &tmp, 2); 
9000388a:	687b      	ldr	r3, [r7, #4]
9000388c:	f103 0018 	add.w	r0, r3, #24
90003890:	f107 020a 	add.w	r2, r7, #10
90003894:	2302      	movs	r3, #2
90003896:	2151      	movs	r1, #81	; 0x51
90003898:	f001 f8aa 	bl	900049f0 <wm8994_write_reg>
9000389c:	4602      	mov	r2, r0
9000389e:	68fb      	ldr	r3, [r7, #12]
900038a0:	4413      	add	r3, r2
900038a2:	60fb      	str	r3, [r7, #12]
900038a4:	e011      	b.n	900038ca <WM8994_Init+0xa6e>
900038a6:	bf00      	nop
900038a8:	24000078 	.word	0x24000078
      }
      else
      {
        /* Enable Class W, Class W Envelope Tracking = AIF1 Timeslot 0 */
        tmp = 0x0005;
900038ac:	2305      	movs	r3, #5
900038ae:	817b      	strh	r3, [r7, #10]
        ret += wm8994_write_reg(&pObj->Ctx, WM8994_CLASS_W, &tmp, 2);
900038b0:	687b      	ldr	r3, [r7, #4]
900038b2:	f103 0018 	add.w	r0, r3, #24
900038b6:	f107 020a 	add.w	r2, r7, #10
900038ba:	2302      	movs	r3, #2
900038bc:	2151      	movs	r1, #81	; 0x51
900038be:	f001 f897 	bl	900049f0 <wm8994_write_reg>
900038c2:	4602      	mov	r2, r0
900038c4:	68fb      	ldr	r3, [r7, #12]
900038c6:	4413      	add	r3, r2
900038c8:	60fb      	str	r3, [r7, #12]
      }
      
      /* Enable bias generator, Enable VMID, Enable HPOUT1 (Left) and Enable HPOUT1 (Right) input stages */
      /* idem for Speaker */
      tmp = 0x3303;
900038ca:	f243 3303 	movw	r3, #13059	; 0x3303
900038ce:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_1, &tmp, 2);
900038d0:	687b      	ldr	r3, [r7, #4]
900038d2:	f103 0018 	add.w	r0, r3, #24
900038d6:	f107 020a 	add.w	r2, r7, #10
900038da:	2302      	movs	r3, #2
900038dc:	2101      	movs	r1, #1
900038de:	f001 f887 	bl	900049f0 <wm8994_write_reg>
900038e2:	4602      	mov	r2, r0
900038e4:	68fb      	ldr	r3, [r7, #12]
900038e6:	4413      	add	r3, r2
900038e8:	60fb      	str	r3, [r7, #12]
      
      /* Enable HPOUT1 (Left) and HPOUT1 (Right) intermediate stages */
      tmp = 0x0022;
900038ea:	2322      	movs	r3, #34	; 0x22
900038ec:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_ANALOG_HP, &tmp, 2);
900038ee:	687b      	ldr	r3, [r7, #4]
900038f0:	f103 0018 	add.w	r0, r3, #24
900038f4:	f107 020a 	add.w	r2, r7, #10
900038f8:	2302      	movs	r3, #2
900038fa:	2160      	movs	r1, #96	; 0x60
900038fc:	f001 f878 	bl	900049f0 <wm8994_write_reg>
90003900:	4602      	mov	r2, r0
90003902:	68fb      	ldr	r3, [r7, #12]
90003904:	4413      	add	r3, r2
90003906:	60fb      	str	r3, [r7, #12]
      
      /* Enable Charge Pump */
      tmp = 0x9F25;
90003908:	f649 7325 	movw	r3, #40741	; 0x9f25
9000390c:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_CHARGE_PUMP1, &tmp, 2);
9000390e:	687b      	ldr	r3, [r7, #4]
90003910:	f103 0018 	add.w	r0, r3, #24
90003914:	f107 020a 	add.w	r2, r7, #10
90003918:	2302      	movs	r3, #2
9000391a:	214c      	movs	r1, #76	; 0x4c
9000391c:	f001 f868 	bl	900049f0 <wm8994_write_reg>
90003920:	4602      	mov	r2, r0
90003922:	68fb      	ldr	r3, [r7, #12]
90003924:	4413      	add	r3, r2
90003926:	60fb      	str	r3, [r7, #12]
      
      /* Add Delay */
      (void)WM8994_Delay(pObj, 15);
90003928:	210f      	movs	r1, #15
9000392a:	6878      	ldr	r0, [r7, #4]
9000392c:	f000 ffe8 	bl	90004900 <WM8994_Delay>
      
      tmp = 0x0001;
90003930:	2301      	movs	r3, #1
90003932:	817b      	strh	r3, [r7, #10]
      /* Select DAC1 (Left) to Left Headphone Output PGA (HPOUT1LVOL) path */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_OUTPUT_MIXER_1, &tmp, 2);
90003934:	687b      	ldr	r3, [r7, #4]
90003936:	f103 0018 	add.w	r0, r3, #24
9000393a:	f107 020a 	add.w	r2, r7, #10
9000393e:	2302      	movs	r3, #2
90003940:	212d      	movs	r1, #45	; 0x2d
90003942:	f001 f855 	bl	900049f0 <wm8994_write_reg>
90003946:	4602      	mov	r2, r0
90003948:	68fb      	ldr	r3, [r7, #12]
9000394a:	4413      	add	r3, r2
9000394c:	60fb      	str	r3, [r7, #12]
      
      /* Select DAC1 (Right) to Right Headphone Output PGA (HPOUT1RVOL) path */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_OUTPUT_MIXER_2, &tmp, 2);
9000394e:	687b      	ldr	r3, [r7, #4]
90003950:	f103 0018 	add.w	r0, r3, #24
90003954:	f107 020a 	add.w	r2, r7, #10
90003958:	2302      	movs	r3, #2
9000395a:	212e      	movs	r1, #46	; 0x2e
9000395c:	f001 f848 	bl	900049f0 <wm8994_write_reg>
90003960:	4602      	mov	r2, r0
90003962:	68fb      	ldr	r3, [r7, #12]
90003964:	4413      	add	r3, r2
90003966:	60fb      	str	r3, [r7, #12]
      
      /* Enable Left Output Mixer (MIXOUTL), Enable Right Output Mixer (MIXOUTR) */
      /* idem for SPKOUTL and SPKOUTR */
      tmp = 0x0330;
90003968:	f44f 734c 	mov.w	r3, #816	; 0x330
9000396c:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_3, &tmp, 2);
9000396e:	687b      	ldr	r3, [r7, #4]
90003970:	f103 0018 	add.w	r0, r3, #24
90003974:	f107 020a 	add.w	r2, r7, #10
90003978:	2302      	movs	r3, #2
9000397a:	2103      	movs	r1, #3
9000397c:	f001 f838 	bl	900049f0 <wm8994_write_reg>
90003980:	4602      	mov	r2, r0
90003982:	68fb      	ldr	r3, [r7, #12]
90003984:	4413      	add	r3, r2
90003986:	60fb      	str	r3, [r7, #12]
      
      /* Enable DC Servo and trigger start-up mode on left and right channels */
      tmp = 0x0033;
90003988:	2333      	movs	r3, #51	; 0x33
9000398a:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_DC_SERVO1, &tmp, 2);
9000398c:	687b      	ldr	r3, [r7, #4]
9000398e:	f103 0018 	add.w	r0, r3, #24
90003992:	f107 020a 	add.w	r2, r7, #10
90003996:	2302      	movs	r3, #2
90003998:	2154      	movs	r1, #84	; 0x54
9000399a:	f001 f829 	bl	900049f0 <wm8994_write_reg>
9000399e:	4602      	mov	r2, r0
900039a0:	68fb      	ldr	r3, [r7, #12]
900039a2:	4413      	add	r3, r2
900039a4:	60fb      	str	r3, [r7, #12]
      
      /* Add Delay */
      (void)WM8994_Delay(pObj, 257);
900039a6:	f240 1101 	movw	r1, #257	; 0x101
900039aa:	6878      	ldr	r0, [r7, #4]
900039ac:	f000 ffa8 	bl	90004900 <WM8994_Delay>
      
      /* Enable HPOUT1 (Left) and HPOUT1 (Right) intermediate and output stages. Remove clamps */
      tmp = 0x00EE;
900039b0:	23ee      	movs	r3, #238	; 0xee
900039b2:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_ANALOG_HP, &tmp, 2);
900039b4:	687b      	ldr	r3, [r7, #4]
900039b6:	f103 0018 	add.w	r0, r3, #24
900039ba:	f107 020a 	add.w	r2, r7, #10
900039be:	2302      	movs	r3, #2
900039c0:	2160      	movs	r1, #96	; 0x60
900039c2:	f001 f815 	bl	900049f0 <wm8994_write_reg>
900039c6:	4602      	mov	r2, r0
900039c8:	68fb      	ldr	r3, [r7, #12]
900039ca:	4413      	add	r3, r2
900039cc:	60fb      	str	r3, [r7, #12]
    }
    
    /* Unmutes */
    
    /* Unmute DAC 1 (Left) */
    tmp = 0x00C0;
900039ce:	23c0      	movs	r3, #192	; 0xc0
900039d0:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_DAC1_LEFT_VOL, &tmp, 2);
900039d2:	687b      	ldr	r3, [r7, #4]
900039d4:	f103 0018 	add.w	r0, r3, #24
900039d8:	f107 020a 	add.w	r2, r7, #10
900039dc:	2302      	movs	r3, #2
900039de:	f44f 61c2 	mov.w	r1, #1552	; 0x610
900039e2:	f001 f805 	bl	900049f0 <wm8994_write_reg>
900039e6:	4602      	mov	r2, r0
900039e8:	68fb      	ldr	r3, [r7, #12]
900039ea:	4413      	add	r3, r2
900039ec:	60fb      	str	r3, [r7, #12]
    
    /* Unmute DAC 1 (Right) */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_DAC1_RIGHT_VOL, &tmp, 2);
900039ee:	687b      	ldr	r3, [r7, #4]
900039f0:	f103 0018 	add.w	r0, r3, #24
900039f4:	f107 020a 	add.w	r2, r7, #10
900039f8:	2302      	movs	r3, #2
900039fa:	f240 6111 	movw	r1, #1553	; 0x611
900039fe:	f000 fff7 	bl	900049f0 <wm8994_write_reg>
90003a02:	4602      	mov	r2, r0
90003a04:	68fb      	ldr	r3, [r7, #12]
90003a06:	4413      	add	r3, r2
90003a08:	60fb      	str	r3, [r7, #12]
    
    /* Unmute the AIF1 Timeslot 0 DAC path */
    tmp = 0x0010;
90003a0a:	2310      	movs	r3, #16
90003a0c:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_FILTER1, &tmp, 2);
90003a0e:	687b      	ldr	r3, [r7, #4]
90003a10:	f103 0018 	add.w	r0, r3, #24
90003a14:	f107 020a 	add.w	r2, r7, #10
90003a18:	2302      	movs	r3, #2
90003a1a:	f44f 6184 	mov.w	r1, #1056	; 0x420
90003a1e:	f000 ffe7 	bl	900049f0 <wm8994_write_reg>
90003a22:	4602      	mov	r2, r0
90003a24:	68fb      	ldr	r3, [r7, #12]
90003a26:	4413      	add	r3, r2
90003a28:	60fb      	str	r3, [r7, #12]
    
    /* Unmute DAC 2 (Left) */
    tmp = 0x00C0;
90003a2a:	23c0      	movs	r3, #192	; 0xc0
90003a2c:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_DAC2_LEFT_VOL, &tmp, 2);
90003a2e:	687b      	ldr	r3, [r7, #4]
90003a30:	f103 0018 	add.w	r0, r3, #24
90003a34:	f107 020a 	add.w	r2, r7, #10
90003a38:	2302      	movs	r3, #2
90003a3a:	f240 6112 	movw	r1, #1554	; 0x612
90003a3e:	f000 ffd7 	bl	900049f0 <wm8994_write_reg>
90003a42:	4602      	mov	r2, r0
90003a44:	68fb      	ldr	r3, [r7, #12]
90003a46:	4413      	add	r3, r2
90003a48:	60fb      	str	r3, [r7, #12]
    
    /* Unmute DAC 2 (Right) */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_DAC2_RIGHT_VOL, &tmp, 2);
90003a4a:	687b      	ldr	r3, [r7, #4]
90003a4c:	f103 0018 	add.w	r0, r3, #24
90003a50:	f107 020a 	add.w	r2, r7, #10
90003a54:	2302      	movs	r3, #2
90003a56:	f240 6113 	movw	r1, #1555	; 0x613
90003a5a:	f000 ffc9 	bl	900049f0 <wm8994_write_reg>
90003a5e:	4602      	mov	r2, r0
90003a60:	68fb      	ldr	r3, [r7, #12]
90003a62:	4413      	add	r3, r2
90003a64:	60fb      	str	r3, [r7, #12]
    
    /* Unmute the AIF1 Timeslot 1 DAC2 path */
    tmp = 0x0010;
90003a66:	2310      	movs	r3, #16
90003a68:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_FILTER1, &tmp, 2);
90003a6a:	687b      	ldr	r3, [r7, #4]
90003a6c:	f103 0018 	add.w	r0, r3, #24
90003a70:	f107 020a 	add.w	r2, r7, #10
90003a74:	2302      	movs	r3, #2
90003a76:	f240 4122 	movw	r1, #1058	; 0x422
90003a7a:	f000 ffb9 	bl	900049f0 <wm8994_write_reg>
90003a7e:	4602      	mov	r2, r0
90003a80:	68fb      	ldr	r3, [r7, #12]
90003a82:	4413      	add	r3, r2
90003a84:	60fb      	str	r3, [r7, #12]
    
    /* Volume Control */
    ret += WM8994_SetVolume(pObj, VOLUME_OUTPUT, (uint8_t)pInit->Volume); 
90003a86:	683b      	ldr	r3, [r7, #0]
90003a88:	691b      	ldr	r3, [r3, #16]
90003a8a:	b2db      	uxtb	r3, r3
90003a8c:	461a      	mov	r2, r3
90003a8e:	2101      	movs	r1, #1
90003a90:	6878      	ldr	r0, [r7, #4]
90003a92:	f000 f99f 	bl	90003dd4 <WM8994_SetVolume>
90003a96:	4602      	mov	r2, r0
90003a98:	68fb      	ldr	r3, [r7, #12]
90003a9a:	4413      	add	r3, r2
90003a9c:	60fb      	str	r3, [r7, #12]
  }
  
  if (pInit->InputDevice != WM8994_IN_NONE) /* Audio input selected */
90003a9e:	683b      	ldr	r3, [r7, #0]
90003aa0:	681b      	ldr	r3, [r3, #0]
90003aa2:	2b00      	cmp	r3, #0
90003aa4:	f000 80b5 	beq.w	90003c12 <WM8994_Init+0xdb6>
  {
    if ((pInit->InputDevice == WM8994_IN_MIC1) || (pInit->InputDevice == WM8994_IN_MIC2))
90003aa8:	683b      	ldr	r3, [r7, #0]
90003aaa:	681b      	ldr	r3, [r3, #0]
90003aac:	2b01      	cmp	r3, #1
90003aae:	d003      	beq.n	90003ab8 <WM8994_Init+0xc5c>
90003ab0:	683b      	ldr	r3, [r7, #0]
90003ab2:	681b      	ldr	r3, [r3, #0]
90003ab4:	2b02      	cmp	r3, #2
90003ab6:	d130      	bne.n	90003b1a <WM8994_Init+0xcbe>
    {
      /* Enable Microphone bias 1 generator, Enable VMID */
      tmp = 0x0013;
90003ab8:	2313      	movs	r3, #19
90003aba:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_1, &tmp, 2);
90003abc:	687b      	ldr	r3, [r7, #4]
90003abe:	f103 0018 	add.w	r0, r3, #24
90003ac2:	f107 020a 	add.w	r2, r7, #10
90003ac6:	2302      	movs	r3, #2
90003ac8:	2101      	movs	r1, #1
90003aca:	f000 ff91 	bl	900049f0 <wm8994_write_reg>
90003ace:	4602      	mov	r2, r0
90003ad0:	68fb      	ldr	r3, [r7, #12]
90003ad2:	4413      	add	r3, r2
90003ad4:	60fb      	str	r3, [r7, #12]
      
      /* ADC oversample enable */
      tmp = 0x0002;
90003ad6:	2302      	movs	r3, #2
90003ad8:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_OVERSAMPLING, &tmp, 2);
90003ada:	687b      	ldr	r3, [r7, #4]
90003adc:	f103 0018 	add.w	r0, r3, #24
90003ae0:	f107 020a 	add.w	r2, r7, #10
90003ae4:	2302      	movs	r3, #2
90003ae6:	f44f 61c4 	mov.w	r1, #1568	; 0x620
90003aea:	f000 ff81 	bl	900049f0 <wm8994_write_reg>
90003aee:	4602      	mov	r2, r0
90003af0:	68fb      	ldr	r3, [r7, #12]
90003af2:	4413      	add	r3, r2
90003af4:	60fb      	str	r3, [r7, #12]
      
      /* AIF ADC2 HPF enable, HPF cut = voice mode 1 fc=127Hz at fs=8kHz */
      tmp = 0x3800;
90003af6:	f44f 5360 	mov.w	r3, #14336	; 0x3800
90003afa:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC2_FILTERS, &tmp, 2);
90003afc:	687b      	ldr	r3, [r7, #4]
90003afe:	f103 0018 	add.w	r0, r3, #24
90003b02:	f107 020a 	add.w	r2, r7, #10
90003b06:	2302      	movs	r3, #2
90003b08:	f240 4111 	movw	r1, #1041	; 0x411
90003b0c:	f000 ff70 	bl	900049f0 <wm8994_write_reg>
90003b10:	4602      	mov	r2, r0
90003b12:	68fb      	ldr	r3, [r7, #12]
90003b14:	4413      	add	r3, r2
90003b16:	60fb      	str	r3, [r7, #12]
90003b18:	e06f      	b.n	90003bfa <WM8994_Init+0xd9e>
    }
    else if(pInit->InputDevice == WM8994_IN_MIC1_MIC2)
90003b1a:	683b      	ldr	r3, [r7, #0]
90003b1c:	681b      	ldr	r3, [r3, #0]
90003b1e:	2b05      	cmp	r3, #5
90003b20:	d13e      	bne.n	90003ba0 <WM8994_Init+0xd44>
    {
      /* Enable Microphone bias 1 generator, Enable VMID */
      tmp = 0x0013;
90003b22:	2313      	movs	r3, #19
90003b24:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_1, &tmp, 2);
90003b26:	687b      	ldr	r3, [r7, #4]
90003b28:	f103 0018 	add.w	r0, r3, #24
90003b2c:	f107 020a 	add.w	r2, r7, #10
90003b30:	2302      	movs	r3, #2
90003b32:	2101      	movs	r1, #1
90003b34:	f000 ff5c 	bl	900049f0 <wm8994_write_reg>
90003b38:	4602      	mov	r2, r0
90003b3a:	68fb      	ldr	r3, [r7, #12]
90003b3c:	4413      	add	r3, r2
90003b3e:	60fb      	str	r3, [r7, #12]
      
      /* ADC oversample enable */
      tmp = 0x0002;
90003b40:	2302      	movs	r3, #2
90003b42:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_OVERSAMPLING, &tmp, 2);
90003b44:	687b      	ldr	r3, [r7, #4]
90003b46:	f103 0018 	add.w	r0, r3, #24
90003b4a:	f107 020a 	add.w	r2, r7, #10
90003b4e:	2302      	movs	r3, #2
90003b50:	f44f 61c4 	mov.w	r1, #1568	; 0x620
90003b54:	f000 ff4c 	bl	900049f0 <wm8994_write_reg>
90003b58:	4602      	mov	r2, r0
90003b5a:	68fb      	ldr	r3, [r7, #12]
90003b5c:	4413      	add	r3, r2
90003b5e:	60fb      	str	r3, [r7, #12]
      
      /* AIF ADC1 HPF enable, HPF cut = voice mode 1 fc=127Hz at fs=8kHz */
      tmp = 0x1800;
90003b60:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
90003b64:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC1_FILTERS, &tmp, 2);
90003b66:	687b      	ldr	r3, [r7, #4]
90003b68:	f103 0018 	add.w	r0, r3, #24
90003b6c:	f107 020a 	add.w	r2, r7, #10
90003b70:	2302      	movs	r3, #2
90003b72:	f44f 6182 	mov.w	r1, #1040	; 0x410
90003b76:	f000 ff3b 	bl	900049f0 <wm8994_write_reg>
90003b7a:	4602      	mov	r2, r0
90003b7c:	68fb      	ldr	r3, [r7, #12]
90003b7e:	4413      	add	r3, r2
90003b80:	60fb      	str	r3, [r7, #12]
      
      /* AIF ADC2 HPF enable, HPF cut = voice mode 1 fc=127Hz at fs=8kHz */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC2_FILTERS, &tmp, 2);
90003b82:	687b      	ldr	r3, [r7, #4]
90003b84:	f103 0018 	add.w	r0, r3, #24
90003b88:	f107 020a 	add.w	r2, r7, #10
90003b8c:	2302      	movs	r3, #2
90003b8e:	f240 4111 	movw	r1, #1041	; 0x411
90003b92:	f000 ff2d 	bl	900049f0 <wm8994_write_reg>
90003b96:	4602      	mov	r2, r0
90003b98:	68fb      	ldr	r3, [r7, #12]
90003b9a:	4413      	add	r3, r2
90003b9c:	60fb      	str	r3, [r7, #12]
90003b9e:	e02c      	b.n	90003bfa <WM8994_Init+0xd9e>
    }    
    else /* ((pInit->InputDevice == WM8994_IN_LINE1) || (pInit->InputDevice == WM8994_IN_LINE2)) */
    {      
      /* Disable mute on IN1L, IN1L Volume = +0dB */
      tmp = 0x000B;
90003ba0:	230b      	movs	r3, #11
90003ba2:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_LEFT_LINE_IN12_VOL, &tmp, 2);
90003ba4:	687b      	ldr	r3, [r7, #4]
90003ba6:	f103 0018 	add.w	r0, r3, #24
90003baa:	f107 020a 	add.w	r2, r7, #10
90003bae:	2302      	movs	r3, #2
90003bb0:	2118      	movs	r1, #24
90003bb2:	f000 ff1d 	bl	900049f0 <wm8994_write_reg>
90003bb6:	4602      	mov	r2, r0
90003bb8:	68fb      	ldr	r3, [r7, #12]
90003bba:	4413      	add	r3, r2
90003bbc:	60fb      	str	r3, [r7, #12]
      
      /* Disable mute on IN1R, IN1R Volume = +0dB */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_RIGHT_LINE_IN12_VOL, &tmp, 2);
90003bbe:	687b      	ldr	r3, [r7, #4]
90003bc0:	f103 0018 	add.w	r0, r3, #24
90003bc4:	f107 020a 	add.w	r2, r7, #10
90003bc8:	2302      	movs	r3, #2
90003bca:	211a      	movs	r1, #26
90003bcc:	f000 ff10 	bl	900049f0 <wm8994_write_reg>
90003bd0:	4602      	mov	r2, r0
90003bd2:	68fb      	ldr	r3, [r7, #12]
90003bd4:	4413      	add	r3, r2
90003bd6:	60fb      	str	r3, [r7, #12]
      
      /* AIF ADC1 HPF enable, HPF cut = voice mode 1 fc=127Hz at fs=8kHz */
      tmp = 0x1800;
90003bd8:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
90003bdc:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC1_FILTERS, &tmp, 2);
90003bde:	687b      	ldr	r3, [r7, #4]
90003be0:	f103 0018 	add.w	r0, r3, #24
90003be4:	f107 020a 	add.w	r2, r7, #10
90003be8:	2302      	movs	r3, #2
90003bea:	f44f 6182 	mov.w	r1, #1040	; 0x410
90003bee:	f000 feff 	bl	900049f0 <wm8994_write_reg>
90003bf2:	4602      	mov	r2, r0
90003bf4:	68fb      	ldr	r3, [r7, #12]
90003bf6:	4413      	add	r3, r2
90003bf8:	60fb      	str	r3, [r7, #12]
    }
    /* Volume Control */
    ret += WM8994_SetVolume(pObj, VOLUME_INPUT, (uint8_t)pInit->Volume); 
90003bfa:	683b      	ldr	r3, [r7, #0]
90003bfc:	691b      	ldr	r3, [r3, #16]
90003bfe:	b2db      	uxtb	r3, r3
90003c00:	461a      	mov	r2, r3
90003c02:	2100      	movs	r1, #0
90003c04:	6878      	ldr	r0, [r7, #4]
90003c06:	f000 f8e5 	bl	90003dd4 <WM8994_SetVolume>
90003c0a:	4602      	mov	r2, r0
90003c0c:	68fb      	ldr	r3, [r7, #12]
90003c0e:	4413      	add	r3, r2
90003c10:	60fb      	str	r3, [r7, #12]
  }
  
  if(ret != WM8994_OK)
90003c12:	68fb      	ldr	r3, [r7, #12]
90003c14:	2b00      	cmp	r3, #0
90003c16:	d002      	beq.n	90003c1e <WM8994_Init+0xdc2>
  {
    ret = WM8994_ERROR;
90003c18:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90003c1c:	60fb      	str	r3, [r7, #12]
  }
  
  return ret;
90003c1e:	68fb      	ldr	r3, [r7, #12]
}
90003c20:	4618      	mov	r0, r3
90003c22:	3710      	adds	r7, #16
90003c24:	46bd      	mov	sp, r7
90003c26:	bd80      	pop	{r7, pc}

90003c28 <WM8994_DeInit>:
  * @brief  Deinitializes the audio codec.
  * @param  pObj pointer to component object
  * @retval Component status
  */
int32_t WM8994_DeInit(WM8994_Object_t *pObj)
{
90003c28:	b580      	push	{r7, lr}
90003c2a:	b082      	sub	sp, #8
90003c2c:	af00      	add	r7, sp, #0
90003c2e:	6078      	str	r0, [r7, #4]
  /* De-Initialize Audio Codec interface */
  return WM8994_Stop(pObj, WM8994_PDWN_HW);
90003c30:	2100      	movs	r1, #0
90003c32:	6878      	ldr	r0, [r7, #4]
90003c34:	f000 f861 	bl	90003cfa <WM8994_Stop>
90003c38:	4603      	mov	r3, r0
}
90003c3a:	4618      	mov	r0, r3
90003c3c:	3708      	adds	r7, #8
90003c3e:	46bd      	mov	sp, r7
90003c40:	bd80      	pop	{r7, pc}

90003c42 <WM8994_ReadID>:
  * @param  pObj pointer to component object
  * @param  Id component ID
  * @retval Component status 
  */
int32_t WM8994_ReadID(WM8994_Object_t *pObj, uint32_t *Id)
{
90003c42:	b580      	push	{r7, lr}
90003c44:	b084      	sub	sp, #16
90003c46:	af00      	add	r7, sp, #0
90003c48:	6078      	str	r0, [r7, #4]
90003c4a:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint16_t wm8994_id;
  
  /* Initialize the Control interface of the Audio Codec */
  pObj->IO.Init();
90003c4c:	687b      	ldr	r3, [r7, #4]
90003c4e:	681b      	ldr	r3, [r3, #0]
90003c50:	4798      	blx	r3
  /* Get ID from component */
  ret = wm8994_sw_reset_r(&pObj->Ctx, &wm8994_id);
90003c52:	687b      	ldr	r3, [r7, #4]
90003c54:	3318      	adds	r3, #24
90003c56:	f107 020a 	add.w	r2, r7, #10
90003c5a:	4611      	mov	r1, r2
90003c5c:	4618      	mov	r0, r3
90003c5e:	f000 ff00 	bl	90004a62 <wm8994_sw_reset_r>
90003c62:	60f8      	str	r0, [r7, #12]
  
  *Id = wm8994_id;
90003c64:	897b      	ldrh	r3, [r7, #10]
90003c66:	461a      	mov	r2, r3
90003c68:	683b      	ldr	r3, [r7, #0]
90003c6a:	601a      	str	r2, [r3, #0]
  
  return ret;
90003c6c:	68fb      	ldr	r3, [r7, #12]
}
90003c6e:	4618      	mov	r0, r3
90003c70:	3710      	adds	r7, #16
90003c72:	46bd      	mov	sp, r7
90003c74:	bd80      	pop	{r7, pc}

90003c76 <WM8994_Play>:
  * @note For this codec no Play options are required.
  * @param  pObj pointer to component object  
  * @retval Component status
  */
int32_t WM8994_Play(WM8994_Object_t *pObj)
{ 
90003c76:	b580      	push	{r7, lr}
90003c78:	b082      	sub	sp, #8
90003c7a:	af00      	add	r7, sp, #0
90003c7c:	6078      	str	r0, [r7, #4]
  /* Resumes the audio file playing */  
  /* Unmute the output first */
  return WM8994_SetMute(pObj, WM8994_MUTE_OFF);
90003c7e:	2100      	movs	r1, #0
90003c80:	6878      	ldr	r0, [r7, #4]
90003c82:	f000 f9d3 	bl	9000402c <WM8994_SetMute>
90003c86:	4603      	mov	r3, r0
}
90003c88:	4618      	mov	r0, r3
90003c8a:	3708      	adds	r7, #8
90003c8c:	46bd      	mov	sp, r7
90003c8e:	bd80      	pop	{r7, pc}

90003c90 <WM8994_Pause>:
  * @brief Pauses playing on the audio codec.
  * @param  pObj pointer to component object
  * @retval Component status
  */
int32_t WM8994_Pause(WM8994_Object_t *pObj)
{
90003c90:	b580      	push	{r7, lr}
90003c92:	b084      	sub	sp, #16
90003c94:	af00      	add	r7, sp, #0
90003c96:	6078      	str	r0, [r7, #4]
  int32_t ret;
  uint16_t tmp = 0x0001;
90003c98:	2301      	movs	r3, #1
90003c9a:	817b      	strh	r3, [r7, #10]
  
  /* Pause the audio file playing */
  /* Mute the output first */
  if(WM8994_SetMute(pObj, WM8994_MUTE_ON) != WM8994_OK)
90003c9c:	2101      	movs	r1, #1
90003c9e:	6878      	ldr	r0, [r7, #4]
90003ca0:	f000 f9c4 	bl	9000402c <WM8994_SetMute>
90003ca4:	4603      	mov	r3, r0
90003ca6:	2b00      	cmp	r3, #0
90003ca8:	d003      	beq.n	90003cb2 <WM8994_Pause+0x22>
  {
    ret  = WM8994_ERROR;
90003caa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90003cae:	60fb      	str	r3, [r7, #12]
90003cb0:	e011      	b.n	90003cd6 <WM8994_Pause+0x46>
  }/* Put the Codec in Power save mode */
  else if(wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_2, &tmp, 2) != WM8994_OK)
90003cb2:	687b      	ldr	r3, [r7, #4]
90003cb4:	f103 0018 	add.w	r0, r3, #24
90003cb8:	f107 020a 	add.w	r2, r7, #10
90003cbc:	2302      	movs	r3, #2
90003cbe:	2102      	movs	r1, #2
90003cc0:	f000 fe96 	bl	900049f0 <wm8994_write_reg>
90003cc4:	4603      	mov	r3, r0
90003cc6:	2b00      	cmp	r3, #0
90003cc8:	d003      	beq.n	90003cd2 <WM8994_Pause+0x42>
  {
    ret  = WM8994_ERROR;
90003cca:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90003cce:	60fb      	str	r3, [r7, #12]
90003cd0:	e001      	b.n	90003cd6 <WM8994_Pause+0x46>
  }
  else
  {
    ret = WM8994_OK;
90003cd2:	2300      	movs	r3, #0
90003cd4:	60fb      	str	r3, [r7, #12]
  }
  
  return ret;
90003cd6:	68fb      	ldr	r3, [r7, #12]
}
90003cd8:	4618      	mov	r0, r3
90003cda:	3710      	adds	r7, #16
90003cdc:	46bd      	mov	sp, r7
90003cde:	bd80      	pop	{r7, pc}

90003ce0 <WM8994_Resume>:
  * @brief Resumes playing on the audio codec.
  * @param  pObj pointer to component object 
  * @retval Component status
  */
int32_t WM8994_Resume(WM8994_Object_t *pObj)
{  
90003ce0:	b580      	push	{r7, lr}
90003ce2:	b082      	sub	sp, #8
90003ce4:	af00      	add	r7, sp, #0
90003ce6:	6078      	str	r0, [r7, #4]
  /* Resumes the audio file playing */  
  /* Unmute the output first */
  return WM8994_SetMute(pObj, WM8994_MUTE_OFF);
90003ce8:	2100      	movs	r1, #0
90003cea:	6878      	ldr	r0, [r7, #4]
90003cec:	f000 f99e 	bl	9000402c <WM8994_SetMute>
90003cf0:	4603      	mov	r3, r0
}
90003cf2:	4618      	mov	r0, r3
90003cf4:	3708      	adds	r7, #8
90003cf6:	46bd      	mov	sp, r7
90003cf8:	bd80      	pop	{r7, pc}

90003cfa <WM8994_Stop>:
  *                           (user should re-Initialize the codec in order to 
  *                            play again the audio stream).
  * @retval 0 if correct communication, else wrong communication
  */
int32_t WM8994_Stop(WM8994_Object_t *pObj, uint32_t CodecPdwnMode)
{
90003cfa:	b580      	push	{r7, lr}
90003cfc:	b084      	sub	sp, #16
90003cfe:	af00      	add	r7, sp, #0
90003d00:	6078      	str	r0, [r7, #4]
90003d02:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint16_t tmp;
  
  /* Mute the output first */
  ret = WM8994_SetMute(pObj, WM8994_MUTE_ON);
90003d04:	2101      	movs	r1, #1
90003d06:	6878      	ldr	r0, [r7, #4]
90003d08:	f000 f990 	bl	9000402c <WM8994_SetMute>
90003d0c:	60f8      	str	r0, [r7, #12]
  
  if (CodecPdwnMode == WM8994_PDWN_SW)
90003d0e:	683b      	ldr	r3, [r7, #0]
90003d10:	2b01      	cmp	r3, #1
90003d12:	d054      	beq.n	90003dbe <WM8994_Stop+0xc4>
  {
    /* Only output mute required*/
  }
  else /* WM8994_PDWN_HW */
  {
    tmp = 0x0200;
90003d14:	f44f 7300 	mov.w	r3, #512	; 0x200
90003d18:	817b      	strh	r3, [r7, #10]
    /* Mute the AIF1 Timeslot 0 DAC1 path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_FILTER1, &tmp, 2);
90003d1a:	687b      	ldr	r3, [r7, #4]
90003d1c:	f103 0018 	add.w	r0, r3, #24
90003d20:	f107 020a 	add.w	r2, r7, #10
90003d24:	2302      	movs	r3, #2
90003d26:	f44f 6184 	mov.w	r1, #1056	; 0x420
90003d2a:	f000 fe61 	bl	900049f0 <wm8994_write_reg>
90003d2e:	4602      	mov	r2, r0
90003d30:	68fb      	ldr	r3, [r7, #12]
90003d32:	4413      	add	r3, r2
90003d34:	60fb      	str	r3, [r7, #12]
    
    /* Mute the AIF1 Timeslot 1 DAC2 path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_FILTER1, &tmp, 2);
90003d36:	687b      	ldr	r3, [r7, #4]
90003d38:	f103 0018 	add.w	r0, r3, #24
90003d3c:	f107 020a 	add.w	r2, r7, #10
90003d40:	2302      	movs	r3, #2
90003d42:	f240 4122 	movw	r1, #1058	; 0x422
90003d46:	f000 fe53 	bl	900049f0 <wm8994_write_reg>
90003d4a:	4602      	mov	r2, r0
90003d4c:	68fb      	ldr	r3, [r7, #12]
90003d4e:	4413      	add	r3, r2
90003d50:	60fb      	str	r3, [r7, #12]
    
    tmp = 0x0000;
90003d52:	2300      	movs	r3, #0
90003d54:	817b      	strh	r3, [r7, #10]
    /* Disable DAC1L_TO_HPOUT1L */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_OUTPUT_MIXER_1, &tmp, 2);
90003d56:	687b      	ldr	r3, [r7, #4]
90003d58:	f103 0018 	add.w	r0, r3, #24
90003d5c:	f107 020a 	add.w	r2, r7, #10
90003d60:	2302      	movs	r3, #2
90003d62:	212d      	movs	r1, #45	; 0x2d
90003d64:	f000 fe44 	bl	900049f0 <wm8994_write_reg>
90003d68:	4602      	mov	r2, r0
90003d6a:	68fb      	ldr	r3, [r7, #12]
90003d6c:	4413      	add	r3, r2
90003d6e:	60fb      	str	r3, [r7, #12]
    
    /* Disable DAC1R_TO_HPOUT1R */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_OUTPUT_MIXER_2, &tmp, 2);
90003d70:	687b      	ldr	r3, [r7, #4]
90003d72:	f103 0018 	add.w	r0, r3, #24
90003d76:	f107 020a 	add.w	r2, r7, #10
90003d7a:	2302      	movs	r3, #2
90003d7c:	212e      	movs	r1, #46	; 0x2e
90003d7e:	f000 fe37 	bl	900049f0 <wm8994_write_reg>
90003d82:	4602      	mov	r2, r0
90003d84:	68fb      	ldr	r3, [r7, #12]
90003d86:	4413      	add	r3, r2
90003d88:	60fb      	str	r3, [r7, #12]
    
    /* Disable DAC1 and DAC2 */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_5, &tmp, 2);
90003d8a:	687b      	ldr	r3, [r7, #4]
90003d8c:	f103 0018 	add.w	r0, r3, #24
90003d90:	f107 020a 	add.w	r2, r7, #10
90003d94:	2302      	movs	r3, #2
90003d96:	2105      	movs	r1, #5
90003d98:	f000 fe2a 	bl	900049f0 <wm8994_write_reg>
90003d9c:	4602      	mov	r2, r0
90003d9e:	68fb      	ldr	r3, [r7, #12]
90003da0:	4413      	add	r3, r2
90003da2:	60fb      	str	r3, [r7, #12]
    
    /* Reset Codec by writing in 0x0000 address register */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_SW_RESET, &tmp, 2);
90003da4:	687b      	ldr	r3, [r7, #4]
90003da6:	f103 0018 	add.w	r0, r3, #24
90003daa:	f107 020a 	add.w	r2, r7, #10
90003dae:	2302      	movs	r3, #2
90003db0:	2100      	movs	r1, #0
90003db2:	f000 fe1d 	bl	900049f0 <wm8994_write_reg>
90003db6:	4602      	mov	r2, r0
90003db8:	68fb      	ldr	r3, [r7, #12]
90003dba:	4413      	add	r3, r2
90003dbc:	60fb      	str	r3, [r7, #12]
  }
  
  if(ret != WM8994_OK)
90003dbe:	68fb      	ldr	r3, [r7, #12]
90003dc0:	2b00      	cmp	r3, #0
90003dc2:	d002      	beq.n	90003dca <WM8994_Stop+0xd0>
  {
    ret = WM8994_ERROR;
90003dc4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90003dc8:	60fb      	str	r3, [r7, #12]
  }
  
  return ret;
90003dca:	68fb      	ldr	r3, [r7, #12]
}
90003dcc:	4618      	mov	r0, r3
90003dce:	3710      	adds	r7, #16
90003dd0:	46bd      	mov	sp, r7
90003dd2:	bd80      	pop	{r7, pc}

90003dd4 <WM8994_SetVolume>:
  * @param  Volume  a byte value from 0 to 63 for output and from 0 to 240 for input
  *         (refer to codec registers description for more details).
  * @retval Component status
  */
int32_t WM8994_SetVolume(WM8994_Object_t *pObj, uint32_t InputOutput, uint8_t Volume)
{
90003dd4:	b580      	push	{r7, lr}
90003dd6:	b086      	sub	sp, #24
90003dd8:	af00      	add	r7, sp, #0
90003dda:	60f8      	str	r0, [r7, #12]
90003ddc:	60b9      	str	r1, [r7, #8]
90003dde:	4613      	mov	r3, r2
90003de0:	71fb      	strb	r3, [r7, #7]
  int32_t ret;  
  uint16_t tmp;
  
  /* Output volume */
  if (InputOutput == VOLUME_OUTPUT)
90003de2:	68bb      	ldr	r3, [r7, #8]
90003de4:	2b01      	cmp	r3, #1
90003de6:	f040 8089 	bne.w	90003efc <WM8994_SetVolume+0x128>
  {    
    if(Volume > 0x3EU)
90003dea:	79fb      	ldrb	r3, [r7, #7]
90003dec:	2b3e      	cmp	r3, #62	; 0x3e
90003dee:	d93c      	bls.n	90003e6a <WM8994_SetVolume+0x96>
    {
      /* Unmute audio codec */
      ret = WM8994_SetMute(pObj, WM8994_MUTE_OFF);
90003df0:	2100      	movs	r1, #0
90003df2:	68f8      	ldr	r0, [r7, #12]
90003df4:	f000 f91a 	bl	9000402c <WM8994_SetMute>
90003df8:	6178      	str	r0, [r7, #20]
      tmp = 0x3FU | 0x140U;
90003dfa:	f240 137f 	movw	r3, #383	; 0x17f
90003dfe:	827b      	strh	r3, [r7, #18]
      
      /* Left Headphone Volume */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_LEFT_OUTPUT_VOL, &tmp, 2);
90003e00:	68fb      	ldr	r3, [r7, #12]
90003e02:	f103 0018 	add.w	r0, r3, #24
90003e06:	f107 0212 	add.w	r2, r7, #18
90003e0a:	2302      	movs	r3, #2
90003e0c:	211c      	movs	r1, #28
90003e0e:	f000 fdef 	bl	900049f0 <wm8994_write_reg>
90003e12:	4602      	mov	r2, r0
90003e14:	697b      	ldr	r3, [r7, #20]
90003e16:	4413      	add	r3, r2
90003e18:	617b      	str	r3, [r7, #20]
      
      /* Right Headphone Volume */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_RIGHT_OUTPUT_VOL, &tmp, 2);
90003e1a:	68fb      	ldr	r3, [r7, #12]
90003e1c:	f103 0018 	add.w	r0, r3, #24
90003e20:	f107 0212 	add.w	r2, r7, #18
90003e24:	2302      	movs	r3, #2
90003e26:	211d      	movs	r1, #29
90003e28:	f000 fde2 	bl	900049f0 <wm8994_write_reg>
90003e2c:	4602      	mov	r2, r0
90003e2e:	697b      	ldr	r3, [r7, #20]
90003e30:	4413      	add	r3, r2
90003e32:	617b      	str	r3, [r7, #20]
      
      /* Left Speaker Volume */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_SPK_LEFT_VOL, &tmp, 2);
90003e34:	68fb      	ldr	r3, [r7, #12]
90003e36:	f103 0018 	add.w	r0, r3, #24
90003e3a:	f107 0212 	add.w	r2, r7, #18
90003e3e:	2302      	movs	r3, #2
90003e40:	2126      	movs	r1, #38	; 0x26
90003e42:	f000 fdd5 	bl	900049f0 <wm8994_write_reg>
90003e46:	4602      	mov	r2, r0
90003e48:	697b      	ldr	r3, [r7, #20]
90003e4a:	4413      	add	r3, r2
90003e4c:	617b      	str	r3, [r7, #20]
      
      /* Right Speaker Volume */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_SPK_RIGHT_VOL, &tmp, 2);
90003e4e:	68fb      	ldr	r3, [r7, #12]
90003e50:	f103 0018 	add.w	r0, r3, #24
90003e54:	f107 0212 	add.w	r2, r7, #18
90003e58:	2302      	movs	r3, #2
90003e5a:	2127      	movs	r1, #39	; 0x27
90003e5c:	f000 fdc8 	bl	900049f0 <wm8994_write_reg>
90003e60:	4602      	mov	r2, r0
90003e62:	697b      	ldr	r3, [r7, #20]
90003e64:	4413      	add	r3, r2
90003e66:	617b      	str	r3, [r7, #20]
90003e68:	e083      	b.n	90003f72 <WM8994_SetVolume+0x19e>
    }
    else if (Volume == 0U)
90003e6a:	79fb      	ldrb	r3, [r7, #7]
90003e6c:	2b00      	cmp	r3, #0
90003e6e:	d105      	bne.n	90003e7c <WM8994_SetVolume+0xa8>
    {
      /* Mute audio codec */
      ret = WM8994_SetMute(pObj, WM8994_MUTE_ON);
90003e70:	2101      	movs	r1, #1
90003e72:	68f8      	ldr	r0, [r7, #12]
90003e74:	f000 f8da 	bl	9000402c <WM8994_SetMute>
90003e78:	6178      	str	r0, [r7, #20]
90003e7a:	e07a      	b.n	90003f72 <WM8994_SetVolume+0x19e>
    }
    else
    {
      /* Unmute audio codec */
      ret = WM8994_SetMute(pObj, WM8994_MUTE_OFF);
90003e7c:	2100      	movs	r1, #0
90003e7e:	68f8      	ldr	r0, [r7, #12]
90003e80:	f000 f8d4 	bl	9000402c <WM8994_SetMute>
90003e84:	6178      	str	r0, [r7, #20]
      
      tmp = Volume | 0x140U;
90003e86:	79fb      	ldrb	r3, [r7, #7]
90003e88:	b29b      	uxth	r3, r3
90003e8a:	f443 73a0 	orr.w	r3, r3, #320	; 0x140
90003e8e:	b29b      	uxth	r3, r3
90003e90:	827b      	strh	r3, [r7, #18]
      
      /* Left Headphone Volume */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_LEFT_OUTPUT_VOL, &tmp, 2);
90003e92:	68fb      	ldr	r3, [r7, #12]
90003e94:	f103 0018 	add.w	r0, r3, #24
90003e98:	f107 0212 	add.w	r2, r7, #18
90003e9c:	2302      	movs	r3, #2
90003e9e:	211c      	movs	r1, #28
90003ea0:	f000 fda6 	bl	900049f0 <wm8994_write_reg>
90003ea4:	4602      	mov	r2, r0
90003ea6:	697b      	ldr	r3, [r7, #20]
90003ea8:	4413      	add	r3, r2
90003eaa:	617b      	str	r3, [r7, #20]
      
      /* Right Headphone Volume */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_RIGHT_OUTPUT_VOL, &tmp, 2);
90003eac:	68fb      	ldr	r3, [r7, #12]
90003eae:	f103 0018 	add.w	r0, r3, #24
90003eb2:	f107 0212 	add.w	r2, r7, #18
90003eb6:	2302      	movs	r3, #2
90003eb8:	211d      	movs	r1, #29
90003eba:	f000 fd99 	bl	900049f0 <wm8994_write_reg>
90003ebe:	4602      	mov	r2, r0
90003ec0:	697b      	ldr	r3, [r7, #20]
90003ec2:	4413      	add	r3, r2
90003ec4:	617b      	str	r3, [r7, #20]
      
      /* Left Speaker Volume */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_SPK_LEFT_VOL, &tmp, 2);
90003ec6:	68fb      	ldr	r3, [r7, #12]
90003ec8:	f103 0018 	add.w	r0, r3, #24
90003ecc:	f107 0212 	add.w	r2, r7, #18
90003ed0:	2302      	movs	r3, #2
90003ed2:	2126      	movs	r1, #38	; 0x26
90003ed4:	f000 fd8c 	bl	900049f0 <wm8994_write_reg>
90003ed8:	4602      	mov	r2, r0
90003eda:	697b      	ldr	r3, [r7, #20]
90003edc:	4413      	add	r3, r2
90003ede:	617b      	str	r3, [r7, #20]
      
      /* Right Speaker Volume */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_SPK_RIGHT_VOL, &tmp, 2);      
90003ee0:	68fb      	ldr	r3, [r7, #12]
90003ee2:	f103 0018 	add.w	r0, r3, #24
90003ee6:	f107 0212 	add.w	r2, r7, #18
90003eea:	2302      	movs	r3, #2
90003eec:	2127      	movs	r1, #39	; 0x27
90003eee:	f000 fd7f 	bl	900049f0 <wm8994_write_reg>
90003ef2:	4602      	mov	r2, r0
90003ef4:	697b      	ldr	r3, [r7, #20]
90003ef6:	4413      	add	r3, r2
90003ef8:	617b      	str	r3, [r7, #20]
90003efa:	e03a      	b.n	90003f72 <WM8994_SetVolume+0x19e>
    }
  }
  else /* Input volume: VOLUME_INPUT */
  {
    tmp = Volume | 0x100U;
90003efc:	79fb      	ldrb	r3, [r7, #7]
90003efe:	b29b      	uxth	r3, r3
90003f00:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90003f04:	b29b      	uxth	r3, r3
90003f06:	827b      	strh	r3, [r7, #18]
    
    /* Left AIF1 ADC1 volume */
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC1_LEFT_VOL, &tmp, 2); 
90003f08:	68fb      	ldr	r3, [r7, #12]
90003f0a:	f103 0018 	add.w	r0, r3, #24
90003f0e:	f107 0212 	add.w	r2, r7, #18
90003f12:	2302      	movs	r3, #2
90003f14:	f44f 6180 	mov.w	r1, #1024	; 0x400
90003f18:	f000 fd6a 	bl	900049f0 <wm8994_write_reg>
90003f1c:	6178      	str	r0, [r7, #20]
    
    /* Right AIF1 ADC1 volume */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC1_RIGHT_VOL, &tmp, 2); 
90003f1e:	68fb      	ldr	r3, [r7, #12]
90003f20:	f103 0018 	add.w	r0, r3, #24
90003f24:	f107 0212 	add.w	r2, r7, #18
90003f28:	2302      	movs	r3, #2
90003f2a:	f240 4101 	movw	r1, #1025	; 0x401
90003f2e:	f000 fd5f 	bl	900049f0 <wm8994_write_reg>
90003f32:	4602      	mov	r2, r0
90003f34:	697b      	ldr	r3, [r7, #20]
90003f36:	4413      	add	r3, r2
90003f38:	617b      	str	r3, [r7, #20]
    
    /* Left AIF1 ADC2 volume */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC2_LEFT_VOL, &tmp, 2); 
90003f3a:	68fb      	ldr	r3, [r7, #12]
90003f3c:	f103 0018 	add.w	r0, r3, #24
90003f40:	f107 0212 	add.w	r2, r7, #18
90003f44:	2302      	movs	r3, #2
90003f46:	f240 4104 	movw	r1, #1028	; 0x404
90003f4a:	f000 fd51 	bl	900049f0 <wm8994_write_reg>
90003f4e:	4602      	mov	r2, r0
90003f50:	697b      	ldr	r3, [r7, #20]
90003f52:	4413      	add	r3, r2
90003f54:	617b      	str	r3, [r7, #20]
    
    /* Right AIF1 ADC2 volume */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_ADC2_RIGHT_VOL, &tmp, 2); 
90003f56:	68fb      	ldr	r3, [r7, #12]
90003f58:	f103 0018 	add.w	r0, r3, #24
90003f5c:	f107 0212 	add.w	r2, r7, #18
90003f60:	2302      	movs	r3, #2
90003f62:	f240 4105 	movw	r1, #1029	; 0x405
90003f66:	f000 fd43 	bl	900049f0 <wm8994_write_reg>
90003f6a:	4602      	mov	r2, r0
90003f6c:	697b      	ldr	r3, [r7, #20]
90003f6e:	4413      	add	r3, r2
90003f70:	617b      	str	r3, [r7, #20]
  }
  
  if(ret != WM8994_OK)
90003f72:	697b      	ldr	r3, [r7, #20]
90003f74:	2b00      	cmp	r3, #0
90003f76:	d002      	beq.n	90003f7e <WM8994_SetVolume+0x1aa>
  {
    ret = WM8994_ERROR;
90003f78:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90003f7c:	617b      	str	r3, [r7, #20]
  }
  
  return ret;
90003f7e:	697b      	ldr	r3, [r7, #20]
}
90003f80:	4618      	mov	r0, r3
90003f82:	3718      	adds	r7, #24
90003f84:	46bd      	mov	sp, r7
90003f86:	bd80      	pop	{r7, pc}

90003f88 <WM8994_GetVolume>:
  * @param  InputOutput Input or Output volume
  * @param  Volume audio volume 
  * @retval Component status
  */
int32_t WM8994_GetVolume(WM8994_Object_t *pObj, uint32_t InputOutput, uint8_t *Volume)
{
90003f88:	b580      	push	{r7, lr}
90003f8a:	b086      	sub	sp, #24
90003f8c:	af00      	add	r7, sp, #0
90003f8e:	60f8      	str	r0, [r7, #12]
90003f90:	60b9      	str	r1, [r7, #8]
90003f92:	607a      	str	r2, [r7, #4]
  int32_t ret = WM8994_OK;  
90003f94:	2300      	movs	r3, #0
90003f96:	617b      	str	r3, [r7, #20]
  uint16_t invertedvol;
  
  /* Output volume */
  if (InputOutput == VOLUME_OUTPUT)
90003f98:	68bb      	ldr	r3, [r7, #8]
90003f9a:	2b01      	cmp	r3, #1
90003f9c:	d11e      	bne.n	90003fdc <WM8994_GetVolume+0x54>
  {
    if(wm8994_lo_hpout1l_vol_r(&pObj->Ctx, &invertedvol) != WM8994_OK)
90003f9e:	68fb      	ldr	r3, [r7, #12]
90003fa0:	3318      	adds	r3, #24
90003fa2:	f107 0212 	add.w	r2, r7, #18
90003fa6:	4611      	mov	r1, r2
90003fa8:	4618      	mov	r0, r3
90003faa:	f000 fd6a 	bl	90004a82 <wm8994_lo_hpout1l_vol_r>
90003fae:	4603      	mov	r3, r0
90003fb0:	2b00      	cmp	r3, #0
90003fb2:	d003      	beq.n	90003fbc <WM8994_GetVolume+0x34>
    {
      ret = WM8994_ERROR;
90003fb4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90003fb8:	617b      	str	r3, [r7, #20]
90003fba:	e02d      	b.n	90004018 <WM8994_GetVolume+0x90>
    }
    else
    {
      *Volume = VOLUME_OUT_INVERT(invertedvol);
90003fbc:	8a7b      	ldrh	r3, [r7, #18]
90003fbe:	461a      	mov	r2, r3
90003fc0:	2364      	movs	r3, #100	; 0x64
90003fc2:	fb03 f302 	mul.w	r3, r3, r2
90003fc6:	4a17      	ldr	r2, [pc, #92]	; (90004024 <WM8994_GetVolume+0x9c>)
90003fc8:	fb82 1203 	smull	r1, r2, r2, r3
90003fcc:	441a      	add	r2, r3
90003fce:	1152      	asrs	r2, r2, #5
90003fd0:	17db      	asrs	r3, r3, #31
90003fd2:	1ad3      	subs	r3, r2, r3
90003fd4:	b2da      	uxtb	r2, r3
90003fd6:	687b      	ldr	r3, [r7, #4]
90003fd8:	701a      	strb	r2, [r3, #0]
90003fda:	e01d      	b.n	90004018 <WM8994_GetVolume+0x90>
    }
  }
  else /* Input volume: VOLUME_INPUT */
  {
    if(wm8994_aif1_adc1_left_vol_adc1l_r(&pObj->Ctx, &invertedvol) != WM8994_OK)
90003fdc:	68fb      	ldr	r3, [r7, #12]
90003fde:	3318      	adds	r3, #24
90003fe0:	f107 0212 	add.w	r2, r7, #18
90003fe4:	4611      	mov	r1, r2
90003fe6:	4618      	mov	r0, r3
90003fe8:	f000 fe60 	bl	90004cac <wm8994_aif1_adc1_left_vol_adc1l_r>
90003fec:	4603      	mov	r3, r0
90003fee:	2b00      	cmp	r3, #0
90003ff0:	d003      	beq.n	90003ffa <WM8994_GetVolume+0x72>
    {
      ret = WM8994_ERROR;
90003ff2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90003ff6:	617b      	str	r3, [r7, #20]
90003ff8:	e00e      	b.n	90004018 <WM8994_GetVolume+0x90>
    }
    else
    {
      *Volume = VOLUME_IN_INVERT(invertedvol);
90003ffa:	8a7b      	ldrh	r3, [r7, #18]
90003ffc:	461a      	mov	r2, r3
90003ffe:	2364      	movs	r3, #100	; 0x64
90004000:	fb03 f302 	mul.w	r3, r3, r2
90004004:	4a08      	ldr	r2, [pc, #32]	; (90004028 <WM8994_GetVolume+0xa0>)
90004006:	fb82 1203 	smull	r1, r2, r2, r3
9000400a:	441a      	add	r2, r3
9000400c:	11d2      	asrs	r2, r2, #7
9000400e:	17db      	asrs	r3, r3, #31
90004010:	1ad3      	subs	r3, r2, r3
90004012:	b2da      	uxtb	r2, r3
90004014:	687b      	ldr	r3, [r7, #4]
90004016:	701a      	strb	r2, [r3, #0]
    }
  }
  
  return ret;
90004018:	697b      	ldr	r3, [r7, #20]
}
9000401a:	4618      	mov	r0, r3
9000401c:	3718      	adds	r7, #24
9000401e:	46bd      	mov	sp, r7
90004020:	bd80      	pop	{r7, pc}
90004022:	bf00      	nop
90004024:	82082083 	.word	0x82082083
90004028:	891ac73b 	.word	0x891ac73b

9000402c <WM8994_SetMute>:
  * @param Cmd  WM8994_MUTE_ON to enable the mute or WM8994_MUTE_OFF to disable the
  *             mute mode.
  * @retval 0 if correct communication, else wrong communication
  */
int32_t WM8994_SetMute(WM8994_Object_t *pObj, uint32_t Cmd)
{
9000402c:	b580      	push	{r7, lr}
9000402e:	b084      	sub	sp, #16
90004030:	af00      	add	r7, sp, #0
90004032:	6078      	str	r0, [r7, #4]
90004034:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint16_t tmp;
  
  /* Set the Mute mode */
  if(Cmd == WM8994_MUTE_ON)
90004036:	683b      	ldr	r3, [r7, #0]
90004038:	2b01      	cmp	r3, #1
9000403a:	d11c      	bne.n	90004076 <WM8994_SetMute+0x4a>
  { 
    tmp = 0x0200;
9000403c:	f44f 7300 	mov.w	r3, #512	; 0x200
90004040:	817b      	strh	r3, [r7, #10]
    /* Soft Mute the AIF1 Timeslot 0 DAC1 path L&R */
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_FILTER1, &tmp, 2);
90004042:	687b      	ldr	r3, [r7, #4]
90004044:	f103 0018 	add.w	r0, r3, #24
90004048:	f107 020a 	add.w	r2, r7, #10
9000404c:	2302      	movs	r3, #2
9000404e:	f44f 6184 	mov.w	r1, #1056	; 0x420
90004052:	f000 fccd 	bl	900049f0 <wm8994_write_reg>
90004056:	60f8      	str	r0, [r7, #12]
    
    /* Soft Mute the AIF1 Timeslot 1 DAC2 path L&R */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_FILTER1, &tmp, 2);
90004058:	687b      	ldr	r3, [r7, #4]
9000405a:	f103 0018 	add.w	r0, r3, #24
9000405e:	f107 020a 	add.w	r2, r7, #10
90004062:	2302      	movs	r3, #2
90004064:	f240 4122 	movw	r1, #1058	; 0x422
90004068:	f000 fcc2 	bl	900049f0 <wm8994_write_reg>
9000406c:	4602      	mov	r2, r0
9000406e:	68fb      	ldr	r3, [r7, #12]
90004070:	4413      	add	r3, r2
90004072:	60fb      	str	r3, [r7, #12]
90004074:	e01a      	b.n	900040ac <WM8994_SetMute+0x80>
  }
  else /* WM8994_MUTE_OFF Disable the Mute */
  {
    tmp = 0x0010;
90004076:	2310      	movs	r3, #16
90004078:	817b      	strh	r3, [r7, #10]
    /* Unmute the AIF1 Timeslot 0 DAC1 path L&R */
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_FILTER1, &tmp, 2);
9000407a:	687b      	ldr	r3, [r7, #4]
9000407c:	f103 0018 	add.w	r0, r3, #24
90004080:	f107 020a 	add.w	r2, r7, #10
90004084:	2302      	movs	r3, #2
90004086:	f44f 6184 	mov.w	r1, #1056	; 0x420
9000408a:	f000 fcb1 	bl	900049f0 <wm8994_write_reg>
9000408e:	60f8      	str	r0, [r7, #12]
    
    /* Unmute the AIF1 Timeslot 1 DAC2 path L&R */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_FILTER1, &tmp, 2);
90004090:	687b      	ldr	r3, [r7, #4]
90004092:	f103 0018 	add.w	r0, r3, #24
90004096:	f107 020a 	add.w	r2, r7, #10
9000409a:	2302      	movs	r3, #2
9000409c:	f240 4122 	movw	r1, #1058	; 0x422
900040a0:	f000 fca6 	bl	900049f0 <wm8994_write_reg>
900040a4:	4602      	mov	r2, r0
900040a6:	68fb      	ldr	r3, [r7, #12]
900040a8:	4413      	add	r3, r2
900040aa:	60fb      	str	r3, [r7, #12]
  }
  
  if(ret != WM8994_OK)
900040ac:	68fb      	ldr	r3, [r7, #12]
900040ae:	2b00      	cmp	r3, #0
900040b0:	d002      	beq.n	900040b8 <WM8994_SetMute+0x8c>
  {
    ret = WM8994_ERROR;
900040b2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900040b6:	60fb      	str	r3, [r7, #12]
  }
  
  return ret;
900040b8:	68fb      	ldr	r3, [r7, #12]
}
900040ba:	4618      	mov	r0, r3
900040bc:	3710      	adds	r7, #16
900040be:	46bd      	mov	sp, r7
900040c0:	bd80      	pop	{r7, pc}

900040c2 <WM8994_SetOutputMode>:
  * @param Output  specifies the audio output target: WM8994_OUT_SPEAKER,
  *         WM8994_OUT_HEADPHONE, WM8994_OUT_BOTH or WM8994_OUT_AUTO 
  * @retval 0 if correct communication, else wrong communication
  */
int32_t WM8994_SetOutputMode(WM8994_Object_t *pObj, uint32_t Output)
{
900040c2:	b580      	push	{r7, lr}
900040c4:	b084      	sub	sp, #16
900040c6:	af00      	add	r7, sp, #0
900040c8:	6078      	str	r0, [r7, #4]
900040ca:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint16_t tmp;
  
  if((Output == WM8994_OUT_HEADPHONE) || (Output == WM8994_OUT_AUTO))
900040cc:	683b      	ldr	r3, [r7, #0]
900040ce:	2b02      	cmp	r3, #2
900040d0:	d003      	beq.n	900040da <WM8994_SetOutputMode+0x18>
900040d2:	683b      	ldr	r3, [r7, #0]
900040d4:	2b04      	cmp	r3, #4
900040d6:	f040 809c 	bne.w	90004212 <WM8994_SetOutputMode+0x150>
  {
    /* Disable bias generator, Enable VMID, Enable SPKOUTL, Enable SPKOUTR */
    tmp = 0x0000;
900040da:	2300      	movs	r3, #0
900040dc:	817b      	strh	r3, [r7, #10]
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_1, &tmp, 2);
900040de:	687b      	ldr	r3, [r7, #4]
900040e0:	f103 0018 	add.w	r0, r3, #24
900040e4:	f107 020a 	add.w	r2, r7, #10
900040e8:	2302      	movs	r3, #2
900040ea:	2101      	movs	r1, #1
900040ec:	f000 fc80 	bl	900049f0 <wm8994_write_reg>
900040f0:	60f8      	str	r0, [r7, #12]
    
    /* Disable DAC1 (Left), Disable DAC1 (Right),
    Enable DAC2 (Left), Enable DAC2 (Right)*/
    tmp = 0x0303;
900040f2:	f240 3303 	movw	r3, #771	; 0x303
900040f6:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_5, &tmp, 2);
900040f8:	687b      	ldr	r3, [r7, #4]
900040fa:	f103 0018 	add.w	r0, r3, #24
900040fe:	f107 020a 	add.w	r2, r7, #10
90004102:	2302      	movs	r3, #2
90004104:	2105      	movs	r1, #5
90004106:	f000 fc73 	bl	900049f0 <wm8994_write_reg>
9000410a:	4602      	mov	r2, r0
9000410c:	68fb      	ldr	r3, [r7, #12]
9000410e:	4413      	add	r3, r2
90004110:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
    tmp = 0x0001;
90004112:	2301      	movs	r3, #1
90004114:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_LMR, &tmp, 2);
90004116:	687b      	ldr	r3, [r7, #4]
90004118:	f103 0018 	add.w	r0, r3, #24
9000411c:	f107 020a 	add.w	r2, r7, #10
90004120:	2302      	movs	r3, #2
90004122:	f240 6101 	movw	r1, #1537	; 0x601
90004126:	f000 fc63 	bl	900049f0 <wm8994_write_reg>
9000412a:	4602      	mov	r2, r0
9000412c:	68fb      	ldr	r3, [r7, #12]
9000412e:	4413      	add	r3, r2
90004130:	60fb      	str	r3, [r7, #12]
    
    /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_RMR, &tmp, 2);
90004132:	687b      	ldr	r3, [r7, #4]
90004134:	f103 0018 	add.w	r0, r3, #24
90004138:	f107 020a 	add.w	r2, r7, #10
9000413c:	2302      	movs	r3, #2
9000413e:	f240 6102 	movw	r1, #1538	; 0x602
90004142:	f000 fc55 	bl	900049f0 <wm8994_write_reg>
90004146:	4602      	mov	r2, r0
90004148:	68fb      	ldr	r3, [r7, #12]
9000414a:	4413      	add	r3, r2
9000414c:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
    tmp = 0x0000;
9000414e:	2300      	movs	r3, #0
90004150:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_LMR, &tmp, 2);
90004152:	687b      	ldr	r3, [r7, #4]
90004154:	f103 0018 	add.w	r0, r3, #24
90004158:	f107 020a 	add.w	r2, r7, #10
9000415c:	2302      	movs	r3, #2
9000415e:	f240 6104 	movw	r1, #1540	; 0x604
90004162:	f000 fc45 	bl	900049f0 <wm8994_write_reg>
90004166:	4602      	mov	r2, r0
90004168:	68fb      	ldr	r3, [r7, #12]
9000416a:	4413      	add	r3, r2
9000416c:	60fb      	str	r3, [r7, #12]
    
    /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_RMR, &tmp, 2);
9000416e:	687b      	ldr	r3, [r7, #4]
90004170:	f103 0018 	add.w	r0, r3, #24
90004174:	f107 020a 	add.w	r2, r7, #10
90004178:	2302      	movs	r3, #2
9000417a:	f240 6105 	movw	r1, #1541	; 0x605
9000417e:	f000 fc37 	bl	900049f0 <wm8994_write_reg>
90004182:	4602      	mov	r2, r0
90004184:	68fb      	ldr	r3, [r7, #12]
90004186:	4413      	add	r3, r2
90004188:	60fb      	str	r3, [r7, #12]
    
    /* Select DAC1 (Left) to Left Headphone Output PGA (HPOUT1LVOL) path */
    tmp = 0x0100;
9000418a:	f44f 7380 	mov.w	r3, #256	; 0x100
9000418e:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_OUTPUT_MIXER_1, &tmp, 2);
90004190:	687b      	ldr	r3, [r7, #4]
90004192:	f103 0018 	add.w	r0, r3, #24
90004196:	f107 020a 	add.w	r2, r7, #10
9000419a:	2302      	movs	r3, #2
9000419c:	212d      	movs	r1, #45	; 0x2d
9000419e:	f000 fc27 	bl	900049f0 <wm8994_write_reg>
900041a2:	4602      	mov	r2, r0
900041a4:	68fb      	ldr	r3, [r7, #12]
900041a6:	4413      	add	r3, r2
900041a8:	60fb      	str	r3, [r7, #12]
    
    /* Select DAC1 (Right) to Right Headphone Output PGA (HPOUT1RVOL) path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_OUTPUT_MIXER_2, &tmp, 2);
900041aa:	687b      	ldr	r3, [r7, #4]
900041ac:	f103 0018 	add.w	r0, r3, #24
900041b0:	f107 020a 	add.w	r2, r7, #10
900041b4:	2302      	movs	r3, #2
900041b6:	212e      	movs	r1, #46	; 0x2e
900041b8:	f000 fc1a 	bl	900049f0 <wm8994_write_reg>
900041bc:	4602      	mov	r2, r0
900041be:	68fb      	ldr	r3, [r7, #12]
900041c0:	4413      	add	r3, r2
900041c2:	60fb      	str	r3, [r7, #12]
    
    /* Startup sequence for Headphone */
    /* Enable/Start the write sequencer */
    tmp = 0x8100;
900041c4:	f44f 4301 	mov.w	r3, #33024	; 0x8100
900041c8:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_WRITE_SEQ_CTRL1, &tmp, 2);
900041ca:	687b      	ldr	r3, [r7, #4]
900041cc:	f103 0018 	add.w	r0, r3, #24
900041d0:	f107 020a 	add.w	r2, r7, #10
900041d4:	2302      	movs	r3, #2
900041d6:	f44f 7188 	mov.w	r1, #272	; 0x110
900041da:	f000 fc09 	bl	900049f0 <wm8994_write_reg>
900041de:	4602      	mov	r2, r0
900041e0:	68fb      	ldr	r3, [r7, #12]
900041e2:	4413      	add	r3, r2
900041e4:	60fb      	str	r3, [r7, #12]
    
    /* Add Delay */
    (void)WM8994_Delay(pObj, 300);
900041e6:	f44f 7196 	mov.w	r1, #300	; 0x12c
900041ea:	6878      	ldr	r0, [r7, #4]
900041ec:	f000 fb88 	bl	90004900 <WM8994_Delay>
    
    /* Soft un-Mute the AIF1 Timeslot 0 DAC1 path L&R */
    tmp = 0x0000;
900041f0:	2300      	movs	r3, #0
900041f2:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_FILTER1, &tmp, 2);    
900041f4:	687b      	ldr	r3, [r7, #4]
900041f6:	f103 0018 	add.w	r0, r3, #24
900041fa:	f107 020a 	add.w	r2, r7, #10
900041fe:	2302      	movs	r3, #2
90004200:	f44f 6184 	mov.w	r1, #1056	; 0x420
90004204:	f000 fbf4 	bl	900049f0 <wm8994_write_reg>
90004208:	4602      	mov	r2, r0
9000420a:	68fb      	ldr	r3, [r7, #12]
9000420c:	4413      	add	r3, r2
9000420e:	60fb      	str	r3, [r7, #12]
90004210:	e165      	b.n	900044de <WM8994_SetOutputMode+0x41c>
  }
  else
  {    
    switch (Output) 
90004212:	683b      	ldr	r3, [r7, #0]
90004214:	2b01      	cmp	r3, #1
90004216:	d149      	bne.n	900042ac <WM8994_SetOutputMode+0x1ea>
    {    
    case WM8994_OUT_SPEAKER: 
      /* Enable DAC1 (Left), Enable DAC1 (Right),
      Disable DAC2 (Left), Disable DAC2 (Right)*/
      tmp = 0x0C0C;
90004218:	f640 430c 	movw	r3, #3084	; 0xc0c
9000421c:	817b      	strh	r3, [r7, #10]
      ret = wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_5, &tmp, 2);
9000421e:	687b      	ldr	r3, [r7, #4]
90004220:	f103 0018 	add.w	r0, r3, #24
90004224:	f107 020a 	add.w	r2, r7, #10
90004228:	2302      	movs	r3, #2
9000422a:	2105      	movs	r1, #5
9000422c:	f000 fbe0 	bl	900049f0 <wm8994_write_reg>
90004230:	60f8      	str	r0, [r7, #12]
      
      /* Disable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
      tmp = 0x0000;
90004232:	2300      	movs	r3, #0
90004234:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_LMR, &tmp, 2);
90004236:	687b      	ldr	r3, [r7, #4]
90004238:	f103 0018 	add.w	r0, r3, #24
9000423c:	f107 020a 	add.w	r2, r7, #10
90004240:	2302      	movs	r3, #2
90004242:	f240 6101 	movw	r1, #1537	; 0x601
90004246:	f000 fbd3 	bl	900049f0 <wm8994_write_reg>
9000424a:	4602      	mov	r2, r0
9000424c:	68fb      	ldr	r3, [r7, #12]
9000424e:	4413      	add	r3, r2
90004250:	60fb      	str	r3, [r7, #12]
      
      /* Disable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_RMR, &tmp, 2);
90004252:	687b      	ldr	r3, [r7, #4]
90004254:	f103 0018 	add.w	r0, r3, #24
90004258:	f107 020a 	add.w	r2, r7, #10
9000425c:	2302      	movs	r3, #2
9000425e:	f240 6102 	movw	r1, #1538	; 0x602
90004262:	f000 fbc5 	bl	900049f0 <wm8994_write_reg>
90004266:	4602      	mov	r2, r0
90004268:	68fb      	ldr	r3, [r7, #12]
9000426a:	4413      	add	r3, r2
9000426c:	60fb      	str	r3, [r7, #12]
      
      /* Enable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
      tmp = 0x0002;
9000426e:	2302      	movs	r3, #2
90004270:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_LMR, &tmp, 2);
90004272:	687b      	ldr	r3, [r7, #4]
90004274:	f103 0018 	add.w	r0, r3, #24
90004278:	f107 020a 	add.w	r2, r7, #10
9000427c:	2302      	movs	r3, #2
9000427e:	f240 6104 	movw	r1, #1540	; 0x604
90004282:	f000 fbb5 	bl	900049f0 <wm8994_write_reg>
90004286:	4602      	mov	r2, r0
90004288:	68fb      	ldr	r3, [r7, #12]
9000428a:	4413      	add	r3, r2
9000428c:	60fb      	str	r3, [r7, #12]
      
      /* Disable the AIF1 Timeslot 1 (Right) to DAC 2 (Right) mixer path */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_RMR, &tmp, 2);
9000428e:	687b      	ldr	r3, [r7, #4]
90004290:	f103 0018 	add.w	r0, r3, #24
90004294:	f107 020a 	add.w	r2, r7, #10
90004298:	2302      	movs	r3, #2
9000429a:	f240 6105 	movw	r1, #1541	; 0x605
9000429e:	f000 fba7 	bl	900049f0 <wm8994_write_reg>
900042a2:	4602      	mov	r2, r0
900042a4:	68fb      	ldr	r3, [r7, #12]
900042a6:	4413      	add	r3, r2
900042a8:	60fb      	str	r3, [r7, #12]
      break;
900042aa:	e03b      	b.n	90004324 <WM8994_SetOutputMode+0x262>
      
    case WM8994_OUT_BOTH:
    default:  
      /* Enable DAC1 (Left), Enable DAC1 (Right),
      also Enable DAC2 (Left), Enable DAC2 (Right)*/
      tmp = 0x0F0F;
900042ac:	f640 730f 	movw	r3, #3855	; 0xf0f
900042b0:	817b      	strh	r3, [r7, #10]
      ret = wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_5, &tmp, 2);
900042b2:	687b      	ldr	r3, [r7, #4]
900042b4:	f103 0018 	add.w	r0, r3, #24
900042b8:	f107 020a 	add.w	r2, r7, #10
900042bc:	2302      	movs	r3, #2
900042be:	2105      	movs	r1, #5
900042c0:	f000 fb96 	bl	900049f0 <wm8994_write_reg>
900042c4:	60f8      	str	r0, [r7, #12]
      
      /* Enable the AIF1 Timeslot 0 (Left) to DAC 1 (Left) mixer path */
      tmp = 0x0001;
900042c6:	2301      	movs	r3, #1
900042c8:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_LMR, &tmp, 2);
900042ca:	687b      	ldr	r3, [r7, #4]
900042cc:	f103 0018 	add.w	r0, r3, #24
900042d0:	f107 020a 	add.w	r2, r7, #10
900042d4:	2302      	movs	r3, #2
900042d6:	f240 6101 	movw	r1, #1537	; 0x601
900042da:	f000 fb89 	bl	900049f0 <wm8994_write_reg>
900042de:	4602      	mov	r2, r0
900042e0:	68fb      	ldr	r3, [r7, #12]
900042e2:	4413      	add	r3, r2
900042e4:	60fb      	str	r3, [r7, #12]
      
      /* Enable the AIF1 Timeslot 0 (Right) to DAC 1 (Right) mixer path */
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC1_RMR, &tmp, 2);
900042e6:	687b      	ldr	r3, [r7, #4]
900042e8:	f103 0018 	add.w	r0, r3, #24
900042ec:	f107 020a 	add.w	r2, r7, #10
900042f0:	2302      	movs	r3, #2
900042f2:	f240 6102 	movw	r1, #1538	; 0x602
900042f6:	f000 fb7b 	bl	900049f0 <wm8994_write_reg>
900042fa:	4602      	mov	r2, r0
900042fc:	68fb      	ldr	r3, [r7, #12]
900042fe:	4413      	add	r3, r2
90004300:	60fb      	str	r3, [r7, #12]
      
      /* Enable the AIF1 Timeslot 1 (Left) to DAC 2 (Left) mixer path */
      tmp = 0x0002;
90004302:	2302      	movs	r3, #2
90004304:	817b      	strh	r3, [r7, #10]
      ret += wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_DAC2_LMR, &tmp, 2);      
90004306:	687b      	ldr	r3, [r7, #4]
90004308:	f103 0018 	add.w	r0, r3, #24
9000430c:	f107 020a 	add.w	r2, r7, #10
90004310:	2302      	movs	r3, #2
90004312:	f240 6104 	movw	r1, #1540	; 0x604
90004316:	f000 fb6b 	bl	900049f0 <wm8994_write_reg>
9000431a:	4602      	mov	r2, r0
9000431c:	68fb      	ldr	r3, [r7, #12]
9000431e:	4413      	add	r3, r2
90004320:	60fb      	str	r3, [r7, #12]
      break;
90004322:	bf00      	nop
    }
    
    /* Enable SPKRVOL PGA, Enable SPKMIXR, Enable SPKLVOL PGA, Enable SPKMIXL */
    tmp = 0x0300;
90004324:	f44f 7340 	mov.w	r3, #768	; 0x300
90004328:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_3, &tmp, 2);
9000432a:	687b      	ldr	r3, [r7, #4]
9000432c:	f103 0018 	add.w	r0, r3, #24
90004330:	f107 020a 	add.w	r2, r7, #10
90004334:	2302      	movs	r3, #2
90004336:	2103      	movs	r1, #3
90004338:	f000 fb5a 	bl	900049f0 <wm8994_write_reg>
9000433c:	4602      	mov	r2, r0
9000433e:	68fb      	ldr	r3, [r7, #12]
90004340:	4413      	add	r3, r2
90004342:	60fb      	str	r3, [r7, #12]
    
    /* Left Speaker Mixer Volume = 0dB */
    tmp = 0x0000;
90004344:	2300      	movs	r3, #0
90004346:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_SPKMIXL_ATT, &tmp, 2);
90004348:	687b      	ldr	r3, [r7, #4]
9000434a:	f103 0018 	add.w	r0, r3, #24
9000434e:	f107 020a 	add.w	r2, r7, #10
90004352:	2302      	movs	r3, #2
90004354:	2122      	movs	r1, #34	; 0x22
90004356:	f000 fb4b 	bl	900049f0 <wm8994_write_reg>
9000435a:	4602      	mov	r2, r0
9000435c:	68fb      	ldr	r3, [r7, #12]
9000435e:	4413      	add	r3, r2
90004360:	60fb      	str	r3, [r7, #12]
    
    /* Speaker output mode = Class D, Right Speaker Mixer Volume = 0dB ((0x23, 0x0100) = class AB)*/
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_SPKMIXR_ATT, &tmp, 2);
90004362:	687b      	ldr	r3, [r7, #4]
90004364:	f103 0018 	add.w	r0, r3, #24
90004368:	f107 020a 	add.w	r2, r7, #10
9000436c:	2302      	movs	r3, #2
9000436e:	2123      	movs	r1, #35	; 0x23
90004370:	f000 fb3e 	bl	900049f0 <wm8994_write_reg>
90004374:	4602      	mov	r2, r0
90004376:	68fb      	ldr	r3, [r7, #12]
90004378:	4413      	add	r3, r2
9000437a:	60fb      	str	r3, [r7, #12]
    
    /* Unmute DAC2 (Left) to Left Speaker Mixer (SPKMIXL) path,
    Unmute DAC2 (Right) to Right Speaker Mixer (SPKMIXR) path */
    tmp = 0x0300;
9000437c:	f44f 7340 	mov.w	r3, #768	; 0x300
90004380:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_SPEAKER_MIXER, &tmp, 2);
90004382:	687b      	ldr	r3, [r7, #4]
90004384:	f103 0018 	add.w	r0, r3, #24
90004388:	f107 020a 	add.w	r2, r7, #10
9000438c:	2302      	movs	r3, #2
9000438e:	2136      	movs	r1, #54	; 0x36
90004390:	f000 fb2e 	bl	900049f0 <wm8994_write_reg>
90004394:	4602      	mov	r2, r0
90004396:	68fb      	ldr	r3, [r7, #12]
90004398:	4413      	add	r3, r2
9000439a:	60fb      	str	r3, [r7, #12]
    
    /* Enable bias generator, Enable VMID, Enable SPKOUTL, Enable SPKOUTR */
    tmp = 0x3003;
9000439c:	f243 0303 	movw	r3, #12291	; 0x3003
900043a0:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_1, &tmp, 2);
900043a2:	687b      	ldr	r3, [r7, #4]
900043a4:	f103 0018 	add.w	r0, r3, #24
900043a8:	f107 020a 	add.w	r2, r7, #10
900043ac:	2302      	movs	r3, #2
900043ae:	2101      	movs	r1, #1
900043b0:	f000 fb1e 	bl	900049f0 <wm8994_write_reg>
900043b4:	4602      	mov	r2, r0
900043b6:	68fb      	ldr	r3, [r7, #12]
900043b8:	4413      	add	r3, r2
900043ba:	60fb      	str	r3, [r7, #12]
    /* Headphone/Speaker Enable */
    
    /* Enable Class W, Class W Envelope Tracking = AIF1 Timeslot 0 */
    tmp = 0x0005;
900043bc:	2305      	movs	r3, #5
900043be:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_CLASS_W, &tmp, 2);
900043c0:	687b      	ldr	r3, [r7, #4]
900043c2:	f103 0018 	add.w	r0, r3, #24
900043c6:	f107 020a 	add.w	r2, r7, #10
900043ca:	2302      	movs	r3, #2
900043cc:	2151      	movs	r1, #81	; 0x51
900043ce:	f000 fb0f 	bl	900049f0 <wm8994_write_reg>
900043d2:	4602      	mov	r2, r0
900043d4:	68fb      	ldr	r3, [r7, #12]
900043d6:	4413      	add	r3, r2
900043d8:	60fb      	str	r3, [r7, #12]
    
    /* Enable bias generator, Enable VMID, Enable HPOUT1 (Left) and Enable HPOUT1 (Right) input stages */
    /* idem for Speaker */
    tmp = 0x3303;
900043da:	f243 3303 	movw	r3, #13059	; 0x3303
900043de:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_1, &tmp, 2);
900043e0:	687b      	ldr	r3, [r7, #4]
900043e2:	f103 0018 	add.w	r0, r3, #24
900043e6:	f107 020a 	add.w	r2, r7, #10
900043ea:	2302      	movs	r3, #2
900043ec:	2101      	movs	r1, #1
900043ee:	f000 faff 	bl	900049f0 <wm8994_write_reg>
900043f2:	4602      	mov	r2, r0
900043f4:	68fb      	ldr	r3, [r7, #12]
900043f6:	4413      	add	r3, r2
900043f8:	60fb      	str	r3, [r7, #12]
    
    /* Enable HPOUT1 (Left) and HPOUT1 (Right) intermediate stages */
    tmp = 0x0022;
900043fa:	2322      	movs	r3, #34	; 0x22
900043fc:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_ANALOG_HP, &tmp, 2);
900043fe:	687b      	ldr	r3, [r7, #4]
90004400:	f103 0018 	add.w	r0, r3, #24
90004404:	f107 020a 	add.w	r2, r7, #10
90004408:	2302      	movs	r3, #2
9000440a:	2160      	movs	r1, #96	; 0x60
9000440c:	f000 faf0 	bl	900049f0 <wm8994_write_reg>
90004410:	4602      	mov	r2, r0
90004412:	68fb      	ldr	r3, [r7, #12]
90004414:	4413      	add	r3, r2
90004416:	60fb      	str	r3, [r7, #12]
    
    /* Enable Charge Pump */
    tmp = 0x9F25;
90004418:	f649 7325 	movw	r3, #40741	; 0x9f25
9000441c:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_CHARGE_PUMP1, &tmp, 2);
9000441e:	687b      	ldr	r3, [r7, #4]
90004420:	f103 0018 	add.w	r0, r3, #24
90004424:	f107 020a 	add.w	r2, r7, #10
90004428:	2302      	movs	r3, #2
9000442a:	214c      	movs	r1, #76	; 0x4c
9000442c:	f000 fae0 	bl	900049f0 <wm8994_write_reg>
90004430:	4602      	mov	r2, r0
90004432:	68fb      	ldr	r3, [r7, #12]
90004434:	4413      	add	r3, r2
90004436:	60fb      	str	r3, [r7, #12]
    
    /* Add Delay */
    (void)WM8994_Delay(pObj, 15);
90004438:	210f      	movs	r1, #15
9000443a:	6878      	ldr	r0, [r7, #4]
9000443c:	f000 fa60 	bl	90004900 <WM8994_Delay>
    
    /* Select DAC1 (Left) to Left Headphone Output PGA (HPOUT1LVOL) path */
    tmp = 0x0001;
90004440:	2301      	movs	r3, #1
90004442:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_OUTPUT_MIXER_1, &tmp, 2);
90004444:	687b      	ldr	r3, [r7, #4]
90004446:	f103 0018 	add.w	r0, r3, #24
9000444a:	f107 020a 	add.w	r2, r7, #10
9000444e:	2302      	movs	r3, #2
90004450:	212d      	movs	r1, #45	; 0x2d
90004452:	f000 facd 	bl	900049f0 <wm8994_write_reg>
90004456:	4602      	mov	r2, r0
90004458:	68fb      	ldr	r3, [r7, #12]
9000445a:	4413      	add	r3, r2
9000445c:	60fb      	str	r3, [r7, #12]
    
    /* Select DAC1 (Right) to Right Headphone Output PGA (HPOUT1RVOL) path */
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_OUTPUT_MIXER_2, &tmp, 2);
9000445e:	687b      	ldr	r3, [r7, #4]
90004460:	f103 0018 	add.w	r0, r3, #24
90004464:	f107 020a 	add.w	r2, r7, #10
90004468:	2302      	movs	r3, #2
9000446a:	212e      	movs	r1, #46	; 0x2e
9000446c:	f000 fac0 	bl	900049f0 <wm8994_write_reg>
90004470:	4602      	mov	r2, r0
90004472:	68fb      	ldr	r3, [r7, #12]
90004474:	4413      	add	r3, r2
90004476:	60fb      	str	r3, [r7, #12]
    
    /* Enable Left Output Mixer (MIXOUTL), Enable Right Output Mixer (MIXOUTR) */
    /* idem for SPKOUTL and SPKOUTR */
    tmp = 0x0330;
90004478:	f44f 734c 	mov.w	r3, #816	; 0x330
9000447c:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_PWR_MANAGEMENT_3, &tmp, 2);
9000447e:	687b      	ldr	r3, [r7, #4]
90004480:	f103 0018 	add.w	r0, r3, #24
90004484:	f107 020a 	add.w	r2, r7, #10
90004488:	2302      	movs	r3, #2
9000448a:	2103      	movs	r1, #3
9000448c:	f000 fab0 	bl	900049f0 <wm8994_write_reg>
90004490:	4602      	mov	r2, r0
90004492:	68fb      	ldr	r3, [r7, #12]
90004494:	4413      	add	r3, r2
90004496:	60fb      	str	r3, [r7, #12]
    
    /* Enable DC Servo and trigger start-up mode on left and right channels */
    tmp = 0x0033;
90004498:	2333      	movs	r3, #51	; 0x33
9000449a:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_DC_SERVO1, &tmp, 2);
9000449c:	687b      	ldr	r3, [r7, #4]
9000449e:	f103 0018 	add.w	r0, r3, #24
900044a2:	f107 020a 	add.w	r2, r7, #10
900044a6:	2302      	movs	r3, #2
900044a8:	2154      	movs	r1, #84	; 0x54
900044aa:	f000 faa1 	bl	900049f0 <wm8994_write_reg>
900044ae:	4602      	mov	r2, r0
900044b0:	68fb      	ldr	r3, [r7, #12]
900044b2:	4413      	add	r3, r2
900044b4:	60fb      	str	r3, [r7, #12]
    
    /* Add Delay */
    (void)WM8994_Delay(pObj, 257);
900044b6:	f240 1101 	movw	r1, #257	; 0x101
900044ba:	6878      	ldr	r0, [r7, #4]
900044bc:	f000 fa20 	bl	90004900 <WM8994_Delay>
    
    /* Enable HPOUT1 (Left) and HPOUT1 (Right) intermediate and output stages. Remove clamps */
    tmp = 0x00EE;
900044c0:	23ee      	movs	r3, #238	; 0xee
900044c2:	817b      	strh	r3, [r7, #10]
    ret += wm8994_write_reg(&pObj->Ctx, WM8994_ANALOG_HP, &tmp, 2);    
900044c4:	687b      	ldr	r3, [r7, #4]
900044c6:	f103 0018 	add.w	r0, r3, #24
900044ca:	f107 020a 	add.w	r2, r7, #10
900044ce:	2302      	movs	r3, #2
900044d0:	2160      	movs	r1, #96	; 0x60
900044d2:	f000 fa8d 	bl	900049f0 <wm8994_write_reg>
900044d6:	4602      	mov	r2, r0
900044d8:	68fb      	ldr	r3, [r7, #12]
900044da:	4413      	add	r3, r2
900044dc:	60fb      	str	r3, [r7, #12]
  }
  
  if(ret != WM8994_OK)
900044de:	68fb      	ldr	r3, [r7, #12]
900044e0:	2b00      	cmp	r3, #0
900044e2:	d002      	beq.n	900044ea <WM8994_SetOutputMode+0x428>
  {
    ret = WM8994_ERROR;
900044e4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900044e8:	60fb      	str	r3, [r7, #12]
  }
  
  return ret;
900044ea:	68fb      	ldr	r3, [r7, #12]
}
900044ec:	4618      	mov	r0, r3
900044ee:	3710      	adds	r7, #16
900044f0:	46bd      	mov	sp, r7
900044f2:	bd80      	pop	{r7, pc}

900044f4 <WM8994_SetResolution>:
  *                    WM8994_RESOLUTION_16b, WM8994_RESOLUTION_20b, 
  *                    WM8994_RESOLUTION_24b or WM8994_RESOLUTION_32b
  * @retval Component status
  */
int32_t WM8994_SetResolution(WM8994_Object_t *pObj, uint32_t Resolution)
{
900044f4:	b580      	push	{r7, lr}
900044f6:	b084      	sub	sp, #16
900044f8:	af00      	add	r7, sp, #0
900044fa:	6078      	str	r0, [r7, #4]
900044fc:	6039      	str	r1, [r7, #0]
  int32_t ret = WM8994_OK;
900044fe:	2300      	movs	r3, #0
90004500:	60fb      	str	r3, [r7, #12]
  
  if(wm8994_aif1_control1_wl(&pObj->Ctx, (uint16_t)Resolution) != WM8994_OK)
90004502:	687b      	ldr	r3, [r7, #4]
90004504:	3318      	adds	r3, #24
90004506:	683a      	ldr	r2, [r7, #0]
90004508:	b292      	uxth	r2, r2
9000450a:	4611      	mov	r1, r2
9000450c:	4618      	mov	r0, r3
9000450e:	f000 fb4b 	bl	90004ba8 <wm8994_aif1_control1_wl>
90004512:	4603      	mov	r3, r0
90004514:	2b00      	cmp	r3, #0
90004516:	d002      	beq.n	9000451e <WM8994_SetResolution+0x2a>
  {
    ret = WM8994_ERROR;
90004518:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9000451c:	60fb      	str	r3, [r7, #12]
  }

  return ret;
9000451e:	68fb      	ldr	r3, [r7, #12]
}
90004520:	4618      	mov	r0, r3
90004522:	3710      	adds	r7, #16
90004524:	46bd      	mov	sp, r7
90004526:	bd80      	pop	{r7, pc}

90004528 <WM8994_GetResolution>:
  * @brief Get Audio resolution.
  * @param pObj pointer to component object
  * @retval Audio resolution
  */
int32_t WM8994_GetResolution(WM8994_Object_t *pObj, uint32_t *Resolution)
{
90004528:	b580      	push	{r7, lr}
9000452a:	b084      	sub	sp, #16
9000452c:	af00      	add	r7, sp, #0
9000452e:	6078      	str	r0, [r7, #4]
90004530:	6039      	str	r1, [r7, #0]
  int32_t ret = WM8994_OK;  
90004532:	2300      	movs	r3, #0
90004534:	60fb      	str	r3, [r7, #12]
  uint16_t resolution = 0;
90004536:	2300      	movs	r3, #0
90004538:	817b      	strh	r3, [r7, #10]
  
  if(wm8994_aif1_control1_wl_r(&pObj->Ctx, &resolution) != WM8994_OK)
9000453a:	687b      	ldr	r3, [r7, #4]
9000453c:	3318      	adds	r3, #24
9000453e:	f107 020a 	add.w	r2, r7, #10
90004542:	4611      	mov	r1, r2
90004544:	4618      	mov	r0, r3
90004546:	f000 fb5f 	bl	90004c08 <wm8994_aif1_control1_wl_r>
9000454a:	4603      	mov	r3, r0
9000454c:	2b00      	cmp	r3, #0
9000454e:	d003      	beq.n	90004558 <WM8994_GetResolution+0x30>
  {
    ret = WM8994_ERROR;
90004550:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90004554:	60fb      	str	r3, [r7, #12]
90004556:	e021      	b.n	9000459c <WM8994_GetResolution+0x74>
  }
  else
  {
    switch(resolution)
90004558:	897b      	ldrh	r3, [r7, #10]
9000455a:	2b03      	cmp	r3, #3
9000455c:	d81a      	bhi.n	90004594 <WM8994_GetResolution+0x6c>
9000455e:	a201      	add	r2, pc, #4	; (adr r2, 90004564 <WM8994_GetResolution+0x3c>)
90004560:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90004564:	90004575 	.word	0x90004575
90004568:	9000457d 	.word	0x9000457d
9000456c:	90004585 	.word	0x90004585
90004570:	9000458d 	.word	0x9000458d
    {
    case 0:
      *Resolution = WM8994_RESOLUTION_16b;
90004574:	683b      	ldr	r3, [r7, #0]
90004576:	2200      	movs	r2, #0
90004578:	601a      	str	r2, [r3, #0]
      break;
9000457a:	e00f      	b.n	9000459c <WM8994_GetResolution+0x74>
    case 1:
      *Resolution = WM8994_RESOLUTION_20b;
9000457c:	683b      	ldr	r3, [r7, #0]
9000457e:	2201      	movs	r2, #1
90004580:	601a      	str	r2, [r3, #0]
      break;
90004582:	e00b      	b.n	9000459c <WM8994_GetResolution+0x74>
    case 2:
      *Resolution = WM8994_RESOLUTION_24b;
90004584:	683b      	ldr	r3, [r7, #0]
90004586:	2202      	movs	r2, #2
90004588:	601a      	str	r2, [r3, #0]
      break;
9000458a:	e007      	b.n	9000459c <WM8994_GetResolution+0x74>
    case 3:
      *Resolution = WM8994_RESOLUTION_32b;
9000458c:	683b      	ldr	r3, [r7, #0]
9000458e:	2203      	movs	r2, #3
90004590:	601a      	str	r2, [r3, #0]
      break; 
90004592:	e003      	b.n	9000459c <WM8994_GetResolution+0x74>
    default:
      *Resolution = WM8994_RESOLUTION_16b;
90004594:	683b      	ldr	r3, [r7, #0]
90004596:	2200      	movs	r2, #0
90004598:	601a      	str	r2, [r3, #0]
      break;
9000459a:	bf00      	nop
    }
  }
  
  return ret;
9000459c:	68fb      	ldr	r3, [r7, #12]
}
9000459e:	4618      	mov	r0, r3
900045a0:	3710      	adds	r7, #16
900045a2:	46bd      	mov	sp, r7
900045a4:	bd80      	pop	{r7, pc}
900045a6:	bf00      	nop

900045a8 <WM8994_SetProtocol>:
  *                  WM8994_PROTOCOL_R_JUSTIFIED, WM8994_PROTOCOL_L_JUSTIFIED, 
  *                  WM8994_PROTOCOL_I2S or WM8994_PROTOCOL_DSP
  * @retval Component status
  */
int32_t WM8994_SetProtocol(WM8994_Object_t *pObj, uint32_t Protocol)
{
900045a8:	b580      	push	{r7, lr}
900045aa:	b084      	sub	sp, #16
900045ac:	af00      	add	r7, sp, #0
900045ae:	6078      	str	r0, [r7, #4]
900045b0:	6039      	str	r1, [r7, #0]
  int32_t ret = WM8994_OK; 
900045b2:	2300      	movs	r3, #0
900045b4:	60fb      	str	r3, [r7, #12]
  
  if(wm8994_aif1_control1_fmt(&pObj->Ctx, (uint16_t)Protocol) != WM8994_OK)
900045b6:	687b      	ldr	r3, [r7, #4]
900045b8:	3318      	adds	r3, #24
900045ba:	683a      	ldr	r2, [r7, #0]
900045bc:	b292      	uxth	r2, r2
900045be:	4611      	mov	r1, r2
900045c0:	4618      	mov	r0, r3
900045c2:	f000 fa9f 	bl	90004b04 <wm8994_aif1_control1_fmt>
900045c6:	4603      	mov	r3, r0
900045c8:	2b00      	cmp	r3, #0
900045ca:	d002      	beq.n	900045d2 <WM8994_SetProtocol+0x2a>
  {
    ret = WM8994_ERROR;
900045cc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900045d0:	60fb      	str	r3, [r7, #12]
  }
  
  return ret;  
900045d2:	68fb      	ldr	r3, [r7, #12]
}
900045d4:	4618      	mov	r0, r3
900045d6:	3710      	adds	r7, #16
900045d8:	46bd      	mov	sp, r7
900045da:	bd80      	pop	{r7, pc}

900045dc <WM8994_GetProtocol>:
  * @brief Get Audio Protocol.
  * @param pObj pointer to component object
  * @retval Component status
  */
int32_t WM8994_GetProtocol(WM8994_Object_t *pObj, uint32_t *Protocol)
{
900045dc:	b580      	push	{r7, lr}
900045de:	b084      	sub	sp, #16
900045e0:	af00      	add	r7, sp, #0
900045e2:	6078      	str	r0, [r7, #4]
900045e4:	6039      	str	r1, [r7, #0]
  int32_t ret = WM8994_OK;  
900045e6:	2300      	movs	r3, #0
900045e8:	60fb      	str	r3, [r7, #12]
  uint16_t protocol;
  
  if(wm8994_aif1_control1_fmt_r(&pObj->Ctx, &protocol) != WM8994_OK)
900045ea:	687b      	ldr	r3, [r7, #4]
900045ec:	3318      	adds	r3, #24
900045ee:	f107 020a 	add.w	r2, r7, #10
900045f2:	4611      	mov	r1, r2
900045f4:	4618      	mov	r0, r3
900045f6:	f000 fab5 	bl	90004b64 <wm8994_aif1_control1_fmt_r>
900045fa:	4603      	mov	r3, r0
900045fc:	2b00      	cmp	r3, #0
900045fe:	d003      	beq.n	90004608 <WM8994_GetProtocol+0x2c>
  {
    ret = WM8994_ERROR;
90004600:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90004604:	60fb      	str	r3, [r7, #12]
90004606:	e003      	b.n	90004610 <WM8994_GetProtocol+0x34>
  }
  else
  {
    *Protocol = protocol;
90004608:	897b      	ldrh	r3, [r7, #10]
9000460a:	461a      	mov	r2, r3
9000460c:	683b      	ldr	r3, [r7, #0]
9000460e:	601a      	str	r2, [r3, #0]
  }
  
  return ret;
90004610:	68fb      	ldr	r3, [r7, #12]
}
90004612:	4618      	mov	r0, r3
90004614:	3710      	adds	r7, #16
90004616:	46bd      	mov	sp, r7
90004618:	bd80      	pop	{r7, pc}
	...

9000461c <WM8994_SetFrequency>:
  * @param pObj pointer to component object
  * @param AudioFreq Audio frequency
  * @retval Component status
  */
int32_t WM8994_SetFrequency(WM8994_Object_t *pObj, uint32_t AudioFreq)
{
9000461c:	b580      	push	{r7, lr}
9000461e:	b084      	sub	sp, #16
90004620:	af00      	add	r7, sp, #0
90004622:	6078      	str	r0, [r7, #4]
90004624:	6039      	str	r1, [r7, #0]
  int32_t ret;
  uint16_t tmp;
  
  switch (AudioFreq)
90004626:	683b      	ldr	r3, [r7, #0]
90004628:	4a55      	ldr	r2, [pc, #340]	; (90004780 <WM8994_SetFrequency+0x164>)
9000462a:	4293      	cmp	r3, r2
9000462c:	d05d      	beq.n	900046ea <WM8994_SetFrequency+0xce>
9000462e:	683b      	ldr	r3, [r7, #0]
90004630:	4a53      	ldr	r2, [pc, #332]	; (90004780 <WM8994_SetFrequency+0x164>)
90004632:	4293      	cmp	r3, r2
90004634:	f200 8091 	bhi.w	9000475a <WM8994_SetFrequency+0x13e>
90004638:	683b      	ldr	r3, [r7, #0]
9000463a:	f64a 4244 	movw	r2, #44100	; 0xac44
9000463e:	4293      	cmp	r3, r2
90004640:	d07d      	beq.n	9000473e <WM8994_SetFrequency+0x122>
90004642:	683b      	ldr	r3, [r7, #0]
90004644:	f64a 4244 	movw	r2, #44100	; 0xac44
90004648:	4293      	cmp	r3, r2
9000464a:	f200 8086 	bhi.w	9000475a <WM8994_SetFrequency+0x13e>
9000464e:	683b      	ldr	r3, [r7, #0]
90004650:	f5b3 4ffa 	cmp.w	r3, #32000	; 0x7d00
90004654:	d03b      	beq.n	900046ce <WM8994_SetFrequency+0xb2>
90004656:	683b      	ldr	r3, [r7, #0]
90004658:	f5b3 4ffa 	cmp.w	r3, #32000	; 0x7d00
9000465c:	d87d      	bhi.n	9000475a <WM8994_SetFrequency+0x13e>
9000465e:	683b      	ldr	r3, [r7, #0]
90004660:	f245 6222 	movw	r2, #22050	; 0x5622
90004664:	4293      	cmp	r3, r2
90004666:	d05c      	beq.n	90004722 <WM8994_SetFrequency+0x106>
90004668:	683b      	ldr	r3, [r7, #0]
9000466a:	f245 6222 	movw	r2, #22050	; 0x5622
9000466e:	4293      	cmp	r3, r2
90004670:	d873      	bhi.n	9000475a <WM8994_SetFrequency+0x13e>
90004672:	683b      	ldr	r3, [r7, #0]
90004674:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
90004678:	d01b      	beq.n	900046b2 <WM8994_SetFrequency+0x96>
9000467a:	683b      	ldr	r3, [r7, #0]
9000467c:	f5b3 5f7a 	cmp.w	r3, #16000	; 0x3e80
90004680:	d86b      	bhi.n	9000475a <WM8994_SetFrequency+0x13e>
90004682:	683b      	ldr	r3, [r7, #0]
90004684:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
90004688:	d005      	beq.n	90004696 <WM8994_SetFrequency+0x7a>
9000468a:	683b      	ldr	r3, [r7, #0]
9000468c:	f642 3211 	movw	r2, #11025	; 0x2b11
90004690:	4293      	cmp	r3, r2
90004692:	d038      	beq.n	90004706 <WM8994_SetFrequency+0xea>
90004694:	e061      	b.n	9000475a <WM8994_SetFrequency+0x13e>
  {
  case  WM8994_FREQUENCY_8K:
    /* AIF1 Sample Rate = 8 (KHz), ratio=256 */
    tmp = 0x0003;
90004696:	2303      	movs	r3, #3
90004698:	817b      	strh	r3, [r7, #10]
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_RATE, &tmp, 2);
9000469a:	687b      	ldr	r3, [r7, #4]
9000469c:	f103 0018 	add.w	r0, r3, #24
900046a0:	f107 020a 	add.w	r2, r7, #10
900046a4:	2302      	movs	r3, #2
900046a6:	f44f 7104 	mov.w	r1, #528	; 0x210
900046aa:	f000 f9a1 	bl	900049f0 <wm8994_write_reg>
900046ae:	60f8      	str	r0, [r7, #12]
    break;
900046b0:	e061      	b.n	90004776 <WM8994_SetFrequency+0x15a>
    
  case  WM8994_FREQUENCY_16K:
    /* AIF1 Sample Rate = 16 (KHz), ratio=256 */ 
    tmp = 0x0033;
900046b2:	2333      	movs	r3, #51	; 0x33
900046b4:	817b      	strh	r3, [r7, #10]
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_RATE, &tmp, 2);
900046b6:	687b      	ldr	r3, [r7, #4]
900046b8:	f103 0018 	add.w	r0, r3, #24
900046bc:	f107 020a 	add.w	r2, r7, #10
900046c0:	2302      	movs	r3, #2
900046c2:	f44f 7104 	mov.w	r1, #528	; 0x210
900046c6:	f000 f993 	bl	900049f0 <wm8994_write_reg>
900046ca:	60f8      	str	r0, [r7, #12]
    break;
900046cc:	e053      	b.n	90004776 <WM8994_SetFrequency+0x15a>
    
  case  WM8994_FREQUENCY_32K:
    /* AIF1 Sample Rate = 32 (KHz), ratio=256 */
    tmp = 0x0063;
900046ce:	2363      	movs	r3, #99	; 0x63
900046d0:	817b      	strh	r3, [r7, #10]
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_RATE, &tmp, 2);
900046d2:	687b      	ldr	r3, [r7, #4]
900046d4:	f103 0018 	add.w	r0, r3, #24
900046d8:	f107 020a 	add.w	r2, r7, #10
900046dc:	2302      	movs	r3, #2
900046de:	f44f 7104 	mov.w	r1, #528	; 0x210
900046e2:	f000 f985 	bl	900049f0 <wm8994_write_reg>
900046e6:	60f8      	str	r0, [r7, #12]
    break;
900046e8:	e045      	b.n	90004776 <WM8994_SetFrequency+0x15a>
    
  case  WM8994_FREQUENCY_96K:
    /* AIF1 Sample Rate = 96 (KHz), ratio=256 */
    tmp = 0x00A3;
900046ea:	23a3      	movs	r3, #163	; 0xa3
900046ec:	817b      	strh	r3, [r7, #10]
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_RATE, &tmp, 2);
900046ee:	687b      	ldr	r3, [r7, #4]
900046f0:	f103 0018 	add.w	r0, r3, #24
900046f4:	f107 020a 	add.w	r2, r7, #10
900046f8:	2302      	movs	r3, #2
900046fa:	f44f 7104 	mov.w	r1, #528	; 0x210
900046fe:	f000 f977 	bl	900049f0 <wm8994_write_reg>
90004702:	60f8      	str	r0, [r7, #12]
    break;
90004704:	e037      	b.n	90004776 <WM8994_SetFrequency+0x15a>
    
  case  WM8994_FREQUENCY_11K:
    /* AIF1 Sample Rate = 11.025 (KHz), ratio=256 */ 
    tmp = 0x0013;
90004706:	2313      	movs	r3, #19
90004708:	817b      	strh	r3, [r7, #10]
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_RATE, &tmp, 2);
9000470a:	687b      	ldr	r3, [r7, #4]
9000470c:	f103 0018 	add.w	r0, r3, #24
90004710:	f107 020a 	add.w	r2, r7, #10
90004714:	2302      	movs	r3, #2
90004716:	f44f 7104 	mov.w	r1, #528	; 0x210
9000471a:	f000 f969 	bl	900049f0 <wm8994_write_reg>
9000471e:	60f8      	str	r0, [r7, #12]
    break;
90004720:	e029      	b.n	90004776 <WM8994_SetFrequency+0x15a>
    
  case  WM8994_FREQUENCY_22K:
    /* AIF1 Sample Rate = 22.050 (KHz), ratio=256 */ 
    tmp = 0x0043;
90004722:	2343      	movs	r3, #67	; 0x43
90004724:	817b      	strh	r3, [r7, #10]
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_RATE, &tmp, 2);
90004726:	687b      	ldr	r3, [r7, #4]
90004728:	f103 0018 	add.w	r0, r3, #24
9000472c:	f107 020a 	add.w	r2, r7, #10
90004730:	2302      	movs	r3, #2
90004732:	f44f 7104 	mov.w	r1, #528	; 0x210
90004736:	f000 f95b 	bl	900049f0 <wm8994_write_reg>
9000473a:	60f8      	str	r0, [r7, #12]
    break;
9000473c:	e01b      	b.n	90004776 <WM8994_SetFrequency+0x15a>
    
  case  WM8994_FREQUENCY_44K:
    /* AIF1 Sample Rate = 44.1 (KHz), ratio=256 */ 
    tmp = 0x0073;
9000473e:	2373      	movs	r3, #115	; 0x73
90004740:	817b      	strh	r3, [r7, #10]
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_RATE, &tmp, 2);
90004742:	687b      	ldr	r3, [r7, #4]
90004744:	f103 0018 	add.w	r0, r3, #24
90004748:	f107 020a 	add.w	r2, r7, #10
9000474c:	2302      	movs	r3, #2
9000474e:	f44f 7104 	mov.w	r1, #528	; 0x210
90004752:	f000 f94d 	bl	900049f0 <wm8994_write_reg>
90004756:	60f8      	str	r0, [r7, #12]
    break; 
90004758:	e00d      	b.n	90004776 <WM8994_SetFrequency+0x15a>
    
  case  WM8994_FREQUENCY_48K:    
  default:
    /* AIF1 Sample Rate = 48 (KHz), ratio=256 */
    tmp = 0x0083;
9000475a:	2383      	movs	r3, #131	; 0x83
9000475c:	817b      	strh	r3, [r7, #10]
    ret = wm8994_write_reg(&pObj->Ctx, WM8994_AIF1_RATE, &tmp, 2);
9000475e:	687b      	ldr	r3, [r7, #4]
90004760:	f103 0018 	add.w	r0, r3, #24
90004764:	f107 020a 	add.w	r2, r7, #10
90004768:	2302      	movs	r3, #2
9000476a:	f44f 7104 	mov.w	r1, #528	; 0x210
9000476e:	f000 f93f 	bl	900049f0 <wm8994_write_reg>
90004772:	60f8      	str	r0, [r7, #12]
    break; 
90004774:	bf00      	nop
  }
  
  return ret;
90004776:	68fb      	ldr	r3, [r7, #12]
}
90004778:	4618      	mov	r0, r3
9000477a:	3710      	adds	r7, #16
9000477c:	46bd      	mov	sp, r7
9000477e:	bd80      	pop	{r7, pc}
90004780:	00017700 	.word	0x00017700

90004784 <WM8994_GetFrequency>:
  * @param pObj pointer to component object
  * @param AudioFreq Audio frequency
  * @retval Component status
  */
int32_t WM8994_GetFrequency(WM8994_Object_t *pObj, uint32_t *AudioFreq)
{
90004784:	b580      	push	{r7, lr}
90004786:	b084      	sub	sp, #16
90004788:	af00      	add	r7, sp, #0
9000478a:	6078      	str	r0, [r7, #4]
9000478c:	6039      	str	r1, [r7, #0]
  int32_t ret = WM8994_OK;   
9000478e:	2300      	movs	r3, #0
90004790:	60fb      	str	r3, [r7, #12]
  uint16_t freq = 0;
90004792:	2300      	movs	r3, #0
90004794:	817b      	strh	r3, [r7, #10]
  
  if(wm8994_aif1_sr_r(&pObj->Ctx, &freq) != WM8994_OK)
90004796:	687b      	ldr	r3, [r7, #4]
90004798:	3318      	adds	r3, #24
9000479a:	f107 020a 	add.w	r2, r7, #10
9000479e:	4611      	mov	r1, r2
900047a0:	4618      	mov	r0, r3
900047a2:	f000 f98d 	bl	90004ac0 <wm8994_aif1_sr_r>
900047a6:	4603      	mov	r3, r0
900047a8:	2b00      	cmp	r3, #0
900047aa:	d003      	beq.n	900047b4 <WM8994_GetFrequency+0x30>
  {
    ret = WM8994_ERROR;
900047ac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900047b0:	60fb      	str	r3, [r7, #12]
900047b2:	e043      	b.n	9000483c <WM8994_GetFrequency+0xb8>
  }
  else
  {
    switch(freq)
900047b4:	897b      	ldrh	r3, [r7, #10]
900047b6:	2b0a      	cmp	r3, #10
900047b8:	d83f      	bhi.n	9000483a <WM8994_GetFrequency+0xb6>
900047ba:	a201      	add	r2, pc, #4	; (adr r2, 900047c0 <WM8994_GetFrequency+0x3c>)
900047bc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
900047c0:	900047ed 	.word	0x900047ed
900047c4:	900047f7 	.word	0x900047f7
900047c8:	9000483b 	.word	0x9000483b
900047cc:	90004801 	.word	0x90004801
900047d0:	9000480b 	.word	0x9000480b
900047d4:	9000483b 	.word	0x9000483b
900047d8:	90004815 	.word	0x90004815
900047dc:	9000481f 	.word	0x9000481f
900047e0:	90004829 	.word	0x90004829
900047e4:	9000483b 	.word	0x9000483b
900047e8:	90004833 	.word	0x90004833
    {
    case 0:
      *AudioFreq = WM8994_FREQUENCY_8K;
900047ec:	683b      	ldr	r3, [r7, #0]
900047ee:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
900047f2:	601a      	str	r2, [r3, #0]
      break;
900047f4:	e022      	b.n	9000483c <WM8994_GetFrequency+0xb8>
    case 1:
      *AudioFreq = WM8994_FREQUENCY_11K;
900047f6:	683b      	ldr	r3, [r7, #0]
900047f8:	f642 3211 	movw	r2, #11025	; 0x2b11
900047fc:	601a      	str	r2, [r3, #0]
      break;    
900047fe:	e01d      	b.n	9000483c <WM8994_GetFrequency+0xb8>
    case 3:
      *AudioFreq = WM8994_FREQUENCY_16K;
90004800:	683b      	ldr	r3, [r7, #0]
90004802:	f44f 527a 	mov.w	r2, #16000	; 0x3e80
90004806:	601a      	str	r2, [r3, #0]
      break;
90004808:	e018      	b.n	9000483c <WM8994_GetFrequency+0xb8>
    case 4:
      *AudioFreq = WM8994_FREQUENCY_22K;
9000480a:	683b      	ldr	r3, [r7, #0]
9000480c:	f245 6222 	movw	r2, #22050	; 0x5622
90004810:	601a      	str	r2, [r3, #0]
      break; 
90004812:	e013      	b.n	9000483c <WM8994_GetFrequency+0xb8>
    case 6:
      *AudioFreq = WM8994_FREQUENCY_32K;
90004814:	683b      	ldr	r3, [r7, #0]
90004816:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
9000481a:	601a      	str	r2, [r3, #0]
      break; 
9000481c:	e00e      	b.n	9000483c <WM8994_GetFrequency+0xb8>
    case 7:
      *AudioFreq = WM8994_FREQUENCY_44K;
9000481e:	683b      	ldr	r3, [r7, #0]
90004820:	f64a 4244 	movw	r2, #44100	; 0xac44
90004824:	601a      	str	r2, [r3, #0]
      break;    
90004826:	e009      	b.n	9000483c <WM8994_GetFrequency+0xb8>
    case 8:
      *AudioFreq = WM8994_FREQUENCY_48K;
90004828:	683b      	ldr	r3, [r7, #0]
9000482a:	f64b 3280 	movw	r2, #48000	; 0xbb80
9000482e:	601a      	str	r2, [r3, #0]
      break;
90004830:	e004      	b.n	9000483c <WM8994_GetFrequency+0xb8>
    case 10:
      *AudioFreq = WM8994_FREQUENCY_96K;
90004832:	683b      	ldr	r3, [r7, #0]
90004834:	4a04      	ldr	r2, [pc, #16]	; (90004848 <WM8994_GetFrequency+0xc4>)
90004836:	601a      	str	r2, [r3, #0]
      break;    
90004838:	e000      	b.n	9000483c <WM8994_GetFrequency+0xb8>
    default:
      break;    
9000483a:	bf00      	nop
    }
  }
  
  return ret;
9000483c:	68fb      	ldr	r3, [r7, #12]
}
9000483e:	4618      	mov	r0, r3
90004840:	3710      	adds	r7, #16
90004842:	46bd      	mov	sp, r7
90004844:	bd80      	pop	{r7, pc}
90004846:	bf00      	nop
90004848:	00017700 	.word	0x00017700

9000484c <WM8994_Reset>:
  * @brief Resets wm8994 registers.
  * @param pObj pointer to component object 
  * @retval Component status if correct communication, else wrong communication
  */
int32_t WM8994_Reset(WM8994_Object_t *pObj)
{
9000484c:	b580      	push	{r7, lr}
9000484e:	b084      	sub	sp, #16
90004850:	af00      	add	r7, sp, #0
90004852:	6078      	str	r0, [r7, #4]
  int32_t ret = WM8994_OK;
90004854:	2300      	movs	r3, #0
90004856:	60fb      	str	r3, [r7, #12]
  
  /* Reset Codec by writing in 0x0000 address register */
  if(wm8994_sw_reset_w(&pObj->Ctx, 0x0000) != WM8994_OK)
90004858:	687b      	ldr	r3, [r7, #4]
9000485a:	3318      	adds	r3, #24
9000485c:	2100      	movs	r1, #0
9000485e:	4618      	mov	r0, r3
90004860:	f000 f8ee 	bl	90004a40 <wm8994_sw_reset_w>
90004864:	4603      	mov	r3, r0
90004866:	2b00      	cmp	r3, #0
90004868:	d002      	beq.n	90004870 <WM8994_Reset+0x24>
  {
    ret = WM8994_ERROR;
9000486a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9000486e:	60fb      	str	r3, [r7, #12]
  }
  
  return ret;
90004870:	68fb      	ldr	r3, [r7, #12]
}
90004872:	4618      	mov	r0, r3
90004874:	3710      	adds	r7, #16
90004876:	46bd      	mov	sp, r7
90004878:	bd80      	pop	{r7, pc}
	...

9000487c <WM8994_RegisterBusIO>:
  * @brief  Function
  * @param  Component object pointer
  * @retval error status
  */
int32_t WM8994_RegisterBusIO (WM8994_Object_t *pObj, WM8994_IO_t *pIO)
{
9000487c:	b580      	push	{r7, lr}
9000487e:	b084      	sub	sp, #16
90004880:	af00      	add	r7, sp, #0
90004882:	6078      	str	r0, [r7, #4]
90004884:	6039      	str	r1, [r7, #0]
  int32_t ret;
  
  if (pObj == NULL)
90004886:	687b      	ldr	r3, [r7, #4]
90004888:	2b00      	cmp	r3, #0
9000488a:	d103      	bne.n	90004894 <WM8994_RegisterBusIO+0x18>
  {
    ret = WM8994_ERROR;
9000488c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90004890:	60fb      	str	r3, [r7, #12]
90004892:	e02c      	b.n	900048ee <WM8994_RegisterBusIO+0x72>
  }
  else
  {
    pObj->IO.Init      = pIO->Init;
90004894:	683b      	ldr	r3, [r7, #0]
90004896:	681a      	ldr	r2, [r3, #0]
90004898:	687b      	ldr	r3, [r7, #4]
9000489a:	601a      	str	r2, [r3, #0]
    pObj->IO.DeInit    = pIO->DeInit;
9000489c:	683b      	ldr	r3, [r7, #0]
9000489e:	685a      	ldr	r2, [r3, #4]
900048a0:	687b      	ldr	r3, [r7, #4]
900048a2:	605a      	str	r2, [r3, #4]
    pObj->IO.Address   = pIO->Address;
900048a4:	683b      	ldr	r3, [r7, #0]
900048a6:	891a      	ldrh	r2, [r3, #8]
900048a8:	687b      	ldr	r3, [r7, #4]
900048aa:	811a      	strh	r2, [r3, #8]
    pObj->IO.WriteReg  = pIO->WriteReg;
900048ac:	683b      	ldr	r3, [r7, #0]
900048ae:	68da      	ldr	r2, [r3, #12]
900048b0:	687b      	ldr	r3, [r7, #4]
900048b2:	60da      	str	r2, [r3, #12]
    pObj->IO.ReadReg   = pIO->ReadReg;
900048b4:	683b      	ldr	r3, [r7, #0]
900048b6:	691a      	ldr	r2, [r3, #16]
900048b8:	687b      	ldr	r3, [r7, #4]
900048ba:	611a      	str	r2, [r3, #16]
    pObj->IO.GetTick   = pIO->GetTick;
900048bc:	683b      	ldr	r3, [r7, #0]
900048be:	695a      	ldr	r2, [r3, #20]
900048c0:	687b      	ldr	r3, [r7, #4]
900048c2:	615a      	str	r2, [r3, #20]
    
    pObj->Ctx.ReadReg  = WM8994_ReadRegWrap;
900048c4:	687b      	ldr	r3, [r7, #4]
900048c6:	4a0c      	ldr	r2, [pc, #48]	; (900048f8 <WM8994_RegisterBusIO+0x7c>)
900048c8:	61da      	str	r2, [r3, #28]
    pObj->Ctx.WriteReg = WM8994_WriteRegWrap;
900048ca:	687b      	ldr	r3, [r7, #4]
900048cc:	4a0b      	ldr	r2, [pc, #44]	; (900048fc <WM8994_RegisterBusIO+0x80>)
900048ce:	619a      	str	r2, [r3, #24]
    pObj->Ctx.handle   = pObj;
900048d0:	687b      	ldr	r3, [r7, #4]
900048d2:	687a      	ldr	r2, [r7, #4]
900048d4:	621a      	str	r2, [r3, #32]
    
    if(pObj->IO.Init != NULL)
900048d6:	687b      	ldr	r3, [r7, #4]
900048d8:	681b      	ldr	r3, [r3, #0]
900048da:	2b00      	cmp	r3, #0
900048dc:	d004      	beq.n	900048e8 <WM8994_RegisterBusIO+0x6c>
    {
      ret = pObj->IO.Init();
900048de:	687b      	ldr	r3, [r7, #4]
900048e0:	681b      	ldr	r3, [r3, #0]
900048e2:	4798      	blx	r3
900048e4:	60f8      	str	r0, [r7, #12]
900048e6:	e002      	b.n	900048ee <WM8994_RegisterBusIO+0x72>
    }
    else
    {
      ret = WM8994_ERROR;
900048e8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900048ec:	60fb      	str	r3, [r7, #12]
    }
  }
  
  return ret;
900048ee:	68fb      	ldr	r3, [r7, #12]
}
900048f0:	4618      	mov	r0, r3
900048f2:	3710      	adds	r7, #16
900048f4:	46bd      	mov	sp, r7
900048f6:	bd80      	pop	{r7, pc}
900048f8:	90004935 	.word	0x90004935
900048fc:	90004967 	.word	0x90004967

90004900 <WM8994_Delay>:
  * @param pObj pointer to component object
  * @param Delay: specifies the delay time length, in milliseconds
  * @retval Component status
  */
static int32_t WM8994_Delay(WM8994_Object_t *pObj, uint32_t Delay)
{  
90004900:	b580      	push	{r7, lr}
90004902:	b084      	sub	sp, #16
90004904:	af00      	add	r7, sp, #0
90004906:	6078      	str	r0, [r7, #4]
90004908:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;

  tickstart = pObj->IO.GetTick();
9000490a:	687b      	ldr	r3, [r7, #4]
9000490c:	695b      	ldr	r3, [r3, #20]
9000490e:	4798      	blx	r3
90004910:	4603      	mov	r3, r0
90004912:	60fb      	str	r3, [r7, #12]
  while((pObj->IO.GetTick() - tickstart) < Delay)
90004914:	bf00      	nop
90004916:	687b      	ldr	r3, [r7, #4]
90004918:	695b      	ldr	r3, [r3, #20]
9000491a:	4798      	blx	r3
9000491c:	4603      	mov	r3, r0
9000491e:	461a      	mov	r2, r3
90004920:	68fb      	ldr	r3, [r7, #12]
90004922:	1ad3      	subs	r3, r2, r3
90004924:	683a      	ldr	r2, [r7, #0]
90004926:	429a      	cmp	r2, r3
90004928:	d8f5      	bhi.n	90004916 <WM8994_Delay+0x16>
  {
  }
  return WM8994_OK;
9000492a:	2300      	movs	r3, #0
}
9000492c:	4618      	mov	r0, r3
9000492e:	3710      	adds	r7, #16
90004930:	46bd      	mov	sp, r7
90004932:	bd80      	pop	{r7, pc}

90004934 <WM8994_ReadRegWrap>:
  * @param  pData   The target register value to be written
  * @param  Length  buffer size to be written
  * @retval error status
  */
static int32_t WM8994_ReadRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
90004934:	b590      	push	{r4, r7, lr}
90004936:	b087      	sub	sp, #28
90004938:	af00      	add	r7, sp, #0
9000493a:	60f8      	str	r0, [r7, #12]
9000493c:	607a      	str	r2, [r7, #4]
9000493e:	461a      	mov	r2, r3
90004940:	460b      	mov	r3, r1
90004942:	817b      	strh	r3, [r7, #10]
90004944:	4613      	mov	r3, r2
90004946:	813b      	strh	r3, [r7, #8]
  WM8994_Object_t *pObj = (WM8994_Object_t *)handle;
90004948:	68fb      	ldr	r3, [r7, #12]
9000494a:	617b      	str	r3, [r7, #20]

  return pObj->IO.ReadReg(pObj->IO.Address, Reg, pData, Length);
9000494c:	697b      	ldr	r3, [r7, #20]
9000494e:	691c      	ldr	r4, [r3, #16]
90004950:	697b      	ldr	r3, [r7, #20]
90004952:	8918      	ldrh	r0, [r3, #8]
90004954:	893b      	ldrh	r3, [r7, #8]
90004956:	8979      	ldrh	r1, [r7, #10]
90004958:	687a      	ldr	r2, [r7, #4]
9000495a:	47a0      	blx	r4
9000495c:	4603      	mov	r3, r0
}
9000495e:	4618      	mov	r0, r3
90004960:	371c      	adds	r7, #28
90004962:	46bd      	mov	sp, r7
90004964:	bd90      	pop	{r4, r7, pc}

90004966 <WM8994_WriteRegWrap>:
  * @param  pData  The target register value to be written
  * @param  Length buffer size to be written
  * @retval error status
  */
static int32_t WM8994_WriteRegWrap(void *handle, uint16_t Reg, uint8_t* pData, uint16_t Length)
{
90004966:	b590      	push	{r4, r7, lr}
90004968:	b087      	sub	sp, #28
9000496a:	af00      	add	r7, sp, #0
9000496c:	60f8      	str	r0, [r7, #12]
9000496e:	607a      	str	r2, [r7, #4]
90004970:	461a      	mov	r2, r3
90004972:	460b      	mov	r3, r1
90004974:	817b      	strh	r3, [r7, #10]
90004976:	4613      	mov	r3, r2
90004978:	813b      	strh	r3, [r7, #8]
  WM8994_Object_t *pObj = (WM8994_Object_t *)handle;
9000497a:	68fb      	ldr	r3, [r7, #12]
9000497c:	617b      	str	r3, [r7, #20]

  return pObj->IO.WriteReg(pObj->IO.Address, Reg, pData, Length);
9000497e:	697b      	ldr	r3, [r7, #20]
90004980:	68dc      	ldr	r4, [r3, #12]
90004982:	697b      	ldr	r3, [r7, #20]
90004984:	8918      	ldrh	r0, [r3, #8]
90004986:	893b      	ldrh	r3, [r7, #8]
90004988:	8979      	ldrh	r1, [r7, #10]
9000498a:	687a      	ldr	r2, [r7, #4]
9000498c:	47a0      	blx	r4
9000498e:	4603      	mov	r3, r0
}
90004990:	4618      	mov	r0, r3
90004992:	371c      	adds	r7, #28
90004994:	46bd      	mov	sp, r7
90004996:	bd90      	pop	{r4, r7, pc}

90004998 <wm8994_read_reg>:
*                 I2C or SPI reading functions
* Input         : Register Address, length of buffer
* Output        : data Read
*******************************************************************************/
int32_t wm8994_read_reg(wm8994_ctx_t *ctx, uint16_t reg, uint16_t* data, uint16_t length)
{
90004998:	b590      	push	{r4, r7, lr}
9000499a:	b087      	sub	sp, #28
9000499c:	af00      	add	r7, sp, #0
9000499e:	60f8      	str	r0, [r7, #12]
900049a0:	607a      	str	r2, [r7, #4]
900049a2:	461a      	mov	r2, r3
900049a4:	460b      	mov	r3, r1
900049a6:	817b      	strh	r3, [r7, #10]
900049a8:	4613      	mov	r3, r2
900049aa:	813b      	strh	r3, [r7, #8]
  int32_t ret;
  uint16_t tmp;
  
  ret = ctx->ReadReg(ctx->handle, reg, (uint8_t *)data, length);
900049ac:	68fb      	ldr	r3, [r7, #12]
900049ae:	685c      	ldr	r4, [r3, #4]
900049b0:	68fb      	ldr	r3, [r7, #12]
900049b2:	6898      	ldr	r0, [r3, #8]
900049b4:	893b      	ldrh	r3, [r7, #8]
900049b6:	8979      	ldrh	r1, [r7, #10]
900049b8:	687a      	ldr	r2, [r7, #4]
900049ba:	47a0      	blx	r4
900049bc:	6178      	str	r0, [r7, #20]
  
  if(ret >= 0)
900049be:	697b      	ldr	r3, [r7, #20]
900049c0:	2b00      	cmp	r3, #0
900049c2:	db10      	blt.n	900049e6 <wm8994_read_reg+0x4e>
  {
    tmp = ((uint16_t)(*data >> 8) & 0x00FF);
900049c4:	687b      	ldr	r3, [r7, #4]
900049c6:	881b      	ldrh	r3, [r3, #0]
900049c8:	0a1b      	lsrs	r3, r3, #8
900049ca:	827b      	strh	r3, [r7, #18]
    tmp |= ((uint16_t)(*data << 8) & 0xFF00);
900049cc:	687b      	ldr	r3, [r7, #4]
900049ce:	881b      	ldrh	r3, [r3, #0]
900049d0:	021b      	lsls	r3, r3, #8
900049d2:	b29b      	uxth	r3, r3
900049d4:	b21a      	sxth	r2, r3
900049d6:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
900049da:	4313      	orrs	r3, r2
900049dc:	b21b      	sxth	r3, r3
900049de:	827b      	strh	r3, [r7, #18]
    *data = tmp;
900049e0:	687b      	ldr	r3, [r7, #4]
900049e2:	8a7a      	ldrh	r2, [r7, #18]
900049e4:	801a      	strh	r2, [r3, #0]
  }
  return ret;
900049e6:	697b      	ldr	r3, [r7, #20]
}
900049e8:	4618      	mov	r0, r3
900049ea:	371c      	adds	r7, #28
900049ec:	46bd      	mov	sp, r7
900049ee:	bd90      	pop	{r4, r7, pc}

900049f0 <wm8994_write_reg>:
*                 I2C or SPI writing function
* Input         : Register Address, data to be written, length of buffer
* Output        : None
*******************************************************************************/
int32_t wm8994_write_reg(wm8994_ctx_t *ctx, uint16_t reg, uint16_t *data, uint16_t length)
{
900049f0:	b590      	push	{r4, r7, lr}
900049f2:	b087      	sub	sp, #28
900049f4:	af00      	add	r7, sp, #0
900049f6:	60f8      	str	r0, [r7, #12]
900049f8:	607a      	str	r2, [r7, #4]
900049fa:	461a      	mov	r2, r3
900049fc:	460b      	mov	r3, r1
900049fe:	817b      	strh	r3, [r7, #10]
90004a00:	4613      	mov	r3, r2
90004a02:	813b      	strh	r3, [r7, #8]
  uint16_t tmp;
  tmp = ((uint16_t)(*data >> 8) & 0x00FF);
90004a04:	687b      	ldr	r3, [r7, #4]
90004a06:	881b      	ldrh	r3, [r3, #0]
90004a08:	0a1b      	lsrs	r3, r3, #8
90004a0a:	b29b      	uxth	r3, r3
90004a0c:	82fb      	strh	r3, [r7, #22]
  tmp |= ((uint16_t)(*data << 8) & 0xFF00);
90004a0e:	687b      	ldr	r3, [r7, #4]
90004a10:	881b      	ldrh	r3, [r3, #0]
90004a12:	021b      	lsls	r3, r3, #8
90004a14:	b29b      	uxth	r3, r3
90004a16:	b21a      	sxth	r2, r3
90004a18:	8afb      	ldrh	r3, [r7, #22]
90004a1a:	b21b      	sxth	r3, r3
90004a1c:	4313      	orrs	r3, r2
90004a1e:	b21b      	sxth	r3, r3
90004a20:	b29b      	uxth	r3, r3
90004a22:	82fb      	strh	r3, [r7, #22]
  
  return ctx->WriteReg(ctx->handle, reg, (uint8_t *)&tmp, length);
90004a24:	68fb      	ldr	r3, [r7, #12]
90004a26:	681c      	ldr	r4, [r3, #0]
90004a28:	68fb      	ldr	r3, [r7, #12]
90004a2a:	6898      	ldr	r0, [r3, #8]
90004a2c:	893b      	ldrh	r3, [r7, #8]
90004a2e:	f107 0216 	add.w	r2, r7, #22
90004a32:	8979      	ldrh	r1, [r7, #10]
90004a34:	47a0      	blx	r4
90004a36:	4603      	mov	r3, r0
}
90004a38:	4618      	mov	r0, r3
90004a3a:	371c      	adds	r7, #28
90004a3c:	46bd      	mov	sp, r7
90004a3e:	bd90      	pop	{r4, r7, pc}

90004a40 <wm8994_sw_reset_w>:
* Input          : uint16_t
* Output         : None
* Return         : Status [WM8994_ERROR, WM8994_OK]
*******************************************************************************/
int32_t  wm8994_sw_reset_w(wm8994_ctx_t *ctx, uint16_t value)
{
90004a40:	b580      	push	{r7, lr}
90004a42:	b082      	sub	sp, #8
90004a44:	af00      	add	r7, sp, #0
90004a46:	6078      	str	r0, [r7, #4]
90004a48:	460b      	mov	r3, r1
90004a4a:	807b      	strh	r3, [r7, #2]
  return wm8994_write_reg(ctx, WM8994_SW_RESET, &value, 2);
90004a4c:	1cba      	adds	r2, r7, #2
90004a4e:	2302      	movs	r3, #2
90004a50:	2100      	movs	r1, #0
90004a52:	6878      	ldr	r0, [r7, #4]
90004a54:	f7ff ffcc 	bl	900049f0 <wm8994_write_reg>
90004a58:	4603      	mov	r3, r0
}
90004a5a:	4618      	mov	r0, r3
90004a5c:	3708      	adds	r7, #8
90004a5e:	46bd      	mov	sp, r7
90004a60:	bd80      	pop	{r7, pc}

90004a62 <wm8994_sw_reset_r>:
* Input          : Pointer to uint8_t
* Output         : None
* Return         : Status [WM8994_ERROR, WM8994_OK]
*******************************************************************************/
int32_t  wm8994_sw_reset_r(wm8994_ctx_t *ctx, uint16_t *value)
{
90004a62:	b580      	push	{r7, lr}
90004a64:	b082      	sub	sp, #8
90004a66:	af00      	add	r7, sp, #0
90004a68:	6078      	str	r0, [r7, #4]
90004a6a:	6039      	str	r1, [r7, #0]
  return wm8994_read_reg(ctx, WM8994_SW_RESET, value, 2);
90004a6c:	2302      	movs	r3, #2
90004a6e:	683a      	ldr	r2, [r7, #0]
90004a70:	2100      	movs	r1, #0
90004a72:	6878      	ldr	r0, [r7, #4]
90004a74:	f7ff ff90 	bl	90004998 <wm8994_read_reg>
90004a78:	4603      	mov	r3, r0
}
90004a7a:	4618      	mov	r0, r3
90004a7c:	3708      	adds	r7, #8
90004a7e:	46bd      	mov	sp, r7
90004a80:	bd80      	pop	{r7, pc}

90004a82 <wm8994_lo_hpout1l_vol_r>:
* Input          : uint16_t
* Output         : None
* Return         : Status [WM8994_ERROR, WM8994_OK]
*******************************************************************************/
int32_t  wm8994_lo_hpout1l_vol_r(wm8994_ctx_t *ctx, uint16_t *value)
{
90004a82:	b580      	push	{r7, lr}
90004a84:	b084      	sub	sp, #16
90004a86:	af00      	add	r7, sp, #0
90004a88:	6078      	str	r0, [r7, #4]
90004a8a:	6039      	str	r1, [r7, #0]
  int32_t ret;
  
  ret = wm8994_read_reg(ctx, WM8994_LEFT_OUTPUT_VOL, value, 2);
90004a8c:	2302      	movs	r3, #2
90004a8e:	683a      	ldr	r2, [r7, #0]
90004a90:	211c      	movs	r1, #28
90004a92:	6878      	ldr	r0, [r7, #4]
90004a94:	f7ff ff80 	bl	90004998 <wm8994_read_reg>
90004a98:	60f8      	str	r0, [r7, #12]

  if(ret == 0)
90004a9a:	68fb      	ldr	r3, [r7, #12]
90004a9c:	2b00      	cmp	r3, #0
90004a9e:	d10a      	bne.n	90004ab6 <wm8994_lo_hpout1l_vol_r+0x34>
  {  
  *value &= WM8994_LO_HPOUT1L_VOL_MASK;
90004aa0:	683b      	ldr	r3, [r7, #0]
90004aa2:	881b      	ldrh	r3, [r3, #0]
90004aa4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
90004aa8:	b29a      	uxth	r2, r3
90004aaa:	683b      	ldr	r3, [r7, #0]
90004aac:	801a      	strh	r2, [r3, #0]
  *value = *value >> WM8994_LO_HPOUT1L_VOL_POSITION;
90004aae:	683b      	ldr	r3, [r7, #0]
90004ab0:	881a      	ldrh	r2, [r3, #0]
90004ab2:	683b      	ldr	r3, [r7, #0]
90004ab4:	801a      	strh	r2, [r3, #0]
  }
  
  return ret;
90004ab6:	68fb      	ldr	r3, [r7, #12]
}
90004ab8:	4618      	mov	r0, r3
90004aba:	3710      	adds	r7, #16
90004abc:	46bd      	mov	sp, r7
90004abe:	bd80      	pop	{r7, pc}

90004ac0 <wm8994_aif1_sr_r>:
* Input          : uint16_t
* Output         : None
* Return         : Status [WM8994_ERROR, WM8994_OK]
*******************************************************************************/
int32_t  wm8994_aif1_sr_r(wm8994_ctx_t *ctx, uint16_t *value)
{
90004ac0:	b580      	push	{r7, lr}
90004ac2:	b084      	sub	sp, #16
90004ac4:	af00      	add	r7, sp, #0
90004ac6:	6078      	str	r0, [r7, #4]
90004ac8:	6039      	str	r1, [r7, #0]
  int32_t ret;
  
  ret = wm8994_read_reg(ctx, WM8994_AIF1_RATE, value, 2);
90004aca:	2302      	movs	r3, #2
90004acc:	683a      	ldr	r2, [r7, #0]
90004ace:	f44f 7104 	mov.w	r1, #528	; 0x210
90004ad2:	6878      	ldr	r0, [r7, #4]
90004ad4:	f7ff ff60 	bl	90004998 <wm8994_read_reg>
90004ad8:	60f8      	str	r0, [r7, #12]

  if(ret == 0)
90004ada:	68fb      	ldr	r3, [r7, #12]
90004adc:	2b00      	cmp	r3, #0
90004ade:	d10c      	bne.n	90004afa <wm8994_aif1_sr_r+0x3a>
  {  
  *value &= WM8994_AIF1_SR_MASK;
90004ae0:	683b      	ldr	r3, [r7, #0]
90004ae2:	881b      	ldrh	r3, [r3, #0]
90004ae4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
90004ae8:	b29a      	uxth	r2, r3
90004aea:	683b      	ldr	r3, [r7, #0]
90004aec:	801a      	strh	r2, [r3, #0]
  *value = *value >> WM8994_AIF1_SR_POSITION;
90004aee:	683b      	ldr	r3, [r7, #0]
90004af0:	881b      	ldrh	r3, [r3, #0]
90004af2:	091b      	lsrs	r3, r3, #4
90004af4:	b29a      	uxth	r2, r3
90004af6:	683b      	ldr	r3, [r7, #0]
90004af8:	801a      	strh	r2, [r3, #0]
  }
  
  return ret;
90004afa:	68fb      	ldr	r3, [r7, #12]
}
90004afc:	4618      	mov	r0, r3
90004afe:	3710      	adds	r7, #16
90004b00:	46bd      	mov	sp, r7
90004b02:	bd80      	pop	{r7, pc}

90004b04 <wm8994_aif1_control1_fmt>:
* Input          : uint16_t
* Output         : None
* Return         : Status [WM8994_ERROR, WM8994_OK]
*******************************************************************************/
int32_t  wm8994_aif1_control1_fmt(wm8994_ctx_t *ctx, uint16_t value)
{
90004b04:	b580      	push	{r7, lr}
90004b06:	b084      	sub	sp, #16
90004b08:	af00      	add	r7, sp, #0
90004b0a:	6078      	str	r0, [r7, #4]
90004b0c:	460b      	mov	r3, r1
90004b0e:	807b      	strh	r3, [r7, #2]
  int32_t ret;
  uint16_t tmp = 0;
90004b10:	2300      	movs	r3, #0
90004b12:	817b      	strh	r3, [r7, #10]
  
  ret = wm8994_read_reg(ctx, WM8994_AIF1_CONTROL1, &tmp, 2);
90004b14:	f107 020a 	add.w	r2, r7, #10
90004b18:	2302      	movs	r3, #2
90004b1a:	f44f 7140 	mov.w	r1, #768	; 0x300
90004b1e:	6878      	ldr	r0, [r7, #4]
90004b20:	f7ff ff3a 	bl	90004998 <wm8994_read_reg>
90004b24:	60f8      	str	r0, [r7, #12]

  if(ret == 0)
90004b26:	68fb      	ldr	r3, [r7, #12]
90004b28:	2b00      	cmp	r3, #0
90004b2a:	d116      	bne.n	90004b5a <wm8994_aif1_control1_fmt+0x56>
  {
    tmp &= ~WM8994_AIF1_CONTROL1_FMT_MASK;
90004b2c:	897b      	ldrh	r3, [r7, #10]
90004b2e:	f023 0318 	bic.w	r3, r3, #24
90004b32:	b29b      	uxth	r3, r3
90004b34:	817b      	strh	r3, [r7, #10]
    tmp |= value << WM8994_AIF1_CONTROL1_FMT_POSITION;
90004b36:	887b      	ldrh	r3, [r7, #2]
90004b38:	00db      	lsls	r3, r3, #3
90004b3a:	b21a      	sxth	r2, r3
90004b3c:	897b      	ldrh	r3, [r7, #10]
90004b3e:	b21b      	sxth	r3, r3
90004b40:	4313      	orrs	r3, r2
90004b42:	b21b      	sxth	r3, r3
90004b44:	b29b      	uxth	r3, r3
90004b46:	817b      	strh	r3, [r7, #10]
    
    ret = wm8994_write_reg(ctx, WM8994_AIF1_CONTROL1, &tmp, 2);
90004b48:	f107 020a 	add.w	r2, r7, #10
90004b4c:	2302      	movs	r3, #2
90004b4e:	f44f 7140 	mov.w	r1, #768	; 0x300
90004b52:	6878      	ldr	r0, [r7, #4]
90004b54:	f7ff ff4c 	bl	900049f0 <wm8994_write_reg>
90004b58:	60f8      	str	r0, [r7, #12]
  }
  
  return ret;
90004b5a:	68fb      	ldr	r3, [r7, #12]
}
90004b5c:	4618      	mov	r0, r3
90004b5e:	3710      	adds	r7, #16
90004b60:	46bd      	mov	sp, r7
90004b62:	bd80      	pop	{r7, pc}

90004b64 <wm8994_aif1_control1_fmt_r>:
* Input          : uint16_t
* Output         : None
* Return         : Status [WM8994_ERROR, WM8994_OK]
*******************************************************************************/
int32_t  wm8994_aif1_control1_fmt_r(wm8994_ctx_t *ctx, uint16_t *value)
{
90004b64:	b580      	push	{r7, lr}
90004b66:	b084      	sub	sp, #16
90004b68:	af00      	add	r7, sp, #0
90004b6a:	6078      	str	r0, [r7, #4]
90004b6c:	6039      	str	r1, [r7, #0]
  int32_t ret;
  
  ret = wm8994_read_reg(ctx, WM8994_AIF1_CONTROL1, value, 2);
90004b6e:	2302      	movs	r3, #2
90004b70:	683a      	ldr	r2, [r7, #0]
90004b72:	f44f 7140 	mov.w	r1, #768	; 0x300
90004b76:	6878      	ldr	r0, [r7, #4]
90004b78:	f7ff ff0e 	bl	90004998 <wm8994_read_reg>
90004b7c:	60f8      	str	r0, [r7, #12]

  if(ret == 0)
90004b7e:	68fb      	ldr	r3, [r7, #12]
90004b80:	2b00      	cmp	r3, #0
90004b82:	d10c      	bne.n	90004b9e <wm8994_aif1_control1_fmt_r+0x3a>
  {  
  *value &= WM8994_AIF1_CONTROL1_FMT_MASK;
90004b84:	683b      	ldr	r3, [r7, #0]
90004b86:	881b      	ldrh	r3, [r3, #0]
90004b88:	f003 0318 	and.w	r3, r3, #24
90004b8c:	b29a      	uxth	r2, r3
90004b8e:	683b      	ldr	r3, [r7, #0]
90004b90:	801a      	strh	r2, [r3, #0]
  *value = *value >> WM8994_AIF1_CONTROL1_FMT_POSITION;
90004b92:	683b      	ldr	r3, [r7, #0]
90004b94:	881b      	ldrh	r3, [r3, #0]
90004b96:	08db      	lsrs	r3, r3, #3
90004b98:	b29a      	uxth	r2, r3
90004b9a:	683b      	ldr	r3, [r7, #0]
90004b9c:	801a      	strh	r2, [r3, #0]
  }
  
  return ret;
90004b9e:	68fb      	ldr	r3, [r7, #12]
}
90004ba0:	4618      	mov	r0, r3
90004ba2:	3710      	adds	r7, #16
90004ba4:	46bd      	mov	sp, r7
90004ba6:	bd80      	pop	{r7, pc}

90004ba8 <wm8994_aif1_control1_wl>:
* Input          : uint16_t
* Output         : None
* Return         : Status [WM8994_ERROR, WM8994_OK]
*******************************************************************************/
int32_t  wm8994_aif1_control1_wl(wm8994_ctx_t *ctx, uint16_t value)
{
90004ba8:	b580      	push	{r7, lr}
90004baa:	b084      	sub	sp, #16
90004bac:	af00      	add	r7, sp, #0
90004bae:	6078      	str	r0, [r7, #4]
90004bb0:	460b      	mov	r3, r1
90004bb2:	807b      	strh	r3, [r7, #2]
  int32_t ret;
  uint16_t tmp = 0;
90004bb4:	2300      	movs	r3, #0
90004bb6:	817b      	strh	r3, [r7, #10]
  
  ret = wm8994_read_reg(ctx, WM8994_AIF1_CONTROL1, &tmp, 2);
90004bb8:	f107 020a 	add.w	r2, r7, #10
90004bbc:	2302      	movs	r3, #2
90004bbe:	f44f 7140 	mov.w	r1, #768	; 0x300
90004bc2:	6878      	ldr	r0, [r7, #4]
90004bc4:	f7ff fee8 	bl	90004998 <wm8994_read_reg>
90004bc8:	60f8      	str	r0, [r7, #12]

  if(ret == 0)
90004bca:	68fb      	ldr	r3, [r7, #12]
90004bcc:	2b00      	cmp	r3, #0
90004bce:	d116      	bne.n	90004bfe <wm8994_aif1_control1_wl+0x56>
  {
    tmp &= ~WM8994_AIF1_CONTROL1_WL_MASK;
90004bd0:	897b      	ldrh	r3, [r7, #10]
90004bd2:	f023 0360 	bic.w	r3, r3, #96	; 0x60
90004bd6:	b29b      	uxth	r3, r3
90004bd8:	817b      	strh	r3, [r7, #10]
    tmp |= value << WM8994_AIF1_CONTROL1_WL_POSITION;
90004bda:	887b      	ldrh	r3, [r7, #2]
90004bdc:	015b      	lsls	r3, r3, #5
90004bde:	b21a      	sxth	r2, r3
90004be0:	897b      	ldrh	r3, [r7, #10]
90004be2:	b21b      	sxth	r3, r3
90004be4:	4313      	orrs	r3, r2
90004be6:	b21b      	sxth	r3, r3
90004be8:	b29b      	uxth	r3, r3
90004bea:	817b      	strh	r3, [r7, #10]
    
    ret = wm8994_write_reg(ctx, WM8994_AIF1_CONTROL1, &tmp, 2);
90004bec:	f107 020a 	add.w	r2, r7, #10
90004bf0:	2302      	movs	r3, #2
90004bf2:	f44f 7140 	mov.w	r1, #768	; 0x300
90004bf6:	6878      	ldr	r0, [r7, #4]
90004bf8:	f7ff fefa 	bl	900049f0 <wm8994_write_reg>
90004bfc:	60f8      	str	r0, [r7, #12]
  }
  
  return ret;
90004bfe:	68fb      	ldr	r3, [r7, #12]
}
90004c00:	4618      	mov	r0, r3
90004c02:	3710      	adds	r7, #16
90004c04:	46bd      	mov	sp, r7
90004c06:	bd80      	pop	{r7, pc}

90004c08 <wm8994_aif1_control1_wl_r>:
* Input          : uint16_t
* Output         : None
* Return         : Status [WM8994_ERROR, WM8994_OK]
*******************************************************************************/
int32_t  wm8994_aif1_control1_wl_r(wm8994_ctx_t *ctx, uint16_t *value)
{
90004c08:	b580      	push	{r7, lr}
90004c0a:	b084      	sub	sp, #16
90004c0c:	af00      	add	r7, sp, #0
90004c0e:	6078      	str	r0, [r7, #4]
90004c10:	6039      	str	r1, [r7, #0]
  int32_t ret;
  
  ret = wm8994_read_reg(ctx, WM8994_AIF1_CONTROL1, value, 2);
90004c12:	2302      	movs	r3, #2
90004c14:	683a      	ldr	r2, [r7, #0]
90004c16:	f44f 7140 	mov.w	r1, #768	; 0x300
90004c1a:	6878      	ldr	r0, [r7, #4]
90004c1c:	f7ff febc 	bl	90004998 <wm8994_read_reg>
90004c20:	60f8      	str	r0, [r7, #12]

  if(ret == 0)
90004c22:	68fb      	ldr	r3, [r7, #12]
90004c24:	2b00      	cmp	r3, #0
90004c26:	d10c      	bne.n	90004c42 <wm8994_aif1_control1_wl_r+0x3a>
  {  
  *value &= WM8994_AIF1_CONTROL1_WL_MASK;
90004c28:	683b      	ldr	r3, [r7, #0]
90004c2a:	881b      	ldrh	r3, [r3, #0]
90004c2c:	f003 0360 	and.w	r3, r3, #96	; 0x60
90004c30:	b29a      	uxth	r2, r3
90004c32:	683b      	ldr	r3, [r7, #0]
90004c34:	801a      	strh	r2, [r3, #0]
  *value = *value >> WM8994_AIF1_CONTROL1_WL_POSITION;
90004c36:	683b      	ldr	r3, [r7, #0]
90004c38:	881b      	ldrh	r3, [r3, #0]
90004c3a:	095b      	lsrs	r3, r3, #5
90004c3c:	b29a      	uxth	r2, r3
90004c3e:	683b      	ldr	r3, [r7, #0]
90004c40:	801a      	strh	r2, [r3, #0]
  }
  
  return ret;
90004c42:	68fb      	ldr	r3, [r7, #12]
}
90004c44:	4618      	mov	r0, r3
90004c46:	3710      	adds	r7, #16
90004c48:	46bd      	mov	sp, r7
90004c4a:	bd80      	pop	{r7, pc}

90004c4c <wm8994_aif1_control1_adcr_src>:
* Input          : uint16_t
* Output         : None
* Return         : Status [WM8994_ERROR, WM8994_OK]
*******************************************************************************/
int32_t  wm8994_aif1_control1_adcr_src(wm8994_ctx_t *ctx, uint16_t value)
{
90004c4c:	b580      	push	{r7, lr}
90004c4e:	b084      	sub	sp, #16
90004c50:	af00      	add	r7, sp, #0
90004c52:	6078      	str	r0, [r7, #4]
90004c54:	460b      	mov	r3, r1
90004c56:	807b      	strh	r3, [r7, #2]
  int32_t ret;
  uint16_t tmp = 0;
90004c58:	2300      	movs	r3, #0
90004c5a:	817b      	strh	r3, [r7, #10]
  
  ret = wm8994_read_reg(ctx, WM8994_AIF1_CONTROL1, &tmp, 2);
90004c5c:	f107 020a 	add.w	r2, r7, #10
90004c60:	2302      	movs	r3, #2
90004c62:	f44f 7140 	mov.w	r1, #768	; 0x300
90004c66:	6878      	ldr	r0, [r7, #4]
90004c68:	f7ff fe96 	bl	90004998 <wm8994_read_reg>
90004c6c:	60f8      	str	r0, [r7, #12]

  if(ret == 0)
90004c6e:	68fb      	ldr	r3, [r7, #12]
90004c70:	2b00      	cmp	r3, #0
90004c72:	d116      	bne.n	90004ca2 <wm8994_aif1_control1_adcr_src+0x56>
  {
    tmp &= ~WM8994_AIF1_CONTROL1_ADCR_SRC_MASK;
90004c74:	897b      	ldrh	r3, [r7, #10]
90004c76:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
90004c7a:	b29b      	uxth	r3, r3
90004c7c:	817b      	strh	r3, [r7, #10]
    tmp |= value << WM8994_AIF1_CONTROL1_ADCR_SRC_POSITION;
90004c7e:	887b      	ldrh	r3, [r7, #2]
90004c80:	039b      	lsls	r3, r3, #14
90004c82:	b21a      	sxth	r2, r3
90004c84:	897b      	ldrh	r3, [r7, #10]
90004c86:	b21b      	sxth	r3, r3
90004c88:	4313      	orrs	r3, r2
90004c8a:	b21b      	sxth	r3, r3
90004c8c:	b29b      	uxth	r3, r3
90004c8e:	817b      	strh	r3, [r7, #10]
    
    ret = wm8994_write_reg(ctx, WM8994_AIF1_CONTROL1, &tmp, 2);
90004c90:	f107 020a 	add.w	r2, r7, #10
90004c94:	2302      	movs	r3, #2
90004c96:	f44f 7140 	mov.w	r1, #768	; 0x300
90004c9a:	6878      	ldr	r0, [r7, #4]
90004c9c:	f7ff fea8 	bl	900049f0 <wm8994_write_reg>
90004ca0:	60f8      	str	r0, [r7, #12]
  }
  
  return ret;
90004ca2:	68fb      	ldr	r3, [r7, #12]
}
90004ca4:	4618      	mov	r0, r3
90004ca6:	3710      	adds	r7, #16
90004ca8:	46bd      	mov	sp, r7
90004caa:	bd80      	pop	{r7, pc}

90004cac <wm8994_aif1_adc1_left_vol_adc1l_r>:
* Input          : uint16_t
* Output         : None
* Return         : Status [WM8994_ERROR, WM8994_OK]
*******************************************************************************/
int32_t  wm8994_aif1_adc1_left_vol_adc1l_r(wm8994_ctx_t *ctx, uint16_t *value)
{
90004cac:	b580      	push	{r7, lr}
90004cae:	b084      	sub	sp, #16
90004cb0:	af00      	add	r7, sp, #0
90004cb2:	6078      	str	r0, [r7, #4]
90004cb4:	6039      	str	r1, [r7, #0]
  int32_t ret;
  
  ret = wm8994_read_reg(ctx, WM8994_AIF1_ADC1_LEFT_VOL, value, 2);
90004cb6:	2302      	movs	r3, #2
90004cb8:	683a      	ldr	r2, [r7, #0]
90004cba:	f44f 6180 	mov.w	r1, #1024	; 0x400
90004cbe:	6878      	ldr	r0, [r7, #4]
90004cc0:	f7ff fe6a 	bl	90004998 <wm8994_read_reg>
90004cc4:	60f8      	str	r0, [r7, #12]
  
  if(ret == 0)
90004cc6:	68fb      	ldr	r3, [r7, #12]
90004cc8:	2b00      	cmp	r3, #0
90004cca:	d109      	bne.n	90004ce0 <wm8994_aif1_adc1_left_vol_adc1l_r+0x34>
  {  
  *value &= WM8994_AIF1_ADC1_LEFT_VOL_ADC1L_MASK;
90004ccc:	683b      	ldr	r3, [r7, #0]
90004cce:	881b      	ldrh	r3, [r3, #0]
90004cd0:	b2db      	uxtb	r3, r3
90004cd2:	b29a      	uxth	r2, r3
90004cd4:	683b      	ldr	r3, [r7, #0]
90004cd6:	801a      	strh	r2, [r3, #0]
  *value = *value >> WM8994_AIF1_ADC1_LEFT_VOL_ADC1L_POSITION;
90004cd8:	683b      	ldr	r3, [r7, #0]
90004cda:	881a      	ldrh	r2, [r3, #0]
90004cdc:	683b      	ldr	r3, [r7, #0]
90004cde:	801a      	strh	r2, [r3, #0]
  }
  
  return ret;
90004ce0:	68fb      	ldr	r3, [r7, #12]
}
90004ce2:	4618      	mov	r0, r3
90004ce4:	3710      	adds	r7, #16
90004ce6:	46bd      	mov	sp, r7
90004ce8:	bd80      	pop	{r7, pc}
	...

90004cec <BSP_LED_Init>:
  *            @arg  LED1
  *            @arg  LED2
  * @retval BSP status
  */
int32_t  BSP_LED_Init(Led_TypeDef Led)
{
90004cec:	b580      	push	{r7, lr}
90004cee:	b08a      	sub	sp, #40	; 0x28
90004cf0:	af00      	add	r7, sp, #0
90004cf2:	4603      	mov	r3, r0
90004cf4:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
90004cf6:	2300      	movs	r3, #0
90004cf8:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitTypeDef  gpio_init_structure;

  /* Enable the GPIO_LED clock */
  if (Led == LED1)
90004cfa:	79fb      	ldrb	r3, [r7, #7]
90004cfc:	2b00      	cmp	r3, #0
90004cfe:	d10f      	bne.n	90004d20 <BSP_LED_Init+0x34>
  {
    LED1_GPIO_CLK_ENABLE() ;
90004d00:	4b26      	ldr	r3, [pc, #152]	; (90004d9c <BSP_LED_Init+0xb0>)
90004d02:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90004d06:	4a25      	ldr	r2, [pc, #148]	; (90004d9c <BSP_LED_Init+0xb0>)
90004d08:	f443 7300 	orr.w	r3, r3, #512	; 0x200
90004d0c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90004d10:	4b22      	ldr	r3, [pc, #136]	; (90004d9c <BSP_LED_Init+0xb0>)
90004d12:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90004d16:	f403 7300 	and.w	r3, r3, #512	; 0x200
90004d1a:	60fb      	str	r3, [r7, #12]
90004d1c:	68fb      	ldr	r3, [r7, #12]
90004d1e:	e015      	b.n	90004d4c <BSP_LED_Init+0x60>
  }
  else if (Led == LED2)
90004d20:	79fb      	ldrb	r3, [r7, #7]
90004d22:	2b01      	cmp	r3, #1
90004d24:	d10f      	bne.n	90004d46 <BSP_LED_Init+0x5a>
  {
    LED2_GPIO_CLK_ENABLE() ;
90004d26:	4b1d      	ldr	r3, [pc, #116]	; (90004d9c <BSP_LED_Init+0xb0>)
90004d28:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90004d2c:	4a1b      	ldr	r2, [pc, #108]	; (90004d9c <BSP_LED_Init+0xb0>)
90004d2e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90004d32:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90004d36:	4b19      	ldr	r3, [pc, #100]	; (90004d9c <BSP_LED_Init+0xb0>)
90004d38:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90004d3c:	f403 7380 	and.w	r3, r3, #256	; 0x100
90004d40:	60bb      	str	r3, [r7, #8]
90004d42:	68bb      	ldr	r3, [r7, #8]
90004d44:	e002      	b.n	90004d4c <BSP_LED_Init+0x60>
  }
  else
  {
    ret = BSP_ERROR_WRONG_PARAM;
90004d46:	f06f 0301 	mvn.w	r3, #1
90004d4a:	627b      	str	r3, [r7, #36]	; 0x24
  }

  /* configure the GPIO_LED pin */
  gpio_init_structure.Pin = LED_PIN [Led];
90004d4c:	79fb      	ldrb	r3, [r7, #7]
90004d4e:	4a14      	ldr	r2, [pc, #80]	; (90004da0 <BSP_LED_Init+0xb4>)
90004d50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90004d54:	613b      	str	r3, [r7, #16]
  gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
90004d56:	2301      	movs	r3, #1
90004d58:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Pull = GPIO_PULLUP;
90004d5a:	2301      	movs	r3, #1
90004d5c:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90004d5e:	2303      	movs	r3, #3
90004d60:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init (LED_PORT [Led], &gpio_init_structure);
90004d62:	79fb      	ldrb	r3, [r7, #7]
90004d64:	4a0f      	ldr	r2, [pc, #60]	; (90004da4 <BSP_LED_Init+0xb8>)
90004d66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90004d6a:	f107 0210 	add.w	r2, r7, #16
90004d6e:	4611      	mov	r1, r2
90004d70:	4618      	mov	r0, r3
90004d72:	f007 ff39 	bl	9000cbe8 <HAL_GPIO_Init>

  /* By default, turn off LED */
  HAL_GPIO_WritePin (LED_PORT [Led], (uint16_t)LED_PIN [Led], GPIO_PIN_SET);
90004d76:	79fb      	ldrb	r3, [r7, #7]
90004d78:	4a0a      	ldr	r2, [pc, #40]	; (90004da4 <BSP_LED_Init+0xb8>)
90004d7a:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
90004d7e:	79fb      	ldrb	r3, [r7, #7]
90004d80:	4a07      	ldr	r2, [pc, #28]	; (90004da0 <BSP_LED_Init+0xb4>)
90004d82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90004d86:	b29b      	uxth	r3, r3
90004d88:	2201      	movs	r2, #1
90004d8a:	4619      	mov	r1, r3
90004d8c:	f008 f9fe 	bl	9000d18c <HAL_GPIO_WritePin>
  return ret;
90004d90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  }
90004d92:	4618      	mov	r0, r3
90004d94:	3728      	adds	r7, #40	; 0x28
90004d96:	46bd      	mov	sp, r7
90004d98:	bd80      	pop	{r7, pc}
90004d9a:	bf00      	nop
90004d9c:	58024400 	.word	0x58024400
90004da0:	9001e7c8 	.word	0x9001e7c8
90004da4:	2400007c 	.word	0x2400007c

90004da8 <BSP_LED_On>:
  *            @arg  LED1
  *            @arg  LED2
  * @retval BSP status
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
90004da8:	b580      	push	{r7, lr}
90004daa:	b084      	sub	sp, #16
90004dac:	af00      	add	r7, sp, #0
90004dae:	4603      	mov	r3, r0
90004db0:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
90004db2:	2300      	movs	r3, #0
90004db4:	60fb      	str	r3, [r7, #12]

  HAL_GPIO_WritePin (LED_PORT [Led], (uint16_t)LED_PIN [Led], GPIO_PIN_RESET);
90004db6:	79fb      	ldrb	r3, [r7, #7]
90004db8:	4a08      	ldr	r2, [pc, #32]	; (90004ddc <BSP_LED_On+0x34>)
90004dba:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
90004dbe:	79fb      	ldrb	r3, [r7, #7]
90004dc0:	4a07      	ldr	r2, [pc, #28]	; (90004de0 <BSP_LED_On+0x38>)
90004dc2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90004dc6:	b29b      	uxth	r3, r3
90004dc8:	2200      	movs	r2, #0
90004dca:	4619      	mov	r1, r3
90004dcc:	f008 f9de 	bl	9000d18c <HAL_GPIO_WritePin>
  return ret;
90004dd0:	68fb      	ldr	r3, [r7, #12]
}
90004dd2:	4618      	mov	r0, r3
90004dd4:	3710      	adds	r7, #16
90004dd6:	46bd      	mov	sp, r7
90004dd8:	bd80      	pop	{r7, pc}
90004dda:	bf00      	nop
90004ddc:	2400007c 	.word	0x2400007c
90004de0:	9001e7c8 	.word	0x9001e7c8

90004de4 <BSP_PB_Init>:
  *            @arg  BUTTON_MODE_EXTI: Button will be connected to EXTI line
  *                                    with interrupt generation capability
  * @retval BSP status
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
90004de4:	b580      	push	{r7, lr}
90004de6:	b088      	sub	sp, #32
90004de8:	af00      	add	r7, sp, #0
90004dea:	4603      	mov	r3, r0
90004dec:	460a      	mov	r2, r1
90004dee:	71fb      	strb	r3, [r7, #7]
90004df0:	4613      	mov	r3, r2
90004df2:	71bb      	strb	r3, [r7, #6]
  GPIO_InitTypeDef gpio_init_structure;
  static BSP_EXTI_LineCallback ButtonCallback[BUTTONn] ={BUTTON_USER_EXTI_Callback};
  static uint32_t  BSP_BUTTON_PRIO [BUTTONn] = {BSP_BUTTON_USER_IT_PRIORITY};
  static const uint32_t BUTTON_EXTI_LINE[BUTTONn] ={BUTTON_USER_EXTI_LINE};
  /* Enable the BUTTON clock*/
  BUTTON_USER_GPIO_CLK_ENABLE();
90004df4:	4b2e      	ldr	r3, [pc, #184]	; (90004eb0 <BSP_PB_Init+0xcc>)
90004df6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90004dfa:	4a2d      	ldr	r2, [pc, #180]	; (90004eb0 <BSP_PB_Init+0xcc>)
90004dfc:	f043 0304 	orr.w	r3, r3, #4
90004e00:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90004e04:	4b2a      	ldr	r3, [pc, #168]	; (90004eb0 <BSP_PB_Init+0xcc>)
90004e06:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90004e0a:	f003 0304 	and.w	r3, r3, #4
90004e0e:	60bb      	str	r3, [r7, #8]
90004e10:	68bb      	ldr	r3, [r7, #8]
  gpio_init_structure.Pin = BUTTON_PIN [Button];
90004e12:	f44f 5300 	mov.w	r3, #8192	; 0x2000
90004e16:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Pull = GPIO_PULLDOWN;
90004e18:	2302      	movs	r3, #2
90004e1a:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
90004e1c:	2302      	movs	r3, #2
90004e1e:	61bb      	str	r3, [r7, #24]

  if(ButtonMode == BUTTON_MODE_GPIO)
90004e20:	79bb      	ldrb	r3, [r7, #6]
90004e22:	2b00      	cmp	r3, #0
90004e24:	d10c      	bne.n	90004e40 <BSP_PB_Init+0x5c>
  {
    /* Configure Button pin as input */
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
90004e26:	2300      	movs	r3, #0
90004e28:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(BUTTON_PORT [Button], &gpio_init_structure);
90004e2a:	79fb      	ldrb	r3, [r7, #7]
90004e2c:	4a21      	ldr	r2, [pc, #132]	; (90004eb4 <BSP_PB_Init+0xd0>)
90004e2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90004e32:	f107 020c 	add.w	r2, r7, #12
90004e36:	4611      	mov	r1, r2
90004e38:	4618      	mov	r0, r3
90004e3a:	f007 fed5 	bl	9000cbe8 <HAL_GPIO_Init>
90004e3e:	e031      	b.n	90004ea4 <BSP_PB_Init+0xc0>
  }
  else /* (ButtonMode == BUTTON_MODE_EXTI) */
  {
    /* Configure Button pin as input with External interrupt */
    gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
90004e40:	f44f 1388 	mov.w	r3, #1114112	; 0x110000
90004e44:	613b      	str	r3, [r7, #16]

    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
90004e46:	79fb      	ldrb	r3, [r7, #7]
90004e48:	4a1a      	ldr	r2, [pc, #104]	; (90004eb4 <BSP_PB_Init+0xd0>)
90004e4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90004e4e:	f107 020c 	add.w	r2, r7, #12
90004e52:	4611      	mov	r1, r2
90004e54:	4618      	mov	r0, r3
90004e56:	f007 fec7 	bl	9000cbe8 <HAL_GPIO_Init>

    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]);
90004e5a:	79fb      	ldrb	r3, [r7, #7]
90004e5c:	00db      	lsls	r3, r3, #3
90004e5e:	4a16      	ldr	r2, [pc, #88]	; (90004eb8 <BSP_PB_Init+0xd4>)
90004e60:	441a      	add	r2, r3
90004e62:	79fb      	ldrb	r3, [r7, #7]
90004e64:	4915      	ldr	r1, [pc, #84]	; (90004ebc <BSP_PB_Init+0xd8>)
90004e66:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
90004e6a:	4619      	mov	r1, r3
90004e6c:	4610      	mov	r0, r2
90004e6e:	f007 fe76 	bl	9000cb5e <HAL_EXTI_GetHandle>
    (void)HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, ButtonCallback[Button]);
90004e72:	79fb      	ldrb	r3, [r7, #7]
90004e74:	00db      	lsls	r3, r3, #3
90004e76:	4a10      	ldr	r2, [pc, #64]	; (90004eb8 <BSP_PB_Init+0xd4>)
90004e78:	1898      	adds	r0, r3, r2
90004e7a:	79fb      	ldrb	r3, [r7, #7]
90004e7c:	4a10      	ldr	r2, [pc, #64]	; (90004ec0 <BSP_PB_Init+0xdc>)
90004e7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90004e82:	461a      	mov	r2, r3
90004e84:	2100      	movs	r1, #0
90004e86:	f007 fe4b 	bl	9000cb20 <HAL_EXTI_RegisterCallback>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), BSP_BUTTON_PRIO[Button], 0x00);
90004e8a:	2028      	movs	r0, #40	; 0x28
90004e8c:	79fb      	ldrb	r3, [r7, #7]
90004e8e:	4a0d      	ldr	r2, [pc, #52]	; (90004ec4 <BSP_PB_Init+0xe0>)
90004e90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90004e94:	2200      	movs	r2, #0
90004e96:	4619      	mov	r1, r3
90004e98:	f004 fbdf 	bl	9000965a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
90004e9c:	2328      	movs	r3, #40	; 0x28
90004e9e:	4618      	mov	r0, r3
90004ea0:	f004 fbf5 	bl	9000968e <HAL_NVIC_EnableIRQ>
  }
  return BSP_ERROR_NONE;
90004ea4:	2300      	movs	r3, #0
}
90004ea6:	4618      	mov	r0, r3
90004ea8:	3720      	adds	r7, #32
90004eaa:	46bd      	mov	sp, r7
90004eac:	bd80      	pop	{r7, pc}
90004eae:	bf00      	nop
90004eb0:	58024400 	.word	0x58024400
90004eb4:	24000084 	.word	0x24000084
90004eb8:	2400290c 	.word	0x2400290c
90004ebc:	9001e7f4 	.word	0x9001e7f4
90004ec0:	24000088 	.word	0x24000088
90004ec4:	2400008c 	.word	0x2400008c

90004ec8 <BSP_PB_GetState>:
  *          This parameter can be one of the following values:
  *            @arg  BUTTON_USER: User Push Button
  * @retval The Button GPIO pin value
  */
int32_t BSP_PB_GetState(Button_TypeDef Button)
{
90004ec8:	b580      	push	{r7, lr}
90004eca:	b082      	sub	sp, #8
90004ecc:	af00      	add	r7, sp, #0
90004ece:	4603      	mov	r3, r0
90004ed0:	71fb      	strb	r3, [r7, #7]
  return (int32_t)HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
90004ed2:	79fb      	ldrb	r3, [r7, #7]
90004ed4:	4a06      	ldr	r2, [pc, #24]	; (90004ef0 <BSP_PB_GetState+0x28>)
90004ed6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90004eda:	f44f 5200 	mov.w	r2, #8192	; 0x2000
90004ede:	4611      	mov	r1, r2
90004ee0:	4618      	mov	r0, r3
90004ee2:	f008 f93b 	bl	9000d15c <HAL_GPIO_ReadPin>
90004ee6:	4603      	mov	r3, r0
}
90004ee8:	4618      	mov	r0, r3
90004eea:	3708      	adds	r7, #8
90004eec:	46bd      	mov	sp, r7
90004eee:	bd80      	pop	{r7, pc}
90004ef0:	24000084 	.word	0x24000084

90004ef4 <BSP_PB_IRQHandler>:
  * @brief  This function handles Push-Button interrupt requests.
  * @param  Button Specifies the pin connected EXTI line
  * @retval None
  */
void BSP_PB_IRQHandler(Button_TypeDef Button)
{
90004ef4:	b580      	push	{r7, lr}
90004ef6:	b082      	sub	sp, #8
90004ef8:	af00      	add	r7, sp, #0
90004efa:	4603      	mov	r3, r0
90004efc:	71fb      	strb	r3, [r7, #7]
  HAL_EXTI_IRQHandler(&hpb_exti[Button]);
90004efe:	79fb      	ldrb	r3, [r7, #7]
90004f00:	00db      	lsls	r3, r3, #3
90004f02:	4a04      	ldr	r2, [pc, #16]	; (90004f14 <BSP_PB_IRQHandler+0x20>)
90004f04:	4413      	add	r3, r2
90004f06:	4618      	mov	r0, r3
90004f08:	f007 fe3e 	bl	9000cb88 <HAL_EXTI_IRQHandler>
}
90004f0c:	bf00      	nop
90004f0e:	3708      	adds	r7, #8
90004f10:	46bd      	mov	sp, r7
90004f12:	bd80      	pop	{r7, pc}
90004f14:	2400290c 	.word	0x2400290c

90004f18 <BUTTON_USER_EXTI_Callback>:
/**
  * @brief  KEY EXTI line detection callbacks.
  * @retval None
  */
static void BUTTON_USER_EXTI_Callback(void)
{
90004f18:	b580      	push	{r7, lr}
90004f1a:	af00      	add	r7, sp, #0
  BSP_PB_Callback(BUTTON_USER);
90004f1c:	2000      	movs	r0, #0
90004f1e:	f012 f8cd 	bl	900170bc <BSP_PB_Callback>
}
90004f22:	bf00      	nop
90004f24:	bd80      	pop	{r7, pc}
	...

90004f28 <BSP_AUDIO_OUT_Init>:
  * @param  Instance   AUDIO OUT Instance. It can only be 0 (SAI)
  * @param  AudioInit  AUDIO OUT init Structure
  * @retval BSP status
  */
int32_t BSP_AUDIO_OUT_Init(uint32_t Instance, BSP_AUDIO_Init_t* AudioInit)
{
90004f28:	b580      	push	{r7, lr}
90004f2a:	b094      	sub	sp, #80	; 0x50
90004f2c:	af00      	add	r7, sp, #0
90004f2e:	6078      	str	r0, [r7, #4]
90004f30:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
90004f32:	2300      	movs	r3, #0
90004f34:	64fb      	str	r3, [r7, #76]	; 0x4c
  if(Instance >= AUDIO_OUT_INSTANCES_NBR)
90004f36:	687b      	ldr	r3, [r7, #4]
90004f38:	2b00      	cmp	r3, #0
90004f3a:	d003      	beq.n	90004f44 <BSP_AUDIO_OUT_Init+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90004f3c:	f06f 0301 	mvn.w	r3, #1
90004f40:	64fb      	str	r3, [r7, #76]	; 0x4c
90004f42:	e0d8      	b.n	900050f6 <BSP_AUDIO_OUT_Init+0x1ce>
  }
  else
  {
    /* Fill Audio_Out_Ctx structure */
    Audio_Out_Ctx[Instance].Device         = AudioInit->Device;
90004f44:	683b      	ldr	r3, [r7, #0]
90004f46:	6819      	ldr	r1, [r3, #0]
90004f48:	486d      	ldr	r0, [pc, #436]	; (90005100 <BSP_AUDIO_OUT_Init+0x1d8>)
90004f4a:	687a      	ldr	r2, [r7, #4]
90004f4c:	4613      	mov	r3, r2
90004f4e:	00db      	lsls	r3, r3, #3
90004f50:	4413      	add	r3, r2
90004f52:	009b      	lsls	r3, r3, #2
90004f54:	4403      	add	r3, r0
90004f56:	3304      	adds	r3, #4
90004f58:	6019      	str	r1, [r3, #0]
    Audio_Out_Ctx[Instance].Instance       = Instance;
90004f5a:	4969      	ldr	r1, [pc, #420]	; (90005100 <BSP_AUDIO_OUT_Init+0x1d8>)
90004f5c:	687a      	ldr	r2, [r7, #4]
90004f5e:	4613      	mov	r3, r2
90004f60:	00db      	lsls	r3, r3, #3
90004f62:	4413      	add	r3, r2
90004f64:	009b      	lsls	r3, r3, #2
90004f66:	440b      	add	r3, r1
90004f68:	687a      	ldr	r2, [r7, #4]
90004f6a:	601a      	str	r2, [r3, #0]
    Audio_Out_Ctx[Instance].SampleRate     = AudioInit->SampleRate;
90004f6c:	683b      	ldr	r3, [r7, #0]
90004f6e:	6859      	ldr	r1, [r3, #4]
90004f70:	4863      	ldr	r0, [pc, #396]	; (90005100 <BSP_AUDIO_OUT_Init+0x1d8>)
90004f72:	687a      	ldr	r2, [r7, #4]
90004f74:	4613      	mov	r3, r2
90004f76:	00db      	lsls	r3, r3, #3
90004f78:	4413      	add	r3, r2
90004f7a:	009b      	lsls	r3, r3, #2
90004f7c:	4403      	add	r3, r0
90004f7e:	3308      	adds	r3, #8
90004f80:	6019      	str	r1, [r3, #0]
    Audio_Out_Ctx[Instance].BitsPerSample  = AudioInit->BitsPerSample;
90004f82:	683b      	ldr	r3, [r7, #0]
90004f84:	6899      	ldr	r1, [r3, #8]
90004f86:	485e      	ldr	r0, [pc, #376]	; (90005100 <BSP_AUDIO_OUT_Init+0x1d8>)
90004f88:	687a      	ldr	r2, [r7, #4]
90004f8a:	4613      	mov	r3, r2
90004f8c:	00db      	lsls	r3, r3, #3
90004f8e:	4413      	add	r3, r2
90004f90:	009b      	lsls	r3, r3, #2
90004f92:	4403      	add	r3, r0
90004f94:	330c      	adds	r3, #12
90004f96:	6019      	str	r1, [r3, #0]
    Audio_Out_Ctx[Instance].ChannelsNbr    = AudioInit->ChannelsNbr;
90004f98:	683b      	ldr	r3, [r7, #0]
90004f9a:	68d9      	ldr	r1, [r3, #12]
90004f9c:	4858      	ldr	r0, [pc, #352]	; (90005100 <BSP_AUDIO_OUT_Init+0x1d8>)
90004f9e:	687a      	ldr	r2, [r7, #4]
90004fa0:	4613      	mov	r3, r2
90004fa2:	00db      	lsls	r3, r3, #3
90004fa4:	4413      	add	r3, r2
90004fa6:	009b      	lsls	r3, r3, #2
90004fa8:	4403      	add	r3, r0
90004faa:	3314      	adds	r3, #20
90004fac:	6019      	str	r1, [r3, #0]
    Audio_Out_Ctx[Instance].Volume         = AudioInit->Volume;
90004fae:	683b      	ldr	r3, [r7, #0]
90004fb0:	6919      	ldr	r1, [r3, #16]
90004fb2:	4853      	ldr	r0, [pc, #332]	; (90005100 <BSP_AUDIO_OUT_Init+0x1d8>)
90004fb4:	687a      	ldr	r2, [r7, #4]
90004fb6:	4613      	mov	r3, r2
90004fb8:	00db      	lsls	r3, r3, #3
90004fba:	4413      	add	r3, r2
90004fbc:	009b      	lsls	r3, r3, #2
90004fbe:	4403      	add	r3, r0
90004fc0:	3310      	adds	r3, #16
90004fc2:	6019      	str	r1, [r3, #0]
    Audio_Out_Ctx[Instance].State          = AUDIO_OUT_STATE_RESET;
90004fc4:	494e      	ldr	r1, [pc, #312]	; (90005100 <BSP_AUDIO_OUT_Init+0x1d8>)
90004fc6:	687a      	ldr	r2, [r7, #4]
90004fc8:	4613      	mov	r3, r2
90004fca:	00db      	lsls	r3, r3, #3
90004fcc:	4413      	add	r3, r2
90004fce:	009b      	lsls	r3, r3, #2
90004fd0:	440b      	add	r3, r1
90004fd2:	331c      	adds	r3, #28
90004fd4:	2200      	movs	r2, #0
90004fd6:	601a      	str	r2, [r3, #0]

#if (USE_AUDIO_CODEC_WM8994 == 1)
    if(WM8994_Probe() != BSP_ERROR_NONE)
90004fd8:	f001 f952 	bl	90006280 <WM8994_Probe>
90004fdc:	4603      	mov	r3, r0
90004fde:	2b00      	cmp	r3, #0
90004fe0:	d002      	beq.n	90004fe8 <BSP_AUDIO_OUT_Init+0xc0>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
90004fe2:	f06f 0304 	mvn.w	r3, #4
90004fe6:	64fb      	str	r3, [r7, #76]	; 0x4c
    }
#endif
    if(ret == BSP_ERROR_NONE)
90004fe8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
90004fea:	2b00      	cmp	r3, #0
90004fec:	d176      	bne.n	900050dc <BSP_AUDIO_OUT_Init+0x1b4>
    {
      /* PLL clock is set depending by the AudioFreq (44.1khz vs 48khz groups) */
      if(MX_SAI2_ClockConfig(&haudio_out_sai, AudioInit->SampleRate) != HAL_OK)
90004fee:	683b      	ldr	r3, [r7, #0]
90004ff0:	685b      	ldr	r3, [r3, #4]
90004ff2:	4619      	mov	r1, r3
90004ff4:	4843      	ldr	r0, [pc, #268]	; (90005104 <BSP_AUDIO_OUT_Init+0x1dc>)
90004ff6:	f000 f95c 	bl	900052b2 <MX_SAI2_ClockConfig>
90004ffa:	4603      	mov	r3, r0
90004ffc:	2b00      	cmp	r3, #0
90004ffe:	d003      	beq.n	90005008 <BSP_AUDIO_OUT_Init+0xe0>
      {
        ret = BSP_ERROR_CLOCK_FAILURE;
90005000:	f06f 0308 	mvn.w	r3, #8
90005004:	64fb      	str	r3, [r7, #76]	; 0x4c
90005006:	e069      	b.n	900050dc <BSP_AUDIO_OUT_Init+0x1b4>
      }
      else
      {
        /* SAI data transfer preparation:
        Prepare the Media to be used for the audio transfer from memory to SAI peripheral */
        haudio_out_sai.Instance = AUDIO_OUT_SAIx;
90005008:	4b3e      	ldr	r3, [pc, #248]	; (90005104 <BSP_AUDIO_OUT_Init+0x1dc>)
9000500a:	4a3f      	ldr	r2, [pc, #252]	; (90005108 <BSP_AUDIO_OUT_Init+0x1e0>)
9000500c:	601a      	str	r2, [r3, #0]

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 0U)
        SAI_MspInit(&haudio_out_sai);
9000500e:	483d      	ldr	r0, [pc, #244]	; (90005104 <BSP_AUDIO_OUT_Init+0x1dc>)
90005010:	f001 f990 	bl	90006334 <SAI_MspInit>
#endif /* (USE_HAL_SAI_REGISTER_CALLBACKS == 0U) */

          MX_SAI_Config_t mx_sai_config;

          /* Prepare haudio_out_sai handle */
          mx_sai_config.AudioFrequency    = AudioInit->SampleRate;
90005014:	683b      	ldr	r3, [r7, #0]
90005016:	685b      	ldr	r3, [r3, #4]
90005018:	60fb      	str	r3, [r7, #12]
          mx_sai_config.AudioMode         = SAI_MODEMASTER_TX;
9000501a:	2300      	movs	r3, #0
9000501c:	613b      	str	r3, [r7, #16]
          mx_sai_config.ClockStrobing     = SAI_CLOCKSTROBING_RISINGEDGE;
9000501e:	2301      	movs	r3, #1
90005020:	61fb      	str	r3, [r7, #28]
          mx_sai_config.MonoStereoMode    = (AudioInit->ChannelsNbr == 1U) ? SAI_MONOMODE : SAI_STEREOMODE;
90005022:	683b      	ldr	r3, [r7, #0]
90005024:	68db      	ldr	r3, [r3, #12]
90005026:	2b01      	cmp	r3, #1
90005028:	d102      	bne.n	90005030 <BSP_AUDIO_OUT_Init+0x108>
9000502a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9000502e:	e000      	b.n	90005032 <BSP_AUDIO_OUT_Init+0x10a>
90005030:	2300      	movs	r3, #0
90005032:	61bb      	str	r3, [r7, #24]
          mx_sai_config.DataSize          = (AudioInit->BitsPerSample == AUDIO_RESOLUTION_32B) ? SAI_DATASIZE_32 : SAI_DATASIZE_16;
90005034:	683b      	ldr	r3, [r7, #0]
90005036:	689b      	ldr	r3, [r3, #8]
90005038:	2b20      	cmp	r3, #32
9000503a:	d101      	bne.n	90005040 <BSP_AUDIO_OUT_Init+0x118>
9000503c:	23e0      	movs	r3, #224	; 0xe0
9000503e:	e000      	b.n	90005042 <BSP_AUDIO_OUT_Init+0x11a>
90005040:	2380      	movs	r3, #128	; 0x80
90005042:	617b      	str	r3, [r7, #20]
          mx_sai_config.FrameLength       = 128;
90005044:	2380      	movs	r3, #128	; 0x80
90005046:	62fb      	str	r3, [r7, #44]	; 0x2c
          mx_sai_config.ActiveFrameLength = 64;
90005048:	2340      	movs	r3, #64	; 0x40
9000504a:	633b      	str	r3, [r7, #48]	; 0x30
          mx_sai_config.OutputDrive       = SAI_OUTPUTDRIVE_ENABLE;
9000504c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
90005050:	627b      	str	r3, [r7, #36]	; 0x24
          mx_sai_config.Synchro           = SAI_ASYNCHRONOUS;
90005052:	2300      	movs	r3, #0
90005054:	623b      	str	r3, [r7, #32]
          mx_sai_config.SynchroExt        = SAI_SYNCEXT_DISABLE;
90005056:	2300      	movs	r3, #0
90005058:	62bb      	str	r3, [r7, #40]	; 0x28
          mx_sai_config.SlotActive        = CODEC_AUDIOFRAME_SLOT_02;
9000505a:	2305      	movs	r3, #5
9000505c:	637b      	str	r3, [r7, #52]	; 0x34

          /* SAI peripheral initialization: this __weak function can be redefined by the application  */
          if(MX_SAI2_Block_A_Init(&haudio_out_sai, &mx_sai_config) != HAL_OK)
9000505e:	f107 030c 	add.w	r3, r7, #12
90005062:	4619      	mov	r1, r3
90005064:	4827      	ldr	r0, [pc, #156]	; (90005104 <BSP_AUDIO_OUT_Init+0x1dc>)
90005066:	f000 f89b 	bl	900051a0 <MX_SAI2_Block_A_Init>
9000506a:	4603      	mov	r3, r0
9000506c:	2b00      	cmp	r3, #0
9000506e:	d002      	beq.n	90005076 <BSP_AUDIO_OUT_Init+0x14e>
          {
            ret = BSP_ERROR_PERIPH_FAILURE;
90005070:	f06f 0303 	mvn.w	r3, #3
90005074:	64fb      	str	r3, [r7, #76]	; 0x4c
              ret = BSP_ERROR_PERIPH_FAILURE;
            }
          }
#endif
#if (USE_AUDIO_CODEC_WM8994 == 1)
          if(ret == BSP_ERROR_NONE)
90005076:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
90005078:	2b00      	cmp	r3, #0
9000507a:	d12f      	bne.n	900050dc <BSP_AUDIO_OUT_Init+0x1b4>
          {
            WM8994_Init_t codec_init;
            codec_init.Resolution  = (AudioInit->BitsPerSample == AUDIO_RESOLUTION_32B) ? 3 : 0;
9000507c:	683b      	ldr	r3, [r7, #0]
9000507e:	689b      	ldr	r3, [r3, #8]
90005080:	2b20      	cmp	r3, #32
90005082:	d101      	bne.n	90005088 <BSP_AUDIO_OUT_Init+0x160>
90005084:	2303      	movs	r3, #3
90005086:	e000      	b.n	9000508a <BSP_AUDIO_OUT_Init+0x162>
90005088:	2300      	movs	r3, #0
9000508a:	647b      	str	r3, [r7, #68]	; 0x44

            /* Fill codec_init structure */
            codec_init.Frequency    = AudioInit->SampleRate;
9000508c:	683b      	ldr	r3, [r7, #0]
9000508e:	685b      	ldr	r3, [r3, #4]
90005090:	643b      	str	r3, [r7, #64]	; 0x40
            codec_init.InputDevice  = WM8994_IN_NONE;
90005092:	2300      	movs	r3, #0
90005094:	63bb      	str	r3, [r7, #56]	; 0x38
            codec_init.OutputDevice = AudioInit->Device;
90005096:	683b      	ldr	r3, [r7, #0]
90005098:	681b      	ldr	r3, [r3, #0]
9000509a:	63fb      	str	r3, [r7, #60]	; 0x3c

            /* Convert volume before sending to the codec */
            codec_init.Volume       = VOLUME_OUT_CONVERT(AudioInit->Volume);
9000509c:	683b      	ldr	r3, [r7, #0]
9000509e:	691b      	ldr	r3, [r3, #16]
900050a0:	2b64      	cmp	r3, #100	; 0x64
900050a2:	d80a      	bhi.n	900050ba <BSP_AUDIO_OUT_Init+0x192>
900050a4:	683b      	ldr	r3, [r7, #0]
900050a6:	691a      	ldr	r2, [r3, #16]
900050a8:	4613      	mov	r3, r2
900050aa:	019b      	lsls	r3, r3, #6
900050ac:	1a9b      	subs	r3, r3, r2
900050ae:	4a17      	ldr	r2, [pc, #92]	; (9000510c <BSP_AUDIO_OUT_Init+0x1e4>)
900050b0:	fba2 2303 	umull	r2, r3, r2, r3
900050b4:	095b      	lsrs	r3, r3, #5
900050b6:	b2db      	uxtb	r3, r3
900050b8:	e000      	b.n	900050bc <BSP_AUDIO_OUT_Init+0x194>
900050ba:	233f      	movs	r3, #63	; 0x3f
900050bc:	64bb      	str	r3, [r7, #72]	; 0x48

            /* Initialize the codec internal registers */
            if(Audio_Drv->Init(Audio_CompObj, &codec_init) != 0)
900050be:	4b14      	ldr	r3, [pc, #80]	; (90005110 <BSP_AUDIO_OUT_Init+0x1e8>)
900050c0:	681b      	ldr	r3, [r3, #0]
900050c2:	681b      	ldr	r3, [r3, #0]
900050c4:	4a13      	ldr	r2, [pc, #76]	; (90005114 <BSP_AUDIO_OUT_Init+0x1ec>)
900050c6:	6812      	ldr	r2, [r2, #0]
900050c8:	f107 0138 	add.w	r1, r7, #56	; 0x38
900050cc:	4610      	mov	r0, r2
900050ce:	4798      	blx	r3
900050d0:	4603      	mov	r3, r0
900050d2:	2b00      	cmp	r3, #0
900050d4:	d002      	beq.n	900050dc <BSP_AUDIO_OUT_Init+0x1b4>
            {
              ret =  BSP_ERROR_COMPONENT_FAILURE;
900050d6:	f06f 0304 	mvn.w	r3, #4
900050da:	64fb      	str	r3, [r7, #76]	; 0x4c
#endif
      }
    }

    /* Update BSP AUDIO OUT state */
    if(ret == BSP_ERROR_NONE)
900050dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
900050de:	2b00      	cmp	r3, #0
900050e0:	d109      	bne.n	900050f6 <BSP_AUDIO_OUT_Init+0x1ce>
    {
      Audio_Out_Ctx[Instance].State = AUDIO_OUT_STATE_STOP;
900050e2:	4907      	ldr	r1, [pc, #28]	; (90005100 <BSP_AUDIO_OUT_Init+0x1d8>)
900050e4:	687a      	ldr	r2, [r7, #4]
900050e6:	4613      	mov	r3, r2
900050e8:	00db      	lsls	r3, r3, #3
900050ea:	4413      	add	r3, r2
900050ec:	009b      	lsls	r3, r3, #2
900050ee:	440b      	add	r3, r1
900050f0:	331c      	adds	r3, #28
900050f2:	2202      	movs	r2, #2
900050f4:	601a      	str	r2, [r3, #0]
    }
  }

  return ret;
900050f6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
900050f8:	4618      	mov	r0, r3
900050fa:	3750      	adds	r7, #80	; 0x50
900050fc:	46bd      	mov	sp, r7
900050fe:	bd80      	pop	{r7, pc}
90005100:	240029ac 	.word	0x240029ac
90005104:	24001238 	.word	0x24001238
90005108:	40015c04 	.word	0x40015c04
9000510c:	51eb851f 	.word	0x51eb851f
90005110:	2400118c 	.word	0x2400118c
90005114:	24001234 	.word	0x24001234

90005118 <BSP_AUDIO_OUT_DeInit>:
  * @brief  De-initializes the audio out peripheral.
  * @param Instance :  AUDIO OUT Instance. It can only be 0 (SAI)
  * @retval None
  */
int32_t BSP_AUDIO_OUT_DeInit(uint32_t Instance)
{
90005118:	b580      	push	{r7, lr}
9000511a:	b084      	sub	sp, #16
9000511c:	af00      	add	r7, sp, #0
9000511e:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
90005120:	2300      	movs	r3, #0
90005122:	60fb      	str	r3, [r7, #12]

  if (Instance >= AUDIO_OUT_INSTANCES_NBR)
90005124:	687b      	ldr	r3, [r7, #4]
90005126:	2b00      	cmp	r3, #0
90005128:	d003      	beq.n	90005132 <BSP_AUDIO_OUT_DeInit+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
9000512a:	f06f 0301 	mvn.w	r3, #1
9000512e:	60fb      	str	r3, [r7, #12]
90005130:	e027      	b.n	90005182 <BSP_AUDIO_OUT_DeInit+0x6a>
  }
  else
  {
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 0U)
    SAI_MspDeInit(&haudio_out_sai);
90005132:	4816      	ldr	r0, [pc, #88]	; (9000518c <BSP_AUDIO_OUT_DeInit+0x74>)
90005134:	f001 fb42 	bl	900067bc <SAI_MspDeInit>
#endif /* (USE_HAL_SAI_REGISTER_CALLBACKS == 0U) */
    /* Initialize the haudio_out_sai Instance parameter */
    haudio_out_sai.Instance = AUDIO_OUT_SAIx;
90005138:	4b14      	ldr	r3, [pc, #80]	; (9000518c <BSP_AUDIO_OUT_DeInit+0x74>)
9000513a:	4a15      	ldr	r2, [pc, #84]	; (90005190 <BSP_AUDIO_OUT_DeInit+0x78>)
9000513c:	601a      	str	r2, [r3, #0]
    /* Call the Media layer stop function */
    if (Audio_Drv->DeInit(Audio_CompObj) != 0)
9000513e:	4b15      	ldr	r3, [pc, #84]	; (90005194 <BSP_AUDIO_OUT_DeInit+0x7c>)
90005140:	681b      	ldr	r3, [r3, #0]
90005142:	685b      	ldr	r3, [r3, #4]
90005144:	4a14      	ldr	r2, [pc, #80]	; (90005198 <BSP_AUDIO_OUT_DeInit+0x80>)
90005146:	6812      	ldr	r2, [r2, #0]
90005148:	4610      	mov	r0, r2
9000514a:	4798      	blx	r3
9000514c:	4603      	mov	r3, r0
9000514e:	2b00      	cmp	r3, #0
90005150:	d003      	beq.n	9000515a <BSP_AUDIO_OUT_DeInit+0x42>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
90005152:	f06f 0304 	mvn.w	r3, #4
90005156:	60fb      	str	r3, [r7, #12]
90005158:	e013      	b.n	90005182 <BSP_AUDIO_OUT_DeInit+0x6a>
    }
    else if (HAL_SAI_DeInit(&haudio_out_sai) != HAL_OK)
9000515a:	480c      	ldr	r0, [pc, #48]	; (9000518c <BSP_AUDIO_OUT_DeInit+0x74>)
9000515c:	f00e fe12 	bl	90013d84 <HAL_SAI_DeInit>
90005160:	4603      	mov	r3, r0
90005162:	2b00      	cmp	r3, #0
90005164:	d003      	beq.n	9000516e <BSP_AUDIO_OUT_DeInit+0x56>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
90005166:	f06f 0303 	mvn.w	r3, #3
9000516a:	60fb      	str	r3, [r7, #12]
9000516c:	e009      	b.n	90005182 <BSP_AUDIO_OUT_DeInit+0x6a>
    }
    else
    {
      /* Update BSP AUDIO OUT state */
      Audio_Out_Ctx[Instance].State = AUDIO_OUT_STATE_RESET;
9000516e:	490b      	ldr	r1, [pc, #44]	; (9000519c <BSP_AUDIO_OUT_DeInit+0x84>)
90005170:	687a      	ldr	r2, [r7, #4]
90005172:	4613      	mov	r3, r2
90005174:	00db      	lsls	r3, r3, #3
90005176:	4413      	add	r3, r2
90005178:	009b      	lsls	r3, r3, #2
9000517a:	440b      	add	r3, r1
9000517c:	331c      	adds	r3, #28
9000517e:	2200      	movs	r2, #0
90005180:	601a      	str	r2, [r3, #0]
    }
  }
  /* Return BSP status */
  return ret;
90005182:	68fb      	ldr	r3, [r7, #12]
}
90005184:	4618      	mov	r0, r3
90005186:	3710      	adds	r7, #16
90005188:	46bd      	mov	sp, r7
9000518a:	bd80      	pop	{r7, pc}
9000518c:	24001238 	.word	0x24001238
90005190:	40015c04 	.word	0x40015c04
90005194:	2400118c 	.word	0x2400118c
90005198:	24001234 	.word	0x24001234
9000519c:	240029ac 	.word	0x240029ac

900051a0 <MX_SAI2_Block_A_Init>:
  * @param  MXConfig SAI configuration structure
  * @note   Being __weak it can be overwritten by the application
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_SAI2_Block_A_Init(SAI_HandleTypeDef *hsai, MX_SAI_Config_t *MXConfig)
{
900051a0:	b580      	push	{r7, lr}
900051a2:	b084      	sub	sp, #16
900051a4:	af00      	add	r7, sp, #0
900051a6:	6078      	str	r0, [r7, #4]
900051a8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef ret = HAL_OK;
900051aa:	2300      	movs	r3, #0
900051ac:	73fb      	strb	r3, [r7, #15]

  /* Disable SAI peripheral to allow access to SAI internal registers */
  __HAL_SAI_DISABLE(hsai);
900051ae:	687b      	ldr	r3, [r7, #4]
900051b0:	681b      	ldr	r3, [r3, #0]
900051b2:	681a      	ldr	r2, [r3, #0]
900051b4:	687b      	ldr	r3, [r7, #4]
900051b6:	681b      	ldr	r3, [r3, #0]
900051b8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
900051bc:	601a      	str	r2, [r3, #0]

  /* Configure SAI1_Block_A */
  hsai->Init.MonoStereoMode = MXConfig->MonoStereoMode;
900051be:	683b      	ldr	r3, [r7, #0]
900051c0:	68da      	ldr	r2, [r3, #12]
900051c2:	687b      	ldr	r3, [r7, #4]
900051c4:	62da      	str	r2, [r3, #44]	; 0x2c
  hsai->Init.AudioFrequency = MXConfig->AudioFrequency;
900051c6:	683b      	ldr	r3, [r7, #0]
900051c8:	681a      	ldr	r2, [r3, #0]
900051ca:	687b      	ldr	r3, [r7, #4]
900051cc:	621a      	str	r2, [r3, #32]
  hsai->Init.AudioMode = MXConfig->AudioMode;
900051ce:	683b      	ldr	r3, [r7, #0]
900051d0:	685a      	ldr	r2, [r3, #4]
900051d2:	687b      	ldr	r3, [r7, #4]
900051d4:	605a      	str	r2, [r3, #4]
  hsai->Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
900051d6:	687b      	ldr	r3, [r7, #4]
900051d8:	2200      	movs	r2, #0
900051da:	619a      	str	r2, [r3, #24]
  hsai->Init.Protocol = SAI_FREE_PROTOCOL;
900051dc:	687b      	ldr	r3, [r7, #4]
900051de:	2200      	movs	r2, #0
900051e0:	645a      	str	r2, [r3, #68]	; 0x44
  hsai->Init.DataSize = MXConfig->DataSize;
900051e2:	683b      	ldr	r3, [r7, #0]
900051e4:	689a      	ldr	r2, [r3, #8]
900051e6:	687b      	ldr	r3, [r7, #4]
900051e8:	649a      	str	r2, [r3, #72]	; 0x48
  hsai->Init.FirstBit = SAI_FIRSTBIT_MSB;
900051ea:	687b      	ldr	r3, [r7, #4]
900051ec:	2200      	movs	r2, #0
900051ee:	64da      	str	r2, [r3, #76]	; 0x4c
  hsai->Init.ClockStrobing = MXConfig->ClockStrobing;
900051f0:	683b      	ldr	r3, [r7, #0]
900051f2:	691a      	ldr	r2, [r3, #16]
900051f4:	687b      	ldr	r3, [r7, #4]
900051f6:	651a      	str	r2, [r3, #80]	; 0x50
  hsai->Init.Synchro = MXConfig->Synchro;
900051f8:	683b      	ldr	r3, [r7, #0]
900051fa:	695a      	ldr	r2, [r3, #20]
900051fc:	687b      	ldr	r3, [r7, #4]
900051fe:	609a      	str	r2, [r3, #8]
  hsai->Init.OutputDrive = MXConfig->OutputDrive;
90005200:	683b      	ldr	r3, [r7, #0]
90005202:	699a      	ldr	r2, [r3, #24]
90005204:	687b      	ldr	r3, [r7, #4]
90005206:	615a      	str	r2, [r3, #20]
  hsai->Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
90005208:	687b      	ldr	r3, [r7, #4]
9000520a:	2201      	movs	r2, #1
9000520c:	61da      	str	r2, [r3, #28]
  hsai->Init.SynchroExt = MXConfig->SynchroExt;
9000520e:	683b      	ldr	r3, [r7, #0]
90005210:	69da      	ldr	r2, [r3, #28]
90005212:	687b      	ldr	r3, [r7, #4]
90005214:	60da      	str	r2, [r3, #12]
  hsai->Init.CompandingMode = SAI_NOCOMPANDING;
90005216:	687b      	ldr	r3, [r7, #4]
90005218:	2200      	movs	r2, #0
9000521a:	631a      	str	r2, [r3, #48]	; 0x30
  hsai->Init.TriState = SAI_OUTPUT_NOTRELEASED;
9000521c:	687b      	ldr	r3, [r7, #4]
9000521e:	2200      	movs	r2, #0
90005220:	635a      	str	r2, [r3, #52]	; 0x34
  hsai->Init.Mckdiv = 0;
90005222:	687b      	ldr	r3, [r7, #4]
90005224:	2200      	movs	r2, #0
90005226:	625a      	str	r2, [r3, #36]	; 0x24
  hsai->Init.MckOverSampling = SAI_MCK_OVERSAMPLING_DISABLE;
90005228:	687b      	ldr	r3, [r7, #4]
9000522a:	2200      	movs	r2, #0
9000522c:	629a      	str	r2, [r3, #40]	; 0x28
  hsai->Init.MckOutput = SAI_MCK_OUTPUT_DISABLE;
9000522e:	687b      	ldr	r3, [r7, #4]
90005230:	2200      	movs	r2, #0
90005232:	611a      	str	r2, [r3, #16]
  hsai->Init.PdmInit.Activation = DISABLE;
90005234:	687b      	ldr	r3, [r7, #4]
90005236:	2200      	movs	r2, #0
90005238:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  hsai->Init.PdmInit.ClockEnable = 0;
9000523c:	687b      	ldr	r3, [r7, #4]
9000523e:	2200      	movs	r2, #0
90005240:	641a      	str	r2, [r3, #64]	; 0x40
  hsai->Init.PdmInit.MicPairsNbr = 0;
90005242:	687b      	ldr	r3, [r7, #4]
90005244:	2200      	movs	r2, #0
90005246:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Configure SAI_Block_x Frame */
  hsai->FrameInit.FrameLength = MXConfig->FrameLength;
90005248:	683b      	ldr	r3, [r7, #0]
9000524a:	6a1a      	ldr	r2, [r3, #32]
9000524c:	687b      	ldr	r3, [r7, #4]
9000524e:	655a      	str	r2, [r3, #84]	; 0x54
  hsai->FrameInit.ActiveFrameLength = MXConfig->ActiveFrameLength;
90005250:	683b      	ldr	r3, [r7, #0]
90005252:	6a5a      	ldr	r2, [r3, #36]	; 0x24
90005254:	687b      	ldr	r3, [r7, #4]
90005256:	659a      	str	r2, [r3, #88]	; 0x58
  hsai->FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
90005258:	687b      	ldr	r3, [r7, #4]
9000525a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
9000525e:	65da      	str	r2, [r3, #92]	; 0x5c
  hsai->FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
90005260:	687b      	ldr	r3, [r7, #4]
90005262:	2200      	movs	r2, #0
90005264:	661a      	str	r2, [r3, #96]	; 0x60
  hsai->FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
90005266:	687b      	ldr	r3, [r7, #4]
90005268:	f44f 2280 	mov.w	r2, #262144	; 0x40000
9000526c:	665a      	str	r2, [r3, #100]	; 0x64

  /* Configure SAI Block_x Slot */
  hsai->SlotInit.FirstBitOffset = 0;
9000526e:	687b      	ldr	r3, [r7, #4]
90005270:	2200      	movs	r2, #0
90005272:	669a      	str	r2, [r3, #104]	; 0x68
  hsai->SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
90005274:	687b      	ldr	r3, [r7, #4]
90005276:	2200      	movs	r2, #0
90005278:	66da      	str	r2, [r3, #108]	; 0x6c
  hsai->SlotInit.SlotNumber = 4;
9000527a:	687b      	ldr	r3, [r7, #4]
9000527c:	2204      	movs	r2, #4
9000527e:	671a      	str	r2, [r3, #112]	; 0x70
  hsai->SlotInit.SlotActive = MXConfig->SlotActive;
90005280:	683b      	ldr	r3, [r7, #0]
90005282:	6a9a      	ldr	r2, [r3, #40]	; 0x28
90005284:	687b      	ldr	r3, [r7, #4]
90005286:	675a      	str	r2, [r3, #116]	; 0x74

  if (HAL_SAI_Init(hsai) != HAL_OK)
90005288:	6878      	ldr	r0, [r7, #4]
9000528a:	f00e fadb 	bl	90013844 <HAL_SAI_Init>
9000528e:	4603      	mov	r3, r0
90005290:	2b00      	cmp	r3, #0
90005292:	d001      	beq.n	90005298 <MX_SAI2_Block_A_Init+0xf8>
  {
    ret = HAL_ERROR;
90005294:	2301      	movs	r3, #1
90005296:	73fb      	strb	r3, [r7, #15]
  }

  /* Enable SAI peripheral to generate MCLK */
  __HAL_SAI_ENABLE(hsai);
90005298:	687b      	ldr	r3, [r7, #4]
9000529a:	681b      	ldr	r3, [r3, #0]
9000529c:	681a      	ldr	r2, [r3, #0]
9000529e:	687b      	ldr	r3, [r7, #4]
900052a0:	681b      	ldr	r3, [r3, #0]
900052a2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
900052a6:	601a      	str	r2, [r3, #0]

  return ret;
900052a8:	7bfb      	ldrb	r3, [r7, #15]
}
900052aa:	4618      	mov	r0, r3
900052ac:	3710      	adds	r7, #16
900052ae:	46bd      	mov	sp, r7
900052b0:	bd80      	pop	{r7, pc}

900052b2 <MX_SAI2_ClockConfig>:
  * @note   This API is called by BSP_AUDIO_OUT_Init() and BSP_AUDIO_OUT_SetFrequency()
  *         Being __weak it can be overwritten by the application
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_SAI2_ClockConfig(SAI_HandleTypeDef *hsai, uint32_t SampleRate)
{
900052b2:	b580      	push	{r7, lr}
900052b4:	b0b2      	sub	sp, #200	; 0xc8
900052b6:	af00      	add	r7, sp, #0
900052b8:	6078      	str	r0, [r7, #4]
900052ba:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hsai);

  RCC_PeriphCLKInitTypeDef rcc_ex_clk_init_struct;

  HAL_RCCEx_GetPeriphCLKConfig(&rcc_ex_clk_init_struct);
900052bc:	f107 030c 	add.w	r3, r7, #12
900052c0:	4618      	mov	r0, r3
900052c2:	f00c ff0d 	bl	900120e0 <HAL_RCCEx_GetPeriphCLKConfig>

  /* Set the PLL configuration according to the audio frequency */
  if((SampleRate == AUDIO_FREQUENCY_11K) || (SampleRate == AUDIO_FREQUENCY_22K) || (SampleRate == AUDIO_FREQUENCY_44K))
900052c6:	683b      	ldr	r3, [r7, #0]
900052c8:	f642 3211 	movw	r2, #11025	; 0x2b11
900052cc:	4293      	cmp	r3, r2
900052ce:	d009      	beq.n	900052e4 <MX_SAI2_ClockConfig+0x32>
900052d0:	683b      	ldr	r3, [r7, #0]
900052d2:	f245 6222 	movw	r2, #22050	; 0x5622
900052d6:	4293      	cmp	r3, r2
900052d8:	d004      	beq.n	900052e4 <MX_SAI2_ClockConfig+0x32>
900052da:	683b      	ldr	r3, [r7, #0]
900052dc:	f64a 4244 	movw	r2, #44100	; 0xac44
900052e0:	4293      	cmp	r3, r2
900052e2:	d10a      	bne.n	900052fa <MX_SAI2_ClockConfig+0x48>
  {
    /* SAI clock config:
    PLL2_VCO Input = HSE_VALUE/PLL2M = 1 Mhz
    PLL2_VCO Output = PLL2_VCO Input * PLL2N = 429 Mhz
    SAI_CLK_x = PLL2_VCO Output/PLL2P = 429/38 = 11.289 Mhz */
    rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
900052e4:	f44f 7300 	mov.w	r3, #512	; 0x200
900052e8:	60fb      	str	r3, [r7, #12]
    rcc_ex_clk_init_struct.Sai23ClockSelection = RCC_SAI2CLKSOURCE_PLL2;
900052ea:	2340      	movs	r3, #64	; 0x40
900052ec:	667b      	str	r3, [r7, #100]	; 0x64
    rcc_ex_clk_init_struct.PLL2.PLL2P = 38;
900052ee:	2326      	movs	r3, #38	; 0x26
900052f0:	61bb      	str	r3, [r7, #24]
    rcc_ex_clk_init_struct.PLL2.PLL2N = 429;
900052f2:	f240 13ad 	movw	r3, #429	; 0x1ad
900052f6:	617b      	str	r3, [r7, #20]
900052f8:	e009      	b.n	9000530e <MX_SAI2_ClockConfig+0x5c>
  {
    /* SAI clock config:
    PLL2_VCO Input = HSE_VALUE/PLL2M = 1 Mhz
    PLL2_VCO Output = PLL2_VCO Input * PLL2N = 344 Mhz
    SAI_CLK_x = PLL2_VCO Output/PLL2P = 344/7 = 49.142 Mhz */
    rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
900052fa:	f44f 7300 	mov.w	r3, #512	; 0x200
900052fe:	60fb      	str	r3, [r7, #12]
    rcc_ex_clk_init_struct.Sai23ClockSelection = RCC_SAI2CLKSOURCE_PLL2;
90005300:	2340      	movs	r3, #64	; 0x40
90005302:	667b      	str	r3, [r7, #100]	; 0x64
    rcc_ex_clk_init_struct.PLL2.PLL2P = 7;
90005304:	2307      	movs	r3, #7
90005306:	61bb      	str	r3, [r7, #24]
    rcc_ex_clk_init_struct.PLL2.PLL2N = 344;
90005308:	f44f 73ac 	mov.w	r3, #344	; 0x158
9000530c:	617b      	str	r3, [r7, #20]

  }
  rcc_ex_clk_init_struct.PLL2.PLL2Q = 1;
9000530e:	2301      	movs	r3, #1
90005310:	61fb      	str	r3, [r7, #28]
  rcc_ex_clk_init_struct.PLL2.PLL2R = 1;
90005312:	2301      	movs	r3, #1
90005314:	623b      	str	r3, [r7, #32]
  rcc_ex_clk_init_struct.PLL2.PLL2M = 25;
90005316:	2319      	movs	r3, #25
90005318:	613b      	str	r3, [r7, #16]
  return  HAL_RCCEx_PeriphCLKConfig(&rcc_ex_clk_init_struct);
9000531a:	f107 030c 	add.w	r3, r7, #12
9000531e:	4618      	mov	r0, r3
90005320:	f00b ff9e 	bl	90011260 <HAL_RCCEx_PeriphCLKConfig>
90005324:	4603      	mov	r3, r0
}
90005326:	4618      	mov	r0, r3
90005328:	37c8      	adds	r7, #200	; 0xc8
9000532a:	46bd      	mov	sp, r7
9000532c:	bd80      	pop	{r7, pc}

9000532e <MX_SAI4_ClockConfig>:
  * @note   This API is called by BSP_AUDIO_OUT_Init() and BSP_AUDIO_OUT_SetFrequency()
  *         Being __weak it can be overwritten by the application
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_SAI4_ClockConfig(SAI_HandleTypeDef *hsai, uint32_t SampleRate)
{
9000532e:	b580      	push	{r7, lr}
90005330:	b0b2      	sub	sp, #200	; 0xc8
90005332:	af00      	add	r7, sp, #0
90005334:	6078      	str	r0, [r7, #4]
90005336:	6039      	str	r1, [r7, #0]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hsai);

  HAL_StatusTypeDef ret = HAL_OK;
90005338:	2300      	movs	r3, #0
9000533a:	f887 30c7 	strb.w	r3, [r7, #199]	; 0xc7
  RCC_PeriphCLKInitTypeDef rcc_ex_clk_init_struct;
  HAL_RCCEx_GetPeriphCLKConfig(&rcc_ex_clk_init_struct);
9000533e:	f107 0308 	add.w	r3, r7, #8
90005342:	4618      	mov	r0, r3
90005344:	f00c fecc 	bl	900120e0 <HAL_RCCEx_GetPeriphCLKConfig>

  /* Set the PLL configuration according to the audio frequency */
  if((SampleRate == AUDIO_FREQUENCY_11K) || (SampleRate == AUDIO_FREQUENCY_22K) || (SampleRate == AUDIO_FREQUENCY_44K))
90005348:	683b      	ldr	r3, [r7, #0]
9000534a:	f642 3211 	movw	r2, #11025	; 0x2b11
9000534e:	4293      	cmp	r3, r2
90005350:	d009      	beq.n	90005366 <MX_SAI4_ClockConfig+0x38>
90005352:	683b      	ldr	r3, [r7, #0]
90005354:	f245 6222 	movw	r2, #22050	; 0x5622
90005358:	4293      	cmp	r3, r2
9000535a:	d004      	beq.n	90005366 <MX_SAI4_ClockConfig+0x38>
9000535c:	683b      	ldr	r3, [r7, #0]
9000535e:	f64a 4244 	movw	r2, #44100	; 0xac44
90005362:	4293      	cmp	r3, r2
90005364:	d105      	bne.n	90005372 <MX_SAI4_ClockConfig+0x44>
  {
    rcc_ex_clk_init_struct.PLL2.PLL2P = 38;
90005366:	2326      	movs	r3, #38	; 0x26
90005368:	617b      	str	r3, [r7, #20]
    rcc_ex_clk_init_struct.PLL2.PLL2N = 429;
9000536a:	f240 13ad 	movw	r3, #429	; 0x1ad
9000536e:	613b      	str	r3, [r7, #16]
90005370:	e004      	b.n	9000537c <MX_SAI4_ClockConfig+0x4e>
  }
  else /* AUDIO_FREQUENCY_8K, AUDIO_FREQUENCY_16K, AUDIO_FREQUENCY_32K, AUDIO_FREQUENCY_48K, AUDIO_FREQUENCY_96K */
  {
    rcc_ex_clk_init_struct.PLL2.PLL2P = 7;
90005372:	2307      	movs	r3, #7
90005374:	617b      	str	r3, [r7, #20]
    rcc_ex_clk_init_struct.PLL2.PLL2N = 344;
90005376:	f44f 73ac 	mov.w	r3, #344	; 0x158
9000537a:	613b      	str	r3, [r7, #16]
  }
  /* SAI clock config */
  rcc_ex_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_SAI4A;
9000537c:	f44f 6380 	mov.w	r3, #1024	; 0x400
90005380:	60bb      	str	r3, [r7, #8]
  rcc_ex_clk_init_struct.Sai4AClockSelection = RCC_SAI4ACLKSOURCE_PLL2;
90005382:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
90005386:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  rcc_ex_clk_init_struct.PLL2.PLL2Q = 1;
9000538a:	2301      	movs	r3, #1
9000538c:	61bb      	str	r3, [r7, #24]
  rcc_ex_clk_init_struct.PLL2.PLL2R = 1;
9000538e:	2301      	movs	r3, #1
90005390:	61fb      	str	r3, [r7, #28]
  rcc_ex_clk_init_struct.PLL2.PLL2M = 25;
90005392:	2319      	movs	r3, #25
90005394:	60fb      	str	r3, [r7, #12]
  if(HAL_RCCEx_PeriphCLKConfig(&rcc_ex_clk_init_struct) != HAL_OK)
90005396:	f107 0308 	add.w	r3, r7, #8
9000539a:	4618      	mov	r0, r3
9000539c:	f00b ff60 	bl	90011260 <HAL_RCCEx_PeriphCLKConfig>
900053a0:	4603      	mov	r3, r0
900053a2:	2b00      	cmp	r3, #0
900053a4:	d002      	beq.n	900053ac <MX_SAI4_ClockConfig+0x7e>
  {
    ret = HAL_ERROR;
900053a6:	2301      	movs	r3, #1
900053a8:	f887 30c7 	strb.w	r3, [r7, #199]	; 0xc7
  }

  return ret;
900053ac:	f897 30c7 	ldrb.w	r3, [r7, #199]	; 0xc7
}
900053b0:	4618      	mov	r0, r3
900053b2:	37c8      	adds	r7, #200	; 0xc8
900053b4:	46bd      	mov	sp, r7
900053b6:	bd80      	pop	{r7, pc}

900053b8 <BSP_AUDIO_OUT_Play>:
  * @param  NbrOfBytes   Size of total samples in bytes
  *                      BitsPerSample: 16 or 32
  * @retval BSP status
  */
int32_t BSP_AUDIO_OUT_Play(uint32_t Instance, uint8_t *pData, uint32_t NbrOfBytes)
{
900053b8:	b580      	push	{r7, lr}
900053ba:	b086      	sub	sp, #24
900053bc:	af00      	add	r7, sp, #0
900053be:	60f8      	str	r0, [r7, #12]
900053c0:	60b9      	str	r1, [r7, #8]
900053c2:	607a      	str	r2, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
900053c4:	2300      	movs	r3, #0
900053c6:	617b      	str	r3, [r7, #20]

  if ((Instance >= AUDIO_OUT_INSTANCES_NBR) || (((NbrOfBytes / (Audio_Out_Ctx[Instance].BitsPerSample / 8U)) > 0xFFFFU)))
900053c8:	68fb      	ldr	r3, [r7, #12]
900053ca:	2b00      	cmp	r3, #0
900053cc:	d10f      	bne.n	900053ee <BSP_AUDIO_OUT_Play+0x36>
900053ce:	492c      	ldr	r1, [pc, #176]	; (90005480 <BSP_AUDIO_OUT_Play+0xc8>)
900053d0:	68fa      	ldr	r2, [r7, #12]
900053d2:	4613      	mov	r3, r2
900053d4:	00db      	lsls	r3, r3, #3
900053d6:	4413      	add	r3, r2
900053d8:	009b      	lsls	r3, r3, #2
900053da:	440b      	add	r3, r1
900053dc:	330c      	adds	r3, #12
900053de:	681b      	ldr	r3, [r3, #0]
900053e0:	08db      	lsrs	r3, r3, #3
900053e2:	687a      	ldr	r2, [r7, #4]
900053e4:	fbb2 f3f3 	udiv	r3, r2, r3
900053e8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
900053ec:	d303      	bcc.n	900053f6 <BSP_AUDIO_OUT_Play+0x3e>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900053ee:	f06f 0301 	mvn.w	r3, #1
900053f2:	617b      	str	r3, [r7, #20]
900053f4:	e03f      	b.n	90005476 <BSP_AUDIO_OUT_Play+0xbe>
  }
  else if (Audio_Out_Ctx[Instance].State != AUDIO_OUT_STATE_STOP)
900053f6:	4922      	ldr	r1, [pc, #136]	; (90005480 <BSP_AUDIO_OUT_Play+0xc8>)
900053f8:	68fa      	ldr	r2, [r7, #12]
900053fa:	4613      	mov	r3, r2
900053fc:	00db      	lsls	r3, r3, #3
900053fe:	4413      	add	r3, r2
90005400:	009b      	lsls	r3, r3, #2
90005402:	440b      	add	r3, r1
90005404:	331c      	adds	r3, #28
90005406:	681b      	ldr	r3, [r3, #0]
90005408:	2b02      	cmp	r3, #2
9000540a:	d003      	beq.n	90005414 <BSP_AUDIO_OUT_Play+0x5c>
  {
    ret = BSP_ERROR_BUSY;
9000540c:	f06f 0302 	mvn.w	r3, #2
90005410:	617b      	str	r3, [r7, #20]
90005412:	e030      	b.n	90005476 <BSP_AUDIO_OUT_Play+0xbe>
  }
  else if (HAL_SAI_Transmit_DMA(&haudio_out_sai, pData, (uint16_t)(NbrOfBytes / (Audio_Out_Ctx[Instance].BitsPerSample / 8U))) != HAL_OK)
90005414:	491a      	ldr	r1, [pc, #104]	; (90005480 <BSP_AUDIO_OUT_Play+0xc8>)
90005416:	68fa      	ldr	r2, [r7, #12]
90005418:	4613      	mov	r3, r2
9000541a:	00db      	lsls	r3, r3, #3
9000541c:	4413      	add	r3, r2
9000541e:	009b      	lsls	r3, r3, #2
90005420:	440b      	add	r3, r1
90005422:	330c      	adds	r3, #12
90005424:	681b      	ldr	r3, [r3, #0]
90005426:	08db      	lsrs	r3, r3, #3
90005428:	687a      	ldr	r2, [r7, #4]
9000542a:	fbb2 f3f3 	udiv	r3, r2, r3
9000542e:	b29b      	uxth	r3, r3
90005430:	461a      	mov	r2, r3
90005432:	68b9      	ldr	r1, [r7, #8]
90005434:	4813      	ldr	r0, [pc, #76]	; (90005484 <BSP_AUDIO_OUT_Play+0xcc>)
90005436:	f00e fdf1 	bl	9001401c <HAL_SAI_Transmit_DMA>
9000543a:	4603      	mov	r3, r0
9000543c:	2b00      	cmp	r3, #0
9000543e:	d003      	beq.n	90005448 <BSP_AUDIO_OUT_Play+0x90>
  {
    ret = BSP_ERROR_PERIPH_FAILURE;
90005440:	f06f 0303 	mvn.w	r3, #3
90005444:	617b      	str	r3, [r7, #20]
90005446:	e016      	b.n	90005476 <BSP_AUDIO_OUT_Play+0xbe>
  }
  else
  {
    if (Audio_Drv->Play(Audio_CompObj) < 0)
90005448:	4b0f      	ldr	r3, [pc, #60]	; (90005488 <BSP_AUDIO_OUT_Play+0xd0>)
9000544a:	681b      	ldr	r3, [r3, #0]
9000544c:	68db      	ldr	r3, [r3, #12]
9000544e:	4a0f      	ldr	r2, [pc, #60]	; (9000548c <BSP_AUDIO_OUT_Play+0xd4>)
90005450:	6812      	ldr	r2, [r2, #0]
90005452:	4610      	mov	r0, r2
90005454:	4798      	blx	r3
90005456:	4603      	mov	r3, r0
90005458:	2b00      	cmp	r3, #0
9000545a:	da02      	bge.n	90005462 <BSP_AUDIO_OUT_Play+0xaa>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
9000545c:	f06f 0304 	mvn.w	r3, #4
90005460:	617b      	str	r3, [r7, #20]
    }
    /* Update BSP AUDIO OUT state */
    Audio_Out_Ctx[Instance].State = AUDIO_OUT_STATE_PLAYING;
90005462:	4907      	ldr	r1, [pc, #28]	; (90005480 <BSP_AUDIO_OUT_Play+0xc8>)
90005464:	68fa      	ldr	r2, [r7, #12]
90005466:	4613      	mov	r3, r2
90005468:	00db      	lsls	r3, r3, #3
9000546a:	4413      	add	r3, r2
9000546c:	009b      	lsls	r3, r3, #2
9000546e:	440b      	add	r3, r1
90005470:	331c      	adds	r3, #28
90005472:	2201      	movs	r2, #1
90005474:	601a      	str	r2, [r3, #0]
  }

  /* Return BSP status */
  return ret;
90005476:	697b      	ldr	r3, [r7, #20]
}
90005478:	4618      	mov	r0, r3
9000547a:	3718      	adds	r7, #24
9000547c:	46bd      	mov	sp, r7
9000547e:	bd80      	pop	{r7, pc}
90005480:	240029ac 	.word	0x240029ac
90005484:	24001238 	.word	0x24001238
90005488:	2400118c 	.word	0x2400118c
9000548c:	24001234 	.word	0x24001234

90005490 <BSP_AUDIO_OUT_Pause>:
  *          BSP_AUDIO_OUT_Resume() function should be called for resume (use of BSP_AUDIO_OUT_Play()
  *          function for resume could lead to unexpected behavior).
  * @retval BSP status
  */
int32_t BSP_AUDIO_OUT_Pause(uint32_t Instance)
{
90005490:	b580      	push	{r7, lr}
90005492:	b084      	sub	sp, #16
90005494:	af00      	add	r7, sp, #0
90005496:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
90005498:	2300      	movs	r3, #0
9000549a:	60fb      	str	r3, [r7, #12]

  if (Instance >= AUDIO_OUT_INSTANCES_NBR)
9000549c:	687b      	ldr	r3, [r7, #4]
9000549e:	2b00      	cmp	r3, #0
900054a0:	d003      	beq.n	900054aa <BSP_AUDIO_OUT_Pause+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900054a2:	f06f 0301 	mvn.w	r3, #1
900054a6:	60fb      	str	r3, [r7, #12]
900054a8:	e030      	b.n	9000550c <BSP_AUDIO_OUT_Pause+0x7c>
  }/* Check audio out state */
  else if (Audio_Out_Ctx[Instance].State != AUDIO_OUT_STATE_PLAYING)
900054aa:	491b      	ldr	r1, [pc, #108]	; (90005518 <BSP_AUDIO_OUT_Pause+0x88>)
900054ac:	687a      	ldr	r2, [r7, #4]
900054ae:	4613      	mov	r3, r2
900054b0:	00db      	lsls	r3, r3, #3
900054b2:	4413      	add	r3, r2
900054b4:	009b      	lsls	r3, r3, #2
900054b6:	440b      	add	r3, r1
900054b8:	331c      	adds	r3, #28
900054ba:	681b      	ldr	r3, [r3, #0]
900054bc:	2b01      	cmp	r3, #1
900054be:	d003      	beq.n	900054c8 <BSP_AUDIO_OUT_Pause+0x38>
  {
    ret = BSP_ERROR_BUSY;
900054c0:	f06f 0302 	mvn.w	r3, #2
900054c4:	60fb      	str	r3, [r7, #12]
900054c6:	e021      	b.n	9000550c <BSP_AUDIO_OUT_Pause+0x7c>
  }/* Call the Media layer pause function */
  else if (HAL_SAI_DMAPause(&haudio_out_sai) != HAL_OK)
900054c8:	4814      	ldr	r0, [pc, #80]	; (9000551c <BSP_AUDIO_OUT_Pause+0x8c>)
900054ca:	f00e fcd5 	bl	90013e78 <HAL_SAI_DMAPause>
900054ce:	4603      	mov	r3, r0
900054d0:	2b00      	cmp	r3, #0
900054d2:	d003      	beq.n	900054dc <BSP_AUDIO_OUT_Pause+0x4c>
  {
    ret = BSP_ERROR_PERIPH_FAILURE;
900054d4:	f06f 0303 	mvn.w	r3, #3
900054d8:	60fb      	str	r3, [r7, #12]
900054da:	e017      	b.n	9000550c <BSP_AUDIO_OUT_Pause+0x7c>
  }/* Call the Audio Codec Pause/Resume function */
  else if (Audio_Drv->Pause(Audio_CompObj) < 0)
900054dc:	4b10      	ldr	r3, [pc, #64]	; (90005520 <BSP_AUDIO_OUT_Pause+0x90>)
900054de:	681b      	ldr	r3, [r3, #0]
900054e0:	691b      	ldr	r3, [r3, #16]
900054e2:	4a10      	ldr	r2, [pc, #64]	; (90005524 <BSP_AUDIO_OUT_Pause+0x94>)
900054e4:	6812      	ldr	r2, [r2, #0]
900054e6:	4610      	mov	r0, r2
900054e8:	4798      	blx	r3
900054ea:	4603      	mov	r3, r0
900054ec:	2b00      	cmp	r3, #0
900054ee:	da03      	bge.n	900054f8 <BSP_AUDIO_OUT_Pause+0x68>
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
900054f0:	f06f 0304 	mvn.w	r3, #4
900054f4:	60fb      	str	r3, [r7, #12]
900054f6:	e009      	b.n	9000550c <BSP_AUDIO_OUT_Pause+0x7c>
  }
  else
  {
    /* Update BSP AUDIO OUT state */
    Audio_Out_Ctx[Instance].State = AUDIO_OUT_STATE_PAUSE;
900054f8:	4907      	ldr	r1, [pc, #28]	; (90005518 <BSP_AUDIO_OUT_Pause+0x88>)
900054fa:	687a      	ldr	r2, [r7, #4]
900054fc:	4613      	mov	r3, r2
900054fe:	00db      	lsls	r3, r3, #3
90005500:	4413      	add	r3, r2
90005502:	009b      	lsls	r3, r3, #2
90005504:	440b      	add	r3, r1
90005506:	331c      	adds	r3, #28
90005508:	2203      	movs	r2, #3
9000550a:	601a      	str	r2, [r3, #0]
  }

  /* Return BSP status */
  return ret;
9000550c:	68fb      	ldr	r3, [r7, #12]
}
9000550e:	4618      	mov	r0, r3
90005510:	3710      	adds	r7, #16
90005512:	46bd      	mov	sp, r7
90005514:	bd80      	pop	{r7, pc}
90005516:	bf00      	nop
90005518:	240029ac 	.word	0x240029ac
9000551c:	24001238 	.word	0x24001238
90005520:	2400118c 	.word	0x2400118c
90005524:	24001234 	.word	0x24001234

90005528 <BSP_AUDIO_OUT_Resume>:
  *          BSP_AUDIO_OUT_Resume() function should be called for resume (use of BSP_AUDIO_OUT_Play()
  *          function for resume could lead to unexpected behavior).
  * @retval BSP status
  */
int32_t BSP_AUDIO_OUT_Resume(uint32_t Instance)
{
90005528:	b580      	push	{r7, lr}
9000552a:	b084      	sub	sp, #16
9000552c:	af00      	add	r7, sp, #0
9000552e:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
90005530:	2300      	movs	r3, #0
90005532:	60fb      	str	r3, [r7, #12]

  if (Instance >= AUDIO_OUT_INSTANCES_NBR)
90005534:	687b      	ldr	r3, [r7, #4]
90005536:	2b00      	cmp	r3, #0
90005538:	d003      	beq.n	90005542 <BSP_AUDIO_OUT_Resume+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
9000553a:	f06f 0301 	mvn.w	r3, #1
9000553e:	60fb      	str	r3, [r7, #12]
90005540:	e030      	b.n	900055a4 <BSP_AUDIO_OUT_Resume+0x7c>
  }/* Check audio out state */
  else if (Audio_Out_Ctx[Instance].State != AUDIO_OUT_STATE_PAUSE)
90005542:	491b      	ldr	r1, [pc, #108]	; (900055b0 <BSP_AUDIO_OUT_Resume+0x88>)
90005544:	687a      	ldr	r2, [r7, #4]
90005546:	4613      	mov	r3, r2
90005548:	00db      	lsls	r3, r3, #3
9000554a:	4413      	add	r3, r2
9000554c:	009b      	lsls	r3, r3, #2
9000554e:	440b      	add	r3, r1
90005550:	331c      	adds	r3, #28
90005552:	681b      	ldr	r3, [r3, #0]
90005554:	2b03      	cmp	r3, #3
90005556:	d003      	beq.n	90005560 <BSP_AUDIO_OUT_Resume+0x38>
  {
    ret = BSP_ERROR_BUSY;
90005558:	f06f 0302 	mvn.w	r3, #2
9000555c:	60fb      	str	r3, [r7, #12]
9000555e:	e021      	b.n	900055a4 <BSP_AUDIO_OUT_Resume+0x7c>
  }/* Call the audio codec resume function */
  else if (Audio_Drv->Resume(Audio_CompObj) < 0)
90005560:	4b14      	ldr	r3, [pc, #80]	; (900055b4 <BSP_AUDIO_OUT_Resume+0x8c>)
90005562:	681b      	ldr	r3, [r3, #0]
90005564:	695b      	ldr	r3, [r3, #20]
90005566:	4a14      	ldr	r2, [pc, #80]	; (900055b8 <BSP_AUDIO_OUT_Resume+0x90>)
90005568:	6812      	ldr	r2, [r2, #0]
9000556a:	4610      	mov	r0, r2
9000556c:	4798      	blx	r3
9000556e:	4603      	mov	r3, r0
90005570:	2b00      	cmp	r3, #0
90005572:	da03      	bge.n	9000557c <BSP_AUDIO_OUT_Resume+0x54>
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
90005574:	f06f 0304 	mvn.w	r3, #4
90005578:	60fb      	str	r3, [r7, #12]
9000557a:	e013      	b.n	900055a4 <BSP_AUDIO_OUT_Resume+0x7c>
  }/* Call the Media layer pause/resume function */
  else if (HAL_SAI_DMAResume(&haudio_out_sai) != HAL_OK)
9000557c:	480f      	ldr	r0, [pc, #60]	; (900055bc <BSP_AUDIO_OUT_Resume+0x94>)
9000557e:	f00e fc9d 	bl	90013ebc <HAL_SAI_DMAResume>
90005582:	4603      	mov	r3, r0
90005584:	2b00      	cmp	r3, #0
90005586:	d003      	beq.n	90005590 <BSP_AUDIO_OUT_Resume+0x68>
  {
    ret = BSP_ERROR_PERIPH_FAILURE;
90005588:	f06f 0303 	mvn.w	r3, #3
9000558c:	60fb      	str	r3, [r7, #12]
9000558e:	e009      	b.n	900055a4 <BSP_AUDIO_OUT_Resume+0x7c>
  }
  else
  {
    /* Update BSP AUDIO OUT state */
    Audio_Out_Ctx[Instance].State = AUDIO_OUT_STATE_PLAYING;
90005590:	4907      	ldr	r1, [pc, #28]	; (900055b0 <BSP_AUDIO_OUT_Resume+0x88>)
90005592:	687a      	ldr	r2, [r7, #4]
90005594:	4613      	mov	r3, r2
90005596:	00db      	lsls	r3, r3, #3
90005598:	4413      	add	r3, r2
9000559a:	009b      	lsls	r3, r3, #2
9000559c:	440b      	add	r3, r1
9000559e:	331c      	adds	r3, #28
900055a0:	2201      	movs	r2, #1
900055a2:	601a      	str	r2, [r3, #0]
  }

  /* Return BSP status */
  return ret;
900055a4:	68fb      	ldr	r3, [r7, #12]
}
900055a6:	4618      	mov	r0, r3
900055a8:	3710      	adds	r7, #16
900055aa:	46bd      	mov	sp, r7
900055ac:	bd80      	pop	{r7, pc}
900055ae:	bf00      	nop
900055b0:	240029ac 	.word	0x240029ac
900055b4:	2400118c 	.word	0x2400118c
900055b8:	24001234 	.word	0x24001234
900055bc:	24001238 	.word	0x24001238

900055c0 <BSP_AUDIO_OUT_Stop>:
  * @brief  Stops audio playing and Power down the Audio Codec.
  * @param Instance :  AUDIO OUT Instance. It can only be 0 (SAI)
  * @retval BSP status
  */
int32_t BSP_AUDIO_OUT_Stop(uint32_t Instance)
{
900055c0:	b580      	push	{r7, lr}
900055c2:	b084      	sub	sp, #16
900055c4:	af00      	add	r7, sp, #0
900055c6:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
900055c8:	2300      	movs	r3, #0
900055ca:	60fb      	str	r3, [r7, #12]

  if (Instance >= AUDIO_OUT_INSTANCES_NBR)
900055cc:	687b      	ldr	r3, [r7, #4]
900055ce:	2b00      	cmp	r3, #0
900055d0:	d003      	beq.n	900055da <BSP_AUDIO_OUT_Stop+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900055d2:	f06f 0301 	mvn.w	r3, #1
900055d6:	60fb      	str	r3, [r7, #12]
900055d8:	e047      	b.n	9000566a <BSP_AUDIO_OUT_Stop+0xaa>
  }/* Check audio out state */
  else if (Audio_Out_Ctx[Instance].State == AUDIO_OUT_STATE_STOP)
900055da:	4926      	ldr	r1, [pc, #152]	; (90005674 <BSP_AUDIO_OUT_Stop+0xb4>)
900055dc:	687a      	ldr	r2, [r7, #4]
900055de:	4613      	mov	r3, r2
900055e0:	00db      	lsls	r3, r3, #3
900055e2:	4413      	add	r3, r2
900055e4:	009b      	lsls	r3, r3, #2
900055e6:	440b      	add	r3, r1
900055e8:	331c      	adds	r3, #28
900055ea:	681b      	ldr	r3, [r3, #0]
900055ec:	2b02      	cmp	r3, #2
900055ee:	d03c      	beq.n	9000566a <BSP_AUDIO_OUT_Stop+0xaa>
  {
    /* Nothing to do */
  }
  else if ((Audio_Out_Ctx[Instance].State != AUDIO_OUT_STATE_PLAYING) &&
900055f0:	4920      	ldr	r1, [pc, #128]	; (90005674 <BSP_AUDIO_OUT_Stop+0xb4>)
900055f2:	687a      	ldr	r2, [r7, #4]
900055f4:	4613      	mov	r3, r2
900055f6:	00db      	lsls	r3, r3, #3
900055f8:	4413      	add	r3, r2
900055fa:	009b      	lsls	r3, r3, #2
900055fc:	440b      	add	r3, r1
900055fe:	331c      	adds	r3, #28
90005600:	681b      	ldr	r3, [r3, #0]
90005602:	2b01      	cmp	r3, #1
90005604:	d00e      	beq.n	90005624 <BSP_AUDIO_OUT_Stop+0x64>
           (Audio_Out_Ctx[Instance].State != AUDIO_OUT_STATE_PAUSE))
90005606:	491b      	ldr	r1, [pc, #108]	; (90005674 <BSP_AUDIO_OUT_Stop+0xb4>)
90005608:	687a      	ldr	r2, [r7, #4]
9000560a:	4613      	mov	r3, r2
9000560c:	00db      	lsls	r3, r3, #3
9000560e:	4413      	add	r3, r2
90005610:	009b      	lsls	r3, r3, #2
90005612:	440b      	add	r3, r1
90005614:	331c      	adds	r3, #28
90005616:	681b      	ldr	r3, [r3, #0]
  else if ((Audio_Out_Ctx[Instance].State != AUDIO_OUT_STATE_PLAYING) &&
90005618:	2b03      	cmp	r3, #3
9000561a:	d003      	beq.n	90005624 <BSP_AUDIO_OUT_Stop+0x64>
  {
    ret = BSP_ERROR_BUSY;
9000561c:	f06f 0302 	mvn.w	r3, #2
90005620:	60fb      	str	r3, [r7, #12]
90005622:	e022      	b.n	9000566a <BSP_AUDIO_OUT_Stop+0xaa>
  }/* Call the Media layer stop function */
  else if (Audio_Drv->Stop(Audio_CompObj, CODEC_PDWN_SW) < 0)
90005624:	4b14      	ldr	r3, [pc, #80]	; (90005678 <BSP_AUDIO_OUT_Stop+0xb8>)
90005626:	681b      	ldr	r3, [r3, #0]
90005628:	699b      	ldr	r3, [r3, #24]
9000562a:	4a14      	ldr	r2, [pc, #80]	; (9000567c <BSP_AUDIO_OUT_Stop+0xbc>)
9000562c:	6812      	ldr	r2, [r2, #0]
9000562e:	2101      	movs	r1, #1
90005630:	4610      	mov	r0, r2
90005632:	4798      	blx	r3
90005634:	4603      	mov	r3, r0
90005636:	2b00      	cmp	r3, #0
90005638:	da03      	bge.n	90005642 <BSP_AUDIO_OUT_Stop+0x82>
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
9000563a:	f06f 0304 	mvn.w	r3, #4
9000563e:	60fb      	str	r3, [r7, #12]
90005640:	e013      	b.n	9000566a <BSP_AUDIO_OUT_Stop+0xaa>
  }
  else if (HAL_SAI_DMAStop(&haudio_out_sai) != HAL_OK)
90005642:	480f      	ldr	r0, [pc, #60]	; (90005680 <BSP_AUDIO_OUT_Stop+0xc0>)
90005644:	f00e fc6b 	bl	90013f1e <HAL_SAI_DMAStop>
90005648:	4603      	mov	r3, r0
9000564a:	2b00      	cmp	r3, #0
9000564c:	d003      	beq.n	90005656 <BSP_AUDIO_OUT_Stop+0x96>
  {
    ret = BSP_ERROR_PERIPH_FAILURE;
9000564e:	f06f 0303 	mvn.w	r3, #3
90005652:	60fb      	str	r3, [r7, #12]
90005654:	e009      	b.n	9000566a <BSP_AUDIO_OUT_Stop+0xaa>
  }
  else
  {
    /* Update BSP AUDIO OUT state */
    Audio_Out_Ctx[Instance].State = AUDIO_OUT_STATE_STOP;
90005656:	4907      	ldr	r1, [pc, #28]	; (90005674 <BSP_AUDIO_OUT_Stop+0xb4>)
90005658:	687a      	ldr	r2, [r7, #4]
9000565a:	4613      	mov	r3, r2
9000565c:	00db      	lsls	r3, r3, #3
9000565e:	4413      	add	r3, r2
90005660:	009b      	lsls	r3, r3, #2
90005662:	440b      	add	r3, r1
90005664:	331c      	adds	r3, #28
90005666:	2202      	movs	r2, #2
90005668:	601a      	str	r2, [r3, #0]
  }

  /* Return BSP status */
  return ret;
9000566a:	68fb      	ldr	r3, [r7, #12]
}
9000566c:	4618      	mov	r0, r3
9000566e:	3710      	adds	r7, #16
90005670:	46bd      	mov	sp, r7
90005672:	bd80      	pop	{r7, pc}
90005674:	240029ac 	.word	0x240029ac
90005678:	2400118c 	.word	0x2400118c
9000567c:	24001234 	.word	0x24001234
90005680:	24001238 	.word	0x24001238

90005684 <BSP_AUDIO_OUT_SetVolume>:
  * @param  Volume    Volume level to be set in percentage from 0% to 100% (0 for
  *         Mute and 100 for Max volume level).
  * @retval BSP status
  */
int32_t BSP_AUDIO_OUT_SetVolume(uint32_t Instance, uint32_t Volume)
{
90005684:	b590      	push	{r4, r7, lr}
90005686:	b085      	sub	sp, #20
90005688:	af00      	add	r7, sp, #0
9000568a:	6078      	str	r0, [r7, #4]
9000568c:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
9000568e:	2300      	movs	r3, #0
90005690:	60fb      	str	r3, [r7, #12]

  if ((Instance >= AUDIO_OUT_INSTANCES_NBR) || (Volume > 100U))
90005692:	687b      	ldr	r3, [r7, #4]
90005694:	2b00      	cmp	r3, #0
90005696:	d102      	bne.n	9000569e <BSP_AUDIO_OUT_SetVolume+0x1a>
90005698:	683b      	ldr	r3, [r7, #0]
9000569a:	2b64      	cmp	r3, #100	; 0x64
9000569c:	d903      	bls.n	900056a6 <BSP_AUDIO_OUT_SetVolume+0x22>
  {
    ret = BSP_ERROR_WRONG_PARAM;
9000569e:	f06f 0301 	mvn.w	r3, #1
900056a2:	60fb      	str	r3, [r7, #12]
900056a4:	e03e      	b.n	90005724 <BSP_AUDIO_OUT_SetVolume+0xa0>
  }
  else
  {
    /* Call the codec volume control function with converted volume value */
    if (Audio_Drv->SetVolume(Audio_CompObj, AUDIO_VOLUME_OUTPUT, VOLUME_OUT_CONVERT(Volume)) < 0)
900056a6:	4b22      	ldr	r3, [pc, #136]	; (90005730 <BSP_AUDIO_OUT_SetVolume+0xac>)
900056a8:	681b      	ldr	r3, [r3, #0]
900056aa:	6a5c      	ldr	r4, [r3, #36]	; 0x24
900056ac:	4b21      	ldr	r3, [pc, #132]	; (90005734 <BSP_AUDIO_OUT_SetVolume+0xb0>)
900056ae:	6818      	ldr	r0, [r3, #0]
900056b0:	683b      	ldr	r3, [r7, #0]
900056b2:	2b64      	cmp	r3, #100	; 0x64
900056b4:	d809      	bhi.n	900056ca <BSP_AUDIO_OUT_SetVolume+0x46>
900056b6:	683a      	ldr	r2, [r7, #0]
900056b8:	4613      	mov	r3, r2
900056ba:	019b      	lsls	r3, r3, #6
900056bc:	1a9b      	subs	r3, r3, r2
900056be:	4a1e      	ldr	r2, [pc, #120]	; (90005738 <BSP_AUDIO_OUT_SetVolume+0xb4>)
900056c0:	fba2 2303 	umull	r2, r3, r2, r3
900056c4:	095b      	lsrs	r3, r3, #5
900056c6:	b2db      	uxtb	r3, r3
900056c8:	e000      	b.n	900056cc <BSP_AUDIO_OUT_SetVolume+0x48>
900056ca:	233f      	movs	r3, #63	; 0x3f
900056cc:	461a      	mov	r2, r3
900056ce:	2101      	movs	r1, #1
900056d0:	47a0      	blx	r4
900056d2:	4603      	mov	r3, r0
900056d4:	2b00      	cmp	r3, #0
900056d6:	da03      	bge.n	900056e0 <BSP_AUDIO_OUT_SetVolume+0x5c>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
900056d8:	f06f 0304 	mvn.w	r3, #4
900056dc:	60fb      	str	r3, [r7, #12]
900056de:	e017      	b.n	90005710 <BSP_AUDIO_OUT_SetVolume+0x8c>
    }
    else if (Volume == 0U)
900056e0:	683b      	ldr	r3, [r7, #0]
900056e2:	2b00      	cmp	r3, #0
900056e4:	d10a      	bne.n	900056fc <BSP_AUDIO_OUT_SetVolume+0x78>
    {
      /* Update Mute State */
      Audio_Out_Ctx[Instance].IsMute = BSP_AUDIO_MUTE_ENABLED;
900056e6:	4915      	ldr	r1, [pc, #84]	; (9000573c <BSP_AUDIO_OUT_SetVolume+0xb8>)
900056e8:	687a      	ldr	r2, [r7, #4]
900056ea:	4613      	mov	r3, r2
900056ec:	00db      	lsls	r3, r3, #3
900056ee:	4413      	add	r3, r2
900056f0:	009b      	lsls	r3, r3, #2
900056f2:	440b      	add	r3, r1
900056f4:	3318      	adds	r3, #24
900056f6:	2201      	movs	r2, #1
900056f8:	601a      	str	r2, [r3, #0]
900056fa:	e009      	b.n	90005710 <BSP_AUDIO_OUT_SetVolume+0x8c>
    }
    else
    {
      /* Update Mute State */
      Audio_Out_Ctx[Instance].IsMute = BSP_AUDIO_MUTE_DISABLED;
900056fc:	490f      	ldr	r1, [pc, #60]	; (9000573c <BSP_AUDIO_OUT_SetVolume+0xb8>)
900056fe:	687a      	ldr	r2, [r7, #4]
90005700:	4613      	mov	r3, r2
90005702:	00db      	lsls	r3, r3, #3
90005704:	4413      	add	r3, r2
90005706:	009b      	lsls	r3, r3, #2
90005708:	440b      	add	r3, r1
9000570a:	3318      	adds	r3, #24
9000570c:	2200      	movs	r2, #0
9000570e:	601a      	str	r2, [r3, #0]
    }
    Audio_Out_Ctx[Instance].Volume = Volume;
90005710:	490a      	ldr	r1, [pc, #40]	; (9000573c <BSP_AUDIO_OUT_SetVolume+0xb8>)
90005712:	687a      	ldr	r2, [r7, #4]
90005714:	4613      	mov	r3, r2
90005716:	00db      	lsls	r3, r3, #3
90005718:	4413      	add	r3, r2
9000571a:	009b      	lsls	r3, r3, #2
9000571c:	440b      	add	r3, r1
9000571e:	3310      	adds	r3, #16
90005720:	683a      	ldr	r2, [r7, #0]
90005722:	601a      	str	r2, [r3, #0]
  }

  /* Return BSP status */
  return ret;
90005724:	68fb      	ldr	r3, [r7, #12]
}
90005726:	4618      	mov	r0, r3
90005728:	3714      	adds	r7, #20
9000572a:	46bd      	mov	sp, r7
9000572c:	bd90      	pop	{r4, r7, pc}
9000572e:	bf00      	nop
90005730:	2400118c 	.word	0x2400118c
90005734:	24001234 	.word	0x24001234
90005738:	51eb851f 	.word	0x51eb851f
9000573c:	240029ac 	.word	0x240029ac

90005740 <BSP_AUDIO_OUT_SetSampleRate>:
  * @note   This API should be called after the BSP_AUDIO_OUT_Init() to adjust the
  *         audio frequency.
  * @retval BSP status
  */
int32_t BSP_AUDIO_OUT_SetSampleRate(uint32_t Instance, uint32_t SampleRate)
{
90005740:	b580      	push	{r7, lr}
90005742:	b084      	sub	sp, #16
90005744:	af00      	add	r7, sp, #0
90005746:	6078      	str	r0, [r7, #4]
90005748:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
9000574a:	2300      	movs	r3, #0
9000574c:	60fb      	str	r3, [r7, #12]

  if (Instance >= AUDIO_OUT_INSTANCES_NBR)
9000574e:	687b      	ldr	r3, [r7, #4]
90005750:	2b00      	cmp	r3, #0
90005752:	d003      	beq.n	9000575c <BSP_AUDIO_OUT_SetSampleRate+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90005754:	f06f 0301 	mvn.w	r3, #1
90005758:	60fb      	str	r3, [r7, #12]
9000575a:	e058      	b.n	9000580e <BSP_AUDIO_OUT_SetSampleRate+0xce>
  }
  /* Check audio out state */
  else if (Audio_Out_Ctx[Instance].State != AUDIO_OUT_STATE_STOP)
9000575c:	492e      	ldr	r1, [pc, #184]	; (90005818 <BSP_AUDIO_OUT_SetSampleRate+0xd8>)
9000575e:	687a      	ldr	r2, [r7, #4]
90005760:	4613      	mov	r3, r2
90005762:	00db      	lsls	r3, r3, #3
90005764:	4413      	add	r3, r2
90005766:	009b      	lsls	r3, r3, #2
90005768:	440b      	add	r3, r1
9000576a:	331c      	adds	r3, #28
9000576c:	681b      	ldr	r3, [r3, #0]
9000576e:	2b02      	cmp	r3, #2
90005770:	d003      	beq.n	9000577a <BSP_AUDIO_OUT_SetSampleRate+0x3a>
  {
    ret = BSP_ERROR_BUSY;
90005772:	f06f 0302 	mvn.w	r3, #2
90005776:	60fb      	str	r3, [r7, #12]
90005778:	e049      	b.n	9000580e <BSP_AUDIO_OUT_SetSampleRate+0xce>
  }
  /* Check if record on instance 0 is on going and corresponding sample rate */
  else if ((Audio_In_Ctx[0].State != AUDIO_IN_STATE_RESET) &&
9000577a:	4b28      	ldr	r3, [pc, #160]	; (9000581c <BSP_AUDIO_OUT_SetSampleRate+0xdc>)
9000577c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9000577e:	2b00      	cmp	r3, #0
90005780:	d008      	beq.n	90005794 <BSP_AUDIO_OUT_SetSampleRate+0x54>
           (Audio_In_Ctx[0].SampleRate != SampleRate))
90005782:	4b26      	ldr	r3, [pc, #152]	; (9000581c <BSP_AUDIO_OUT_SetSampleRate+0xdc>)
90005784:	689b      	ldr	r3, [r3, #8]
  else if ((Audio_In_Ctx[0].State != AUDIO_IN_STATE_RESET) &&
90005786:	683a      	ldr	r2, [r7, #0]
90005788:	429a      	cmp	r2, r3
9000578a:	d003      	beq.n	90005794 <BSP_AUDIO_OUT_SetSampleRate+0x54>
  {
    ret = BSP_ERROR_FEATURE_NOT_SUPPORTED;
9000578c:	f06f 030a 	mvn.w	r3, #10
90005790:	60fb      	str	r3, [r7, #12]
90005792:	e03c      	b.n	9000580e <BSP_AUDIO_OUT_SetSampleRate+0xce>
  }/* Check if sample rate is modified */
  else if (Audio_Out_Ctx[Instance].SampleRate == SampleRate)
90005794:	4920      	ldr	r1, [pc, #128]	; (90005818 <BSP_AUDIO_OUT_SetSampleRate+0xd8>)
90005796:	687a      	ldr	r2, [r7, #4]
90005798:	4613      	mov	r3, r2
9000579a:	00db      	lsls	r3, r3, #3
9000579c:	4413      	add	r3, r2
9000579e:	009b      	lsls	r3, r3, #2
900057a0:	440b      	add	r3, r1
900057a2:	3308      	adds	r3, #8
900057a4:	681b      	ldr	r3, [r3, #0]
900057a6:	683a      	ldr	r2, [r7, #0]
900057a8:	429a      	cmp	r2, r3
900057aa:	d030      	beq.n	9000580e <BSP_AUDIO_OUT_SetSampleRate+0xce>
    /* Nothing to do */
  }
  else
  {
    /* Call the Codec output device function */
    if (Audio_Drv->SetFrequency(Audio_CompObj, SampleRate) != 0)
900057ac:	4b1c      	ldr	r3, [pc, #112]	; (90005820 <BSP_AUDIO_OUT_SetSampleRate+0xe0>)
900057ae:	681b      	ldr	r3, [r3, #0]
900057b0:	69db      	ldr	r3, [r3, #28]
900057b2:	4a1c      	ldr	r2, [pc, #112]	; (90005824 <BSP_AUDIO_OUT_SetSampleRate+0xe4>)
900057b4:	6812      	ldr	r2, [r2, #0]
900057b6:	6839      	ldr	r1, [r7, #0]
900057b8:	4610      	mov	r0, r2
900057ba:	4798      	blx	r3
900057bc:	4603      	mov	r3, r0
900057be:	2b00      	cmp	r3, #0
900057c0:	d003      	beq.n	900057ca <BSP_AUDIO_OUT_SetSampleRate+0x8a>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
900057c2:	f06f 0304 	mvn.w	r3, #4
900057c6:	60fb      	str	r3, [r7, #12]
900057c8:	e021      	b.n	9000580e <BSP_AUDIO_OUT_SetSampleRate+0xce>
    }
    else
    {
      /* Update the SAI audio frequency configuration */
      haudio_out_sai.Init.AudioFrequency = SampleRate;
900057ca:	4a17      	ldr	r2, [pc, #92]	; (90005828 <BSP_AUDIO_OUT_SetSampleRate+0xe8>)
900057cc:	683b      	ldr	r3, [r7, #0]
900057ce:	6213      	str	r3, [r2, #32]
      /* PLL clock is set depending by the AudioFreq (44.1khz vs 48khz groups) */
      if (MX_SAI2_ClockConfig(&haudio_out_sai, SampleRate) != HAL_OK)
900057d0:	6839      	ldr	r1, [r7, #0]
900057d2:	4815      	ldr	r0, [pc, #84]	; (90005828 <BSP_AUDIO_OUT_SetSampleRate+0xe8>)
900057d4:	f7ff fd6d 	bl	900052b2 <MX_SAI2_ClockConfig>
900057d8:	4603      	mov	r3, r0
900057da:	2b00      	cmp	r3, #0
900057dc:	d003      	beq.n	900057e6 <BSP_AUDIO_OUT_SetSampleRate+0xa6>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
900057de:	f06f 0303 	mvn.w	r3, #3
900057e2:	60fb      	str	r3, [r7, #12]
900057e4:	e013      	b.n	9000580e <BSP_AUDIO_OUT_SetSampleRate+0xce>
      }
      else if (HAL_SAI_Init(&haudio_out_sai) != HAL_OK)
900057e6:	4810      	ldr	r0, [pc, #64]	; (90005828 <BSP_AUDIO_OUT_SetSampleRate+0xe8>)
900057e8:	f00e f82c 	bl	90013844 <HAL_SAI_Init>
900057ec:	4603      	mov	r3, r0
900057ee:	2b00      	cmp	r3, #0
900057f0:	d003      	beq.n	900057fa <BSP_AUDIO_OUT_SetSampleRate+0xba>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
900057f2:	f06f 0303 	mvn.w	r3, #3
900057f6:	60fb      	str	r3, [r7, #12]
900057f8:	e009      	b.n	9000580e <BSP_AUDIO_OUT_SetSampleRate+0xce>
      }
#endif /* (USE_HAL_SAI_REGISTER_CALLBACKS == 1U) */
      /* Store new sample rate */
      else
      {
        Audio_Out_Ctx[Instance].SampleRate = SampleRate;
900057fa:	4907      	ldr	r1, [pc, #28]	; (90005818 <BSP_AUDIO_OUT_SetSampleRate+0xd8>)
900057fc:	687a      	ldr	r2, [r7, #4]
900057fe:	4613      	mov	r3, r2
90005800:	00db      	lsls	r3, r3, #3
90005802:	4413      	add	r3, r2
90005804:	009b      	lsls	r3, r3, #2
90005806:	440b      	add	r3, r1
90005808:	3308      	adds	r3, #8
9000580a:	683a      	ldr	r2, [r7, #0]
9000580c:	601a      	str	r2, [r3, #0]
      }
    }
  }

  /* Return BSP status */
  return ret;
9000580e:	68fb      	ldr	r3, [r7, #12]
}
90005810:	4618      	mov	r0, r3
90005812:	3710      	adds	r7, #16
90005814:	46bd      	mov	sp, r7
90005816:	bd80      	pop	{r7, pc}
90005818:	240029ac 	.word	0x240029ac
9000581c:	240029d0 	.word	0x240029d0
90005820:	2400118c 	.word	0x2400118c
90005824:	24001234 	.word	0x24001234
90005828:	24001238 	.word	0x24001238

9000582c <BSP_AUDIO_OUT_GetState>:
  * @param Instance :  AUDIO OUT Instance. It can only be 0 (SAI)
  * @param  State     Audio Out state
  * @retval BSP status
  */
int32_t BSP_AUDIO_OUT_GetState(uint32_t Instance, uint32_t *State)
{
9000582c:	b480      	push	{r7}
9000582e:	b085      	sub	sp, #20
90005830:	af00      	add	r7, sp, #0
90005832:	6078      	str	r0, [r7, #4]
90005834:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
90005836:	2300      	movs	r3, #0
90005838:	60fb      	str	r3, [r7, #12]

  if (Instance >= AUDIO_OUT_INSTANCES_NBR)
9000583a:	687b      	ldr	r3, [r7, #4]
9000583c:	2b00      	cmp	r3, #0
9000583e:	d003      	beq.n	90005848 <BSP_AUDIO_OUT_GetState+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90005840:	f06f 0301 	mvn.w	r3, #1
90005844:	60fb      	str	r3, [r7, #12]
90005846:	e00a      	b.n	9000585e <BSP_AUDIO_OUT_GetState+0x32>
  }
  else
  {
    /* Return audio Output State */
    *State = Audio_Out_Ctx[Instance].State;
90005848:	4908      	ldr	r1, [pc, #32]	; (9000586c <BSP_AUDIO_OUT_GetState+0x40>)
9000584a:	687a      	ldr	r2, [r7, #4]
9000584c:	4613      	mov	r3, r2
9000584e:	00db      	lsls	r3, r3, #3
90005850:	4413      	add	r3, r2
90005852:	009b      	lsls	r3, r3, #2
90005854:	440b      	add	r3, r1
90005856:	331c      	adds	r3, #28
90005858:	681a      	ldr	r2, [r3, #0]
9000585a:	683b      	ldr	r3, [r7, #0]
9000585c:	601a      	str	r2, [r3, #0]
  }

  /* Return BSP status */
  return ret;
9000585e:	68fb      	ldr	r3, [r7, #12]
}
90005860:	4618      	mov	r0, r3
90005862:	3714      	adds	r7, #20
90005864:	46bd      	mov	sp, r7
90005866:	f85d 7b04 	ldr.w	r7, [sp], #4
9000586a:	4770      	bx	lr
9000586c:	240029ac 	.word	0x240029ac

90005870 <BSP_AUDIO_OUT_IRQHandler>:
  * @brief  This function handles Audio Out DMA interrupt requests.
  * @param  Instance Audio OUT instance
  * @retval None
  */
void BSP_AUDIO_OUT_IRQHandler(uint32_t Instance)
{
90005870:	b580      	push	{r7, lr}
90005872:	b082      	sub	sp, #8
90005874:	af00      	add	r7, sp, #0
90005876:	6078      	str	r0, [r7, #4]
  if (Instance == 0U)
90005878:	687b      	ldr	r3, [r7, #4]
9000587a:	2b00      	cmp	r3, #0
9000587c:	d105      	bne.n	9000588a <BSP_AUDIO_OUT_IRQHandler+0x1a>
  {
    HAL_DMA_IRQHandler(haudio_out_sai.hdmatx);
9000587e:	4b05      	ldr	r3, [pc, #20]	; (90005894 <BSP_AUDIO_OUT_IRQHandler+0x24>)
90005880:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
90005884:	4618      	mov	r0, r3
90005886:	f005 fa41 	bl	9000ad0c <HAL_DMA_IRQHandler>
  }
}
9000588a:	bf00      	nop
9000588c:	3708      	adds	r7, #8
9000588e:	46bd      	mov	sp, r7
90005890:	bd80      	pop	{r7, pc}
90005892:	bf00      	nop
90005894:	24001238 	.word	0x24001238

90005898 <HAL_SAI_TxCpltCallback>:
  * @brief  Tx Transfer completed callbacks.
  * @param  hsai SAI handle
  * @retval None
  */
void HAL_SAI_TxCpltCallback(SAI_HandleTypeDef *hsai)
{
90005898:	b580      	push	{r7, lr}
9000589a:	b082      	sub	sp, #8
9000589c:	af00      	add	r7, sp, #0
9000589e:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hsai);

  /* Manage the remaining file size and new address offset: This function
     should be coded by user (its prototype is already declared in stm32h750b_discovery_audio.h) */
  BSP_AUDIO_OUT_TransferComplete_CallBack(0);
900058a0:	2000      	movs	r0, #0
900058a2:	f010 fdb9 	bl	90016418 <BSP_AUDIO_OUT_TransferComplete_CallBack>
}
900058a6:	bf00      	nop
900058a8:	3708      	adds	r7, #8
900058aa:	46bd      	mov	sp, r7
900058ac:	bd80      	pop	{r7, pc}

900058ae <HAL_SAI_TxHalfCpltCallback>:
  * @brief  Tx Half Transfer completed callbacks.
  * @param  hsai  SAI handle
  * @retval None
  */
void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
900058ae:	b580      	push	{r7, lr}
900058b0:	b082      	sub	sp, #8
900058b2:	af00      	add	r7, sp, #0
900058b4:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hsai);

  /* Manage the remaining file size and new address offset: This function
     should be coded by user (its prototype is already declared in stm32h750b_discovery_audio.h) */
  BSP_AUDIO_OUT_HalfTransfer_CallBack(0);
900058b6:	2000      	movs	r0, #0
900058b8:	f010 fdc4 	bl	90016444 <BSP_AUDIO_OUT_HalfTransfer_CallBack>
}
900058bc:	bf00      	nop
900058be:	3708      	adds	r7, #8
900058c0:	46bd      	mov	sp, r7
900058c2:	bd80      	pop	{r7, pc}

900058c4 <HAL_SAI_ErrorCallback>:
  * @brief  SAI error callbacks.
  * @param  hsai  SAI handle
  * @retval None
  */
void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
900058c4:	b580      	push	{r7, lr}
900058c6:	b082      	sub	sp, #8
900058c8:	af00      	add	r7, sp, #0
900058ca:	6078      	str	r0, [r7, #4]
  if (hsai->Instance == AUDIO_OUT_SAIx)
900058cc:	687b      	ldr	r3, [r7, #4]
900058ce:	681b      	ldr	r3, [r3, #0]
900058d0:	4a06      	ldr	r2, [pc, #24]	; (900058ec <HAL_SAI_ErrorCallback+0x28>)
900058d2:	4293      	cmp	r3, r2
900058d4:	d103      	bne.n	900058de <HAL_SAI_ErrorCallback+0x1a>
  {
    BSP_AUDIO_OUT_Error_CallBack(0);
900058d6:	2000      	movs	r0, #0
900058d8:	f010 fdca 	bl	90016470 <BSP_AUDIO_OUT_Error_CallBack>
  }
  else
  {
    BSP_AUDIO_IN_Error_CallBack(0);
  }
}
900058dc:	e002      	b.n	900058e4 <HAL_SAI_ErrorCallback+0x20>
    BSP_AUDIO_IN_Error_CallBack(0);
900058de:	2000      	movs	r0, #0
900058e0:	f000 fcc4 	bl	9000626c <BSP_AUDIO_IN_Error_CallBack>
}
900058e4:	bf00      	nop
900058e6:	3708      	adds	r7, #8
900058e8:	46bd      	mov	sp, r7
900058ea:	bd80      	pop	{r7, pc}
900058ec:	40015c04 	.word	0x40015c04

900058f0 <BSP_AUDIO_IN_Init>:
  *       - 1 if SAI PDM is used
  * @param  AudioInit Init structure
  * @retval BSP status
  */
int32_t BSP_AUDIO_IN_Init(uint32_t Instance, BSP_AUDIO_Init_t *AudioInit)
{
900058f0:	b590      	push	{r4, r7, lr}
900058f2:	b095      	sub	sp, #84	; 0x54
900058f4:	af00      	add	r7, sp, #0
900058f6:	6078      	str	r0, [r7, #4]
900058f8:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
900058fa:	2300      	movs	r3, #0
900058fc:	64fb      	str	r3, [r7, #76]	; 0x4c

  if(Instance >= AUDIO_IN_INSTANCES_NBR)
900058fe:	687b      	ldr	r3, [r7, #4]
90005900:	2b01      	cmp	r3, #1
90005902:	d903      	bls.n	9000590c <BSP_AUDIO_IN_Init+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90005904:	f06f 0301 	mvn.w	r3, #1
90005908:	64fb      	str	r3, [r7, #76]	; 0x4c
9000590a:	e17c      	b.n	90005c06 <BSP_AUDIO_IN_Init+0x316>
  }
  else
  {
    /* Store the audio record context */
    Audio_In_Ctx[Instance].Device = AudioInit->Device;
9000590c:	683b      	ldr	r3, [r7, #0]
9000590e:	6819      	ldr	r1, [r3, #0]
90005910:	489e      	ldr	r0, [pc, #632]	; (90005b8c <BSP_AUDIO_IN_Init+0x29c>)
90005912:	687a      	ldr	r2, [r7, #4]
90005914:	4613      	mov	r3, r2
90005916:	005b      	lsls	r3, r3, #1
90005918:	4413      	add	r3, r2
9000591a:	011b      	lsls	r3, r3, #4
9000591c:	4403      	add	r3, r0
9000591e:	3304      	adds	r3, #4
90005920:	6019      	str	r1, [r3, #0]
    Audio_In_Ctx[Instance].ChannelsNbr = AudioInit->ChannelsNbr;
90005922:	683b      	ldr	r3, [r7, #0]
90005924:	68d9      	ldr	r1, [r3, #12]
90005926:	4899      	ldr	r0, [pc, #612]	; (90005b8c <BSP_AUDIO_IN_Init+0x29c>)
90005928:	687a      	ldr	r2, [r7, #4]
9000592a:	4613      	mov	r3, r2
9000592c:	005b      	lsls	r3, r3, #1
9000592e:	4413      	add	r3, r2
90005930:	011b      	lsls	r3, r3, #4
90005932:	4403      	add	r3, r0
90005934:	3310      	adds	r3, #16
90005936:	6019      	str	r1, [r3, #0]
    Audio_In_Ctx[Instance].SampleRate = AudioInit->SampleRate;
90005938:	683b      	ldr	r3, [r7, #0]
9000593a:	6859      	ldr	r1, [r3, #4]
9000593c:	4893      	ldr	r0, [pc, #588]	; (90005b8c <BSP_AUDIO_IN_Init+0x29c>)
9000593e:	687a      	ldr	r2, [r7, #4]
90005940:	4613      	mov	r3, r2
90005942:	005b      	lsls	r3, r3, #1
90005944:	4413      	add	r3, r2
90005946:	011b      	lsls	r3, r3, #4
90005948:	4403      	add	r3, r0
9000594a:	3308      	adds	r3, #8
9000594c:	6019      	str	r1, [r3, #0]
    Audio_In_Ctx[Instance].BitsPerSample = AudioInit->BitsPerSample;
9000594e:	683b      	ldr	r3, [r7, #0]
90005950:	6899      	ldr	r1, [r3, #8]
90005952:	488e      	ldr	r0, [pc, #568]	; (90005b8c <BSP_AUDIO_IN_Init+0x29c>)
90005954:	687a      	ldr	r2, [r7, #4]
90005956:	4613      	mov	r3, r2
90005958:	005b      	lsls	r3, r3, #1
9000595a:	4413      	add	r3, r2
9000595c:	011b      	lsls	r3, r3, #4
9000595e:	4403      	add	r3, r0
90005960:	330c      	adds	r3, #12
90005962:	6019      	str	r1, [r3, #0]
    Audio_In_Ctx[Instance].Volume = AudioInit->Volume;
90005964:	683b      	ldr	r3, [r7, #0]
90005966:	6919      	ldr	r1, [r3, #16]
90005968:	4888      	ldr	r0, [pc, #544]	; (90005b8c <BSP_AUDIO_IN_Init+0x29c>)
9000596a:	687a      	ldr	r2, [r7, #4]
9000596c:	4613      	mov	r3, r2
9000596e:	005b      	lsls	r3, r3, #1
90005970:	4413      	add	r3, r2
90005972:	011b      	lsls	r3, r3, #4
90005974:	4403      	add	r3, r0
90005976:	3320      	adds	r3, #32
90005978:	6019      	str	r1, [r3, #0]
    Audio_In_Ctx[Instance].State = AUDIO_IN_STATE_RESET;
9000597a:	4984      	ldr	r1, [pc, #528]	; (90005b8c <BSP_AUDIO_IN_Init+0x29c>)
9000597c:	687a      	ldr	r2, [r7, #4]
9000597e:	4613      	mov	r3, r2
90005980:	005b      	lsls	r3, r3, #1
90005982:	4413      	add	r3, r2
90005984:	011b      	lsls	r3, r3, #4
90005986:	440b      	add	r3, r1
90005988:	3324      	adds	r3, #36	; 0x24
9000598a:	2200      	movs	r2, #0
9000598c:	601a      	str	r2, [r3, #0]

    if (Instance == 0U)
9000598e:	687b      	ldr	r3, [r7, #4]
90005990:	2b00      	cmp	r3, #0
90005992:	f040 80bc 	bne.w	90005b0e <BSP_AUDIO_IN_Init+0x21e>
    {
      /* PLL clock is set depending by the AudioFreq (44.1khz vs 48khz groups) */
      if (MX_SAI2_ClockConfig(&haudio_in_sai, AudioInit->SampleRate) != HAL_OK)
90005996:	683b      	ldr	r3, [r7, #0]
90005998:	685b      	ldr	r3, [r3, #4]
9000599a:	4619      	mov	r1, r3
9000599c:	487c      	ldr	r0, [pc, #496]	; (90005b90 <BSP_AUDIO_IN_Init+0x2a0>)
9000599e:	f7ff fc88 	bl	900052b2 <MX_SAI2_ClockConfig>
900059a2:	4603      	mov	r3, r0
900059a4:	2b00      	cmp	r3, #0
900059a6:	d003      	beq.n	900059b0 <BSP_AUDIO_IN_Init+0xc0>
      {
        ret = BSP_ERROR_CLOCK_FAILURE;
900059a8:	f06f 0308 	mvn.w	r3, #8
900059ac:	64fb      	str	r3, [r7, #76]	; 0x4c
900059ae:	e12a      	b.n	90005c06 <BSP_AUDIO_IN_Init+0x316>
      }
      else
      {
        haudio_in_sai.Instance = AUDIO_IN_SAIx;
900059b0:	4b77      	ldr	r3, [pc, #476]	; (90005b90 <BSP_AUDIO_IN_Init+0x2a0>)
900059b2:	4a78      	ldr	r2, [pc, #480]	; (90005b94 <BSP_AUDIO_IN_Init+0x2a4>)
900059b4:	601a      	str	r2, [r3, #0]

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 0)
        SAI_MspInit(&haudio_in_sai);
900059b6:	4876      	ldr	r0, [pc, #472]	; (90005b90 <BSP_AUDIO_IN_Init+0x2a0>)
900059b8:	f000 fcbc 	bl	90006334 <SAI_MspInit>
        {
#endif /* (USE_HAL_SAI_REGISTER_CALLBACKS == 0) */

          MX_SAI_Config_t mx_config;

          mx_config.MonoStereoMode = (AudioInit->ChannelsNbr == 1U) ? SAI_MONOMODE : SAI_STEREOMODE;
900059bc:	683b      	ldr	r3, [r7, #0]
900059be:	68db      	ldr	r3, [r3, #12]
900059c0:	2b01      	cmp	r3, #1
900059c2:	d102      	bne.n	900059ca <BSP_AUDIO_IN_Init+0xda>
900059c4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900059c8:	e000      	b.n	900059cc <BSP_AUDIO_IN_Init+0xdc>
900059ca:	2300      	movs	r3, #0
900059cc:	61bb      	str	r3, [r7, #24]
          mx_config.DataSize = SAI_DATASIZE_16;
900059ce:	2380      	movs	r3, #128	; 0x80
900059d0:	617b      	str	r3, [r7, #20]
          mx_config.FrameLength = 64;
900059d2:	2340      	movs	r3, #64	; 0x40
900059d4:	62fb      	str	r3, [r7, #44]	; 0x2c
          mx_config.ActiveFrameLength = 32;
900059d6:	2320      	movs	r3, #32
900059d8:	633b      	str	r3, [r7, #48]	; 0x30
          if (AudioInit->BitsPerSample == AUDIO_RESOLUTION_32B)
900059da:	683b      	ldr	r3, [r7, #0]
900059dc:	689b      	ldr	r3, [r3, #8]
900059de:	2b20      	cmp	r3, #32
900059e0:	d105      	bne.n	900059ee <BSP_AUDIO_IN_Init+0xfe>
          {
            mx_config.DataSize = SAI_DATASIZE_32;
900059e2:	23e0      	movs	r3, #224	; 0xe0
900059e4:	617b      	str	r3, [r7, #20]
            mx_config.FrameLength = 128;
900059e6:	2380      	movs	r3, #128	; 0x80
900059e8:	62fb      	str	r3, [r7, #44]	; 0x2c
            mx_config.ActiveFrameLength = 64;
900059ea:	2340      	movs	r3, #64	; 0x40
900059ec:	633b      	str	r3, [r7, #48]	; 0x30
          }
          mx_config.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
900059ee:	2300      	movs	r3, #0
900059f0:	627b      	str	r3, [r7, #36]	; 0x24
          switch (AudioInit->Device)
900059f2:	683b      	ldr	r3, [r7, #0]
900059f4:	681b      	ldr	r3, [r3, #0]
900059f6:	2b00      	cmp	r3, #0
900059f8:	d102      	bne.n	90005a00 <BSP_AUDIO_IN_Init+0x110>
          {
          case AUDIO_IN_DEVICE_ANALOG_MIC:
            mx_config.SlotActive = SAI_SLOTACTIVE_0;
900059fa:	2301      	movs	r3, #1
900059fc:	637b      	str	r3, [r7, #52]	; 0x34
            break;
900059fe:	e002      	b.n	90005a06 <BSP_AUDIO_IN_Init+0x116>
          case AUDIO_IN_DEVICE_DIGITAL_MIC:
          default:
            mx_config.SlotActive = CODEC_AUDIOFRAME_SLOT_13;
90005a00:	230a      	movs	r3, #10
90005a02:	637b      	str	r3, [r7, #52]	; 0x34
            break;
90005a04:	bf00      	nop
          }

          /* Prepare haudio_in_sai handle */
          haudio_in_sai.Instance = SAI2_Block_B;
90005a06:	4b62      	ldr	r3, [pc, #392]	; (90005b90 <BSP_AUDIO_IN_Init+0x2a0>)
90005a08:	4a62      	ldr	r2, [pc, #392]	; (90005b94 <BSP_AUDIO_IN_Init+0x2a4>)
90005a0a:	601a      	str	r2, [r3, #0]
          mx_config.AudioFrequency = Audio_In_Ctx[Instance].SampleRate;
90005a0c:	495f      	ldr	r1, [pc, #380]	; (90005b8c <BSP_AUDIO_IN_Init+0x29c>)
90005a0e:	687a      	ldr	r2, [r7, #4]
90005a10:	4613      	mov	r3, r2
90005a12:	005b      	lsls	r3, r3, #1
90005a14:	4413      	add	r3, r2
90005a16:	011b      	lsls	r3, r3, #4
90005a18:	440b      	add	r3, r1
90005a1a:	3308      	adds	r3, #8
90005a1c:	681b      	ldr	r3, [r3, #0]
90005a1e:	60fb      	str	r3, [r7, #12]
          mx_config.AudioMode = SAI_MODESLAVE_RX;
90005a20:	2303      	movs	r3, #3
90005a22:	613b      	str	r3, [r7, #16]
          mx_config.ClockStrobing = SAI_CLOCKSTROBING_RISINGEDGE;
90005a24:	2301      	movs	r3, #1
90005a26:	61fb      	str	r3, [r7, #28]
          mx_config.Synchro = SAI_SYNCHRONOUS;
90005a28:	2301      	movs	r3, #1
90005a2a:	623b      	str	r3, [r7, #32]
          mx_config.SynchroExt = SAI_SYNCEXT_DISABLE;
90005a2c:	2300      	movs	r3, #0
90005a2e:	62bb      	str	r3, [r7, #40]	; 0x28

          if (MX_SAI2_Block_B_Init(&haudio_in_sai, &mx_config) != HAL_OK)
90005a30:	f107 030c 	add.w	r3, r7, #12
90005a34:	4619      	mov	r1, r3
90005a36:	4856      	ldr	r0, [pc, #344]	; (90005b90 <BSP_AUDIO_IN_Init+0x2a0>)
90005a38:	f000 f966 	bl	90005d08 <MX_SAI2_Block_B_Init>
90005a3c:	4603      	mov	r3, r0
90005a3e:	2b00      	cmp	r3, #0
90005a40:	d003      	beq.n	90005a4a <BSP_AUDIO_IN_Init+0x15a>
          {
            /* Return BSP_ERROR_PERIPH_FAILURE when operations are not correctly done */
            ret = BSP_ERROR_PERIPH_FAILURE;
90005a42:	f06f 0303 	mvn.w	r3, #3
90005a46:	64fb      	str	r3, [r7, #76]	; 0x4c
90005a48:	e01b      	b.n	90005a82 <BSP_AUDIO_IN_Init+0x192>
          }
          else
          {
            /* Prepare haudio_out_sai handle */
            haudio_out_sai.Instance = SAI2_Block_A;
90005a4a:	4b53      	ldr	r3, [pc, #332]	; (90005b98 <BSP_AUDIO_IN_Init+0x2a8>)
90005a4c:	4a53      	ldr	r2, [pc, #332]	; (90005b9c <BSP_AUDIO_IN_Init+0x2ac>)
90005a4e:	601a      	str	r2, [r3, #0]
            mx_config.AudioMode = SAI_MODEMASTER_TX;
90005a50:	2300      	movs	r3, #0
90005a52:	613b      	str	r3, [r7, #16]
            mx_config.ClockStrobing = SAI_CLOCKSTROBING_FALLINGEDGE;
90005a54:	2300      	movs	r3, #0
90005a56:	61fb      	str	r3, [r7, #28]
            mx_config.OutputDrive = SAI_OUTPUTDRIVE_ENABLE;
90005a58:	f44f 5300 	mov.w	r3, #8192	; 0x2000
90005a5c:	627b      	str	r3, [r7, #36]	; 0x24
            mx_config.Synchro = SAI_ASYNCHRONOUS;
90005a5e:	2300      	movs	r3, #0
90005a60:	623b      	str	r3, [r7, #32]
            mx_config.SynchroExt = SAI_SYNCEXT_DISABLE;
90005a62:	2300      	movs	r3, #0
90005a64:	62bb      	str	r3, [r7, #40]	; 0x28
            mx_config.SlotActive = CODEC_AUDIOFRAME_SLOT_0123;
90005a66:	230f      	movs	r3, #15
90005a68:	637b      	str	r3, [r7, #52]	; 0x34
            if (MX_SAI2_Block_A_Init(&haudio_out_sai, &mx_config) != HAL_OK)
90005a6a:	f107 030c 	add.w	r3, r7, #12
90005a6e:	4619      	mov	r1, r3
90005a70:	4849      	ldr	r0, [pc, #292]	; (90005b98 <BSP_AUDIO_IN_Init+0x2a8>)
90005a72:	f7ff fb95 	bl	900051a0 <MX_SAI2_Block_A_Init>
90005a76:	4603      	mov	r3, r0
90005a78:	2b00      	cmp	r3, #0
90005a7a:	d002      	beq.n	90005a82 <BSP_AUDIO_IN_Init+0x192>
            {
              /* Return BSP_ERROR_PERIPH_FAILURE when operations are not correctly done */
              ret = BSP_ERROR_PERIPH_FAILURE;
90005a7c:	f06f 0303 	mvn.w	r3, #3
90005a80:	64fb      	str	r3, [r7, #76]	; 0x4c
              }
            }
          }
#endif /* (USE_HAL_SAI_REGISTER_CALLBACKS == 1U) */
#if (USE_AUDIO_CODEC_WM8994 == 1U)
          if (ret == BSP_ERROR_NONE)
90005a82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
90005a84:	2b00      	cmp	r3, #0
90005a86:	f040 80be 	bne.w	90005c06 <BSP_AUDIO_IN_Init+0x316>
          {
            /* Initialize the codec internal registers */
            if (WM8994_Probe() == BSP_ERROR_NONE)
90005a8a:	f000 fbf9 	bl	90006280 <WM8994_Probe>
90005a8e:	4603      	mov	r3, r0
90005a90:	2b00      	cmp	r3, #0
90005a92:	f040 80b8 	bne.w	90005c06 <BSP_AUDIO_IN_Init+0x316>
            {
              WM8994_Init_t codec_init;

              /* Fill codec_init structure */
              codec_init.Frequency = AudioInit->SampleRate;
90005a96:	683b      	ldr	r3, [r7, #0]
90005a98:	685b      	ldr	r3, [r3, #4]
90005a9a:	643b      	str	r3, [r7, #64]	; 0x40
              codec_init.OutputDevice = WM8994_OUT_NONE;
90005a9c:	2300      	movs	r3, #0
90005a9e:	63fb      	str	r3, [r7, #60]	; 0x3c
              if (AudioInit->Device == AUDIO_IN_DEVICE_ANALOG_MIC)
90005aa0:	683b      	ldr	r3, [r7, #0]
90005aa2:	681b      	ldr	r3, [r3, #0]
90005aa4:	2b00      	cmp	r3, #0
90005aa6:	d104      	bne.n	90005ab2 <BSP_AUDIO_IN_Init+0x1c2>
              {
                codec_init.InputDevice = WM8994_IN_LINE1;
90005aa8:	2303      	movs	r3, #3
90005aaa:	63bb      	str	r3, [r7, #56]	; 0x38
                codec_init.OutputDevice = AUDIO_OUT_DEVICE_HEADPHONE;
90005aac:	2302      	movs	r3, #2
90005aae:	63fb      	str	r3, [r7, #60]	; 0x3c
90005ab0:	e001      	b.n	90005ab6 <BSP_AUDIO_IN_Init+0x1c6>
              }
              else /* (AudioInit->Device == AUDIO_IN_DEVICE_DIGITAL_MIC) */
              {
                codec_init.InputDevice = WM8994_IN_MIC2;
90005ab2:	2302      	movs	r3, #2
90005ab4:	63bb      	str	r3, [r7, #56]	; 0x38
              }
              codec_init.Resolution = (AudioInit->BitsPerSample == AUDIO_RESOLUTION_32B) ? 3 : 0;
90005ab6:	683b      	ldr	r3, [r7, #0]
90005ab8:	689b      	ldr	r3, [r3, #8]
90005aba:	2b20      	cmp	r3, #32
90005abc:	d101      	bne.n	90005ac2 <BSP_AUDIO_IN_Init+0x1d2>
90005abe:	2303      	movs	r3, #3
90005ac0:	e000      	b.n	90005ac4 <BSP_AUDIO_IN_Init+0x1d4>
90005ac2:	2300      	movs	r3, #0
90005ac4:	647b      	str	r3, [r7, #68]	; 0x44

              /* Convert volume before sending to the codec */
              codec_init.Volume = VOLUME_IN_CONVERT(AudioInit->Volume);
90005ac6:	683b      	ldr	r3, [r7, #0]
90005ac8:	691b      	ldr	r3, [r3, #16]
90005aca:	2b63      	cmp	r3, #99	; 0x63
90005acc:	d80c      	bhi.n	90005ae8 <BSP_AUDIO_IN_Init+0x1f8>
90005ace:	683b      	ldr	r3, [r7, #0]
90005ad0:	691a      	ldr	r2, [r3, #16]
90005ad2:	4613      	mov	r3, r2
90005ad4:	011b      	lsls	r3, r3, #4
90005ad6:	1a9b      	subs	r3, r3, r2
90005ad8:	011b      	lsls	r3, r3, #4
90005ada:	1a9b      	subs	r3, r3, r2
90005adc:	4a30      	ldr	r2, [pc, #192]	; (90005ba0 <BSP_AUDIO_IN_Init+0x2b0>)
90005ade:	fba2 2303 	umull	r2, r3, r2, r3
90005ae2:	095b      	lsrs	r3, r3, #5
90005ae4:	b2db      	uxtb	r3, r3
90005ae6:	e000      	b.n	90005aea <BSP_AUDIO_IN_Init+0x1fa>
90005ae8:	23ef      	movs	r3, #239	; 0xef
90005aea:	64bb      	str	r3, [r7, #72]	; 0x48

              /* Initialize the codec internal registers */
              if (Audio_Drv->Init(Audio_CompObj, &codec_init) != 0)
90005aec:	4b2d      	ldr	r3, [pc, #180]	; (90005ba4 <BSP_AUDIO_IN_Init+0x2b4>)
90005aee:	681b      	ldr	r3, [r3, #0]
90005af0:	681b      	ldr	r3, [r3, #0]
90005af2:	4a2d      	ldr	r2, [pc, #180]	; (90005ba8 <BSP_AUDIO_IN_Init+0x2b8>)
90005af4:	6812      	ldr	r2, [r2, #0]
90005af6:	f107 0138 	add.w	r1, r7, #56	; 0x38
90005afa:	4610      	mov	r0, r2
90005afc:	4798      	blx	r3
90005afe:	4603      	mov	r3, r0
90005b00:	2b00      	cmp	r3, #0
90005b02:	f000 8080 	beq.w	90005c06 <BSP_AUDIO_IN_Init+0x316>
              {
                ret = BSP_ERROR_COMPONENT_FAILURE;
90005b06:	f06f 0304 	mvn.w	r3, #4
90005b0a:	64fb      	str	r3, [r7, #76]	; 0x4c
90005b0c:	e07b      	b.n	90005c06 <BSP_AUDIO_IN_Init+0x316>
      }
    }
    else /* (Instance == 1U) */
    {
      /* PLL clock is set depending by the AudioFreq (44.1khz vs 48khz groups) */
      if(MX_SAI4_ClockConfig(&haudio_in_sai, AudioInit->SampleRate) != HAL_OK)
90005b0e:	683b      	ldr	r3, [r7, #0]
90005b10:	685b      	ldr	r3, [r3, #4]
90005b12:	4619      	mov	r1, r3
90005b14:	481e      	ldr	r0, [pc, #120]	; (90005b90 <BSP_AUDIO_IN_Init+0x2a0>)
90005b16:	f7ff fc0a 	bl	9000532e <MX_SAI4_ClockConfig>
90005b1a:	4603      	mov	r3, r0
90005b1c:	2b00      	cmp	r3, #0
90005b1e:	d003      	beq.n	90005b28 <BSP_AUDIO_IN_Init+0x238>
      {
        ret = BSP_ERROR_CLOCK_FAILURE;
90005b20:	f06f 0308 	mvn.w	r3, #8
90005b24:	64fb      	str	r3, [r7, #76]	; 0x4c
90005b26:	e06e      	b.n	90005c06 <BSP_AUDIO_IN_Init+0x316>
      }
      else
      {
        haudio_in_sai.Instance = AUDIO_IN_SAI_PDMx;
90005b28:	4b19      	ldr	r3, [pc, #100]	; (90005b90 <BSP_AUDIO_IN_Init+0x2a0>)
90005b2a:	4a20      	ldr	r2, [pc, #128]	; (90005bac <BSP_AUDIO_IN_Init+0x2bc>)
90005b2c:	601a      	str	r2, [r3, #0]

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 0U)
        SAI_MspInit(&haudio_in_sai);
90005b2e:	4818      	ldr	r0, [pc, #96]	; (90005b90 <BSP_AUDIO_IN_Init+0x2a0>)
90005b30:	f000 fc00 	bl	90006334 <SAI_MspInit>
        {
#endif /* (USE_HAL_SAI_REGISTER_CALLBACKS == 0U) */
          MX_SAI_Config_t mx_config;

          /* Prepare haudio_in_sai handle */
          mx_config.MonoStereoMode    = SAI_STEREOMODE;
90005b34:	2300      	movs	r3, #0
90005b36:	61bb      	str	r3, [r7, #24]
          mx_config.DataSize          = SAI_DATASIZE_16;
90005b38:	2380      	movs	r3, #128	; 0x80
90005b3a:	617b      	str	r3, [r7, #20]
          mx_config.FrameLength       = 32;
90005b3c:	2320      	movs	r3, #32
90005b3e:	62fb      	str	r3, [r7, #44]	; 0x2c
          mx_config.ActiveFrameLength = 1;
90005b40:	2301      	movs	r3, #1
90005b42:	633b      	str	r3, [r7, #48]	; 0x30
          mx_config.OutputDrive       = SAI_OUTPUTDRIVE_DISABLE;
90005b44:	2300      	movs	r3, #0
90005b46:	627b      	str	r3, [r7, #36]	; 0x24
          mx_config.SlotActive        = SAI_SLOTACTIVE_1;
90005b48:	2302      	movs	r3, #2
90005b4a:	637b      	str	r3, [r7, #52]	; 0x34
          mx_config.AudioFrequency    = Audio_In_Ctx[Instance].SampleRate*8;
90005b4c:	490f      	ldr	r1, [pc, #60]	; (90005b8c <BSP_AUDIO_IN_Init+0x29c>)
90005b4e:	687a      	ldr	r2, [r7, #4]
90005b50:	4613      	mov	r3, r2
90005b52:	005b      	lsls	r3, r3, #1
90005b54:	4413      	add	r3, r2
90005b56:	011b      	lsls	r3, r3, #4
90005b58:	440b      	add	r3, r1
90005b5a:	3308      	adds	r3, #8
90005b5c:	681b      	ldr	r3, [r3, #0]
90005b5e:	00db      	lsls	r3, r3, #3
90005b60:	60fb      	str	r3, [r7, #12]
          mx_config.AudioMode         = SAI_MODEMASTER_RX;
90005b62:	2301      	movs	r3, #1
90005b64:	613b      	str	r3, [r7, #16]
          mx_config.ClockStrobing     = SAI_CLOCKSTROBING_FALLINGEDGE;
90005b66:	2300      	movs	r3, #0
90005b68:	61fb      	str	r3, [r7, #28]
          mx_config.Synchro           = SAI_ASYNCHRONOUS;
90005b6a:	2300      	movs	r3, #0
90005b6c:	623b      	str	r3, [r7, #32]
          mx_config.SynchroExt        = SAI_SYNCEXT_DISABLE;
90005b6e:	2300      	movs	r3, #0
90005b70:	62bb      	str	r3, [r7, #40]	; 0x28

          if(MX_SAI4_Block_A_Init(&haudio_in_sai, &mx_config) != HAL_OK)
90005b72:	f107 030c 	add.w	r3, r7, #12
90005b76:	4619      	mov	r1, r3
90005b78:	4805      	ldr	r0, [pc, #20]	; (90005b90 <BSP_AUDIO_IN_Init+0x2a0>)
90005b7a:	f000 f93a 	bl	90005df2 <MX_SAI4_Block_A_Init>
90005b7e:	4603      	mov	r3, r0
90005b80:	2b00      	cmp	r3, #0
90005b82:	d015      	beq.n	90005bb0 <BSP_AUDIO_IN_Init+0x2c0>
          {
            /* Return BSP_ERROR_PERIPH_FAILURE when operations are not correctly done */
            ret = BSP_ERROR_PERIPH_FAILURE;
90005b84:	f06f 0303 	mvn.w	r3, #3
90005b88:	64fb      	str	r3, [r7, #76]	; 0x4c
90005b8a:	e02f      	b.n	90005bec <BSP_AUDIO_IN_Init+0x2fc>
90005b8c:	240029d0 	.word	0x240029d0
90005b90:	24002914 	.word	0x24002914
90005b94:	40015c24 	.word	0x40015c24
90005b98:	24001238 	.word	0x24001238
90005b9c:	40015c04 	.word	0x40015c04
90005ba0:	51eb851f 	.word	0x51eb851f
90005ba4:	2400118c 	.word	0x2400118c
90005ba8:	24001234 	.word	0x24001234
90005bac:	58005404 	.word	0x58005404
          }
#endif /* (USE_HAL_SAI_REGISTER_CALLBACKS == 1U) */

          else
          {
            if(BSP_AUDIO_IN_PDMToPCM_Init(Instance, AudioInit->SampleRate, Audio_In_Ctx[Instance].ChannelsNbr, Audio_In_Ctx[Instance].ChannelsNbr) != BSP_ERROR_NONE)
90005bb0:	683b      	ldr	r3, [r7, #0]
90005bb2:	6859      	ldr	r1, [r3, #4]
90005bb4:	4816      	ldr	r0, [pc, #88]	; (90005c10 <BSP_AUDIO_IN_Init+0x320>)
90005bb6:	687a      	ldr	r2, [r7, #4]
90005bb8:	4613      	mov	r3, r2
90005bba:	005b      	lsls	r3, r3, #1
90005bbc:	4413      	add	r3, r2
90005bbe:	011b      	lsls	r3, r3, #4
90005bc0:	4403      	add	r3, r0
90005bc2:	3310      	adds	r3, #16
90005bc4:	6818      	ldr	r0, [r3, #0]
90005bc6:	4c12      	ldr	r4, [pc, #72]	; (90005c10 <BSP_AUDIO_IN_Init+0x320>)
90005bc8:	687a      	ldr	r2, [r7, #4]
90005bca:	4613      	mov	r3, r2
90005bcc:	005b      	lsls	r3, r3, #1
90005bce:	4413      	add	r3, r2
90005bd0:	011b      	lsls	r3, r3, #4
90005bd2:	4423      	add	r3, r4
90005bd4:	3310      	adds	r3, #16
90005bd6:	681b      	ldr	r3, [r3, #0]
90005bd8:	4602      	mov	r2, r0
90005bda:	6878      	ldr	r0, [r7, #4]
90005bdc:	f000 f98e 	bl	90005efc <BSP_AUDIO_IN_PDMToPCM_Init>
90005be0:	4603      	mov	r3, r0
90005be2:	2b00      	cmp	r3, #0
90005be4:	d002      	beq.n	90005bec <BSP_AUDIO_IN_Init+0x2fc>
            {
              ret = BSP_ERROR_NO_INIT;
90005be6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90005bea:	64fb      	str	r3, [r7, #76]	; 0x4c
          }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
        }
#endif
        /* Update BSP AUDIO IN state */
        if(ret == BSP_ERROR_NONE)
90005bec:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
90005bee:	2b00      	cmp	r3, #0
90005bf0:	d109      	bne.n	90005c06 <BSP_AUDIO_IN_Init+0x316>
        {
          Audio_In_Ctx[Instance].State = AUDIO_IN_STATE_STOP;
90005bf2:	4907      	ldr	r1, [pc, #28]	; (90005c10 <BSP_AUDIO_IN_Init+0x320>)
90005bf4:	687a      	ldr	r2, [r7, #4]
90005bf6:	4613      	mov	r3, r2
90005bf8:	005b      	lsls	r3, r3, #1
90005bfa:	4413      	add	r3, r2
90005bfc:	011b      	lsls	r3, r3, #4
90005bfe:	440b      	add	r3, r1
90005c00:	3324      	adds	r3, #36	; 0x24
90005c02:	2202      	movs	r2, #2
90005c04:	601a      	str	r2, [r3, #0]
        }
      }
    }
  }
  /* Return BSP status */
  return ret;
90005c06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
90005c08:	4618      	mov	r0, r3
90005c0a:	3754      	adds	r7, #84	; 0x54
90005c0c:	46bd      	mov	sp, r7
90005c0e:	bd90      	pop	{r4, r7, pc}
90005c10:	240029d0 	.word	0x240029d0

90005c14 <BSP_AUDIO_IN_DeInit>:
  * @param  Instance  AUDIO IN Instance. It can be 0 when SAI is used or 1 is used
  * @retval BSP status
  */

int32_t BSP_AUDIO_IN_DeInit(uint32_t Instance)
{
90005c14:	b580      	push	{r7, lr}
90005c16:	b084      	sub	sp, #16
90005c18:	af00      	add	r7, sp, #0
90005c1a:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
90005c1c:	2300      	movs	r3, #0
90005c1e:	60fb      	str	r3, [r7, #12]

  if (Instance >= AUDIO_IN_INSTANCES_NBR)
90005c20:	687b      	ldr	r3, [r7, #4]
90005c22:	2b01      	cmp	r3, #1
90005c24:	d903      	bls.n	90005c2e <BSP_AUDIO_IN_DeInit+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90005c26:	f06f 0301 	mvn.w	r3, #1
90005c2a:	60fb      	str	r3, [r7, #12]
90005c2c:	e056      	b.n	90005cdc <BSP_AUDIO_IN_DeInit+0xc8>
  }
  else
  {
    if (Instance == 0U)
90005c2e:	687b      	ldr	r3, [r7, #4]
90005c30:	2b00      	cmp	r3, #0
90005c32:	d12a      	bne.n	90005c8a <BSP_AUDIO_IN_DeInit+0x76>
    {
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 0U)
      SAI_MspDeInit(&haudio_in_sai);
90005c34:	482c      	ldr	r0, [pc, #176]	; (90005ce8 <BSP_AUDIO_IN_DeInit+0xd4>)
90005c36:	f000 fdc1 	bl	900067bc <SAI_MspDeInit>
#endif /* (USE_HAL_SAI_REGISTER_CALLBACKS == 0U) */

      /* Initialize the haudio_in_sai Instance parameter */
      haudio_in_sai.Instance = AUDIO_IN_SAIx;
90005c3a:	4b2b      	ldr	r3, [pc, #172]	; (90005ce8 <BSP_AUDIO_IN_DeInit+0xd4>)
90005c3c:	4a2b      	ldr	r2, [pc, #172]	; (90005cec <BSP_AUDIO_IN_DeInit+0xd8>)
90005c3e:	601a      	str	r2, [r3, #0]
      /* Initialize the haudio_out_sai Instance parameter */
      haudio_out_sai.Instance = AUDIO_OUT_SAIx;
90005c40:	4b2b      	ldr	r3, [pc, #172]	; (90005cf0 <BSP_AUDIO_IN_DeInit+0xdc>)
90005c42:	4a2c      	ldr	r2, [pc, #176]	; (90005cf4 <BSP_AUDIO_IN_DeInit+0xe0>)
90005c44:	601a      	str	r2, [r3, #0]

      if (Audio_Drv->DeInit(Audio_CompObj) < 0)
90005c46:	4b2c      	ldr	r3, [pc, #176]	; (90005cf8 <BSP_AUDIO_IN_DeInit+0xe4>)
90005c48:	681b      	ldr	r3, [r3, #0]
90005c4a:	685b      	ldr	r3, [r3, #4]
90005c4c:	4a2b      	ldr	r2, [pc, #172]	; (90005cfc <BSP_AUDIO_IN_DeInit+0xe8>)
90005c4e:	6812      	ldr	r2, [r2, #0]
90005c50:	4610      	mov	r0, r2
90005c52:	4798      	blx	r3
90005c54:	4603      	mov	r3, r0
90005c56:	2b00      	cmp	r3, #0
90005c58:	da03      	bge.n	90005c62 <BSP_AUDIO_IN_DeInit+0x4e>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
90005c5a:	f06f 0304 	mvn.w	r3, #4
90005c5e:	60fb      	str	r3, [r7, #12]
90005c60:	e032      	b.n	90005cc8 <BSP_AUDIO_IN_DeInit+0xb4>
      } /* De-Initializes SAI handles */
      else if (HAL_SAI_DeInit(&haudio_in_sai) != HAL_OK)
90005c62:	4821      	ldr	r0, [pc, #132]	; (90005ce8 <BSP_AUDIO_IN_DeInit+0xd4>)
90005c64:	f00e f88e 	bl	90013d84 <HAL_SAI_DeInit>
90005c68:	4603      	mov	r3, r0
90005c6a:	2b00      	cmp	r3, #0
90005c6c:	d003      	beq.n	90005c76 <BSP_AUDIO_IN_DeInit+0x62>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
90005c6e:	f06f 0303 	mvn.w	r3, #3
90005c72:	60fb      	str	r3, [r7, #12]
90005c74:	e028      	b.n	90005cc8 <BSP_AUDIO_IN_DeInit+0xb4>
      }
      else
      {
        if (HAL_SAI_DeInit(&haudio_out_sai) != HAL_OK)
90005c76:	481e      	ldr	r0, [pc, #120]	; (90005cf0 <BSP_AUDIO_IN_DeInit+0xdc>)
90005c78:	f00e f884 	bl	90013d84 <HAL_SAI_DeInit>
90005c7c:	4603      	mov	r3, r0
90005c7e:	2b00      	cmp	r3, #0
90005c80:	d022      	beq.n	90005cc8 <BSP_AUDIO_IN_DeInit+0xb4>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
90005c82:	f06f 0303 	mvn.w	r3, #3
90005c86:	60fb      	str	r3, [r7, #12]
90005c88:	e01e      	b.n	90005cc8 <BSP_AUDIO_IN_DeInit+0xb4>
        }
      }
    }
    else if (Instance == 1U)
90005c8a:	687b      	ldr	r3, [r7, #4]
90005c8c:	2b01      	cmp	r3, #1
90005c8e:	d11b      	bne.n	90005cc8 <BSP_AUDIO_IN_DeInit+0xb4>
    {
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 0U)
      SAI_MspDeInit(&haudio_in_sai);
90005c90:	4815      	ldr	r0, [pc, #84]	; (90005ce8 <BSP_AUDIO_IN_DeInit+0xd4>)
90005c92:	f000 fd93 	bl	900067bc <SAI_MspDeInit>
#endif /* (USE_HAL_SAI_REGISTER_CALLBACKS == 0U) */

      /* Initialize the haudio_in_sai Instance parameter */
      haudio_in_sai.Instance = AUDIO_IN_SAI_PDMx;
90005c96:	4b14      	ldr	r3, [pc, #80]	; (90005ce8 <BSP_AUDIO_IN_DeInit+0xd4>)
90005c98:	4a19      	ldr	r2, [pc, #100]	; (90005d00 <BSP_AUDIO_IN_DeInit+0xec>)
90005c9a:	601a      	str	r2, [r3, #0]
      /* Initialize the haudio_out_sai Instance parameter */
      haudio_out_sai.Instance = AUDIO_OUT_SAIx;
90005c9c:	4b14      	ldr	r3, [pc, #80]	; (90005cf0 <BSP_AUDIO_IN_DeInit+0xdc>)
90005c9e:	4a15      	ldr	r2, [pc, #84]	; (90005cf4 <BSP_AUDIO_IN_DeInit+0xe0>)
90005ca0:	601a      	str	r2, [r3, #0]

      if (HAL_SAI_DeInit(&haudio_in_sai) != HAL_OK)
90005ca2:	4811      	ldr	r0, [pc, #68]	; (90005ce8 <BSP_AUDIO_IN_DeInit+0xd4>)
90005ca4:	f00e f86e 	bl	90013d84 <HAL_SAI_DeInit>
90005ca8:	4603      	mov	r3, r0
90005caa:	2b00      	cmp	r3, #0
90005cac:	d003      	beq.n	90005cb6 <BSP_AUDIO_IN_DeInit+0xa2>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
90005cae:	f06f 0303 	mvn.w	r3, #3
90005cb2:	60fb      	str	r3, [r7, #12]
90005cb4:	e008      	b.n	90005cc8 <BSP_AUDIO_IN_DeInit+0xb4>
      }
      else
      {
        if (HAL_SAI_DeInit(&haudio_out_sai) != HAL_OK)
90005cb6:	480e      	ldr	r0, [pc, #56]	; (90005cf0 <BSP_AUDIO_IN_DeInit+0xdc>)
90005cb8:	f00e f864 	bl	90013d84 <HAL_SAI_DeInit>
90005cbc:	4603      	mov	r3, r0
90005cbe:	2b00      	cmp	r3, #0
90005cc0:	d002      	beq.n	90005cc8 <BSP_AUDIO_IN_DeInit+0xb4>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
90005cc2:	f06f 0303 	mvn.w	r3, #3
90005cc6:	60fb      	str	r3, [r7, #12]
      }
    }
    else
    {}
    /* Update BSP AUDIO IN state */
    Audio_In_Ctx[Instance].State = AUDIO_IN_STATE_RESET;
90005cc8:	490e      	ldr	r1, [pc, #56]	; (90005d04 <BSP_AUDIO_IN_DeInit+0xf0>)
90005cca:	687a      	ldr	r2, [r7, #4]
90005ccc:	4613      	mov	r3, r2
90005cce:	005b      	lsls	r3, r3, #1
90005cd0:	4413      	add	r3, r2
90005cd2:	011b      	lsls	r3, r3, #4
90005cd4:	440b      	add	r3, r1
90005cd6:	3324      	adds	r3, #36	; 0x24
90005cd8:	2200      	movs	r2, #0
90005cda:	601a      	str	r2, [r3, #0]
  }

  /* Return BSP status */
  return ret;
90005cdc:	68fb      	ldr	r3, [r7, #12]
}
90005cde:	4618      	mov	r0, r3
90005ce0:	3710      	adds	r7, #16
90005ce2:	46bd      	mov	sp, r7
90005ce4:	bd80      	pop	{r7, pc}
90005ce6:	bf00      	nop
90005ce8:	24002914 	.word	0x24002914
90005cec:	40015c24 	.word	0x40015c24
90005cf0:	24001238 	.word	0x24001238
90005cf4:	40015c04 	.word	0x40015c04
90005cf8:	2400118c 	.word	0x2400118c
90005cfc:	24001234 	.word	0x24001234
90005d00:	58005404 	.word	0x58005404
90005d04:	240029d0 	.word	0x240029d0

90005d08 <MX_SAI2_Block_B_Init>:
  * @param  MXConfig SAI configuration structure
  * @note   Being __weak it can be overwritten by the application
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_SAI2_Block_B_Init(SAI_HandleTypeDef *hsai, MX_SAI_Config_t *MXConfig)
{
90005d08:	b580      	push	{r7, lr}
90005d0a:	b084      	sub	sp, #16
90005d0c:	af00      	add	r7, sp, #0
90005d0e:	6078      	str	r0, [r7, #4]
90005d10:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef ret = HAL_OK;
90005d12:	2300      	movs	r3, #0
90005d14:	73fb      	strb	r3, [r7, #15]

  /* Disable SAI peripheral to allow access to SAI internal registers */
  __HAL_SAI_DISABLE(hsai);
90005d16:	687b      	ldr	r3, [r7, #4]
90005d18:	681b      	ldr	r3, [r3, #0]
90005d1a:	681a      	ldr	r2, [r3, #0]
90005d1c:	687b      	ldr	r3, [r7, #4]
90005d1e:	681b      	ldr	r3, [r3, #0]
90005d20:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
90005d24:	601a      	str	r2, [r3, #0]

  /* Configure SAI1_Block_B */
  hsai->Init.AudioFrequency = MXConfig->AudioFrequency;
90005d26:	683b      	ldr	r3, [r7, #0]
90005d28:	681a      	ldr	r2, [r3, #0]
90005d2a:	687b      	ldr	r3, [r7, #4]
90005d2c:	621a      	str	r2, [r3, #32]
  hsai->Init.MonoStereoMode = MXConfig->MonoStereoMode;
90005d2e:	683b      	ldr	r3, [r7, #0]
90005d30:	68da      	ldr	r2, [r3, #12]
90005d32:	687b      	ldr	r3, [r7, #4]
90005d34:	62da      	str	r2, [r3, #44]	; 0x2c
  hsai->Init.AudioMode = MXConfig->AudioMode;
90005d36:	683b      	ldr	r3, [r7, #0]
90005d38:	685a      	ldr	r2, [r3, #4]
90005d3a:	687b      	ldr	r3, [r7, #4]
90005d3c:	605a      	str	r2, [r3, #4]
  hsai->Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
90005d3e:	687b      	ldr	r3, [r7, #4]
90005d40:	2200      	movs	r2, #0
90005d42:	619a      	str	r2, [r3, #24]
  hsai->Init.Protocol = SAI_FREE_PROTOCOL;
90005d44:	687b      	ldr	r3, [r7, #4]
90005d46:	2200      	movs	r2, #0
90005d48:	645a      	str	r2, [r3, #68]	; 0x44
  hsai->Init.DataSize = MXConfig->DataSize;
90005d4a:	683b      	ldr	r3, [r7, #0]
90005d4c:	689a      	ldr	r2, [r3, #8]
90005d4e:	687b      	ldr	r3, [r7, #4]
90005d50:	649a      	str	r2, [r3, #72]	; 0x48
  hsai->Init.FirstBit = SAI_FIRSTBIT_MSB;
90005d52:	687b      	ldr	r3, [r7, #4]
90005d54:	2200      	movs	r2, #0
90005d56:	64da      	str	r2, [r3, #76]	; 0x4c
  hsai->Init.ClockStrobing = MXConfig->ClockStrobing;
90005d58:	683b      	ldr	r3, [r7, #0]
90005d5a:	691a      	ldr	r2, [r3, #16]
90005d5c:	687b      	ldr	r3, [r7, #4]
90005d5e:	651a      	str	r2, [r3, #80]	; 0x50
  hsai->Init.Synchro = MXConfig->Synchro;
90005d60:	683b      	ldr	r3, [r7, #0]
90005d62:	695a      	ldr	r2, [r3, #20]
90005d64:	687b      	ldr	r3, [r7, #4]
90005d66:	609a      	str	r2, [r3, #8]
  hsai->Init.OutputDrive = MXConfig->OutputDrive;
90005d68:	683b      	ldr	r3, [r7, #0]
90005d6a:	699a      	ldr	r2, [r3, #24]
90005d6c:	687b      	ldr	r3, [r7, #4]
90005d6e:	615a      	str	r2, [r3, #20]
  hsai->Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
90005d70:	687b      	ldr	r3, [r7, #4]
90005d72:	2201      	movs	r2, #1
90005d74:	61da      	str	r2, [r3, #28]
  hsai->Init.SynchroExt = MXConfig->SynchroExt;
90005d76:	683b      	ldr	r3, [r7, #0]
90005d78:	69da      	ldr	r2, [r3, #28]
90005d7a:	687b      	ldr	r3, [r7, #4]
90005d7c:	60da      	str	r2, [r3, #12]
  hsai->Init.CompandingMode = SAI_NOCOMPANDING;
90005d7e:	687b      	ldr	r3, [r7, #4]
90005d80:	2200      	movs	r2, #0
90005d82:	631a      	str	r2, [r3, #48]	; 0x30
  hsai->Init.TriState = SAI_OUTPUT_RELEASED;
90005d84:	687b      	ldr	r3, [r7, #4]
90005d86:	2210      	movs	r2, #16
90005d88:	635a      	str	r2, [r3, #52]	; 0x34
  hsai->Init.Mckdiv = 0;
90005d8a:	687b      	ldr	r3, [r7, #4]
90005d8c:	2200      	movs	r2, #0
90005d8e:	625a      	str	r2, [r3, #36]	; 0x24
  hsai->Init.PdmInit.Activation = DISABLE;
90005d90:	687b      	ldr	r3, [r7, #4]
90005d92:	2200      	movs	r2, #0
90005d94:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  /* Configure SAI_Block_x Frame */
  hsai->FrameInit.FrameLength = MXConfig->FrameLength;
90005d98:	683b      	ldr	r3, [r7, #0]
90005d9a:	6a1a      	ldr	r2, [r3, #32]
90005d9c:	687b      	ldr	r3, [r7, #4]
90005d9e:	655a      	str	r2, [r3, #84]	; 0x54
  hsai->FrameInit.ActiveFrameLength = MXConfig->ActiveFrameLength;
90005da0:	683b      	ldr	r3, [r7, #0]
90005da2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
90005da4:	687b      	ldr	r3, [r7, #4]
90005da6:	659a      	str	r2, [r3, #88]	; 0x58
  hsai->FrameInit.FSDefinition = SAI_FS_CHANNEL_IDENTIFICATION;
90005da8:	687b      	ldr	r3, [r7, #4]
90005daa:	f44f 3280 	mov.w	r2, #65536	; 0x10000
90005dae:	65da      	str	r2, [r3, #92]	; 0x5c
  hsai->FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
90005db0:	687b      	ldr	r3, [r7, #4]
90005db2:	2200      	movs	r2, #0
90005db4:	661a      	str	r2, [r3, #96]	; 0x60
  hsai->FrameInit.FSOffset = SAI_FS_BEFOREFIRSTBIT;
90005db6:	687b      	ldr	r3, [r7, #4]
90005db8:	f44f 2280 	mov.w	r2, #262144	; 0x40000
90005dbc:	665a      	str	r2, [r3, #100]	; 0x64

  /* Configure SAI Block_x Slot */
  hsai->SlotInit.FirstBitOffset = 0;
90005dbe:	687b      	ldr	r3, [r7, #4]
90005dc0:	2200      	movs	r2, #0
90005dc2:	669a      	str	r2, [r3, #104]	; 0x68
  hsai->SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
90005dc4:	687b      	ldr	r3, [r7, #4]
90005dc6:	2200      	movs	r2, #0
90005dc8:	66da      	str	r2, [r3, #108]	; 0x6c
  hsai->SlotInit.SlotNumber = 4;
90005dca:	687b      	ldr	r3, [r7, #4]
90005dcc:	2204      	movs	r2, #4
90005dce:	671a      	str	r2, [r3, #112]	; 0x70
  hsai->SlotInit.SlotActive = MXConfig->SlotActive;
90005dd0:	683b      	ldr	r3, [r7, #0]
90005dd2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
90005dd4:	687b      	ldr	r3, [r7, #4]
90005dd6:	675a      	str	r2, [r3, #116]	; 0x74

  if (HAL_SAI_Init(hsai) != HAL_OK)
90005dd8:	6878      	ldr	r0, [r7, #4]
90005dda:	f00d fd33 	bl	90013844 <HAL_SAI_Init>
90005dde:	4603      	mov	r3, r0
90005de0:	2b00      	cmp	r3, #0
90005de2:	d001      	beq.n	90005de8 <MX_SAI2_Block_B_Init+0xe0>
  {
    ret = HAL_ERROR;
90005de4:	2301      	movs	r3, #1
90005de6:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
90005de8:	7bfb      	ldrb	r3, [r7, #15]
}
90005dea:	4618      	mov	r0, r3
90005dec:	3710      	adds	r7, #16
90005dee:	46bd      	mov	sp, r7
90005df0:	bd80      	pop	{r7, pc}

90005df2 <MX_SAI4_Block_A_Init>:
  * @param  MXConfig SAI configuration structure
  * @note   Being __weak it can be overwritten by the application
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_SAI4_Block_A_Init(SAI_HandleTypeDef *hsai, MX_SAI_Config_t *MXConfig)
{
90005df2:	b580      	push	{r7, lr}
90005df4:	b084      	sub	sp, #16
90005df6:	af00      	add	r7, sp, #0
90005df8:	6078      	str	r0, [r7, #4]
90005dfa:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef ret = HAL_OK;
90005dfc:	2300      	movs	r3, #0
90005dfe:	73fb      	strb	r3, [r7, #15]

  /* Disable SAI peripheral to allow access to SAI internal registers */
  __HAL_SAI_DISABLE(hsai);
90005e00:	687b      	ldr	r3, [r7, #4]
90005e02:	681b      	ldr	r3, [r3, #0]
90005e04:	681a      	ldr	r2, [r3, #0]
90005e06:	687b      	ldr	r3, [r7, #4]
90005e08:	681b      	ldr	r3, [r3, #0]
90005e0a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
90005e0e:	601a      	str	r2, [r3, #0]

  /* Configure SAI4_Block_A */
  hsai->Init.AudioFrequency      = MXConfig->AudioFrequency;
90005e10:	683b      	ldr	r3, [r7, #0]
90005e12:	681a      	ldr	r2, [r3, #0]
90005e14:	687b      	ldr	r3, [r7, #4]
90005e16:	621a      	str	r2, [r3, #32]
  hsai->Init.MonoStereoMode      = MXConfig->MonoStereoMode;
90005e18:	683b      	ldr	r3, [r7, #0]
90005e1a:	68da      	ldr	r2, [r3, #12]
90005e1c:	687b      	ldr	r3, [r7, #4]
90005e1e:	62da      	str	r2, [r3, #44]	; 0x2c
  hsai->Init.AudioMode           = MXConfig->AudioMode;
90005e20:	683b      	ldr	r3, [r7, #0]
90005e22:	685a      	ldr	r2, [r3, #4]
90005e24:	687b      	ldr	r3, [r7, #4]
90005e26:	605a      	str	r2, [r3, #4]
  hsai->Init.NoDivider           = SAI_MASTERDIVIDER_DISABLE;
90005e28:	687b      	ldr	r3, [r7, #4]
90005e2a:	f44f 2200 	mov.w	r2, #524288	; 0x80000
90005e2e:	619a      	str	r2, [r3, #24]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
90005e30:	687b      	ldr	r3, [r7, #4]
90005e32:	2200      	movs	r2, #0
90005e34:	645a      	str	r2, [r3, #68]	; 0x44
  hsai->Init.DataSize            = MXConfig->DataSize;
90005e36:	683b      	ldr	r3, [r7, #0]
90005e38:	689a      	ldr	r2, [r3, #8]
90005e3a:	687b      	ldr	r3, [r7, #4]
90005e3c:	649a      	str	r2, [r3, #72]	; 0x48
  hsai->Init.FirstBit            = SAI_FIRSTBIT_LSB;
90005e3e:	687b      	ldr	r3, [r7, #4]
90005e40:	f44f 7280 	mov.w	r2, #256	; 0x100
90005e44:	64da      	str	r2, [r3, #76]	; 0x4c
  hsai->Init.ClockStrobing       = MXConfig->ClockStrobing;
90005e46:	683b      	ldr	r3, [r7, #0]
90005e48:	691a      	ldr	r2, [r3, #16]
90005e4a:	687b      	ldr	r3, [r7, #4]
90005e4c:	651a      	str	r2, [r3, #80]	; 0x50
  hsai->Init.Synchro             = MXConfig->Synchro;
90005e4e:	683b      	ldr	r3, [r7, #0]
90005e50:	695a      	ldr	r2, [r3, #20]
90005e52:	687b      	ldr	r3, [r7, #4]
90005e54:	609a      	str	r2, [r3, #8]
  hsai->Init.OutputDrive         = MXConfig->OutputDrive;
90005e56:	683b      	ldr	r3, [r7, #0]
90005e58:	699a      	ldr	r2, [r3, #24]
90005e5a:	687b      	ldr	r3, [r7, #4]
90005e5c:	615a      	str	r2, [r3, #20]
  hsai->Init.FIFOThreshold       = SAI_FIFOTHRESHOLD_1QF;
90005e5e:	687b      	ldr	r3, [r7, #4]
90005e60:	2201      	movs	r2, #1
90005e62:	61da      	str	r2, [r3, #28]
  hsai->Init.SynchroExt          = MXConfig->SynchroExt;
90005e64:	683b      	ldr	r3, [r7, #0]
90005e66:	69da      	ldr	r2, [r3, #28]
90005e68:	687b      	ldr	r3, [r7, #4]
90005e6a:	60da      	str	r2, [r3, #12]
  hsai->Init.CompandingMode      = SAI_NOCOMPANDING;
90005e6c:	687b      	ldr	r3, [r7, #4]
90005e6e:	2200      	movs	r2, #0
90005e70:	631a      	str	r2, [r3, #48]	; 0x30
  hsai->Init.TriState            = SAI_OUTPUT_RELEASED;
90005e72:	687b      	ldr	r3, [r7, #4]
90005e74:	2210      	movs	r2, #16
90005e76:	635a      	str	r2, [r3, #52]	; 0x34
  hsai->Init.Mckdiv              = 0;
90005e78:	687b      	ldr	r3, [r7, #4]
90005e7a:	2200      	movs	r2, #0
90005e7c:	625a      	str	r2, [r3, #36]	; 0x24
  hsai->Init.PdmInit.Activation  = ENABLE;
90005e7e:	687b      	ldr	r3, [r7, #4]
90005e80:	2201      	movs	r2, #1
90005e82:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  hsai->Init.PdmInit.MicPairsNbr = 2;
90005e86:	687b      	ldr	r3, [r7, #4]
90005e88:	2202      	movs	r2, #2
90005e8a:	63da      	str	r2, [r3, #60]	; 0x3c
  hsai->Init.PdmInit.ClockEnable = SAI_PDM_CLOCK2_ENABLE;
90005e8c:	687b      	ldr	r3, [r7, #4]
90005e8e:	f44f 7200 	mov.w	r2, #512	; 0x200
90005e92:	641a      	str	r2, [r3, #64]	; 0x40

  /* Configure SAI_Block_x Frame */
  hsai->FrameInit.FrameLength       = MXConfig->FrameLength;
90005e94:	683b      	ldr	r3, [r7, #0]
90005e96:	6a1a      	ldr	r2, [r3, #32]
90005e98:	687b      	ldr	r3, [r7, #4]
90005e9a:	655a      	str	r2, [r3, #84]	; 0x54
  hsai->FrameInit.ActiveFrameLength = MXConfig->ActiveFrameLength;
90005e9c:	683b      	ldr	r3, [r7, #0]
90005e9e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
90005ea0:	687b      	ldr	r3, [r7, #4]
90005ea2:	659a      	str	r2, [r3, #88]	; 0x58
  hsai->FrameInit.FSDefinition      = SAI_FS_STARTFRAME;
90005ea4:	687b      	ldr	r3, [r7, #4]
90005ea6:	2200      	movs	r2, #0
90005ea8:	65da      	str	r2, [r3, #92]	; 0x5c
  hsai->FrameInit.FSPolarity        = SAI_FS_ACTIVE_HIGH;
90005eaa:	687b      	ldr	r3, [r7, #4]
90005eac:	f44f 3200 	mov.w	r2, #131072	; 0x20000
90005eb0:	661a      	str	r2, [r3, #96]	; 0x60
  hsai->FrameInit.FSOffset          = SAI_FS_FIRSTBIT;
90005eb2:	687b      	ldr	r3, [r7, #4]
90005eb4:	2200      	movs	r2, #0
90005eb6:	665a      	str	r2, [r3, #100]	; 0x64

  /* Configure SAI Block_x Slot */
  hsai->SlotInit.FirstBitOffset = 0;
90005eb8:	687b      	ldr	r3, [r7, #4]
90005eba:	2200      	movs	r2, #0
90005ebc:	669a      	str	r2, [r3, #104]	; 0x68
  hsai->SlotInit.SlotSize       = SAI_SLOTSIZE_DATASIZE;
90005ebe:	687b      	ldr	r3, [r7, #4]
90005ec0:	2200      	movs	r2, #0
90005ec2:	66da      	str	r2, [r3, #108]	; 0x6c
  hsai->SlotInit.SlotNumber     = 2;
90005ec4:	687b      	ldr	r3, [r7, #4]
90005ec6:	2202      	movs	r2, #2
90005ec8:	671a      	str	r2, [r3, #112]	; 0x70
  hsai->SlotInit.SlotActive     = MXConfig->SlotActive;
90005eca:	683b      	ldr	r3, [r7, #0]
90005ecc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
90005ece:	687b      	ldr	r3, [r7, #4]
90005ed0:	675a      	str	r2, [r3, #116]	; 0x74

  if (HAL_SAI_Init(hsai) != HAL_OK)
90005ed2:	6878      	ldr	r0, [r7, #4]
90005ed4:	f00d fcb6 	bl	90013844 <HAL_SAI_Init>
90005ed8:	4603      	mov	r3, r0
90005eda:	2b00      	cmp	r3, #0
90005edc:	d001      	beq.n	90005ee2 <MX_SAI4_Block_A_Init+0xf0>
  {
    ret = HAL_ERROR;
90005ede:	2301      	movs	r3, #1
90005ee0:	73fb      	strb	r3, [r7, #15]
  }
  __HAL_SAI_ENABLE(hsai);
90005ee2:	687b      	ldr	r3, [r7, #4]
90005ee4:	681b      	ldr	r3, [r3, #0]
90005ee6:	681a      	ldr	r2, [r3, #0]
90005ee8:	687b      	ldr	r3, [r7, #4]
90005eea:	681b      	ldr	r3, [r3, #0]
90005eec:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90005ef0:	601a      	str	r2, [r3, #0]
  return ret ;
90005ef2:	7bfb      	ldrb	r3, [r7, #15]

}
90005ef4:	4618      	mov	r0, r3
90005ef6:	3710      	adds	r7, #16
90005ef8:	46bd      	mov	sp, r7
90005efa:	bd80      	pop	{r7, pc}

90005efc <BSP_AUDIO_IN_PDMToPCM_Init>:
  * @param  ChnlNbrIn  Number of input audio channels in the PDM buffer
  * @param  ChnlNbrOut Number of desired output audio channels in the  resulting PCM buffer
  * @retval BSP status
  */
int32_t BSP_AUDIO_IN_PDMToPCM_Init(uint32_t Instance, uint32_t AudioFreq, uint32_t ChnlNbrIn, uint32_t ChnlNbrOut)
{
90005efc:	b580      	push	{r7, lr}
90005efe:	b086      	sub	sp, #24
90005f00:	af00      	add	r7, sp, #0
90005f02:	60f8      	str	r0, [r7, #12]
90005f04:	60b9      	str	r1, [r7, #8]
90005f06:	607a      	str	r2, [r7, #4]
90005f08:	603b      	str	r3, [r7, #0]
  uint32_t index = 0;
90005f0a:	2300      	movs	r3, #0
90005f0c:	617b      	str	r3, [r7, #20]

  if (Instance != 1U)
90005f0e:	68fb      	ldr	r3, [r7, #12]
90005f10:	2b01      	cmp	r3, #1
90005f12:	d002      	beq.n	90005f1a <BSP_AUDIO_IN_PDMToPCM_Init+0x1e>
  {
    return  BSP_ERROR_WRONG_PARAM;
90005f14:	f06f 0301 	mvn.w	r3, #1
90005f18:	e085      	b.n	90006026 <BSP_AUDIO_IN_PDMToPCM_Init+0x12a>
  }
  else
  {
    /* Enable CRC peripheral to unlock the PDM library */
    __HAL_RCC_CRC_CLK_ENABLE();
90005f1a:	4b45      	ldr	r3, [pc, #276]	; (90006030 <BSP_AUDIO_IN_PDMToPCM_Init+0x134>)
90005f1c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90005f20:	4a43      	ldr	r2, [pc, #268]	; (90006030 <BSP_AUDIO_IN_PDMToPCM_Init+0x134>)
90005f22:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
90005f26:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90005f2a:	4b41      	ldr	r3, [pc, #260]	; (90006030 <BSP_AUDIO_IN_PDMToPCM_Init+0x134>)
90005f2c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90005f30:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
90005f34:	613b      	str	r3, [r7, #16]
90005f36:	693b      	ldr	r3, [r7, #16]

    for (index = 0; index < ChnlNbrIn; index++)
90005f38:	2300      	movs	r3, #0
90005f3a:	617b      	str	r3, [r7, #20]
90005f3c:	e06e      	b.n	9000601c <BSP_AUDIO_IN_PDMToPCM_Init+0x120>
    {
      /* Init PDM filters */
      PDM_FilterHandler[index].bit_order = PDM_FILTER_BIT_ORDER_MSB;
90005f3e:	4a3d      	ldr	r2, [pc, #244]	; (90006034 <BSP_AUDIO_IN_PDMToPCM_Init+0x138>)
90005f40:	697b      	ldr	r3, [r7, #20]
90005f42:	214c      	movs	r1, #76	; 0x4c
90005f44:	fb01 f303 	mul.w	r3, r1, r3
90005f48:	4413      	add	r3, r2
90005f4a:	2201      	movs	r2, #1
90005f4c:	801a      	strh	r2, [r3, #0]
      PDM_FilterHandler[index].endianness = PDM_FILTER_ENDIANNESS_LE;
90005f4e:	4a39      	ldr	r2, [pc, #228]	; (90006034 <BSP_AUDIO_IN_PDMToPCM_Init+0x138>)
90005f50:	697b      	ldr	r3, [r7, #20]
90005f52:	214c      	movs	r1, #76	; 0x4c
90005f54:	fb01 f303 	mul.w	r3, r1, r3
90005f58:	4413      	add	r3, r2
90005f5a:	3302      	adds	r3, #2
90005f5c:	2200      	movs	r2, #0
90005f5e:	801a      	strh	r2, [r3, #0]
      PDM_FilterHandler[index].high_pass_tap = 2122358088;
90005f60:	4a34      	ldr	r2, [pc, #208]	; (90006034 <BSP_AUDIO_IN_PDMToPCM_Init+0x138>)
90005f62:	697b      	ldr	r3, [r7, #20]
90005f64:	214c      	movs	r1, #76	; 0x4c
90005f66:	fb01 f303 	mul.w	r3, r1, r3
90005f6a:	4413      	add	r3, r2
90005f6c:	3304      	adds	r3, #4
90005f6e:	4a32      	ldr	r2, [pc, #200]	; (90006038 <BSP_AUDIO_IN_PDMToPCM_Init+0x13c>)
90005f70:	601a      	str	r2, [r3, #0]
      PDM_FilterHandler[index].out_ptr_channels = ChnlNbrOut;
90005f72:	683b      	ldr	r3, [r7, #0]
90005f74:	b298      	uxth	r0, r3
90005f76:	4a2f      	ldr	r2, [pc, #188]	; (90006034 <BSP_AUDIO_IN_PDMToPCM_Init+0x138>)
90005f78:	697b      	ldr	r3, [r7, #20]
90005f7a:	214c      	movs	r1, #76	; 0x4c
90005f7c:	fb01 f303 	mul.w	r3, r1, r3
90005f80:	4413      	add	r3, r2
90005f82:	330a      	adds	r3, #10
90005f84:	4602      	mov	r2, r0
90005f86:	801a      	strh	r2, [r3, #0]
      PDM_FilterHandler[index].in_ptr_channels = ChnlNbrIn;
90005f88:	687b      	ldr	r3, [r7, #4]
90005f8a:	b298      	uxth	r0, r3
90005f8c:	4a29      	ldr	r2, [pc, #164]	; (90006034 <BSP_AUDIO_IN_PDMToPCM_Init+0x138>)
90005f8e:	697b      	ldr	r3, [r7, #20]
90005f90:	214c      	movs	r1, #76	; 0x4c
90005f92:	fb01 f303 	mul.w	r3, r1, r3
90005f96:	4413      	add	r3, r2
90005f98:	3308      	adds	r3, #8
90005f9a:	4602      	mov	r2, r0
90005f9c:	801a      	strh	r2, [r3, #0]
      PDM_Filter_Init((PDM_Filter_Handler_t *)(&PDM_FilterHandler[index]));
90005f9e:	697b      	ldr	r3, [r7, #20]
90005fa0:	224c      	movs	r2, #76	; 0x4c
90005fa2:	fb02 f303 	mul.w	r3, r2, r3
90005fa6:	4a23      	ldr	r2, [pc, #140]	; (90006034 <BSP_AUDIO_IN_PDMToPCM_Init+0x138>)
90005fa8:	4413      	add	r3, r2
90005faa:	4618      	mov	r0, r3
90005fac:	f7fa f998 	bl	900002e0 <PDM_Filter_Init>

      /* PDM lib config phase */
      PDM_FilterConfig[index].output_samples_number = AudioFreq / 1000;
90005fb0:	68bb      	ldr	r3, [r7, #8]
90005fb2:	4a22      	ldr	r2, [pc, #136]	; (9000603c <BSP_AUDIO_IN_PDMToPCM_Init+0x140>)
90005fb4:	fba2 2303 	umull	r2, r3, r2, r3
90005fb8:	099b      	lsrs	r3, r3, #6
90005fba:	b298      	uxth	r0, r3
90005fbc:	4920      	ldr	r1, [pc, #128]	; (90006040 <BSP_AUDIO_IN_PDMToPCM_Init+0x144>)
90005fbe:	697a      	ldr	r2, [r7, #20]
90005fc0:	4613      	mov	r3, r2
90005fc2:	005b      	lsls	r3, r3, #1
90005fc4:	4413      	add	r3, r2
90005fc6:	005b      	lsls	r3, r3, #1
90005fc8:	440b      	add	r3, r1
90005fca:	3302      	adds	r3, #2
90005fcc:	4602      	mov	r2, r0
90005fce:	801a      	strh	r2, [r3, #0]
      PDM_FilterConfig[index].mic_gain = 24;
90005fd0:	491b      	ldr	r1, [pc, #108]	; (90006040 <BSP_AUDIO_IN_PDMToPCM_Init+0x144>)
90005fd2:	697a      	ldr	r2, [r7, #20]
90005fd4:	4613      	mov	r3, r2
90005fd6:	005b      	lsls	r3, r3, #1
90005fd8:	4413      	add	r3, r2
90005fda:	005b      	lsls	r3, r3, #1
90005fdc:	440b      	add	r3, r1
90005fde:	3304      	adds	r3, #4
90005fe0:	2218      	movs	r2, #24
90005fe2:	801a      	strh	r2, [r3, #0]
      PDM_FilterConfig[index].decimation_factor = PDM_FILTER_DEC_FACTOR_64;
90005fe4:	4916      	ldr	r1, [pc, #88]	; (90006040 <BSP_AUDIO_IN_PDMToPCM_Init+0x144>)
90005fe6:	697a      	ldr	r2, [r7, #20]
90005fe8:	4613      	mov	r3, r2
90005fea:	005b      	lsls	r3, r3, #1
90005fec:	4413      	add	r3, r2
90005fee:	005b      	lsls	r3, r3, #1
90005ff0:	440b      	add	r3, r1
90005ff2:	2202      	movs	r2, #2
90005ff4:	801a      	strh	r2, [r3, #0]
      PDM_Filter_setConfig((PDM_Filter_Handler_t *)&PDM_FilterHandler[index], &PDM_FilterConfig[index]);
90005ff6:	697b      	ldr	r3, [r7, #20]
90005ff8:	224c      	movs	r2, #76	; 0x4c
90005ffa:	fb02 f303 	mul.w	r3, r2, r3
90005ffe:	4a0d      	ldr	r2, [pc, #52]	; (90006034 <BSP_AUDIO_IN_PDMToPCM_Init+0x138>)
90006000:	1898      	adds	r0, r3, r2
90006002:	697a      	ldr	r2, [r7, #20]
90006004:	4613      	mov	r3, r2
90006006:	005b      	lsls	r3, r3, #1
90006008:	4413      	add	r3, r2
9000600a:	005b      	lsls	r3, r3, #1
9000600c:	4a0c      	ldr	r2, [pc, #48]	; (90006040 <BSP_AUDIO_IN_PDMToPCM_Init+0x144>)
9000600e:	4413      	add	r3, r2
90006010:	4619      	mov	r1, r3
90006012:	f7fa fa83 	bl	9000051c <PDM_Filter_setConfig>
    for (index = 0; index < ChnlNbrIn; index++)
90006016:	697b      	ldr	r3, [r7, #20]
90006018:	3301      	adds	r3, #1
9000601a:	617b      	str	r3, [r7, #20]
9000601c:	697a      	ldr	r2, [r7, #20]
9000601e:	687b      	ldr	r3, [r7, #4]
90006020:	429a      	cmp	r2, r3
90006022:	d38c      	bcc.n	90005f3e <BSP_AUDIO_IN_PDMToPCM_Init+0x42>
    }

  }

   return BSP_ERROR_NONE;
90006024:	2300      	movs	r3, #0
}
90006026:	4618      	mov	r0, r3
90006028:	3718      	adds	r7, #24
9000602a:	46bd      	mov	sp, r7
9000602c:	bd80      	pop	{r7, pc}
9000602e:	bf00      	nop
90006030:	58024400 	.word	0x58024400
90006034:	24001190 	.word	0x24001190
90006038:	7e809d48 	.word	0x7e809d48
9000603c:	10624dd3 	.word	0x10624dd3
90006040:	24001228 	.word	0x24001228

90006044 <BSP_AUDIO_IN_PDMToPCM>:
  * @param  PDMBuf    Pointer to PDM buffer data
  * @param  PCMBuf    Pointer to PCM buffer data
  * @retval BSP status
  */
int32_t BSP_AUDIO_IN_PDMToPCM(uint32_t Instance, uint16_t *PDMBuf, uint16_t *PCMBuf)
{
90006044:	b580      	push	{r7, lr}
90006046:	b086      	sub	sp, #24
90006048:	af00      	add	r7, sp, #0
9000604a:	60f8      	str	r0, [r7, #12]
9000604c:	60b9      	str	r1, [r7, #8]
9000604e:	607a      	str	r2, [r7, #4]
  uint32_t index = 0;
90006050:	2300      	movs	r3, #0
90006052:	617b      	str	r3, [r7, #20]

  if (Instance != 1U)
90006054:	68fb      	ldr	r3, [r7, #12]
90006056:	2b01      	cmp	r3, #1
90006058:	d002      	beq.n	90006060 <BSP_AUDIO_IN_PDMToPCM+0x1c>
  {
    return BSP_ERROR_WRONG_PARAM;
9000605a:	f06f 0301 	mvn.w	r3, #1
9000605e:	e022      	b.n	900060a6 <BSP_AUDIO_IN_PDMToPCM+0x62>
  }
  else
  {
    for (index = 0; index < Audio_In_Ctx[Instance].ChannelsNbr; index++)
90006060:	2300      	movs	r3, #0
90006062:	617b      	str	r3, [r7, #20]
90006064:	e012      	b.n	9000608c <BSP_AUDIO_IN_PDMToPCM+0x48>
    {
      PDM_Filter(&((uint8_t *)(PDMBuf))[index], (uint16_t *)&(PCMBuf[index]), &PDM_FilterHandler[index]);
90006066:	68ba      	ldr	r2, [r7, #8]
90006068:	697b      	ldr	r3, [r7, #20]
9000606a:	18d0      	adds	r0, r2, r3
9000606c:	697b      	ldr	r3, [r7, #20]
9000606e:	005b      	lsls	r3, r3, #1
90006070:	687a      	ldr	r2, [r7, #4]
90006072:	18d1      	adds	r1, r2, r3
90006074:	697b      	ldr	r3, [r7, #20]
90006076:	224c      	movs	r2, #76	; 0x4c
90006078:	fb02 f303 	mul.w	r3, r2, r3
9000607c:	4a0c      	ldr	r2, [pc, #48]	; (900060b0 <BSP_AUDIO_IN_PDMToPCM+0x6c>)
9000607e:	4413      	add	r3, r2
90006080:	461a      	mov	r2, r3
90006082:	f7fa fb50 	bl	90000726 <PDM_Filter>
    for (index = 0; index < Audio_In_Ctx[Instance].ChannelsNbr; index++)
90006086:	697b      	ldr	r3, [r7, #20]
90006088:	3301      	adds	r3, #1
9000608a:	617b      	str	r3, [r7, #20]
9000608c:	4909      	ldr	r1, [pc, #36]	; (900060b4 <BSP_AUDIO_IN_PDMToPCM+0x70>)
9000608e:	68fa      	ldr	r2, [r7, #12]
90006090:	4613      	mov	r3, r2
90006092:	005b      	lsls	r3, r3, #1
90006094:	4413      	add	r3, r2
90006096:	011b      	lsls	r3, r3, #4
90006098:	440b      	add	r3, r1
9000609a:	3310      	adds	r3, #16
9000609c:	681b      	ldr	r3, [r3, #0]
9000609e:	697a      	ldr	r2, [r7, #20]
900060a0:	429a      	cmp	r2, r3
900060a2:	d3e0      	bcc.n	90006066 <BSP_AUDIO_IN_PDMToPCM+0x22>
    }
  }

  return BSP_ERROR_NONE;
900060a4:	2300      	movs	r3, #0
}
900060a6:	4618      	mov	r0, r3
900060a8:	3718      	adds	r7, #24
900060aa:	46bd      	mov	sp, r7
900060ac:	bd80      	pop	{r7, pc}
900060ae:	bf00      	nop
900060b0:	24001190 	.word	0x24001190
900060b4:	240029d0 	.word	0x240029d0

900060b8 <BSP_AUDIO_IN_Stop>:
  * @brief  Stop audio recording.
  * @param  Instance  AUDIO IN Instance. It can be 0 when SAI is used or 1 when PDM is used
  * @retval BSP status
  */
int32_t BSP_AUDIO_IN_Stop(uint32_t Instance)
{
900060b8:	b580      	push	{r7, lr}
900060ba:	b084      	sub	sp, #16
900060bc:	af00      	add	r7, sp, #0
900060be:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
900060c0:	2300      	movs	r3, #0
900060c2:	60fb      	str	r3, [r7, #12]

  if (Instance >= AUDIO_IN_INSTANCES_NBR)
900060c4:	687b      	ldr	r3, [r7, #4]
900060c6:	2b01      	cmp	r3, #1
900060c8:	d903      	bls.n	900060d2 <BSP_AUDIO_IN_Stop+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900060ca:	f06f 0301 	mvn.w	r3, #1
900060ce:	60fb      	str	r3, [r7, #12]
900060d0:	e026      	b.n	90006120 <BSP_AUDIO_IN_Stop+0x68>
  }
  else
  {
      if (Instance == 0U)
900060d2:	687b      	ldr	r3, [r7, #4]
900060d4:	2b00      	cmp	r3, #0
900060d6:	d10d      	bne.n	900060f4 <BSP_AUDIO_IN_Stop+0x3c>
      {
        /* Call the Media layer stop function */
        if (Audio_Drv->Stop(Audio_CompObj, CODEC_PDWN_SW) < 0)
900060d8:	4b14      	ldr	r3, [pc, #80]	; (9000612c <BSP_AUDIO_IN_Stop+0x74>)
900060da:	681b      	ldr	r3, [r3, #0]
900060dc:	699b      	ldr	r3, [r3, #24]
900060de:	4a14      	ldr	r2, [pc, #80]	; (90006130 <BSP_AUDIO_IN_Stop+0x78>)
900060e0:	6812      	ldr	r2, [r2, #0]
900060e2:	2101      	movs	r1, #1
900060e4:	4610      	mov	r0, r2
900060e6:	4798      	blx	r3
900060e8:	4603      	mov	r3, r0
900060ea:	2b00      	cmp	r3, #0
900060ec:	da02      	bge.n	900060f4 <BSP_AUDIO_IN_Stop+0x3c>
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
900060ee:	f06f 0304 	mvn.w	r3, #4
900060f2:	60fb      	str	r3, [r7, #12]
        }
      }

      if (ret == BSP_ERROR_NONE)
900060f4:	68fb      	ldr	r3, [r7, #12]
900060f6:	2b00      	cmp	r3, #0
900060f8:	d108      	bne.n	9000610c <BSP_AUDIO_IN_Stop+0x54>
      {
        if (HAL_SAI_DMAStop(&haudio_in_sai) != HAL_OK)
900060fa:	480e      	ldr	r0, [pc, #56]	; (90006134 <BSP_AUDIO_IN_Stop+0x7c>)
900060fc:	f00d ff0f 	bl	90013f1e <HAL_SAI_DMAStop>
90006100:	4603      	mov	r3, r0
90006102:	2b00      	cmp	r3, #0
90006104:	d002      	beq.n	9000610c <BSP_AUDIO_IN_Stop+0x54>
        {
          ret = BSP_ERROR_PERIPH_FAILURE;
90006106:	f06f 0303 	mvn.w	r3, #3
9000610a:	60fb      	str	r3, [r7, #12]
        }
      }


    /* Update BSP AUDIO IN state */
    Audio_In_Ctx[Instance].State = AUDIO_IN_STATE_STOP;
9000610c:	490a      	ldr	r1, [pc, #40]	; (90006138 <BSP_AUDIO_IN_Stop+0x80>)
9000610e:	687a      	ldr	r2, [r7, #4]
90006110:	4613      	mov	r3, r2
90006112:	005b      	lsls	r3, r3, #1
90006114:	4413      	add	r3, r2
90006116:	011b      	lsls	r3, r3, #4
90006118:	440b      	add	r3, r1
9000611a:	3324      	adds	r3, #36	; 0x24
9000611c:	2202      	movs	r2, #2
9000611e:	601a      	str	r2, [r3, #0]
  }

  /* Return BSP status */
  return ret;
90006120:	68fb      	ldr	r3, [r7, #12]
}
90006122:	4618      	mov	r0, r3
90006124:	3710      	adds	r7, #16
90006126:	46bd      	mov	sp, r7
90006128:	bd80      	pop	{r7, pc}
9000612a:	bf00      	nop
9000612c:	2400118c 	.word	0x2400118c
90006130:	24001234 	.word	0x24001234
90006134:	24002914 	.word	0x24002914
90006138:	240029d0 	.word	0x240029d0

9000613c <BSP_AUDIO_IN_RecordPDM>:
  * @param  pBuf     Main buffer pointer for the recorded data storing
  * @param  NbrOfBytes     Size of the record buffer
  * @retval BSP status
  */
int32_t BSP_AUDIO_IN_RecordPDM(uint32_t Instance, uint8_t *pBuf, uint32_t NbrOfBytes)
{
9000613c:	b580      	push	{r7, lr}
9000613e:	b086      	sub	sp, #24
90006140:	af00      	add	r7, sp, #0
90006142:	60f8      	str	r0, [r7, #12]
90006144:	60b9      	str	r1, [r7, #8]
90006146:	607a      	str	r2, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
90006148:	2300      	movs	r3, #0
9000614a:	617b      	str	r3, [r7, #20]

  if(Instance != 1U)
9000614c:	68fb      	ldr	r3, [r7, #12]
9000614e:	2b01      	cmp	r3, #1
90006150:	d003      	beq.n	9000615a <BSP_AUDIO_IN_RecordPDM+0x1e>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90006152:	f06f 0301 	mvn.w	r3, #1
90006156:	617b      	str	r3, [r7, #20]
90006158:	e018      	b.n	9000618c <BSP_AUDIO_IN_RecordPDM+0x50>
  }
  else
  {
    /* Start the process receive DMA */
    if(HAL_SAI_Receive_DMA(&haudio_in_sai, (uint8_t*)pBuf, (uint16_t)(NbrOfBytes/(Audio_In_Ctx[Instance].BitsPerSample/8U))) != HAL_OK)
9000615a:	490f      	ldr	r1, [pc, #60]	; (90006198 <BSP_AUDIO_IN_RecordPDM+0x5c>)
9000615c:	68fa      	ldr	r2, [r7, #12]
9000615e:	4613      	mov	r3, r2
90006160:	005b      	lsls	r3, r3, #1
90006162:	4413      	add	r3, r2
90006164:	011b      	lsls	r3, r3, #4
90006166:	440b      	add	r3, r1
90006168:	330c      	adds	r3, #12
9000616a:	681b      	ldr	r3, [r3, #0]
9000616c:	08db      	lsrs	r3, r3, #3
9000616e:	687a      	ldr	r2, [r7, #4]
90006170:	fbb2 f3f3 	udiv	r3, r2, r3
90006174:	b29b      	uxth	r3, r3
90006176:	461a      	mov	r2, r3
90006178:	68b9      	ldr	r1, [r7, #8]
9000617a:	4808      	ldr	r0, [pc, #32]	; (9000619c <BSP_AUDIO_IN_RecordPDM+0x60>)
9000617c:	f00e f804 	bl	90014188 <HAL_SAI_Receive_DMA>
90006180:	4603      	mov	r3, r0
90006182:	2b00      	cmp	r3, #0
90006184:	d002      	beq.n	9000618c <BSP_AUDIO_IN_RecordPDM+0x50>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
90006186:	f06f 0303 	mvn.w	r3, #3
9000618a:	617b      	str	r3, [r7, #20]
    }
  }

  /* Return BSP status */
  return ret;
9000618c:	697b      	ldr	r3, [r7, #20]
}
9000618e:	4618      	mov	r0, r3
90006190:	3718      	adds	r7, #24
90006192:	46bd      	mov	sp, r7
90006194:	bd80      	pop	{r7, pc}
90006196:	bf00      	nop
90006198:	240029d0 	.word	0x240029d0
9000619c:	24002914 	.word	0x24002914

900061a0 <BSP_AUDIO_IN_GetState>:
  * @param  Instance  AUDIO IN Instance. It can be 0 when SAI is used
  * @param  State     Audio Out state
  * @retval BSP status
  */
int32_t BSP_AUDIO_IN_GetState(uint32_t Instance, uint32_t *State)
{
900061a0:	b480      	push	{r7}
900061a2:	b085      	sub	sp, #20
900061a4:	af00      	add	r7, sp, #0
900061a6:	6078      	str	r0, [r7, #4]
900061a8:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
900061aa:	2300      	movs	r3, #0
900061ac:	60fb      	str	r3, [r7, #12]

  if (Instance >= AUDIO_IN_INSTANCES_NBR)
900061ae:	687b      	ldr	r3, [r7, #4]
900061b0:	2b01      	cmp	r3, #1
900061b2:	d903      	bls.n	900061bc <BSP_AUDIO_IN_GetState+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900061b4:	f06f 0301 	mvn.w	r3, #1
900061b8:	60fb      	str	r3, [r7, #12]
900061ba:	e00a      	b.n	900061d2 <BSP_AUDIO_IN_GetState+0x32>
  }
  else
  {
    /* Input State to be returned */
    *State = Audio_In_Ctx[Instance].State;
900061bc:	4908      	ldr	r1, [pc, #32]	; (900061e0 <BSP_AUDIO_IN_GetState+0x40>)
900061be:	687a      	ldr	r2, [r7, #4]
900061c0:	4613      	mov	r3, r2
900061c2:	005b      	lsls	r3, r3, #1
900061c4:	4413      	add	r3, r2
900061c6:	011b      	lsls	r3, r3, #4
900061c8:	440b      	add	r3, r1
900061ca:	3324      	adds	r3, #36	; 0x24
900061cc:	681a      	ldr	r2, [r3, #0]
900061ce:	683b      	ldr	r3, [r7, #0]
900061d0:	601a      	str	r2, [r3, #0]
  }
  return ret;
900061d2:	68fb      	ldr	r3, [r7, #12]
}
900061d4:	4618      	mov	r0, r3
900061d6:	3714      	adds	r7, #20
900061d8:	46bd      	mov	sp, r7
900061da:	f85d 7b04 	ldr.w	r7, [sp], #4
900061de:	4770      	bx	lr
900061e0:	240029d0 	.word	0x240029d0

900061e4 <BSP_AUDIO_IN_IRQHandler>:
  *         - AUDIO_IN_DEVICE_DIGITAL_MIC1
  *         - AUDIO_IN_DEVICE_DIGITAL_MIC2
  * @retval None
  */
void BSP_AUDIO_IN_IRQHandler(uint32_t Instance, uint32_t InputDevice)
{
900061e4:	b580      	push	{r7, lr}
900061e6:	b082      	sub	sp, #8
900061e8:	af00      	add	r7, sp, #0
900061ea:	6078      	str	r0, [r7, #4]
900061ec:	6039      	str	r1, [r7, #0]

  if ((InputDevice == AUDIO_IN_DEVICE_DIGITAL_MIC) || (InputDevice == AUDIO_IN_DEVICE_ANALOG_MIC))
900061ee:	683b      	ldr	r3, [r7, #0]
900061f0:	2b30      	cmp	r3, #48	; 0x30
900061f2:	d002      	beq.n	900061fa <BSP_AUDIO_IN_IRQHandler+0x16>
900061f4:	683b      	ldr	r3, [r7, #0]
900061f6:	2b00      	cmp	r3, #0
900061f8:	d105      	bne.n	90006206 <BSP_AUDIO_IN_IRQHandler+0x22>
  {
    HAL_DMA_IRQHandler(haudio_in_sai.hdmarx);
900061fa:	4b05      	ldr	r3, [pc, #20]	; (90006210 <BSP_AUDIO_IN_IRQHandler+0x2c>)
900061fc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90006200:	4618      	mov	r0, r3
90006202:	f004 fd83 	bl	9000ad0c <HAL_DMA_IRQHandler>
  }

}
90006206:	bf00      	nop
90006208:	3708      	adds	r7, #8
9000620a:	46bd      	mov	sp, r7
9000620c:	bd80      	pop	{r7, pc}
9000620e:	bf00      	nop
90006210:	24002914 	.word	0x24002914

90006214 <HAL_SAI_RxHalfCpltCallback>:
  * @brief  Half reception complete callback.
  * @param  hsai   SAI handle.
  * @retval None
  */
void HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
90006214:	b580      	push	{r7, lr}
90006216:	b082      	sub	sp, #8
90006218:	af00      	add	r7, sp, #0
9000621a:	6078      	str	r0, [r7, #4]
  /* Call the record update function to get the first half */
  if (hsai->Instance == AUDIO_IN_SAIx)
9000621c:	687b      	ldr	r3, [r7, #4]
9000621e:	681b      	ldr	r3, [r3, #0]
90006220:	4a06      	ldr	r2, [pc, #24]	; (9000623c <HAL_SAI_RxHalfCpltCallback+0x28>)
90006222:	4293      	cmp	r3, r2
90006224:	d103      	bne.n	9000622e <HAL_SAI_RxHalfCpltCallback+0x1a>
  {
    BSP_AUDIO_IN_HalfTransfer_CallBack(0);
90006226:	2000      	movs	r0, #0
90006228:	f010 faa2 	bl	90016770 <BSP_AUDIO_IN_HalfTransfer_CallBack>
  }
  else
  {
    BSP_AUDIO_IN_HalfTransfer_CallBack(1);
  }
}
9000622c:	e002      	b.n	90006234 <HAL_SAI_RxHalfCpltCallback+0x20>
    BSP_AUDIO_IN_HalfTransfer_CallBack(1);
9000622e:	2001      	movs	r0, #1
90006230:	f010 fa9e 	bl	90016770 <BSP_AUDIO_IN_HalfTransfer_CallBack>
}
90006234:	bf00      	nop
90006236:	3708      	adds	r7, #8
90006238:	46bd      	mov	sp, r7
9000623a:	bd80      	pop	{r7, pc}
9000623c:	40015c24 	.word	0x40015c24

90006240 <HAL_SAI_RxCpltCallback>:
  * @brief  Reception complete callback.
  * @param  hsai   SAI handle.
  * @retval None
  */
void HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai)
{
90006240:	b580      	push	{r7, lr}
90006242:	b082      	sub	sp, #8
90006244:	af00      	add	r7, sp, #0
90006246:	6078      	str	r0, [r7, #4]
  /* Call the record update function to get the second half */
  if (hsai->Instance == AUDIO_IN_SAIx)
90006248:	687b      	ldr	r3, [r7, #4]
9000624a:	681b      	ldr	r3, [r3, #0]
9000624c:	4a06      	ldr	r2, [pc, #24]	; (90006268 <HAL_SAI_RxCpltCallback+0x28>)
9000624e:	4293      	cmp	r3, r2
90006250:	d103      	bne.n	9000625a <HAL_SAI_RxCpltCallback+0x1a>
  {
    BSP_AUDIO_IN_TransferComplete_CallBack(0);
90006252:	2000      	movs	r0, #0
90006254:	f010 fa0a 	bl	9001666c <BSP_AUDIO_IN_TransferComplete_CallBack>
  }
  else
  {
    BSP_AUDIO_IN_TransferComplete_CallBack(1);
  }
}
90006258:	e002      	b.n	90006260 <HAL_SAI_RxCpltCallback+0x20>
    BSP_AUDIO_IN_TransferComplete_CallBack(1);
9000625a:	2001      	movs	r0, #1
9000625c:	f010 fa06 	bl	9001666c <BSP_AUDIO_IN_TransferComplete_CallBack>
}
90006260:	bf00      	nop
90006262:	3708      	adds	r7, #8
90006264:	46bd      	mov	sp, r7
90006266:	bd80      	pop	{r7, pc}
90006268:	40015c24 	.word	0x40015c24

9000626c <BSP_AUDIO_IN_Error_CallBack>:
/**
  * @brief  Audio IN Error callback function.
  * @retval None
  */
__weak void BSP_AUDIO_IN_Error_CallBack(uint32_t Instance)
{
9000626c:	b480      	push	{r7}
9000626e:	b083      	sub	sp, #12
90006270:	af00      	add	r7, sp, #0
90006272:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Instance);

  /* This function is called when an Interrupt due to transfer error on or peripheral
     error occurs. */
}
90006274:	bf00      	nop
90006276:	370c      	adds	r7, #12
90006278:	46bd      	mov	sp, r7
9000627a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000627e:	4770      	bx	lr

90006280 <WM8994_Probe>:
/**
  * @brief  Register Bus IOs if component ID is OK
  * @retval error status
  */
static int32_t WM8994_Probe(void)
{
90006280:	b580      	push	{r7, lr}
90006282:	b088      	sub	sp, #32
90006284:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
90006286:	2300      	movs	r3, #0
90006288:	61fb      	str	r3, [r7, #28]
  WM8994_IO_t              IOCtx;
  static WM8994_Object_t   WM8994Obj;
  uint32_t id;

  /* Configure the audio driver */
  IOCtx.Address     = AUDIO_I2C_ADDRESS;
9000628a:	2334      	movs	r3, #52	; 0x34
9000628c:	81bb      	strh	r3, [r7, #12]
  IOCtx.Init        = BSP_I2C4_Init;
9000628e:	4b20      	ldr	r3, [pc, #128]	; (90006310 <WM8994_Probe+0x90>)
90006290:	607b      	str	r3, [r7, #4]
  IOCtx.DeInit      = BSP_I2C4_DeInit;
90006292:	4b20      	ldr	r3, [pc, #128]	; (90006314 <WM8994_Probe+0x94>)
90006294:	60bb      	str	r3, [r7, #8]
  IOCtx.ReadReg     = BSP_I2C4_ReadReg16;
90006296:	4b20      	ldr	r3, [pc, #128]	; (90006318 <WM8994_Probe+0x98>)
90006298:	617b      	str	r3, [r7, #20]
  IOCtx.WriteReg    = BSP_I2C4_WriteReg16;
9000629a:	4b20      	ldr	r3, [pc, #128]	; (9000631c <WM8994_Probe+0x9c>)
9000629c:	613b      	str	r3, [r7, #16]
  IOCtx.GetTick     = BSP_GetTick;
9000629e:	4b20      	ldr	r3, [pc, #128]	; (90006320 <WM8994_Probe+0xa0>)
900062a0:	61bb      	str	r3, [r7, #24]

  if(WM8994_RegisterBusIO (&WM8994Obj, &IOCtx) != WM8994_OK)
900062a2:	1d3b      	adds	r3, r7, #4
900062a4:	4619      	mov	r1, r3
900062a6:	481f      	ldr	r0, [pc, #124]	; (90006324 <WM8994_Probe+0xa4>)
900062a8:	f7fe fae8 	bl	9000487c <WM8994_RegisterBusIO>
900062ac:	4603      	mov	r3, r0
900062ae:	2b00      	cmp	r3, #0
900062b0:	d003      	beq.n	900062ba <WM8994_Probe+0x3a>
  {
    ret = BSP_ERROR_BUS_FAILURE;
900062b2:	f06f 0307 	mvn.w	r3, #7
900062b6:	61fb      	str	r3, [r7, #28]
900062b8:	e024      	b.n	90006304 <WM8994_Probe+0x84>
  }
  else
  {
    /* Reset the codec */
    if(WM8994_Reset(&WM8994Obj) != WM8994_OK)
900062ba:	481a      	ldr	r0, [pc, #104]	; (90006324 <WM8994_Probe+0xa4>)
900062bc:	f7fe fac6 	bl	9000484c <WM8994_Reset>
900062c0:	4603      	mov	r3, r0
900062c2:	2b00      	cmp	r3, #0
900062c4:	d003      	beq.n	900062ce <WM8994_Probe+0x4e>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
900062c6:	f06f 0304 	mvn.w	r3, #4
900062ca:	61fb      	str	r3, [r7, #28]
900062cc:	e01a      	b.n	90006304 <WM8994_Probe+0x84>
    }
    else if(WM8994_ReadID(&WM8994Obj, &id) != WM8994_OK)
900062ce:	463b      	mov	r3, r7
900062d0:	4619      	mov	r1, r3
900062d2:	4814      	ldr	r0, [pc, #80]	; (90006324 <WM8994_Probe+0xa4>)
900062d4:	f7fd fcb5 	bl	90003c42 <WM8994_ReadID>
900062d8:	4603      	mov	r3, r0
900062da:	2b00      	cmp	r3, #0
900062dc:	d003      	beq.n	900062e6 <WM8994_Probe+0x66>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
900062de:	f06f 0304 	mvn.w	r3, #4
900062e2:	61fb      	str	r3, [r7, #28]
900062e4:	e00e      	b.n	90006304 <WM8994_Probe+0x84>
    }
    else if(id != WM8994_ID)
900062e6:	683b      	ldr	r3, [r7, #0]
900062e8:	f648 1294 	movw	r2, #35220	; 0x8994
900062ec:	4293      	cmp	r3, r2
900062ee:	d003      	beq.n	900062f8 <WM8994_Probe+0x78>
    {
      ret = BSP_ERROR_UNKNOWN_COMPONENT;
900062f0:	f06f 0306 	mvn.w	r3, #6
900062f4:	61fb      	str	r3, [r7, #28]
900062f6:	e005      	b.n	90006304 <WM8994_Probe+0x84>
    }
    else
    {
      Audio_Drv = (AUDIO_Drv_t *) &WM8994_Driver;
900062f8:	4b0b      	ldr	r3, [pc, #44]	; (90006328 <WM8994_Probe+0xa8>)
900062fa:	4a0c      	ldr	r2, [pc, #48]	; (9000632c <WM8994_Probe+0xac>)
900062fc:	601a      	str	r2, [r3, #0]
      Audio_CompObj = &WM8994Obj;
900062fe:	4b0c      	ldr	r3, [pc, #48]	; (90006330 <WM8994_Probe+0xb0>)
90006300:	4a08      	ldr	r2, [pc, #32]	; (90006324 <WM8994_Probe+0xa4>)
90006302:	601a      	str	r2, [r3, #0]
    }
  }
  return ret;
90006304:	69fb      	ldr	r3, [r7, #28]
}
90006306:	4618      	mov	r0, r3
90006308:	3720      	adds	r7, #32
9000630a:	46bd      	mov	sp, r7
9000630c:	bd80      	pop	{r7, pc}
9000630e:	bf00      	nop
90006310:	90006831 	.word	0x90006831
90006314:	900068a5 	.word	0x900068a5
90006318:	90006a85 	.word	0x90006a85
9000631c:	90006a29 	.word	0x90006a29
90006320:	90006ae1 	.word	0x90006ae1
90006324:	240012d0 	.word	0x240012d0
90006328:	2400118c 	.word	0x2400118c
9000632c:	24000030 	.word	0x24000030
90006330:	24001234 	.word	0x24001234

90006334 <SAI_MspInit>:
  * @brief  Initialize BSP_AUDIO_OUT MSP.
  * @param  hsai  SAI handle
  * @retval None
  */
static void SAI_MspInit(SAI_HandleTypeDef *hsai)
{
90006334:	b580      	push	{r7, lr}
90006336:	b094      	sub	sp, #80	; 0x50
90006338:	af00      	add	r7, sp, #0
9000633a:	6078      	str	r0, [r7, #4]
GPIO_InitTypeDef gpio_init_structure;
  static DMA_HandleTypeDef hdma_sai_tx, hdma_sai_rx;

  /* Enable SAI clock */
  AUDIO_OUT_SAIx_CLK_ENABLE();
9000633c:	4bad      	ldr	r3, [pc, #692]	; (900065f4 <SAI_MspInit+0x2c0>)
9000633e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
90006342:	4aac      	ldr	r2, [pc, #688]	; (900065f4 <SAI_MspInit+0x2c0>)
90006344:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
90006348:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
9000634c:	4ba9      	ldr	r3, [pc, #676]	; (900065f4 <SAI_MspInit+0x2c0>)
9000634e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
90006352:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
90006356:	63bb      	str	r3, [r7, #56]	; 0x38
90006358:	6bbb      	ldr	r3, [r7, #56]	; 0x38

  /* Enable GPIO clock */
  AUDIO_OUT_SAIx_SCK_ENABLE();
9000635a:	4ba6      	ldr	r3, [pc, #664]	; (900065f4 <SAI_MspInit+0x2c0>)
9000635c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006360:	4aa4      	ldr	r2, [pc, #656]	; (900065f4 <SAI_MspInit+0x2c0>)
90006362:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90006366:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
9000636a:	4ba2      	ldr	r3, [pc, #648]	; (900065f4 <SAI_MspInit+0x2c0>)
9000636c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006370:	f403 7380 	and.w	r3, r3, #256	; 0x100
90006374:	637b      	str	r3, [r7, #52]	; 0x34
90006376:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  AUDIO_OUT_SAIx_SD_ENABLE();
90006378:	4b9e      	ldr	r3, [pc, #632]	; (900065f4 <SAI_MspInit+0x2c0>)
9000637a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
9000637e:	4a9d      	ldr	r2, [pc, #628]	; (900065f4 <SAI_MspInit+0x2c0>)
90006380:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90006384:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90006388:	4b9a      	ldr	r3, [pc, #616]	; (900065f4 <SAI_MspInit+0x2c0>)
9000638a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
9000638e:	f403 7380 	and.w	r3, r3, #256	; 0x100
90006392:	633b      	str	r3, [r7, #48]	; 0x30
90006394:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  AUDIO_OUT_SAIx_FS_ENABLE();
90006396:	4b97      	ldr	r3, [pc, #604]	; (900065f4 <SAI_MspInit+0x2c0>)
90006398:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
9000639c:	4a95      	ldr	r2, [pc, #596]	; (900065f4 <SAI_MspInit+0x2c0>)
9000639e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
900063a2:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
900063a6:	4b93      	ldr	r3, [pc, #588]	; (900065f4 <SAI_MspInit+0x2c0>)
900063a8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900063ac:	f403 7380 	and.w	r3, r3, #256	; 0x100
900063b0:	62fb      	str	r3, [r7, #44]	; 0x2c
900063b2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  /* CODEC_SAI pins configuration: FS, SCK, MCK and SD pins ------------------*/
  gpio_init_structure.Pin = AUDIO_OUT_SAIx_FS_PIN;
900063b4:	2380      	movs	r3, #128	; 0x80
900063b6:	63fb      	str	r3, [r7, #60]	; 0x3c
  gpio_init_structure.Mode = GPIO_MODE_AF_PP;
900063b8:	2302      	movs	r3, #2
900063ba:	643b      	str	r3, [r7, #64]	; 0x40
  gpio_init_structure.Pull = GPIO_NOPULL;
900063bc:	2300      	movs	r3, #0
900063be:	647b      	str	r3, [r7, #68]	; 0x44
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
900063c0:	2303      	movs	r3, #3
900063c2:	64bb      	str	r3, [r7, #72]	; 0x48
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_FS_AF;
900063c4:	230a      	movs	r3, #10
900063c6:	64fb      	str	r3, [r7, #76]	; 0x4c
  HAL_GPIO_Init(AUDIO_OUT_SAIx_FS_GPIO_PORT, &gpio_init_structure);
900063c8:	f107 033c 	add.w	r3, r7, #60	; 0x3c
900063cc:	4619      	mov	r1, r3
900063ce:	488a      	ldr	r0, [pc, #552]	; (900065f8 <SAI_MspInit+0x2c4>)
900063d0:	f006 fc0a 	bl	9000cbe8 <HAL_GPIO_Init>

  gpio_init_structure.Pin = AUDIO_OUT_SAIx_SCK_PIN;
900063d4:	2320      	movs	r3, #32
900063d6:	63fb      	str	r3, [r7, #60]	; 0x3c
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_SCK_AF;
900063d8:	230a      	movs	r3, #10
900063da:	64fb      	str	r3, [r7, #76]	; 0x4c
  HAL_GPIO_Init(AUDIO_OUT_SAIx_SCK_GPIO_PORT, &gpio_init_structure);
900063dc:	f107 033c 	add.w	r3, r7, #60	; 0x3c
900063e0:	4619      	mov	r1, r3
900063e2:	4885      	ldr	r0, [pc, #532]	; (900065f8 <SAI_MspInit+0x2c4>)
900063e4:	f006 fc00 	bl	9000cbe8 <HAL_GPIO_Init>

  gpio_init_structure.Pin = AUDIO_OUT_SAIx_SD_PIN;
900063e8:	2340      	movs	r3, #64	; 0x40
900063ea:	63fb      	str	r3, [r7, #60]	; 0x3c
  gpio_init_structure.Alternate = AUDIO_OUT_SAIx_SD_AF;
900063ec:	230a      	movs	r3, #10
900063ee:	64fb      	str	r3, [r7, #76]	; 0x4c
  HAL_GPIO_Init(AUDIO_OUT_SAIx_SD_GPIO_PORT, &gpio_init_structure);
900063f0:	f107 033c 	add.w	r3, r7, #60	; 0x3c
900063f4:	4619      	mov	r1, r3
900063f6:	4880      	ldr	r0, [pc, #512]	; (900065f8 <SAI_MspInit+0x2c4>)
900063f8:	f006 fbf6 	bl	9000cbe8 <HAL_GPIO_Init>

  if (hsai->Instance != AUDIO_IN_SAI_PDMx)
900063fc:	687b      	ldr	r3, [r7, #4]
900063fe:	681b      	ldr	r3, [r3, #0]
90006400:	4a7e      	ldr	r2, [pc, #504]	; (900065fc <SAI_MspInit+0x2c8>)
90006402:	4293      	cmp	r3, r2
90006404:	d01e      	beq.n	90006444 <SAI_MspInit+0x110>
  {
    if (haudio_out_sai.State != HAL_SAI_STATE_READY)
90006406:	4b7e      	ldr	r3, [pc, #504]	; (90006600 <SAI_MspInit+0x2cc>)
90006408:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
9000640c:	b2db      	uxtb	r3, r3
9000640e:	2b01      	cmp	r3, #1
90006410:	d018      	beq.n	90006444 <SAI_MspInit+0x110>
    {
      AUDIO_OUT_SAIx_MCLK_ENABLE();
90006412:	4b78      	ldr	r3, [pc, #480]	; (900065f4 <SAI_MspInit+0x2c0>)
90006414:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006418:	4a76      	ldr	r2, [pc, #472]	; (900065f4 <SAI_MspInit+0x2c0>)
9000641a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
9000641e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90006422:	4b74      	ldr	r3, [pc, #464]	; (900065f4 <SAI_MspInit+0x2c0>)
90006424:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006428:	f403 7380 	and.w	r3, r3, #256	; 0x100
9000642c:	62bb      	str	r3, [r7, #40]	; 0x28
9000642e:	6abb      	ldr	r3, [r7, #40]	; 0x28
      gpio_init_structure.Pin = AUDIO_OUT_SAIx_MCLK_PIN;
90006430:	2310      	movs	r3, #16
90006432:	63fb      	str	r3, [r7, #60]	; 0x3c
      gpio_init_structure.Alternate = AUDIO_OUT_SAIx_MCLK_AF;
90006434:	230a      	movs	r3, #10
90006436:	64fb      	str	r3, [r7, #76]	; 0x4c
      HAL_GPIO_Init(AUDIO_OUT_SAIx_MCLK_GPIO_PORT, &gpio_init_structure);
90006438:	f107 033c 	add.w	r3, r7, #60	; 0x3c
9000643c:	4619      	mov	r1, r3
9000643e:	486e      	ldr	r0, [pc, #440]	; (900065f8 <SAI_MspInit+0x2c4>)
90006440:	f006 fbd2 	bl	9000cbe8 <HAL_GPIO_Init>
    }
  }

  if (hsai->Instance == AUDIO_OUT_SAIx)
90006444:	687b      	ldr	r3, [r7, #4]
90006446:	681b      	ldr	r3, [r3, #0]
90006448:	4a6e      	ldr	r2, [pc, #440]	; (90006604 <SAI_MspInit+0x2d0>)
9000644a:	4293      	cmp	r3, r2
9000644c:	d15c      	bne.n	90006508 <SAI_MspInit+0x1d4>
  {
    /* Enable the DMA clock */
    AUDIO_OUT_SAIx_DMAx_CLK_ENABLE();
9000644e:	4b69      	ldr	r3, [pc, #420]	; (900065f4 <SAI_MspInit+0x2c0>)
90006450:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
90006454:	4a67      	ldr	r2, [pc, #412]	; (900065f4 <SAI_MspInit+0x2c0>)
90006456:	f043 0302 	orr.w	r3, r3, #2
9000645a:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
9000645e:	4b65      	ldr	r3, [pc, #404]	; (900065f4 <SAI_MspInit+0x2c0>)
90006460:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
90006464:	f003 0302 	and.w	r3, r3, #2
90006468:	627b      	str	r3, [r7, #36]	; 0x24
9000646a:	6a7b      	ldr	r3, [r7, #36]	; 0x24

    /* Configure the hdma_saiTx handle parameters */
    if (Audio_Out_Ctx[0].BitsPerSample == AUDIO_RESOLUTION_16B)
9000646c:	4b66      	ldr	r3, [pc, #408]	; (90006608 <SAI_MspInit+0x2d4>)
9000646e:	68db      	ldr	r3, [r3, #12]
90006470:	2b10      	cmp	r3, #16
90006472:	d108      	bne.n	90006486 <SAI_MspInit+0x152>
    {
      hdma_sai_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
90006474:	4b65      	ldr	r3, [pc, #404]	; (9000660c <SAI_MspInit+0x2d8>)
90006476:	f44f 6200 	mov.w	r2, #2048	; 0x800
9000647a:	615a      	str	r2, [r3, #20]
      hdma_sai_tx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
9000647c:	4b63      	ldr	r3, [pc, #396]	; (9000660c <SAI_MspInit+0x2d8>)
9000647e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
90006482:	619a      	str	r2, [r3, #24]
90006484:	e007      	b.n	90006496 <SAI_MspInit+0x162>
    }
    else
    {
      hdma_sai_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
90006486:	4b61      	ldr	r3, [pc, #388]	; (9000660c <SAI_MspInit+0x2d8>)
90006488:	f44f 5280 	mov.w	r2, #4096	; 0x1000
9000648c:	615a      	str	r2, [r3, #20]
      hdma_sai_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
9000648e:	4b5f      	ldr	r3, [pc, #380]	; (9000660c <SAI_MspInit+0x2d8>)
90006490:	f44f 4280 	mov.w	r2, #16384	; 0x4000
90006494:	619a      	str	r2, [r3, #24]
    }

    hdma_sai_tx.Init.Request = AUDIO_OUT_SAIx_DMAx_REQUEST;
90006496:	4b5d      	ldr	r3, [pc, #372]	; (9000660c <SAI_MspInit+0x2d8>)
90006498:	2259      	movs	r2, #89	; 0x59
9000649a:	605a      	str	r2, [r3, #4]
    hdma_sai_tx.Init.PeriphInc = DMA_PINC_DISABLE;
9000649c:	4b5b      	ldr	r3, [pc, #364]	; (9000660c <SAI_MspInit+0x2d8>)
9000649e:	2200      	movs	r2, #0
900064a0:	60da      	str	r2, [r3, #12]
    hdma_sai_tx.Init.MemInc = DMA_MINC_ENABLE;
900064a2:	4b5a      	ldr	r3, [pc, #360]	; (9000660c <SAI_MspInit+0x2d8>)
900064a4:	f44f 6280 	mov.w	r2, #1024	; 0x400
900064a8:	611a      	str	r2, [r3, #16]
    hdma_sai_tx.Init.Mode = DMA_CIRCULAR;
900064aa:	4b58      	ldr	r3, [pc, #352]	; (9000660c <SAI_MspInit+0x2d8>)
900064ac:	f44f 7280 	mov.w	r2, #256	; 0x100
900064b0:	61da      	str	r2, [r3, #28]
    hdma_sai_tx.Init.Priority = DMA_PRIORITY_HIGH;
900064b2:	4b56      	ldr	r3, [pc, #344]	; (9000660c <SAI_MspInit+0x2d8>)
900064b4:	f44f 3200 	mov.w	r2, #131072	; 0x20000
900064b8:	621a      	str	r2, [r3, #32]
    hdma_sai_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
900064ba:	4b54      	ldr	r3, [pc, #336]	; (9000660c <SAI_MspInit+0x2d8>)
900064bc:	2204      	movs	r2, #4
900064be:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_sai_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
900064c0:	4b52      	ldr	r3, [pc, #328]	; (9000660c <SAI_MspInit+0x2d8>)
900064c2:	2203      	movs	r2, #3
900064c4:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_sai_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
900064c6:	4b51      	ldr	r3, [pc, #324]	; (9000660c <SAI_MspInit+0x2d8>)
900064c8:	2240      	movs	r2, #64	; 0x40
900064ca:	609a      	str	r2, [r3, #8]
    hdma_sai_tx.Instance = AUDIO_OUT_SAIx_DMAx_STREAM;
900064cc:	4b4f      	ldr	r3, [pc, #316]	; (9000660c <SAI_MspInit+0x2d8>)
900064ce:	4a50      	ldr	r2, [pc, #320]	; (90006610 <SAI_MspInit+0x2dc>)
900064d0:	601a      	str	r2, [r3, #0]
    hdma_sai_tx.Init.MemBurst = DMA_MBURST_SINGLE;
900064d2:	4b4e      	ldr	r3, [pc, #312]	; (9000660c <SAI_MspInit+0x2d8>)
900064d4:	2200      	movs	r2, #0
900064d6:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_sai_tx.Init.PeriphBurst = DMA_PBURST_SINGLE;
900064d8:	4b4c      	ldr	r3, [pc, #304]	; (9000660c <SAI_MspInit+0x2d8>)
900064da:	2200      	movs	r2, #0
900064dc:	631a      	str	r2, [r3, #48]	; 0x30

    /* Associate the DMA handle */
    __HAL_LINKDMA(hsai, hdmatx, hdma_sai_tx);
900064de:	687b      	ldr	r3, [r7, #4]
900064e0:	4a4a      	ldr	r2, [pc, #296]	; (9000660c <SAI_MspInit+0x2d8>)
900064e2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
900064e6:	4a49      	ldr	r2, [pc, #292]	; (9000660c <SAI_MspInit+0x2d8>)
900064e8:	687b      	ldr	r3, [r7, #4]
900064ea:	6393      	str	r3, [r2, #56]	; 0x38

    /* Deinitialize the Stream for new transfer */
    (void)HAL_DMA_DeInit(&hdma_sai_tx);
900064ec:	4847      	ldr	r0, [pc, #284]	; (9000660c <SAI_MspInit+0x2d8>)
900064ee:	f003 fccf 	bl	90009e90 <HAL_DMA_DeInit>

    /* Configure the DMA Stream */
    (void)HAL_DMA_Init(&hdma_sai_tx);
900064f2:	4846      	ldr	r0, [pc, #280]	; (9000660c <SAI_MspInit+0x2d8>)
900064f4:	f003 f970 	bl	900097d8 <HAL_DMA_Init>

    /* SAI DMA IRQ Channel configuration */
    HAL_NVIC_SetPriority(AUDIO_OUT_SAIx_DMAx_IRQ, BSP_AUDIO_OUT_IT_PRIORITY, 0);
900064f8:	2200      	movs	r2, #0
900064fa:	210e      	movs	r1, #14
900064fc:	2039      	movs	r0, #57	; 0x39
900064fe:	f003 f8ac 	bl	9000965a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(AUDIO_OUT_SAIx_DMAx_IRQ);
90006502:	2039      	movs	r0, #57	; 0x39
90006504:	f003 f8c3 	bl	9000968e <HAL_NVIC_EnableIRQ>
  }

  /* Audio In Msp initialization */
  if (hsai->Instance == AUDIO_IN_SAIx)
90006508:	687b      	ldr	r3, [r7, #4]
9000650a:	681b      	ldr	r3, [r3, #0]
9000650c:	4a41      	ldr	r2, [pc, #260]	; (90006614 <SAI_MspInit+0x2e0>)
9000650e:	4293      	cmp	r3, r2
90006510:	f040 80a7 	bne.w	90006662 <SAI_MspInit+0x32e>
  {
    /* Enable SAI clock */
    AUDIO_IN_SAIx_CLK_ENABLE();
90006514:	4b37      	ldr	r3, [pc, #220]	; (900065f4 <SAI_MspInit+0x2c0>)
90006516:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
9000651a:	4a36      	ldr	r2, [pc, #216]	; (900065f4 <SAI_MspInit+0x2c0>)
9000651c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
90006520:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
90006524:	4b33      	ldr	r3, [pc, #204]	; (900065f4 <SAI_MspInit+0x2c0>)
90006526:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
9000652a:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
9000652e:	623b      	str	r3, [r7, #32]
90006530:	6a3b      	ldr	r3, [r7, #32]

    /* Enable SD GPIO clock */
    AUDIO_IN_SAIx_SD_ENABLE();
90006532:	4b30      	ldr	r3, [pc, #192]	; (900065f4 <SAI_MspInit+0x2c0>)
90006534:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006538:	4a2e      	ldr	r2, [pc, #184]	; (900065f4 <SAI_MspInit+0x2c0>)
9000653a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
9000653e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90006542:	4b2c      	ldr	r3, [pc, #176]	; (900065f4 <SAI_MspInit+0x2c0>)
90006544:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006548:	f003 0340 	and.w	r3, r3, #64	; 0x40
9000654c:	61fb      	str	r3, [r7, #28]
9000654e:	69fb      	ldr	r3, [r7, #28]
    /* CODEC_SAI pin configuration: SD pin */
    gpio_init_structure.Pin = AUDIO_IN_SAIx_SD_PIN;
90006550:	f44f 6380 	mov.w	r3, #1024	; 0x400
90006554:	63fb      	str	r3, [r7, #60]	; 0x3c
    gpio_init_structure.Mode = GPIO_MODE_AF_PP;
90006556:	2302      	movs	r3, #2
90006558:	643b      	str	r3, [r7, #64]	; 0x40
    gpio_init_structure.Pull = GPIO_NOPULL;
9000655a:	2300      	movs	r3, #0
9000655c:	647b      	str	r3, [r7, #68]	; 0x44
    gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
9000655e:	2302      	movs	r3, #2
90006560:	64bb      	str	r3, [r7, #72]	; 0x48
    gpio_init_structure.Alternate = AUDIO_IN_SAIx_AF;
90006562:	230a      	movs	r3, #10
90006564:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(AUDIO_IN_SAIx_SD_GPIO_PORT, &gpio_init_structure);
90006566:	f107 033c 	add.w	r3, r7, #60	; 0x3c
9000656a:	4619      	mov	r1, r3
9000656c:	482a      	ldr	r0, [pc, #168]	; (90006618 <SAI_MspInit+0x2e4>)
9000656e:	f006 fb3b 	bl	9000cbe8 <HAL_GPIO_Init>

    /* Enable the DMA clock */
    AUDIO_IN_SAIx_DMAx_CLK_ENABLE();
90006572:	4b20      	ldr	r3, [pc, #128]	; (900065f4 <SAI_MspInit+0x2c0>)
90006574:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
90006578:	4a1e      	ldr	r2, [pc, #120]	; (900065f4 <SAI_MspInit+0x2c0>)
9000657a:	f043 0302 	orr.w	r3, r3, #2
9000657e:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
90006582:	4b1c      	ldr	r3, [pc, #112]	; (900065f4 <SAI_MspInit+0x2c0>)
90006584:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
90006588:	f003 0302 	and.w	r3, r3, #2
9000658c:	61bb      	str	r3, [r7, #24]
9000658e:	69bb      	ldr	r3, [r7, #24]

    /* Configure the hdma_sai_rx handle parameters */
    hdma_sai_rx.Instance = AUDIO_IN_SAIx_DMAx_STREAM;
90006590:	4b22      	ldr	r3, [pc, #136]	; (9000661c <SAI_MspInit+0x2e8>)
90006592:	4a23      	ldr	r2, [pc, #140]	; (90006620 <SAI_MspInit+0x2ec>)
90006594:	601a      	str	r2, [r3, #0]
    hdma_sai_rx.Init.Request = AUDIO_IN_SAIx_DMAx_REQUEST;
90006596:	4b21      	ldr	r3, [pc, #132]	; (9000661c <SAI_MspInit+0x2e8>)
90006598:	225a      	movs	r2, #90	; 0x5a
9000659a:	605a      	str	r2, [r3, #4]
    hdma_sai_rx.Init.Mode = DMA_CIRCULAR;
9000659c:	4b1f      	ldr	r3, [pc, #124]	; (9000661c <SAI_MspInit+0x2e8>)
9000659e:	f44f 7280 	mov.w	r2, #256	; 0x100
900065a2:	61da      	str	r2, [r3, #28]
    hdma_sai_rx.Init.Priority = DMA_PRIORITY_HIGH;
900065a4:	4b1d      	ldr	r3, [pc, #116]	; (9000661c <SAI_MspInit+0x2e8>)
900065a6:	f44f 3200 	mov.w	r2, #131072	; 0x20000
900065aa:	621a      	str	r2, [r3, #32]
    hdma_sai_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
900065ac:	4b1b      	ldr	r3, [pc, #108]	; (9000661c <SAI_MspInit+0x2e8>)
900065ae:	2200      	movs	r2, #0
900065b0:	609a      	str	r2, [r3, #8]
    hdma_sai_rx.Init.PeriphInc = DMA_PINC_DISABLE;
900065b2:	4b1a      	ldr	r3, [pc, #104]	; (9000661c <SAI_MspInit+0x2e8>)
900065b4:	2200      	movs	r2, #0
900065b6:	60da      	str	r2, [r3, #12]
    hdma_sai_rx.Init.MemInc = DMA_MINC_ENABLE;
900065b8:	4b18      	ldr	r3, [pc, #96]	; (9000661c <SAI_MspInit+0x2e8>)
900065ba:	f44f 6280 	mov.w	r2, #1024	; 0x400
900065be:	611a      	str	r2, [r3, #16]
    hdma_sai_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
900065c0:	4b16      	ldr	r3, [pc, #88]	; (9000661c <SAI_MspInit+0x2e8>)
900065c2:	2200      	movs	r2, #0
900065c4:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_sai_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
900065c6:	4b15      	ldr	r3, [pc, #84]	; (9000661c <SAI_MspInit+0x2e8>)
900065c8:	2203      	movs	r2, #3
900065ca:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_sai_rx.Init.MemBurst = DMA_MBURST_SINGLE;
900065cc:	4b13      	ldr	r3, [pc, #76]	; (9000661c <SAI_MspInit+0x2e8>)
900065ce:	2200      	movs	r2, #0
900065d0:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_sai_rx.Init.PeriphBurst = DMA_MBURST_SINGLE;
900065d2:	4b12      	ldr	r3, [pc, #72]	; (9000661c <SAI_MspInit+0x2e8>)
900065d4:	2200      	movs	r2, #0
900065d6:	631a      	str	r2, [r3, #48]	; 0x30

    if (Audio_In_Ctx[0].BitsPerSample == AUDIO_RESOLUTION_16B)
900065d8:	4b12      	ldr	r3, [pc, #72]	; (90006624 <SAI_MspInit+0x2f0>)
900065da:	68db      	ldr	r3, [r3, #12]
900065dc:	2b10      	cmp	r3, #16
900065de:	d123      	bne.n	90006628 <SAI_MspInit+0x2f4>
    {
      hdma_sai_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
900065e0:	4b0e      	ldr	r3, [pc, #56]	; (9000661c <SAI_MspInit+0x2e8>)
900065e2:	f44f 6200 	mov.w	r2, #2048	; 0x800
900065e6:	615a      	str	r2, [r3, #20]
      hdma_sai_rx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
900065e8:	4b0c      	ldr	r3, [pc, #48]	; (9000661c <SAI_MspInit+0x2e8>)
900065ea:	f44f 5200 	mov.w	r2, #8192	; 0x2000
900065ee:	619a      	str	r2, [r3, #24]
900065f0:	e022      	b.n	90006638 <SAI_MspInit+0x304>
900065f2:	bf00      	nop
900065f4:	58024400 	.word	0x58024400
900065f8:	58022000 	.word	0x58022000
900065fc:	58005404 	.word	0x58005404
90006600:	24001238 	.word	0x24001238
90006604:	40015c04 	.word	0x40015c04
90006608:	240029ac 	.word	0x240029ac
9000660c:	240012f8 	.word	0x240012f8
90006610:	40020428 	.word	0x40020428
90006614:	40015c24 	.word	0x40015c24
90006618:	58021800 	.word	0x58021800
9000661c:	24001370 	.word	0x24001370
90006620:	40020470 	.word	0x40020470
90006624:	240029d0 	.word	0x240029d0
    }
    else
    {
      hdma_sai_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
90006628:	4b5f      	ldr	r3, [pc, #380]	; (900067a8 <SAI_MspInit+0x474>)
9000662a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
9000662e:	615a      	str	r2, [r3, #20]
      hdma_sai_rx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
90006630:	4b5d      	ldr	r3, [pc, #372]	; (900067a8 <SAI_MspInit+0x474>)
90006632:	f44f 4280 	mov.w	r2, #16384	; 0x4000
90006636:	619a      	str	r2, [r3, #24]
    }

    /* Associate the DMA handle */
    __HAL_LINKDMA(hsai, hdmarx, hdma_sai_rx);
90006638:	687b      	ldr	r3, [r7, #4]
9000663a:	4a5b      	ldr	r2, [pc, #364]	; (900067a8 <SAI_MspInit+0x474>)
9000663c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
90006640:	4a59      	ldr	r2, [pc, #356]	; (900067a8 <SAI_MspInit+0x474>)
90006642:	687b      	ldr	r3, [r7, #4]
90006644:	6393      	str	r3, [r2, #56]	; 0x38

    /* Deinitialize the Stream for new transfer */
    (void)HAL_DMA_DeInit(&hdma_sai_rx);
90006646:	4858      	ldr	r0, [pc, #352]	; (900067a8 <SAI_MspInit+0x474>)
90006648:	f003 fc22 	bl	90009e90 <HAL_DMA_DeInit>

    /* Configure the DMA Stream */
    (void)HAL_DMA_Init(&hdma_sai_rx);
9000664c:	4856      	ldr	r0, [pc, #344]	; (900067a8 <SAI_MspInit+0x474>)
9000664e:	f003 f8c3 	bl	900097d8 <HAL_DMA_Init>

    /* SAI DMA IRQ Channel configuration */
    HAL_NVIC_SetPriority(AUDIO_IN_SAIx_DMAx_IRQ, BSP_AUDIO_IN_IT_PRIORITY, 0);
90006652:	2200      	movs	r2, #0
90006654:	210f      	movs	r1, #15
90006656:	203c      	movs	r0, #60	; 0x3c
90006658:	f002 ffff 	bl	9000965a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(AUDIO_IN_SAIx_DMAx_IRQ);
9000665c:	203c      	movs	r0, #60	; 0x3c
9000665e:	f003 f816 	bl	9000968e <HAL_NVIC_EnableIRQ>
  }

  if (hsai->Instance == AUDIO_IN_SAI_PDMx)
90006662:	687b      	ldr	r3, [r7, #4]
90006664:	681b      	ldr	r3, [r3, #0]
90006666:	4a51      	ldr	r2, [pc, #324]	; (900067ac <SAI_MspInit+0x478>)
90006668:	4293      	cmp	r3, r2
9000666a:	f040 8099 	bne.w	900067a0 <SAI_MspInit+0x46c>
  {
    /* Enable SAI clock */
    AUDIO_IN_SAI_PDMx_CLK_ENABLE();
9000666e:	4b50      	ldr	r3, [pc, #320]	; (900067b0 <SAI_MspInit+0x47c>)
90006670:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
90006674:	4a4e      	ldr	r2, [pc, #312]	; (900067b0 <SAI_MspInit+0x47c>)
90006676:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
9000667a:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
9000667e:	4b4c      	ldr	r3, [pc, #304]	; (900067b0 <SAI_MspInit+0x47c>)
90006680:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
90006684:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
90006688:	617b      	str	r3, [r7, #20]
9000668a:	697b      	ldr	r3, [r7, #20]

    AUDIO_IN_SAI_PDMx_CLK_IN_ENABLE();
9000668c:	4b48      	ldr	r3, [pc, #288]	; (900067b0 <SAI_MspInit+0x47c>)
9000668e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006692:	4a47      	ldr	r2, [pc, #284]	; (900067b0 <SAI_MspInit+0x47c>)
90006694:	f043 0310 	orr.w	r3, r3, #16
90006698:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
9000669c:	4b44      	ldr	r3, [pc, #272]	; (900067b0 <SAI_MspInit+0x47c>)
9000669e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900066a2:	f003 0310 	and.w	r3, r3, #16
900066a6:	613b      	str	r3, [r7, #16]
900066a8:	693b      	ldr	r3, [r7, #16]
    AUDIO_IN_SAI_PDMx_DATA_IN_ENABLE();
900066aa:	4b41      	ldr	r3, [pc, #260]	; (900067b0 <SAI_MspInit+0x47c>)
900066ac:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900066b0:	4a3f      	ldr	r2, [pc, #252]	; (900067b0 <SAI_MspInit+0x47c>)
900066b2:	f043 0310 	orr.w	r3, r3, #16
900066b6:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
900066ba:	4b3d      	ldr	r3, [pc, #244]	; (900067b0 <SAI_MspInit+0x47c>)
900066bc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900066c0:	f003 0310 	and.w	r3, r3, #16
900066c4:	60fb      	str	r3, [r7, #12]
900066c6:	68fb      	ldr	r3, [r7, #12]

    gpio_init_structure.Pin = AUDIO_IN_SAI_PDMx_CLK_IN_PIN;
900066c8:	2320      	movs	r3, #32
900066ca:	63fb      	str	r3, [r7, #60]	; 0x3c
    gpio_init_structure.Mode = GPIO_MODE_AF_PP;
900066cc:	2302      	movs	r3, #2
900066ce:	643b      	str	r3, [r7, #64]	; 0x40
    gpio_init_structure.Pull = GPIO_NOPULL;
900066d0:	2300      	movs	r3, #0
900066d2:	647b      	str	r3, [r7, #68]	; 0x44
    gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
900066d4:	2302      	movs	r3, #2
900066d6:	64bb      	str	r3, [r7, #72]	; 0x48
    gpio_init_structure.Alternate = AUDIO_IN_SAI_PDMx_DATA_CLK_AF;
900066d8:	230a      	movs	r3, #10
900066da:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(AUDIO_IN_SAI_PDMx_CLK_IN_PORT, &gpio_init_structure);
900066dc:	f107 033c 	add.w	r3, r7, #60	; 0x3c
900066e0:	4619      	mov	r1, r3
900066e2:	4834      	ldr	r0, [pc, #208]	; (900067b4 <SAI_MspInit+0x480>)
900066e4:	f006 fa80 	bl	9000cbe8 <HAL_GPIO_Init>

    gpio_init_structure.Pull = GPIO_PULLUP;
900066e8:	2301      	movs	r3, #1
900066ea:	647b      	str	r3, [r7, #68]	; 0x44
    gpio_init_structure.Speed = GPIO_SPEED_FREQ_MEDIUM;
900066ec:	2301      	movs	r3, #1
900066ee:	64bb      	str	r3, [r7, #72]	; 0x48
    gpio_init_structure.Pin = AUDIO_IN_SAI_PDMx_DATA_IN_PIN;
900066f0:	2310      	movs	r3, #16
900066f2:	63fb      	str	r3, [r7, #60]	; 0x3c
    HAL_GPIO_Init(AUDIO_IN_SAI_PDMx_DATA_IN_PORT, &gpio_init_structure);
900066f4:	f107 033c 	add.w	r3, r7, #60	; 0x3c
900066f8:	4619      	mov	r1, r3
900066fa:	482e      	ldr	r0, [pc, #184]	; (900067b4 <SAI_MspInit+0x480>)
900066fc:	f006 fa74 	bl	9000cbe8 <HAL_GPIO_Init>



    /* Enable the DMA clock */
    AUDIO_IN_SAI_PDMx_DMAx_CLK_ENABLE();
90006700:	4b2b      	ldr	r3, [pc, #172]	; (900067b0 <SAI_MspInit+0x47c>)
90006702:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006706:	4a2a      	ldr	r2, [pc, #168]	; (900067b0 <SAI_MspInit+0x47c>)
90006708:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
9000670c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90006710:	4b27      	ldr	r3, [pc, #156]	; (900067b0 <SAI_MspInit+0x47c>)
90006712:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006716:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
9000671a:	60bb      	str	r3, [r7, #8]
9000671c:	68bb      	ldr	r3, [r7, #8]

    /* Configure the hdma_sai_rx handle parameters */
    hdma_sai_rx.Init.Request             = AUDIO_IN_SAI_PDMx_DMAx_REQUEST;
9000671e:	4b22      	ldr	r3, [pc, #136]	; (900067a8 <SAI_MspInit+0x474>)
90006720:	220f      	movs	r2, #15
90006722:	605a      	str	r2, [r3, #4]
    hdma_sai_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
90006724:	4b20      	ldr	r3, [pc, #128]	; (900067a8 <SAI_MspInit+0x474>)
90006726:	2200      	movs	r2, #0
90006728:	609a      	str	r2, [r3, #8]
    hdma_sai_rx.Init.PeriphInc           = DMA_PINC_DISABLE;
9000672a:	4b1f      	ldr	r3, [pc, #124]	; (900067a8 <SAI_MspInit+0x474>)
9000672c:	2200      	movs	r2, #0
9000672e:	60da      	str	r2, [r3, #12]
    hdma_sai_rx.Init.MemInc              = DMA_MINC_ENABLE;
90006730:	4b1d      	ldr	r3, [pc, #116]	; (900067a8 <SAI_MspInit+0x474>)
90006732:	f44f 6280 	mov.w	r2, #1024	; 0x400
90006736:	611a      	str	r2, [r3, #16]
    hdma_sai_rx.Init.PeriphDataAlignment = AUDIO_IN_SAI_PDMx_DMAx_PERIPH_DATA_SIZE;
90006738:	4b1b      	ldr	r3, [pc, #108]	; (900067a8 <SAI_MspInit+0x474>)
9000673a:	f44f 6200 	mov.w	r2, #2048	; 0x800
9000673e:	615a      	str	r2, [r3, #20]
    hdma_sai_rx.Init.MemDataAlignment    = AUDIO_IN_SAI_PDMx_DMAx_MEM_DATA_SIZE;
90006740:	4b19      	ldr	r3, [pc, #100]	; (900067a8 <SAI_MspInit+0x474>)
90006742:	f44f 5200 	mov.w	r2, #8192	; 0x2000
90006746:	619a      	str	r2, [r3, #24]
    hdma_sai_rx.Init.Mode                = DMA_CIRCULAR;
90006748:	4b17      	ldr	r3, [pc, #92]	; (900067a8 <SAI_MspInit+0x474>)
9000674a:	f44f 7280 	mov.w	r2, #256	; 0x100
9000674e:	61da      	str	r2, [r3, #28]
    hdma_sai_rx.Init.Priority            = DMA_PRIORITY_HIGH;
90006750:	4b15      	ldr	r3, [pc, #84]	; (900067a8 <SAI_MspInit+0x474>)
90006752:	f44f 3200 	mov.w	r2, #131072	; 0x20000
90006756:	621a      	str	r2, [r3, #32]
    hdma_sai_rx.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
90006758:	4b13      	ldr	r3, [pc, #76]	; (900067a8 <SAI_MspInit+0x474>)
9000675a:	2200      	movs	r2, #0
9000675c:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_sai_rx.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
9000675e:	4b12      	ldr	r3, [pc, #72]	; (900067a8 <SAI_MspInit+0x474>)
90006760:	2203      	movs	r2, #3
90006762:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_sai_rx.Init.MemBurst            = DMA_MBURST_SINGLE;
90006764:	4b10      	ldr	r3, [pc, #64]	; (900067a8 <SAI_MspInit+0x474>)
90006766:	2200      	movs	r2, #0
90006768:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_sai_rx.Init.PeriphBurst         = DMA_MBURST_SINGLE;
9000676a:	4b0f      	ldr	r3, [pc, #60]	; (900067a8 <SAI_MspInit+0x474>)
9000676c:	2200      	movs	r2, #0
9000676e:	631a      	str	r2, [r3, #48]	; 0x30

    hdma_sai_rx.Instance = AUDIO_IN_SAI_PDMx_DMAx_STREAM;
90006770:	4b0d      	ldr	r3, [pc, #52]	; (900067a8 <SAI_MspInit+0x474>)
90006772:	4a11      	ldr	r2, [pc, #68]	; (900067b8 <SAI_MspInit+0x484>)
90006774:	601a      	str	r2, [r3, #0]

    /* Associate the DMA handle */
    __HAL_LINKDMA(hsai, hdmarx, hdma_sai_rx);
90006776:	687b      	ldr	r3, [r7, #4]
90006778:	4a0b      	ldr	r2, [pc, #44]	; (900067a8 <SAI_MspInit+0x474>)
9000677a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
9000677e:	4a0a      	ldr	r2, [pc, #40]	; (900067a8 <SAI_MspInit+0x474>)
90006780:	687b      	ldr	r3, [r7, #4]
90006782:	6393      	str	r3, [r2, #56]	; 0x38

    /* Deinitialize the Stream for new transfer */
    HAL_DMA_DeInit(&hdma_sai_rx);
90006784:	4808      	ldr	r0, [pc, #32]	; (900067a8 <SAI_MspInit+0x474>)
90006786:	f003 fb83 	bl	90009e90 <HAL_DMA_DeInit>

    /* Configure the DMA Stream */
    HAL_DMA_Init(&hdma_sai_rx);
9000678a:	4807      	ldr	r0, [pc, #28]	; (900067a8 <SAI_MspInit+0x474>)
9000678c:	f003 f824 	bl	900097d8 <HAL_DMA_Init>

    /* SAI DMA IRQ Channel configuration */
    HAL_NVIC_SetPriority(AUDIO_IN_SAI_PDMx_DMAx_IRQ, BSP_AUDIO_IN_IT_PRIORITY, 0);
90006790:	2200      	movs	r2, #0
90006792:	210f      	movs	r1, #15
90006794:	2082      	movs	r0, #130	; 0x82
90006796:	f002 ff60 	bl	9000965a <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(AUDIO_IN_SAI_PDMx_DMAx_IRQ);
9000679a:	2082      	movs	r0, #130	; 0x82
9000679c:	f002 ff77 	bl	9000968e <HAL_NVIC_EnableIRQ>
  }
}
900067a0:	bf00      	nop
900067a2:	3750      	adds	r7, #80	; 0x50
900067a4:	46bd      	mov	sp, r7
900067a6:	bd80      	pop	{r7, pc}
900067a8:	24001370 	.word	0x24001370
900067ac:	58005404 	.word	0x58005404
900067b0:	58024400 	.word	0x58024400
900067b4:	58021000 	.word	0x58021000
900067b8:	5802541c 	.word	0x5802541c

900067bc <SAI_MspDeInit>:
static void SAI_MspDeInit(SAI_HandleTypeDef *hsai){
900067bc:	b580      	push	{r7, lr}
900067be:	b088      	sub	sp, #32
900067c0:	af00      	add	r7, sp, #0
900067c2:	6078      	str	r0, [r7, #4]

    GPIO_InitTypeDef  gpio_init_structure;

    /* SAI DMA IRQ Channel deactivation */
    HAL_NVIC_DisableIRQ(AUDIO_OUT_SAIx_DMAx_IRQ);
900067c4:	2039      	movs	r0, #57	; 0x39
900067c6:	f002 ff70 	bl	900096aa <HAL_NVIC_DisableIRQ>

    if(hsai->Instance == AUDIO_OUT_SAIx)
900067ca:	687b      	ldr	r3, [r7, #4]
900067cc:	681b      	ldr	r3, [r3, #0]
900067ce:	4a15      	ldr	r2, [pc, #84]	; (90006824 <SAI_MspDeInit+0x68>)
900067d0:	4293      	cmp	r3, r2
900067d2:	d105      	bne.n	900067e0 <SAI_MspDeInit+0x24>
    {
      /* Deinitialize the DMA stream */
      HAL_DMA_DeInit(hsai->hdmatx);
900067d4:	687b      	ldr	r3, [r7, #4]
900067d6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
900067da:	4618      	mov	r0, r3
900067dc:	f003 fb58 	bl	90009e90 <HAL_DMA_DeInit>
    }

    /* Disable SAI peripheral */
    __HAL_SAI_DISABLE(hsai);
900067e0:	687b      	ldr	r3, [r7, #4]
900067e2:	681b      	ldr	r3, [r3, #0]
900067e4:	681a      	ldr	r2, [r3, #0]
900067e6:	687b      	ldr	r3, [r7, #4]
900067e8:	681b      	ldr	r3, [r3, #0]
900067ea:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
900067ee:	601a      	str	r2, [r3, #0]

    /* Deactivates CODEC_SAI pins FS, SCK, MCK and SD by putting them in input mode */
    gpio_init_structure.Pin = AUDIO_OUT_SAIx_FS_PIN | AUDIO_OUT_SAIx_SCK_PIN | AUDIO_OUT_SAIx_SD_PIN;
900067f0:	23e0      	movs	r3, #224	; 0xe0
900067f2:	60fb      	str	r3, [r7, #12]
    HAL_GPIO_DeInit(GPIOI, gpio_init_structure.Pin);
900067f4:	68fb      	ldr	r3, [r7, #12]
900067f6:	4619      	mov	r1, r3
900067f8:	480b      	ldr	r0, [pc, #44]	; (90006828 <SAI_MspDeInit+0x6c>)
900067fa:	f006 fba5 	bl	9000cf48 <HAL_GPIO_DeInit>

    gpio_init_structure.Pin = AUDIO_OUT_SAIx_MCLK_PIN;
900067fe:	2310      	movs	r3, #16
90006800:	60fb      	str	r3, [r7, #12]
    HAL_GPIO_DeInit(AUDIO_OUT_SAIx_MCLK_GPIO_PORT, gpio_init_structure.Pin);
90006802:	68fb      	ldr	r3, [r7, #12]
90006804:	4619      	mov	r1, r3
90006806:	4808      	ldr	r0, [pc, #32]	; (90006828 <SAI_MspDeInit+0x6c>)
90006808:	f006 fb9e 	bl	9000cf48 <HAL_GPIO_DeInit>

    /* Disable SAI clock */
    AUDIO_OUT_SAIx_CLK_DISABLE();
9000680c:	4b07      	ldr	r3, [pc, #28]	; (9000682c <SAI_MspDeInit+0x70>)
9000680e:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
90006812:	4a06      	ldr	r2, [pc, #24]	; (9000682c <SAI_MspDeInit+0x70>)
90006814:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
90006818:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0

    /* GPIO pins clock and DMA clock can be shut down in the applic
       by surcharging this __weak function */
}
9000681c:	bf00      	nop
9000681e:	3720      	adds	r7, #32
90006820:	46bd      	mov	sp, r7
90006822:	bd80      	pop	{r7, pc}
90006824:	40015c04 	.word	0x40015c04
90006828:	58022000 	.word	0x58022000
9000682c:	58024400 	.word	0x58024400

90006830 <BSP_I2C4_Init>:
/**
  * @brief  Initializes I2C HAL.
  * @retval BSP status
  */
int32_t BSP_I2C4_Init(void)
{
90006830:	b580      	push	{r7, lr}
90006832:	b082      	sub	sp, #8
90006834:	af00      	add	r7, sp, #0
  int32_t ret = BSP_ERROR_NONE;
90006836:	2300      	movs	r3, #0
90006838:	607b      	str	r3, [r7, #4]

  hbus_i2c4.Instance = BUS_I2C4;
9000683a:	4b16      	ldr	r3, [pc, #88]	; (90006894 <BSP_I2C4_Init+0x64>)
9000683c:	4a16      	ldr	r2, [pc, #88]	; (90006898 <BSP_I2C4_Init+0x68>)
9000683e:	601a      	str	r2, [r3, #0]

  if (I2c4InitCounter == 0U)
90006840:	4b16      	ldr	r3, [pc, #88]	; (9000689c <BSP_I2C4_Init+0x6c>)
90006842:	681b      	ldr	r3, [r3, #0]
90006844:	2b00      	cmp	r3, #0
90006846:	d11f      	bne.n	90006888 <BSP_I2C4_Init+0x58>
  {
    I2c4InitCounter++;
90006848:	4b14      	ldr	r3, [pc, #80]	; (9000689c <BSP_I2C4_Init+0x6c>)
9000684a:	681b      	ldr	r3, [r3, #0]
9000684c:	3301      	adds	r3, #1
9000684e:	4a13      	ldr	r2, [pc, #76]	; (9000689c <BSP_I2C4_Init+0x6c>)
90006850:	6013      	str	r3, [r2, #0]

    if (HAL_I2C_GetState(&hbus_i2c4) == HAL_I2C_STATE_RESET)
90006852:	4810      	ldr	r0, [pc, #64]	; (90006894 <BSP_I2C4_Init+0x64>)
90006854:	f006 ffb6 	bl	9000d7c4 <HAL_I2C_GetState>
90006858:	4603      	mov	r3, r0
9000685a:	2b00      	cmp	r3, #0
9000685c:	d114      	bne.n	90006888 <BSP_I2C4_Init+0x58>
        BspI2cSemaphore = osSemaphoreCreate(osSemaphore(BSP_I2C_SEM), 1);
      }
#endif
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 0)
      /* Init the I2C4 Msp */
      I2C4_MspInit(&hbus_i2c4);
9000685e:	480d      	ldr	r0, [pc, #52]	; (90006894 <BSP_I2C4_Init+0x64>)
90006860:	f000 fbbc 	bl	90006fdc <I2C4_MspInit>
        }
      }
      if (ret == BSP_ERROR_NONE)
      {
#endif
        if (MX_I2C4_Init(&hbus_i2c4, I2C_GetTiming(HAL_RCC_GetPCLK2Freq(), BUS_I2C4_FREQUENCY)) != HAL_OK)
90006864:	f00a fce6 	bl	90011234 <HAL_RCC_GetPCLK2Freq>
90006868:	4603      	mov	r3, r0
9000686a:	490d      	ldr	r1, [pc, #52]	; (900068a0 <BSP_I2C4_Init+0x70>)
9000686c:	4618      	mov	r0, r3
9000686e:	f000 f93f 	bl	90006af0 <I2C_GetTiming>
90006872:	4603      	mov	r3, r0
90006874:	4619      	mov	r1, r3
90006876:	4807      	ldr	r0, [pc, #28]	; (90006894 <BSP_I2C4_Init+0x64>)
90006878:	f000 f838 	bl	900068ec <MX_I2C4_Init>
9000687c:	4603      	mov	r3, r0
9000687e:	2b00      	cmp	r3, #0
90006880:	d002      	beq.n	90006888 <BSP_I2C4_Init+0x58>
        {
          ret = BSP_ERROR_BUS_FAILURE;
90006882:	f06f 0307 	mvn.w	r3, #7
90006886:	607b      	str	r3, [r7, #4]
      }
#endif
    }
  }

  return ret;
90006888:	687b      	ldr	r3, [r7, #4]
}
9000688a:	4618      	mov	r0, r3
9000688c:	3708      	adds	r7, #8
9000688e:	46bd      	mov	sp, r7
90006890:	bd80      	pop	{r7, pc}
90006892:	bf00      	nop
90006894:	24002a30 	.word	0x24002a30
90006898:	58001c00 	.word	0x58001c00
9000689c:	240013e8 	.word	0x240013e8
900068a0:	000186a0 	.word	0x000186a0

900068a4 <BSP_I2C4_DeInit>:
/**
  * @brief  DeInitializes I2C HAL.
  * @retval BSP status
  */
int32_t BSP_I2C4_DeInit(void)
{
900068a4:	b580      	push	{r7, lr}
900068a6:	b082      	sub	sp, #8
900068a8:	af00      	add	r7, sp, #0
  int32_t ret  = BSP_ERROR_NONE;
900068aa:	2300      	movs	r3, #0
900068ac:	607b      	str	r3, [r7, #4]

  I2c4InitCounter--;
900068ae:	4b0d      	ldr	r3, [pc, #52]	; (900068e4 <BSP_I2C4_DeInit+0x40>)
900068b0:	681b      	ldr	r3, [r3, #0]
900068b2:	3b01      	subs	r3, #1
900068b4:	4a0b      	ldr	r2, [pc, #44]	; (900068e4 <BSP_I2C4_DeInit+0x40>)
900068b6:	6013      	str	r3, [r2, #0]

  if (I2c4InitCounter == 0U)
900068b8:	4b0a      	ldr	r3, [pc, #40]	; (900068e4 <BSP_I2C4_DeInit+0x40>)
900068ba:	681b      	ldr	r3, [r3, #0]
900068bc:	2b00      	cmp	r3, #0
900068be:	d10b      	bne.n	900068d8 <BSP_I2C4_DeInit+0x34>
  {
#if (USE_HAL_I2C_REGISTER_CALLBACKS == 0)
    I2C4_MspDeInit(&hbus_i2c4);
900068c0:	4809      	ldr	r0, [pc, #36]	; (900068e8 <BSP_I2C4_DeInit+0x44>)
900068c2:	f000 fbf7 	bl	900070b4 <I2C4_MspDeInit>
#endif /* (USE_HAL_I2C_REGISTER_CALLBACKS == 0) */

    /* Init the I2C */
    if (HAL_I2C_DeInit(&hbus_i2c4) != HAL_OK)
900068c6:	4808      	ldr	r0, [pc, #32]	; (900068e8 <BSP_I2C4_DeInit+0x44>)
900068c8:	f006 fd0a 	bl	9000d2e0 <HAL_I2C_DeInit>
900068cc:	4603      	mov	r3, r0
900068ce:	2b00      	cmp	r3, #0
900068d0:	d002      	beq.n	900068d8 <BSP_I2C4_DeInit+0x34>
    {
      ret = BSP_ERROR_BUS_FAILURE;
900068d2:	f06f 0307 	mvn.w	r3, #7
900068d6:	607b      	str	r3, [r7, #4]
    }
  }

  return ret;
900068d8:	687b      	ldr	r3, [r7, #4]
}
900068da:	4618      	mov	r0, r3
900068dc:	3708      	adds	r7, #8
900068de:	46bd      	mov	sp, r7
900068e0:	bd80      	pop	{r7, pc}
900068e2:	bf00      	nop
900068e4:	240013e8 	.word	0x240013e8
900068e8:	24002a30 	.word	0x24002a30

900068ec <MX_I2C4_Init>:
  * @param  hI2c I2C handle
  * @param  timing I2C timing
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_I2C4_Init(I2C_HandleTypeDef *hI2c, uint32_t timing)
{
900068ec:	b580      	push	{r7, lr}
900068ee:	b084      	sub	sp, #16
900068f0:	af00      	add	r7, sp, #0
900068f2:	6078      	str	r0, [r7, #4]
900068f4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
900068f6:	2300      	movs	r3, #0
900068f8:	73fb      	strb	r3, [r7, #15]

  hI2c->Init.Timing           = timing;
900068fa:	687b      	ldr	r3, [r7, #4]
900068fc:	683a      	ldr	r2, [r7, #0]
900068fe:	605a      	str	r2, [r3, #4]
  hI2c->Init.OwnAddress1      = 0;
90006900:	687b      	ldr	r3, [r7, #4]
90006902:	2200      	movs	r2, #0
90006904:	609a      	str	r2, [r3, #8]
  hI2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
90006906:	687b      	ldr	r3, [r7, #4]
90006908:	2201      	movs	r2, #1
9000690a:	60da      	str	r2, [r3, #12]
  hI2c->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
9000690c:	687b      	ldr	r3, [r7, #4]
9000690e:	2200      	movs	r2, #0
90006910:	611a      	str	r2, [r3, #16]
  hI2c->Init.OwnAddress2      = 0;
90006912:	687b      	ldr	r3, [r7, #4]
90006914:	2200      	movs	r2, #0
90006916:	615a      	str	r2, [r3, #20]
  hI2c->Init.OwnAddress2Masks = I2C_OA2_NOMASK;
90006918:	687b      	ldr	r3, [r7, #4]
9000691a:	2200      	movs	r2, #0
9000691c:	619a      	str	r2, [r3, #24]
  hI2c->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
9000691e:	687b      	ldr	r3, [r7, #4]
90006920:	2200      	movs	r2, #0
90006922:	61da      	str	r2, [r3, #28]
  hI2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
90006924:	687b      	ldr	r3, [r7, #4]
90006926:	2200      	movs	r2, #0
90006928:	621a      	str	r2, [r3, #32]

  if (HAL_I2C_Init(hI2c) != HAL_OK)
9000692a:	6878      	ldr	r0, [r7, #4]
9000692c:	f006 fc48 	bl	9000d1c0 <HAL_I2C_Init>
90006930:	4603      	mov	r3, r0
90006932:	2b00      	cmp	r3, #0
90006934:	d002      	beq.n	9000693c <MX_I2C4_Init+0x50>
  {
    status = HAL_ERROR;
90006936:	2301      	movs	r3, #1
90006938:	73fb      	strb	r3, [r7, #15]
9000693a:	e014      	b.n	90006966 <MX_I2C4_Init+0x7a>
  }
  else
  {
    uint32_t analog_filter;

    analog_filter = I2C_ANALOGFILTER_ENABLE;
9000693c:	2300      	movs	r3, #0
9000693e:	60bb      	str	r3, [r7, #8]
    if (HAL_I2CEx_ConfigAnalogFilter(hI2c, analog_filter) != HAL_OK)
90006940:	68b9      	ldr	r1, [r7, #8]
90006942:	6878      	ldr	r0, [r7, #4]
90006944:	f007 f9fe 	bl	9000dd44 <HAL_I2CEx_ConfigAnalogFilter>
90006948:	4603      	mov	r3, r0
9000694a:	2b00      	cmp	r3, #0
9000694c:	d002      	beq.n	90006954 <MX_I2C4_Init+0x68>
    {
      status = HAL_ERROR;
9000694e:	2301      	movs	r3, #1
90006950:	73fb      	strb	r3, [r7, #15]
90006952:	e008      	b.n	90006966 <MX_I2C4_Init+0x7a>
    }
    else
    {
      if (HAL_I2CEx_ConfigDigitalFilter(hI2c, I2C_DIGITAL_FILTER_COEF) != HAL_OK)
90006954:	2100      	movs	r1, #0
90006956:	6878      	ldr	r0, [r7, #4]
90006958:	f007 fa3f 	bl	9000ddda <HAL_I2CEx_ConfigDigitalFilter>
9000695c:	4603      	mov	r3, r0
9000695e:	2b00      	cmp	r3, #0
90006960:	d001      	beq.n	90006966 <MX_I2C4_Init+0x7a>
      {
        status = HAL_ERROR;
90006962:	2301      	movs	r3, #1
90006964:	73fb      	strb	r3, [r7, #15]
      }
    }
  }

  return status;
90006966:	7bfb      	ldrb	r3, [r7, #15]
}
90006968:	4618      	mov	r0, r3
9000696a:	3710      	adds	r7, #16
9000696c:	46bd      	mov	sp, r7
9000696e:	bd80      	pop	{r7, pc}

90006970 <BSP_I2C4_WriteReg>:
  * @param  pData  The target register value to be written
  * @param  Length buffer size to be written
  * @retval BSP status
  */
int32_t BSP_I2C4_WriteReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
90006970:	b580      	push	{r7, lr}
90006972:	b088      	sub	sp, #32
90006974:	af02      	add	r7, sp, #8
90006976:	60ba      	str	r2, [r7, #8]
90006978:	461a      	mov	r2, r3
9000697a:	4603      	mov	r3, r0
9000697c:	81fb      	strh	r3, [r7, #14]
9000697e:	460b      	mov	r3, r1
90006980:	81bb      	strh	r3, [r7, #12]
90006982:	4613      	mov	r3, r2
90006984:	80fb      	strh	r3, [r7, #6]
  int32_t ret;
#if defined(BSP_USE_CMSIS_OS)
  /* Get semaphore to prevent multiple I2C access */
  osSemaphoreWait(BspI2cSemaphore, osWaitForever);
#endif
  if(I2C4_WriteReg(DevAddr, Reg, I2C_MEMADD_SIZE_8BIT, pData, Length) == 0)
90006986:	89b9      	ldrh	r1, [r7, #12]
90006988:	89f8      	ldrh	r0, [r7, #14]
9000698a:	88fb      	ldrh	r3, [r7, #6]
9000698c:	9300      	str	r3, [sp, #0]
9000698e:	68bb      	ldr	r3, [r7, #8]
90006990:	2201      	movs	r2, #1
90006992:	f000 fbb3 	bl	900070fc <I2C4_WriteReg>
90006996:	4603      	mov	r3, r0
90006998:	2b00      	cmp	r3, #0
9000699a:	d102      	bne.n	900069a2 <BSP_I2C4_WriteReg+0x32>
  {
    ret = BSP_ERROR_NONE;
9000699c:	2300      	movs	r3, #0
9000699e:	617b      	str	r3, [r7, #20]
900069a0:	e00c      	b.n	900069bc <BSP_I2C4_WriteReg+0x4c>
  }
  else
  {
    if( HAL_I2C_GetError(&hbus_i2c4) == HAL_I2C_ERROR_AF)
900069a2:	4809      	ldr	r0, [pc, #36]	; (900069c8 <BSP_I2C4_WriteReg+0x58>)
900069a4:	f006 ff1c 	bl	9000d7e0 <HAL_I2C_GetError>
900069a8:	4603      	mov	r3, r0
900069aa:	2b04      	cmp	r3, #4
900069ac:	d103      	bne.n	900069b6 <BSP_I2C4_WriteReg+0x46>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
900069ae:	f06f 0365 	mvn.w	r3, #101	; 0x65
900069b2:	617b      	str	r3, [r7, #20]
900069b4:	e002      	b.n	900069bc <BSP_I2C4_WriteReg+0x4c>
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
900069b6:	f06f 0303 	mvn.w	r3, #3
900069ba:	617b      	str	r3, [r7, #20]
  }
#if defined(BSP_USE_CMSIS_OS)
  /* Release semaphore to prevent multiple I2C access */
  osSemaphoreRelease(BspI2cSemaphore);
#endif
  return ret;
900069bc:	697b      	ldr	r3, [r7, #20]
}
900069be:	4618      	mov	r0, r3
900069c0:	3718      	adds	r7, #24
900069c2:	46bd      	mov	sp, r7
900069c4:	bd80      	pop	{r7, pc}
900069c6:	bf00      	nop
900069c8:	24002a30 	.word	0x24002a30

900069cc <BSP_I2C4_ReadReg>:
  * @param  pData   Pointer to data buffer
  * @param  Length  Length of the data
  * @retval BSP status
  */
int32_t BSP_I2C4_ReadReg(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
900069cc:	b580      	push	{r7, lr}
900069ce:	b088      	sub	sp, #32
900069d0:	af02      	add	r7, sp, #8
900069d2:	60ba      	str	r2, [r7, #8]
900069d4:	461a      	mov	r2, r3
900069d6:	4603      	mov	r3, r0
900069d8:	81fb      	strh	r3, [r7, #14]
900069da:	460b      	mov	r3, r1
900069dc:	81bb      	strh	r3, [r7, #12]
900069de:	4613      	mov	r3, r2
900069e0:	80fb      	strh	r3, [r7, #6]
  int32_t ret;
#if defined(BSP_USE_CMSIS_OS)
  /* Get semaphore to prevent multiple I2C access */
  osSemaphoreWait(BspI2cSemaphore, osWaitForever);
#endif
  if(I2C4_ReadReg(DevAddr, Reg, I2C_MEMADD_SIZE_8BIT, pData, Length) == 0)
900069e2:	89b9      	ldrh	r1, [r7, #12]
900069e4:	89f8      	ldrh	r0, [r7, #14]
900069e6:	88fb      	ldrh	r3, [r7, #6]
900069e8:	9300      	str	r3, [sp, #0]
900069ea:	68bb      	ldr	r3, [r7, #8]
900069ec:	2201      	movs	r2, #1
900069ee:	f000 fbab 	bl	90007148 <I2C4_ReadReg>
900069f2:	4603      	mov	r3, r0
900069f4:	2b00      	cmp	r3, #0
900069f6:	d102      	bne.n	900069fe <BSP_I2C4_ReadReg+0x32>
  {
    ret = BSP_ERROR_NONE;
900069f8:	2300      	movs	r3, #0
900069fa:	617b      	str	r3, [r7, #20]
900069fc:	e00c      	b.n	90006a18 <BSP_I2C4_ReadReg+0x4c>
  }
  else
  {
    if( HAL_I2C_GetError(&hbus_i2c4) == HAL_I2C_ERROR_AF)
900069fe:	4809      	ldr	r0, [pc, #36]	; (90006a24 <BSP_I2C4_ReadReg+0x58>)
90006a00:	f006 feee 	bl	9000d7e0 <HAL_I2C_GetError>
90006a04:	4603      	mov	r3, r0
90006a06:	2b04      	cmp	r3, #4
90006a08:	d103      	bne.n	90006a12 <BSP_I2C4_ReadReg+0x46>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
90006a0a:	f06f 0365 	mvn.w	r3, #101	; 0x65
90006a0e:	617b      	str	r3, [r7, #20]
90006a10:	e002      	b.n	90006a18 <BSP_I2C4_ReadReg+0x4c>
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
90006a12:	f06f 0303 	mvn.w	r3, #3
90006a16:	617b      	str	r3, [r7, #20]
  }
#if defined(BSP_USE_CMSIS_OS)
  /* Release semaphore to prevent multiple I2C access */
  osSemaphoreRelease(BspI2cSemaphore);
#endif
  return ret;
90006a18:	697b      	ldr	r3, [r7, #20]
}
90006a1a:	4618      	mov	r0, r3
90006a1c:	3718      	adds	r7, #24
90006a1e:	46bd      	mov	sp, r7
90006a20:	bd80      	pop	{r7, pc}
90006a22:	bf00      	nop
90006a24:	24002a30 	.word	0x24002a30

90006a28 <BSP_I2C4_WriteReg16>:
  * @param  pData  The target register value to be written
  * @param  Length buffer size to be written
  * @retval BSP status
  */
int32_t BSP_I2C4_WriteReg16(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
90006a28:	b580      	push	{r7, lr}
90006a2a:	b088      	sub	sp, #32
90006a2c:	af02      	add	r7, sp, #8
90006a2e:	60ba      	str	r2, [r7, #8]
90006a30:	461a      	mov	r2, r3
90006a32:	4603      	mov	r3, r0
90006a34:	81fb      	strh	r3, [r7, #14]
90006a36:	460b      	mov	r3, r1
90006a38:	81bb      	strh	r3, [r7, #12]
90006a3a:	4613      	mov	r3, r2
90006a3c:	80fb      	strh	r3, [r7, #6]
  int32_t ret;
 #if defined(BSP_USE_CMSIS_OS)
  /* Get semaphore to prevent multiple I2C access */
  osSemaphoreWait(BspI2cSemaphore, osWaitForever);
#endif
  if(I2C4_WriteReg(DevAddr, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length) == 0)
90006a3e:	89b9      	ldrh	r1, [r7, #12]
90006a40:	89f8      	ldrh	r0, [r7, #14]
90006a42:	88fb      	ldrh	r3, [r7, #6]
90006a44:	9300      	str	r3, [sp, #0]
90006a46:	68bb      	ldr	r3, [r7, #8]
90006a48:	2202      	movs	r2, #2
90006a4a:	f000 fb57 	bl	900070fc <I2C4_WriteReg>
90006a4e:	4603      	mov	r3, r0
90006a50:	2b00      	cmp	r3, #0
90006a52:	d102      	bne.n	90006a5a <BSP_I2C4_WriteReg16+0x32>
  {
    ret = BSP_ERROR_NONE;
90006a54:	2300      	movs	r3, #0
90006a56:	617b      	str	r3, [r7, #20]
90006a58:	e00c      	b.n	90006a74 <BSP_I2C4_WriteReg16+0x4c>
  }
  else
  {
    if( HAL_I2C_GetError(&hbus_i2c4) == HAL_I2C_ERROR_AF)
90006a5a:	4809      	ldr	r0, [pc, #36]	; (90006a80 <BSP_I2C4_WriteReg16+0x58>)
90006a5c:	f006 fec0 	bl	9000d7e0 <HAL_I2C_GetError>
90006a60:	4603      	mov	r3, r0
90006a62:	2b04      	cmp	r3, #4
90006a64:	d103      	bne.n	90006a6e <BSP_I2C4_WriteReg16+0x46>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
90006a66:	f06f 0365 	mvn.w	r3, #101	; 0x65
90006a6a:	617b      	str	r3, [r7, #20]
90006a6c:	e002      	b.n	90006a74 <BSP_I2C4_WriteReg16+0x4c>
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
90006a6e:	f06f 0303 	mvn.w	r3, #3
90006a72:	617b      	str	r3, [r7, #20]
  }
#if defined(BSP_USE_CMSIS_OS)
  /* Release semaphore to prevent multiple I2C access */
  osSemaphoreRelease(BspI2cSemaphore);
#endif
  return ret;
90006a74:	697b      	ldr	r3, [r7, #20]
}
90006a76:	4618      	mov	r0, r3
90006a78:	3718      	adds	r7, #24
90006a7a:	46bd      	mov	sp, r7
90006a7c:	bd80      	pop	{r7, pc}
90006a7e:	bf00      	nop
90006a80:	24002a30 	.word	0x24002a30

90006a84 <BSP_I2C4_ReadReg16>:
  * @param  pData   Pointer to data buffer
  * @param  Length  Length of the data
  * @retval BSP status
  */
int32_t BSP_I2C4_ReadReg16(uint16_t DevAddr, uint16_t Reg, uint8_t *pData, uint16_t Length)
{
90006a84:	b580      	push	{r7, lr}
90006a86:	b088      	sub	sp, #32
90006a88:	af02      	add	r7, sp, #8
90006a8a:	60ba      	str	r2, [r7, #8]
90006a8c:	461a      	mov	r2, r3
90006a8e:	4603      	mov	r3, r0
90006a90:	81fb      	strh	r3, [r7, #14]
90006a92:	460b      	mov	r3, r1
90006a94:	81bb      	strh	r3, [r7, #12]
90006a96:	4613      	mov	r3, r2
90006a98:	80fb      	strh	r3, [r7, #6]
  int32_t ret;
#if defined(BSP_USE_CMSIS_OS)
  /* Get semaphore to prevent multiple I2C access */
  osSemaphoreWait(BspI2cSemaphore, osWaitForever);
#endif
  if(I2C4_ReadReg(DevAddr, Reg, I2C_MEMADD_SIZE_16BIT, pData, Length) == 0)
90006a9a:	89b9      	ldrh	r1, [r7, #12]
90006a9c:	89f8      	ldrh	r0, [r7, #14]
90006a9e:	88fb      	ldrh	r3, [r7, #6]
90006aa0:	9300      	str	r3, [sp, #0]
90006aa2:	68bb      	ldr	r3, [r7, #8]
90006aa4:	2202      	movs	r2, #2
90006aa6:	f000 fb4f 	bl	90007148 <I2C4_ReadReg>
90006aaa:	4603      	mov	r3, r0
90006aac:	2b00      	cmp	r3, #0
90006aae:	d102      	bne.n	90006ab6 <BSP_I2C4_ReadReg16+0x32>
  {
    ret = BSP_ERROR_NONE;
90006ab0:	2300      	movs	r3, #0
90006ab2:	617b      	str	r3, [r7, #20]
90006ab4:	e00c      	b.n	90006ad0 <BSP_I2C4_ReadReg16+0x4c>
  }
  else
  {
    if( HAL_I2C_GetError(&hbus_i2c4) == HAL_I2C_ERROR_AF)
90006ab6:	4809      	ldr	r0, [pc, #36]	; (90006adc <BSP_I2C4_ReadReg16+0x58>)
90006ab8:	f006 fe92 	bl	9000d7e0 <HAL_I2C_GetError>
90006abc:	4603      	mov	r3, r0
90006abe:	2b04      	cmp	r3, #4
90006ac0:	d103      	bne.n	90006aca <BSP_I2C4_ReadReg16+0x46>
    {
      ret = BSP_ERROR_BUS_ACKNOWLEDGE_FAILURE;
90006ac2:	f06f 0365 	mvn.w	r3, #101	; 0x65
90006ac6:	617b      	str	r3, [r7, #20]
90006ac8:	e002      	b.n	90006ad0 <BSP_I2C4_ReadReg16+0x4c>
    }
    else
    {
      ret =  BSP_ERROR_PERIPH_FAILURE;
90006aca:	f06f 0303 	mvn.w	r3, #3
90006ace:	617b      	str	r3, [r7, #20]
  }
#if defined(BSP_USE_CMSIS_OS)
  /* Release semaphore to prevent multiple I2C access */
  osSemaphoreRelease(BspI2cSemaphore);
#endif
  return ret;
90006ad0:	697b      	ldr	r3, [r7, #20]
}
90006ad2:	4618      	mov	r0, r3
90006ad4:	3718      	adds	r7, #24
90006ad6:	46bd      	mov	sp, r7
90006ad8:	bd80      	pop	{r7, pc}
90006ada:	bf00      	nop
90006adc:	24002a30 	.word	0x24002a30

90006ae0 <BSP_GetTick>:
/**
  * @brief  Delay function
  * @retval Tick value
  */
int32_t BSP_GetTick(void)
{
90006ae0:	b580      	push	{r7, lr}
90006ae2:	af00      	add	r7, sp, #0
  return (int32_t)HAL_GetTick();
90006ae4:	f002 fc6e 	bl	900093c4 <HAL_GetTick>
90006ae8:	4603      	mov	r3, r0
}
90006aea:	4618      	mov	r0, r3
90006aec:	bd80      	pop	{r7, pc}
	...

90006af0 <I2C_GetTiming>:
  * @param  clock_src_freq I2C clock source in Hz.
  * @param  i2c_freq Required I2C clock in Hz.
  * @retval I2C timing or 0 in case of error.
  */
static uint32_t I2C_GetTiming(uint32_t clock_src_freq, uint32_t i2c_freq)
{
90006af0:	b580      	push	{r7, lr}
90006af2:	b086      	sub	sp, #24
90006af4:	af00      	add	r7, sp, #0
90006af6:	6078      	str	r0, [r7, #4]
90006af8:	6039      	str	r1, [r7, #0]
  uint32_t ret = 0;
90006afa:	2300      	movs	r3, #0
90006afc:	617b      	str	r3, [r7, #20]
  uint32_t speed;
  uint32_t idx;

  if((clock_src_freq != 0U) && (i2c_freq != 0U))
90006afe:	687b      	ldr	r3, [r7, #4]
90006b00:	2b00      	cmp	r3, #0
90006b02:	d06b      	beq.n	90006bdc <I2C_GetTiming+0xec>
90006b04:	683b      	ldr	r3, [r7, #0]
90006b06:	2b00      	cmp	r3, #0
90006b08:	d068      	beq.n	90006bdc <I2C_GetTiming+0xec>
  {
    for ( speed = 0 ; speed <=  (uint32_t)I2C_SPEED_FREQ_FAST_PLUS ; speed++)
90006b0a:	2300      	movs	r3, #0
90006b0c:	613b      	str	r3, [r7, #16]
90006b0e:	e060      	b.n	90006bd2 <I2C_GetTiming+0xe2>
    {
      if ((i2c_freq >= I2C_Charac[speed].freq_min) &&
90006b10:	4a35      	ldr	r2, [pc, #212]	; (90006be8 <I2C_GetTiming+0xf8>)
90006b12:	693b      	ldr	r3, [r7, #16]
90006b14:	212c      	movs	r1, #44	; 0x2c
90006b16:	fb01 f303 	mul.w	r3, r1, r3
90006b1a:	4413      	add	r3, r2
90006b1c:	3304      	adds	r3, #4
90006b1e:	681b      	ldr	r3, [r3, #0]
90006b20:	683a      	ldr	r2, [r7, #0]
90006b22:	429a      	cmp	r2, r3
90006b24:	d352      	bcc.n	90006bcc <I2C_GetTiming+0xdc>
          (i2c_freq <= I2C_Charac[speed].freq_max))
90006b26:	4a30      	ldr	r2, [pc, #192]	; (90006be8 <I2C_GetTiming+0xf8>)
90006b28:	693b      	ldr	r3, [r7, #16]
90006b2a:	212c      	movs	r1, #44	; 0x2c
90006b2c:	fb01 f303 	mul.w	r3, r1, r3
90006b30:	4413      	add	r3, r2
90006b32:	3308      	adds	r3, #8
90006b34:	681b      	ldr	r3, [r3, #0]
      if ((i2c_freq >= I2C_Charac[speed].freq_min) &&
90006b36:	683a      	ldr	r2, [r7, #0]
90006b38:	429a      	cmp	r2, r3
90006b3a:	d847      	bhi.n	90006bcc <I2C_GetTiming+0xdc>
      {
        I2C_Compute_PRESC_SCLDEL_SDADEL(clock_src_freq, speed);
90006b3c:	6939      	ldr	r1, [r7, #16]
90006b3e:	6878      	ldr	r0, [r7, #4]
90006b40:	f000 f856 	bl	90006bf0 <I2C_Compute_PRESC_SCLDEL_SDADEL>
        idx = I2C_Compute_SCLL_SCLH(clock_src_freq, speed);
90006b44:	6939      	ldr	r1, [r7, #16]
90006b46:	6878      	ldr	r0, [r7, #4]
90006b48:	f000 f940 	bl	90006dcc <I2C_Compute_SCLL_SCLH>
90006b4c:	60f8      	str	r0, [r7, #12]

        if (idx < I2C_VALID_TIMING_NBR)
90006b4e:	68fb      	ldr	r3, [r7, #12]
90006b50:	2b7f      	cmp	r3, #127	; 0x7f
90006b52:	d842      	bhi.n	90006bda <I2C_GetTiming+0xea>
        {
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
90006b54:	4925      	ldr	r1, [pc, #148]	; (90006bec <I2C_GetTiming+0xfc>)
90006b56:	68fa      	ldr	r2, [r7, #12]
90006b58:	4613      	mov	r3, r2
90006b5a:	009b      	lsls	r3, r3, #2
90006b5c:	4413      	add	r3, r2
90006b5e:	009b      	lsls	r3, r3, #2
90006b60:	440b      	add	r3, r1
90006b62:	681b      	ldr	r3, [r3, #0]
90006b64:	0719      	lsls	r1, r3, #28
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
90006b66:	4821      	ldr	r0, [pc, #132]	; (90006bec <I2C_GetTiming+0xfc>)
90006b68:	68fa      	ldr	r2, [r7, #12]
90006b6a:	4613      	mov	r3, r2
90006b6c:	009b      	lsls	r3, r3, #2
90006b6e:	4413      	add	r3, r2
90006b70:	009b      	lsls	r3, r3, #2
90006b72:	4403      	add	r3, r0
90006b74:	3304      	adds	r3, #4
90006b76:	681b      	ldr	r3, [r3, #0]
90006b78:	051b      	lsls	r3, r3, #20
90006b7a:	f403 0370 	and.w	r3, r3, #15728640	; 0xf00000
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
90006b7e:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
90006b80:	481a      	ldr	r0, [pc, #104]	; (90006bec <I2C_GetTiming+0xfc>)
90006b82:	68fa      	ldr	r2, [r7, #12]
90006b84:	4613      	mov	r3, r2
90006b86:	009b      	lsls	r3, r3, #2
90006b88:	4413      	add	r3, r2
90006b8a:	009b      	lsls	r3, r3, #2
90006b8c:	4403      	add	r3, r0
90006b8e:	3308      	adds	r3, #8
90006b90:	681b      	ldr	r3, [r3, #0]
90006b92:	041b      	lsls	r3, r3, #16
90006b94:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
                ((I2c_valid_timing[idx].tscldel & 0x0FU) << 20) |\
90006b98:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].sclh & 0xFFU) << 8) |\
90006b9a:	4814      	ldr	r0, [pc, #80]	; (90006bec <I2C_GetTiming+0xfc>)
90006b9c:	68fa      	ldr	r2, [r7, #12]
90006b9e:	4613      	mov	r3, r2
90006ba0:	009b      	lsls	r3, r3, #2
90006ba2:	4413      	add	r3, r2
90006ba4:	009b      	lsls	r3, r3, #2
90006ba6:	4403      	add	r3, r0
90006ba8:	330c      	adds	r3, #12
90006baa:	681b      	ldr	r3, [r3, #0]
90006bac:	021b      	lsls	r3, r3, #8
90006bae:	b29b      	uxth	r3, r3
                ((I2c_valid_timing[idx].tsdadel & 0x0FU) << 16) |\
90006bb0:	4319      	orrs	r1, r3
                ((I2c_valid_timing[idx].scll & 0xFFU) << 0);
90006bb2:	480e      	ldr	r0, [pc, #56]	; (90006bec <I2C_GetTiming+0xfc>)
90006bb4:	68fa      	ldr	r2, [r7, #12]
90006bb6:	4613      	mov	r3, r2
90006bb8:	009b      	lsls	r3, r3, #2
90006bba:	4413      	add	r3, r2
90006bbc:	009b      	lsls	r3, r3, #2
90006bbe:	4403      	add	r3, r0
90006bc0:	3310      	adds	r3, #16
90006bc2:	681b      	ldr	r3, [r3, #0]
90006bc4:	b2db      	uxtb	r3, r3
          ret = ((I2c_valid_timing[idx].presc  & 0x0FU) << 28) |\
90006bc6:	430b      	orrs	r3, r1
90006bc8:	617b      	str	r3, [r7, #20]
        }
        break;
90006bca:	e006      	b.n	90006bda <I2C_GetTiming+0xea>
    for ( speed = 0 ; speed <=  (uint32_t)I2C_SPEED_FREQ_FAST_PLUS ; speed++)
90006bcc:	693b      	ldr	r3, [r7, #16]
90006bce:	3301      	adds	r3, #1
90006bd0:	613b      	str	r3, [r7, #16]
90006bd2:	693b      	ldr	r3, [r7, #16]
90006bd4:	2b02      	cmp	r3, #2
90006bd6:	d99b      	bls.n	90006b10 <I2C_GetTiming+0x20>
90006bd8:	e000      	b.n	90006bdc <I2C_GetTiming+0xec>
        break;
90006bda:	bf00      	nop
      }
    }
  }

  return ret;
90006bdc:	697b      	ldr	r3, [r7, #20]
}
90006bde:	4618      	mov	r0, r3
90006be0:	3718      	adds	r7, #24
90006be2:	46bd      	mov	sp, r7
90006be4:	bd80      	pop	{r7, pc}
90006be6:	bf00      	nop
90006be8:	9001e7f8 	.word	0x9001e7f8
90006bec:	240013ec 	.word	0x240013ec

90006bf0 <I2C_Compute_PRESC_SCLDEL_SDADEL>:
  * @param  clock_src_freq I2C source clock in HZ.
  * @param  I2C_speed I2C frequency (index).
  * @retval None.
  */
static void I2C_Compute_PRESC_SCLDEL_SDADEL(uint32_t clock_src_freq, uint32_t I2C_speed)
{
90006bf0:	b480      	push	{r7}
90006bf2:	b08f      	sub	sp, #60	; 0x3c
90006bf4:	af00      	add	r7, sp, #0
90006bf6:	6078      	str	r0, [r7, #4]
90006bf8:	6039      	str	r1, [r7, #0]
  uint32_t prev_presc = I2C_PRESC_MAX;
90006bfa:	2310      	movs	r3, #16
90006bfc:	637b      	str	r3, [r7, #52]	; 0x34
  int32_t  tsdadel_min, tsdadel_max;
  int32_t  tscldel_min;
  uint32_t presc, scldel, sdadel;
  uint32_t tafdel_min, tafdel_max;

  ti2cclk   = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
90006bfe:	687b      	ldr	r3, [r7, #4]
90006c00:	085a      	lsrs	r2, r3, #1
90006c02:	4b6e      	ldr	r3, [pc, #440]	; (90006dbc <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1cc>)
90006c04:	4413      	add	r3, r2
90006c06:	687a      	ldr	r2, [r7, #4]
90006c08:	fbb3 f3f2 	udiv	r3, r3, r2
90006c0c:	61fb      	str	r3, [r7, #28]

  tafdel_min = I2C_ANALOG_FILTER_DELAY_MIN;
90006c0e:	2332      	movs	r3, #50	; 0x32
90006c10:	61bb      	str	r3, [r7, #24]
  tafdel_max = I2C_ANALOG_FILTER_DELAY_MAX;
90006c12:	f44f 7382 	mov.w	r3, #260	; 0x104
90006c16:	617b      	str	r3, [r7, #20]
  /* tDNF = DNF x tI2CCLK
     tPRESC = (PRESC+1) x tI2CCLK
     SDADEL >= {tf +tHD;DAT(min) - tAF(min) - tDNF - [3 x tI2CCLK]} / {tPRESC}
     SDADEL <= {tVD;DAT(max) - tr - tAF(max) - tDNF- [4 x tI2CCLK]} / {tPRESC} */

  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
90006c18:	4a69      	ldr	r2, [pc, #420]	; (90006dc0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
90006c1a:	683b      	ldr	r3, [r7, #0]
90006c1c:	212c      	movs	r1, #44	; 0x2c
90006c1e:	fb01 f303 	mul.w	r3, r1, r3
90006c22:	4413      	add	r3, r2
90006c24:	3324      	adds	r3, #36	; 0x24
90006c26:	681b      	ldr	r3, [r3, #0]
90006c28:	4618      	mov	r0, r3
90006c2a:	4a65      	ldr	r2, [pc, #404]	; (90006dc0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
90006c2c:	683b      	ldr	r3, [r7, #0]
90006c2e:	212c      	movs	r1, #44	; 0x2c
90006c30:	fb01 f303 	mul.w	r3, r1, r3
90006c34:	4413      	add	r3, r2
90006c36:	330c      	adds	r3, #12
90006c38:	681b      	ldr	r3, [r3, #0]
90006c3a:	18c2      	adds	r2, r0, r3
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
90006c3c:	69bb      	ldr	r3, [r7, #24]
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
90006c3e:	1ad2      	subs	r2, r2, r3
    (int32_t)tafdel_min - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 3) * (int32_t)ti2cclk);
90006c40:	495f      	ldr	r1, [pc, #380]	; (90006dc0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
90006c42:	683b      	ldr	r3, [r7, #0]
90006c44:	202c      	movs	r0, #44	; 0x2c
90006c46:	fb00 f303 	mul.w	r3, r0, r3
90006c4a:	440b      	add	r3, r1
90006c4c:	3328      	adds	r3, #40	; 0x28
90006c4e:	681b      	ldr	r3, [r3, #0]
90006c50:	3303      	adds	r3, #3
90006c52:	69f9      	ldr	r1, [r7, #28]
90006c54:	fb01 f303 	mul.w	r3, r1, r3
  tsdadel_min = (int32_t)I2C_Charac[I2C_speed].tfall + (int32_t)I2C_Charac[I2C_speed].hddat_min -
90006c58:	1ad3      	subs	r3, r2, r3
90006c5a:	633b      	str	r3, [r7, #48]	; 0x30

  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
90006c5c:	4a58      	ldr	r2, [pc, #352]	; (90006dc0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
90006c5e:	683b      	ldr	r3, [r7, #0]
90006c60:	212c      	movs	r1, #44	; 0x2c
90006c62:	fb01 f303 	mul.w	r3, r1, r3
90006c66:	4413      	add	r3, r2
90006c68:	3310      	adds	r3, #16
90006c6a:	681b      	ldr	r3, [r3, #0]
90006c6c:	4618      	mov	r0, r3
90006c6e:	4a54      	ldr	r2, [pc, #336]	; (90006dc0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
90006c70:	683b      	ldr	r3, [r7, #0]
90006c72:	212c      	movs	r1, #44	; 0x2c
90006c74:	fb01 f303 	mul.w	r3, r1, r3
90006c78:	4413      	add	r3, r2
90006c7a:	3320      	adds	r3, #32
90006c7c:	681b      	ldr	r3, [r3, #0]
90006c7e:	1ac2      	subs	r2, r0, r3
    (int32_t)tafdel_max - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 4) * (int32_t)ti2cclk);
90006c80:	697b      	ldr	r3, [r7, #20]
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
90006c82:	1ad2      	subs	r2, r2, r3
    (int32_t)tafdel_max - (int32_t)(((int32_t)I2C_Charac[I2C_speed].dnf + 4) * (int32_t)ti2cclk);
90006c84:	494e      	ldr	r1, [pc, #312]	; (90006dc0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
90006c86:	683b      	ldr	r3, [r7, #0]
90006c88:	202c      	movs	r0, #44	; 0x2c
90006c8a:	fb00 f303 	mul.w	r3, r0, r3
90006c8e:	440b      	add	r3, r1
90006c90:	3328      	adds	r3, #40	; 0x28
90006c92:	681b      	ldr	r3, [r3, #0]
90006c94:	3304      	adds	r3, #4
90006c96:	69f9      	ldr	r1, [r7, #28]
90006c98:	fb01 f303 	mul.w	r3, r1, r3
  tsdadel_max = (int32_t)I2C_Charac[I2C_speed].vddat_max - (int32_t)I2C_Charac[I2C_speed].trise -
90006c9c:	1ad3      	subs	r3, r2, r3
90006c9e:	62fb      	str	r3, [r7, #44]	; 0x2c


  /* {[tr+ tSU;DAT(min)] / [tPRESC]} - 1 <= SCLDEL */
  tscldel_min = (int32_t)I2C_Charac[I2C_speed].trise + (int32_t)I2C_Charac[I2C_speed].sudat_min;
90006ca0:	4a47      	ldr	r2, [pc, #284]	; (90006dc0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
90006ca2:	683b      	ldr	r3, [r7, #0]
90006ca4:	212c      	movs	r1, #44	; 0x2c
90006ca6:	fb01 f303 	mul.w	r3, r1, r3
90006caa:	4413      	add	r3, r2
90006cac:	3320      	adds	r3, #32
90006cae:	681b      	ldr	r3, [r3, #0]
90006cb0:	4618      	mov	r0, r3
90006cb2:	4a43      	ldr	r2, [pc, #268]	; (90006dc0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d0>)
90006cb4:	683b      	ldr	r3, [r7, #0]
90006cb6:	212c      	movs	r1, #44	; 0x2c
90006cb8:	fb01 f303 	mul.w	r3, r1, r3
90006cbc:	4413      	add	r3, r2
90006cbe:	3314      	adds	r3, #20
90006cc0:	681b      	ldr	r3, [r3, #0]
90006cc2:	4403      	add	r3, r0
90006cc4:	613b      	str	r3, [r7, #16]

  if (tsdadel_min <= 0)
90006cc6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90006cc8:	2b00      	cmp	r3, #0
90006cca:	dc01      	bgt.n	90006cd0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0xe0>
  {
    tsdadel_min = 0;
90006ccc:	2300      	movs	r3, #0
90006cce:	633b      	str	r3, [r7, #48]	; 0x30
  }

  if (tsdadel_max <= 0)
90006cd0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90006cd2:	2b00      	cmp	r3, #0
90006cd4:	dc01      	bgt.n	90006cda <I2C_Compute_PRESC_SCLDEL_SDADEL+0xea>
  {
    tsdadel_max = 0;
90006cd6:	2300      	movs	r3, #0
90006cd8:	62fb      	str	r3, [r7, #44]	; 0x2c
  }

  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
90006cda:	2300      	movs	r3, #0
90006cdc:	62bb      	str	r3, [r7, #40]	; 0x28
90006cde:	e062      	b.n	90006da6 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1b6>
  {
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
90006ce0:	2300      	movs	r3, #0
90006ce2:	627b      	str	r3, [r7, #36]	; 0x24
90006ce4:	e059      	b.n	90006d9a <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1aa>
    {
      /* TSCLDEL = (SCLDEL+1) * (PRESC+1) * TI2CCLK */
      uint32_t tscldel = (scldel + 1U) * (presc + 1U) * ti2cclk;
90006ce6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90006ce8:	3301      	adds	r3, #1
90006cea:	6aba      	ldr	r2, [r7, #40]	; 0x28
90006cec:	3201      	adds	r2, #1
90006cee:	fb02 f203 	mul.w	r2, r2, r3
90006cf2:	69fb      	ldr	r3, [r7, #28]
90006cf4:	fb02 f303 	mul.w	r3, r2, r3
90006cf8:	60fb      	str	r3, [r7, #12]

      if (tscldel >= (uint32_t)tscldel_min)
90006cfa:	693b      	ldr	r3, [r7, #16]
90006cfc:	68fa      	ldr	r2, [r7, #12]
90006cfe:	429a      	cmp	r2, r3
90006d00:	d348      	bcc.n	90006d94 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1a4>
      {
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
90006d02:	2300      	movs	r3, #0
90006d04:	623b      	str	r3, [r7, #32]
90006d06:	e042      	b.n	90006d8e <I2C_Compute_PRESC_SCLDEL_SDADEL+0x19e>
        {
          /* TSDADEL = SDADEL * (PRESC+1) * TI2CCLK */
          uint32_t tsdadel = (sdadel * (presc + 1U)) * ti2cclk;
90006d08:	6abb      	ldr	r3, [r7, #40]	; 0x28
90006d0a:	3301      	adds	r3, #1
90006d0c:	6a3a      	ldr	r2, [r7, #32]
90006d0e:	fb02 f203 	mul.w	r2, r2, r3
90006d12:	69fb      	ldr	r3, [r7, #28]
90006d14:	fb02 f303 	mul.w	r3, r2, r3
90006d18:	60bb      	str	r3, [r7, #8]

          if ((tsdadel >= (uint32_t)tsdadel_min) && (tsdadel <= (uint32_t)tsdadel_max))
90006d1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90006d1c:	68ba      	ldr	r2, [r7, #8]
90006d1e:	429a      	cmp	r2, r3
90006d20:	d332      	bcc.n	90006d88 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
90006d22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90006d24:	68ba      	ldr	r2, [r7, #8]
90006d26:	429a      	cmp	r2, r3
90006d28:	d82e      	bhi.n	90006d88 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
          {
            if(presc != prev_presc)
90006d2a:	6aba      	ldr	r2, [r7, #40]	; 0x28
90006d2c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90006d2e:	429a      	cmp	r2, r3
90006d30:	d02a      	beq.n	90006d88 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x198>
            {
              I2c_valid_timing[I2c_valid_timing_nbr].presc = presc;
90006d32:	4b24      	ldr	r3, [pc, #144]	; (90006dc4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
90006d34:	681a      	ldr	r2, [r3, #0]
90006d36:	4924      	ldr	r1, [pc, #144]	; (90006dc8 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
90006d38:	4613      	mov	r3, r2
90006d3a:	009b      	lsls	r3, r3, #2
90006d3c:	4413      	add	r3, r2
90006d3e:	009b      	lsls	r3, r3, #2
90006d40:	440b      	add	r3, r1
90006d42:	6aba      	ldr	r2, [r7, #40]	; 0x28
90006d44:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[I2c_valid_timing_nbr].tscldel = scldel;
90006d46:	4b1f      	ldr	r3, [pc, #124]	; (90006dc4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
90006d48:	681a      	ldr	r2, [r3, #0]
90006d4a:	491f      	ldr	r1, [pc, #124]	; (90006dc8 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
90006d4c:	4613      	mov	r3, r2
90006d4e:	009b      	lsls	r3, r3, #2
90006d50:	4413      	add	r3, r2
90006d52:	009b      	lsls	r3, r3, #2
90006d54:	440b      	add	r3, r1
90006d56:	3304      	adds	r3, #4
90006d58:	6a7a      	ldr	r2, [r7, #36]	; 0x24
90006d5a:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[I2c_valid_timing_nbr].tsdadel = sdadel;
90006d5c:	4b19      	ldr	r3, [pc, #100]	; (90006dc4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
90006d5e:	681a      	ldr	r2, [r3, #0]
90006d60:	4919      	ldr	r1, [pc, #100]	; (90006dc8 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d8>)
90006d62:	4613      	mov	r3, r2
90006d64:	009b      	lsls	r3, r3, #2
90006d66:	4413      	add	r3, r2
90006d68:	009b      	lsls	r3, r3, #2
90006d6a:	440b      	add	r3, r1
90006d6c:	3308      	adds	r3, #8
90006d6e:	6a3a      	ldr	r2, [r7, #32]
90006d70:	601a      	str	r2, [r3, #0]
              prev_presc = presc;
90006d72:	6abb      	ldr	r3, [r7, #40]	; 0x28
90006d74:	637b      	str	r3, [r7, #52]	; 0x34
              I2c_valid_timing_nbr ++;
90006d76:	4b13      	ldr	r3, [pc, #76]	; (90006dc4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
90006d78:	681b      	ldr	r3, [r3, #0]
90006d7a:	3301      	adds	r3, #1
90006d7c:	4a11      	ldr	r2, [pc, #68]	; (90006dc4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
90006d7e:	6013      	str	r3, [r2, #0]

              if(I2c_valid_timing_nbr >= I2C_VALID_TIMING_NBR)
90006d80:	4b10      	ldr	r3, [pc, #64]	; (90006dc4 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1d4>)
90006d82:	681b      	ldr	r3, [r3, #0]
90006d84:	2b7f      	cmp	r3, #127	; 0x7f
90006d86:	d812      	bhi.n	90006dae <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1be>
        for (sdadel = 0; sdadel < I2C_SDADEL_MAX; sdadel++)
90006d88:	6a3b      	ldr	r3, [r7, #32]
90006d8a:	3301      	adds	r3, #1
90006d8c:	623b      	str	r3, [r7, #32]
90006d8e:	6a3b      	ldr	r3, [r7, #32]
90006d90:	2b0f      	cmp	r3, #15
90006d92:	d9b9      	bls.n	90006d08 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x118>
    for (scldel = 0; scldel < I2C_SCLDEL_MAX; scldel++)
90006d94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90006d96:	3301      	adds	r3, #1
90006d98:	627b      	str	r3, [r7, #36]	; 0x24
90006d9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90006d9c:	2b0f      	cmp	r3, #15
90006d9e:	d9a2      	bls.n	90006ce6 <I2C_Compute_PRESC_SCLDEL_SDADEL+0xf6>
  for (presc = 0; presc < I2C_PRESC_MAX; presc++)
90006da0:	6abb      	ldr	r3, [r7, #40]	; 0x28
90006da2:	3301      	adds	r3, #1
90006da4:	62bb      	str	r3, [r7, #40]	; 0x28
90006da6:	6abb      	ldr	r3, [r7, #40]	; 0x28
90006da8:	2b0f      	cmp	r3, #15
90006daa:	d999      	bls.n	90006ce0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0xf0>
90006dac:	e000      	b.n	90006db0 <I2C_Compute_PRESC_SCLDEL_SDADEL+0x1c0>
              {
                return;
90006dae:	bf00      	nop
          }
        }
      }
    }
  }
}
90006db0:	373c      	adds	r7, #60	; 0x3c
90006db2:	46bd      	mov	sp, r7
90006db4:	f85d 7b04 	ldr.w	r7, [sp], #4
90006db8:	4770      	bx	lr
90006dba:	bf00      	nop
90006dbc:	3b9aca00 	.word	0x3b9aca00
90006dc0:	9001e7f8 	.word	0x9001e7f8
90006dc4:	24001dec 	.word	0x24001dec
90006dc8:	240013ec 	.word	0x240013ec

90006dcc <I2C_Compute_SCLL_SCLH>:
  * @param  clock_src_freq I2C source clock in HZ.
  * @param  I2C_speed I2C frequency (index).
  * @retval config index (0 to I2C_VALID_TIMING_NBR], 0xFFFFFFFF for no valid config.
  */
static uint32_t I2C_Compute_SCLL_SCLH (uint32_t clock_src_freq, uint32_t I2C_speed)
{
90006dcc:	b480      	push	{r7}
90006dce:	b093      	sub	sp, #76	; 0x4c
90006dd0:	af00      	add	r7, sp, #0
90006dd2:	6078      	str	r0, [r7, #4]
90006dd4:	6039      	str	r1, [r7, #0]
 uint32_t ret = 0xFFFFFFFFU;
90006dd6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90006dda:	647b      	str	r3, [r7, #68]	; 0x44
  uint32_t dnf_delay;
  uint32_t clk_min, clk_max;
  uint32_t scll, sclh;
  uint32_t tafdel_min;

  ti2cclk   = (SEC2NSEC + (clock_src_freq / 2U))/ clock_src_freq;
90006ddc:	687b      	ldr	r3, [r7, #4]
90006dde:	085a      	lsrs	r2, r3, #1
90006de0:	4b7a      	ldr	r3, [pc, #488]	; (90006fcc <I2C_Compute_SCLL_SCLH+0x200>)
90006de2:	4413      	add	r3, r2
90006de4:	687a      	ldr	r2, [r7, #4]
90006de6:	fbb3 f3f2 	udiv	r3, r3, r2
90006dea:	62fb      	str	r3, [r7, #44]	; 0x2c
  ti2cspeed   = (SEC2NSEC + (I2C_Charac[I2C_speed].freq / 2U))/ I2C_Charac[I2C_speed].freq;
90006dec:	4a78      	ldr	r2, [pc, #480]	; (90006fd0 <I2C_Compute_SCLL_SCLH+0x204>)
90006dee:	683b      	ldr	r3, [r7, #0]
90006df0:	212c      	movs	r1, #44	; 0x2c
90006df2:	fb01 f303 	mul.w	r3, r1, r3
90006df6:	4413      	add	r3, r2
90006df8:	681b      	ldr	r3, [r3, #0]
90006dfa:	085a      	lsrs	r2, r3, #1
90006dfc:	4b73      	ldr	r3, [pc, #460]	; (90006fcc <I2C_Compute_SCLL_SCLH+0x200>)
90006dfe:	4413      	add	r3, r2
90006e00:	4973      	ldr	r1, [pc, #460]	; (90006fd0 <I2C_Compute_SCLL_SCLH+0x204>)
90006e02:	683a      	ldr	r2, [r7, #0]
90006e04:	202c      	movs	r0, #44	; 0x2c
90006e06:	fb00 f202 	mul.w	r2, r0, r2
90006e0a:	440a      	add	r2, r1
90006e0c:	6812      	ldr	r2, [r2, #0]
90006e0e:	fbb3 f3f2 	udiv	r3, r3, r2
90006e12:	62bb      	str	r3, [r7, #40]	; 0x28

  tafdel_min = I2C_ANALOG_FILTER_DELAY_MIN;
90006e14:	2332      	movs	r3, #50	; 0x32
90006e16:	627b      	str	r3, [r7, #36]	; 0x24

  /* tDNF = DNF x tI2CCLK */
  dnf_delay = I2C_Charac[I2C_speed].dnf * ti2cclk;
90006e18:	4a6d      	ldr	r2, [pc, #436]	; (90006fd0 <I2C_Compute_SCLL_SCLH+0x204>)
90006e1a:	683b      	ldr	r3, [r7, #0]
90006e1c:	212c      	movs	r1, #44	; 0x2c
90006e1e:	fb01 f303 	mul.w	r3, r1, r3
90006e22:	4413      	add	r3, r2
90006e24:	3328      	adds	r3, #40	; 0x28
90006e26:	681a      	ldr	r2, [r3, #0]
90006e28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90006e2a:	fb02 f303 	mul.w	r3, r2, r3
90006e2e:	623b      	str	r3, [r7, #32]

  clk_max = SEC2NSEC / I2C_Charac[I2C_speed].freq_min;
90006e30:	4a67      	ldr	r2, [pc, #412]	; (90006fd0 <I2C_Compute_SCLL_SCLH+0x204>)
90006e32:	683b      	ldr	r3, [r7, #0]
90006e34:	212c      	movs	r1, #44	; 0x2c
90006e36:	fb01 f303 	mul.w	r3, r1, r3
90006e3a:	4413      	add	r3, r2
90006e3c:	3304      	adds	r3, #4
90006e3e:	681b      	ldr	r3, [r3, #0]
90006e40:	4a62      	ldr	r2, [pc, #392]	; (90006fcc <I2C_Compute_SCLL_SCLH+0x200>)
90006e42:	fbb2 f3f3 	udiv	r3, r2, r3
90006e46:	61fb      	str	r3, [r7, #28]
  clk_min = SEC2NSEC / I2C_Charac[I2C_speed].freq_max;
90006e48:	4a61      	ldr	r2, [pc, #388]	; (90006fd0 <I2C_Compute_SCLL_SCLH+0x204>)
90006e4a:	683b      	ldr	r3, [r7, #0]
90006e4c:	212c      	movs	r1, #44	; 0x2c
90006e4e:	fb01 f303 	mul.w	r3, r1, r3
90006e52:	4413      	add	r3, r2
90006e54:	3308      	adds	r3, #8
90006e56:	681b      	ldr	r3, [r3, #0]
90006e58:	4a5c      	ldr	r2, [pc, #368]	; (90006fcc <I2C_Compute_SCLL_SCLH+0x200>)
90006e5a:	fbb2 f3f3 	udiv	r3, r2, r3
90006e5e:	61bb      	str	r3, [r7, #24]

  prev_error = ti2cspeed;
90006e60:	6abb      	ldr	r3, [r7, #40]	; 0x28
90006e62:	643b      	str	r3, [r7, #64]	; 0x40

  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
90006e64:	2300      	movs	r3, #0
90006e66:	637b      	str	r3, [r7, #52]	; 0x34
90006e68:	e0a3      	b.n	90006fb2 <I2C_Compute_SCLL_SCLH+0x1e6>
  {
    /* tPRESC = (PRESC+1) x tI2CCLK*/
    uint32_t tpresc = (I2c_valid_timing[count].presc + 1U) * ti2cclk;
90006e6a:	495a      	ldr	r1, [pc, #360]	; (90006fd4 <I2C_Compute_SCLL_SCLH+0x208>)
90006e6c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
90006e6e:	4613      	mov	r3, r2
90006e70:	009b      	lsls	r3, r3, #2
90006e72:	4413      	add	r3, r2
90006e74:	009b      	lsls	r3, r3, #2
90006e76:	440b      	add	r3, r1
90006e78:	681b      	ldr	r3, [r3, #0]
90006e7a:	1c5a      	adds	r2, r3, #1
90006e7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90006e7e:	fb02 f303 	mul.w	r3, r2, r3
90006e82:	617b      	str	r3, [r7, #20]

    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
90006e84:	2300      	movs	r3, #0
90006e86:	63fb      	str	r3, [r7, #60]	; 0x3c
90006e88:	e08c      	b.n	90006fa4 <I2C_Compute_SCLL_SCLH+0x1d8>
    {
      /* tLOW(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLL+1) x tPRESC ] */
      uint32_t tscl_l = tafdel_min + dnf_delay + (2U * ti2cclk) + ((scll + 1U) * tpresc);
90006e8a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
90006e8c:	6a3b      	ldr	r3, [r7, #32]
90006e8e:	441a      	add	r2, r3
90006e90:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
90006e92:	3301      	adds	r3, #1
90006e94:	6979      	ldr	r1, [r7, #20]
90006e96:	fb01 f103 	mul.w	r1, r1, r3
90006e9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90006e9c:	005b      	lsls	r3, r3, #1
90006e9e:	440b      	add	r3, r1
90006ea0:	4413      	add	r3, r2
90006ea2:	613b      	str	r3, [r7, #16]


      /* The I2CCLK period tI2CCLK must respect the following conditions:
      tI2CCLK < (tLOW - tfilters) / 4 and tI2CCLK < tHIGH */
      if ((tscl_l > I2C_Charac[I2C_speed].lscl_min) && (ti2cclk < ((tscl_l - tafdel_min - dnf_delay) / 4U)))
90006ea4:	4a4a      	ldr	r2, [pc, #296]	; (90006fd0 <I2C_Compute_SCLL_SCLH+0x204>)
90006ea6:	683b      	ldr	r3, [r7, #0]
90006ea8:	212c      	movs	r1, #44	; 0x2c
90006eaa:	fb01 f303 	mul.w	r3, r1, r3
90006eae:	4413      	add	r3, r2
90006eb0:	3318      	adds	r3, #24
90006eb2:	681b      	ldr	r3, [r3, #0]
90006eb4:	693a      	ldr	r2, [r7, #16]
90006eb6:	429a      	cmp	r2, r3
90006eb8:	d971      	bls.n	90006f9e <I2C_Compute_SCLL_SCLH+0x1d2>
90006eba:	693a      	ldr	r2, [r7, #16]
90006ebc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90006ebe:	1ad2      	subs	r2, r2, r3
90006ec0:	6a3b      	ldr	r3, [r7, #32]
90006ec2:	1ad3      	subs	r3, r2, r3
90006ec4:	089b      	lsrs	r3, r3, #2
90006ec6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
90006ec8:	429a      	cmp	r2, r3
90006eca:	d268      	bcs.n	90006f9e <I2C_Compute_SCLL_SCLH+0x1d2>
      {
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
90006ecc:	2300      	movs	r3, #0
90006ece:	63bb      	str	r3, [r7, #56]	; 0x38
90006ed0:	e062      	b.n	90006f98 <I2C_Compute_SCLL_SCLH+0x1cc>
        {
          /* tHIGH(min) <= tAF(min) + tDNF + 2 x tI2CCLK + [(SCLH+1) x tPRESC] */
          uint32_t tscl_h = tafdel_min + dnf_delay + (2U * ti2cclk) + ((sclh + 1U) * tpresc);
90006ed2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
90006ed4:	6a3b      	ldr	r3, [r7, #32]
90006ed6:	441a      	add	r2, r3
90006ed8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90006eda:	3301      	adds	r3, #1
90006edc:	6979      	ldr	r1, [r7, #20]
90006ede:	fb01 f103 	mul.w	r1, r1, r3
90006ee2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90006ee4:	005b      	lsls	r3, r3, #1
90006ee6:	440b      	add	r3, r1
90006ee8:	4413      	add	r3, r2
90006eea:	60fb      	str	r3, [r7, #12]

          /* tSCL = tf + tLOW + tr + tHIGH */
          uint32_t tscl = tscl_l + tscl_h + I2C_Charac[I2C_speed].trise + I2C_Charac[I2C_speed].tfall;
90006eec:	693a      	ldr	r2, [r7, #16]
90006eee:	68fb      	ldr	r3, [r7, #12]
90006ef0:	441a      	add	r2, r3
90006ef2:	4937      	ldr	r1, [pc, #220]	; (90006fd0 <I2C_Compute_SCLL_SCLH+0x204>)
90006ef4:	683b      	ldr	r3, [r7, #0]
90006ef6:	202c      	movs	r0, #44	; 0x2c
90006ef8:	fb00 f303 	mul.w	r3, r0, r3
90006efc:	440b      	add	r3, r1
90006efe:	3320      	adds	r3, #32
90006f00:	681b      	ldr	r3, [r3, #0]
90006f02:	441a      	add	r2, r3
90006f04:	4932      	ldr	r1, [pc, #200]	; (90006fd0 <I2C_Compute_SCLL_SCLH+0x204>)
90006f06:	683b      	ldr	r3, [r7, #0]
90006f08:	202c      	movs	r0, #44	; 0x2c
90006f0a:	fb00 f303 	mul.w	r3, r0, r3
90006f0e:	440b      	add	r3, r1
90006f10:	3324      	adds	r3, #36	; 0x24
90006f12:	681b      	ldr	r3, [r3, #0]
90006f14:	4413      	add	r3, r2
90006f16:	60bb      	str	r3, [r7, #8]

          if ((tscl >= clk_min) && (tscl <= clk_max) && (tscl_h >= I2C_Charac[I2C_speed].hscl_min) && (ti2cclk < tscl_h))
90006f18:	68ba      	ldr	r2, [r7, #8]
90006f1a:	69bb      	ldr	r3, [r7, #24]
90006f1c:	429a      	cmp	r2, r3
90006f1e:	d338      	bcc.n	90006f92 <I2C_Compute_SCLL_SCLH+0x1c6>
90006f20:	68ba      	ldr	r2, [r7, #8]
90006f22:	69fb      	ldr	r3, [r7, #28]
90006f24:	429a      	cmp	r2, r3
90006f26:	d834      	bhi.n	90006f92 <I2C_Compute_SCLL_SCLH+0x1c6>
90006f28:	4a29      	ldr	r2, [pc, #164]	; (90006fd0 <I2C_Compute_SCLL_SCLH+0x204>)
90006f2a:	683b      	ldr	r3, [r7, #0]
90006f2c:	212c      	movs	r1, #44	; 0x2c
90006f2e:	fb01 f303 	mul.w	r3, r1, r3
90006f32:	4413      	add	r3, r2
90006f34:	331c      	adds	r3, #28
90006f36:	681b      	ldr	r3, [r3, #0]
90006f38:	68fa      	ldr	r2, [r7, #12]
90006f3a:	429a      	cmp	r2, r3
90006f3c:	d329      	bcc.n	90006f92 <I2C_Compute_SCLL_SCLH+0x1c6>
90006f3e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
90006f40:	68fb      	ldr	r3, [r7, #12]
90006f42:	429a      	cmp	r2, r3
90006f44:	d225      	bcs.n	90006f92 <I2C_Compute_SCLL_SCLH+0x1c6>
          {
            int32_t error = (int32_t)tscl - (int32_t)ti2cspeed;
90006f46:	68ba      	ldr	r2, [r7, #8]
90006f48:	6abb      	ldr	r3, [r7, #40]	; 0x28
90006f4a:	1ad3      	subs	r3, r2, r3
90006f4c:	633b      	str	r3, [r7, #48]	; 0x30

            if (error < 0)
90006f4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90006f50:	2b00      	cmp	r3, #0
90006f52:	da02      	bge.n	90006f5a <I2C_Compute_SCLL_SCLH+0x18e>
            {
              error = -error;
90006f54:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90006f56:	425b      	negs	r3, r3
90006f58:	633b      	str	r3, [r7, #48]	; 0x30
            }

            /* look for the timings with the lowest clock error */
            if ((uint32_t)error < prev_error)
90006f5a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90006f5c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
90006f5e:	429a      	cmp	r2, r3
90006f60:	d917      	bls.n	90006f92 <I2C_Compute_SCLL_SCLH+0x1c6>
            {
              prev_error = (uint32_t)error;
90006f62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90006f64:	643b      	str	r3, [r7, #64]	; 0x40
              I2c_valid_timing[count].scll = scll;
90006f66:	491b      	ldr	r1, [pc, #108]	; (90006fd4 <I2C_Compute_SCLL_SCLH+0x208>)
90006f68:	6b7a      	ldr	r2, [r7, #52]	; 0x34
90006f6a:	4613      	mov	r3, r2
90006f6c:	009b      	lsls	r3, r3, #2
90006f6e:	4413      	add	r3, r2
90006f70:	009b      	lsls	r3, r3, #2
90006f72:	440b      	add	r3, r1
90006f74:	3310      	adds	r3, #16
90006f76:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
90006f78:	601a      	str	r2, [r3, #0]
              I2c_valid_timing[count].sclh = sclh;
90006f7a:	4916      	ldr	r1, [pc, #88]	; (90006fd4 <I2C_Compute_SCLL_SCLH+0x208>)
90006f7c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
90006f7e:	4613      	mov	r3, r2
90006f80:	009b      	lsls	r3, r3, #2
90006f82:	4413      	add	r3, r2
90006f84:	009b      	lsls	r3, r3, #2
90006f86:	440b      	add	r3, r1
90006f88:	330c      	adds	r3, #12
90006f8a:	6bba      	ldr	r2, [r7, #56]	; 0x38
90006f8c:	601a      	str	r2, [r3, #0]
              ret = count;
90006f8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90006f90:	647b      	str	r3, [r7, #68]	; 0x44
        for (sclh = 0; sclh < I2C_SCLH_MAX; sclh++)
90006f92:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90006f94:	3301      	adds	r3, #1
90006f96:	63bb      	str	r3, [r7, #56]	; 0x38
90006f98:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90006f9a:	2bff      	cmp	r3, #255	; 0xff
90006f9c:	d999      	bls.n	90006ed2 <I2C_Compute_SCLL_SCLH+0x106>
    for (scll = 0; scll < I2C_SCLL_MAX; scll++)
90006f9e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
90006fa0:	3301      	adds	r3, #1
90006fa2:	63fb      	str	r3, [r7, #60]	; 0x3c
90006fa4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
90006fa6:	2bff      	cmp	r3, #255	; 0xff
90006fa8:	f67f af6f 	bls.w	90006e8a <I2C_Compute_SCLL_SCLH+0xbe>
  for (uint32_t count = 0; count < I2c_valid_timing_nbr; count++)
90006fac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90006fae:	3301      	adds	r3, #1
90006fb0:	637b      	str	r3, [r7, #52]	; 0x34
90006fb2:	4b09      	ldr	r3, [pc, #36]	; (90006fd8 <I2C_Compute_SCLL_SCLH+0x20c>)
90006fb4:	681b      	ldr	r3, [r3, #0]
90006fb6:	6b7a      	ldr	r2, [r7, #52]	; 0x34
90006fb8:	429a      	cmp	r2, r3
90006fba:	f4ff af56 	bcc.w	90006e6a <I2C_Compute_SCLL_SCLH+0x9e>
        }
      }
    }
  }

  return ret;
90006fbe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
90006fc0:	4618      	mov	r0, r3
90006fc2:	374c      	adds	r7, #76	; 0x4c
90006fc4:	46bd      	mov	sp, r7
90006fc6:	f85d 7b04 	ldr.w	r7, [sp], #4
90006fca:	4770      	bx	lr
90006fcc:	3b9aca00 	.word	0x3b9aca00
90006fd0:	9001e7f8 	.word	0x9001e7f8
90006fd4:	240013ec 	.word	0x240013ec
90006fd8:	24001dec 	.word	0x24001dec

90006fdc <I2C4_MspInit>:
  * @brief  Initializes I2C MSP.
  * @param  phi2c  I2C handler
  * @retval None
  */
static void I2C4_MspInit(I2C_HandleTypeDef *phi2c)
{
90006fdc:	b580      	push	{r7, lr}
90006fde:	b08a      	sub	sp, #40	; 0x28
90006fe0:	af00      	add	r7, sp, #0
90006fe2:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(phi2c);

  /*** Configure the GPIOs ***/
  /* Enable SCL GPIO clock */
  BUS_I2C4_SCL_GPIO_CLK_ENABLE();
90006fe4:	4b31      	ldr	r3, [pc, #196]	; (900070ac <I2C4_MspInit+0xd0>)
90006fe6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006fea:	4a30      	ldr	r2, [pc, #192]	; (900070ac <I2C4_MspInit+0xd0>)
90006fec:	f043 0308 	orr.w	r3, r3, #8
90006ff0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90006ff4:	4b2d      	ldr	r3, [pc, #180]	; (900070ac <I2C4_MspInit+0xd0>)
90006ff6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90006ffa:	f003 0308 	and.w	r3, r3, #8
90006ffe:	613b      	str	r3, [r7, #16]
90007000:	693b      	ldr	r3, [r7, #16]
  /* Enable SDA GPIO clock */
  BUS_I2C4_SDA_GPIO_CLK_ENABLE();
90007002:	4b2a      	ldr	r3, [pc, #168]	; (900070ac <I2C4_MspInit+0xd0>)
90007004:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007008:	4a28      	ldr	r2, [pc, #160]	; (900070ac <I2C4_MspInit+0xd0>)
9000700a:	f043 0308 	orr.w	r3, r3, #8
9000700e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90007012:	4b26      	ldr	r3, [pc, #152]	; (900070ac <I2C4_MspInit+0xd0>)
90007014:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007018:	f003 0308 	and.w	r3, r3, #8
9000701c:	60fb      	str	r3, [r7, #12]
9000701e:	68fb      	ldr	r3, [r7, #12]

  /* Configure I2C Tx as alternate function */
  gpio_init_structure.Pin       = BUS_I2C4_SCL_PIN;
90007020:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90007024:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
90007026:	2312      	movs	r3, #18
90007028:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Pull      = GPIO_NOPULL;
9000702a:	2300      	movs	r3, #0
9000702c:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
9000702e:	2302      	movs	r3, #2
90007030:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Alternate = BUS_I2C4_SCL_AF;
90007032:	2304      	movs	r3, #4
90007034:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(BUS_I2C4_SCL_GPIO_PORT, &gpio_init_structure);
90007036:	f107 0314 	add.w	r3, r7, #20
9000703a:	4619      	mov	r1, r3
9000703c:	481c      	ldr	r0, [pc, #112]	; (900070b0 <I2C4_MspInit+0xd4>)
9000703e:	f005 fdd3 	bl	9000cbe8 <HAL_GPIO_Init>

  /* Configure I2C Rx as alternate function */
  gpio_init_structure.Pin       = BUS_I2C4_SDA_PIN;
90007042:	f44f 5300 	mov.w	r3, #8192	; 0x2000
90007046:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Mode      = GPIO_MODE_AF_OD;
90007048:	2312      	movs	r3, #18
9000704a:	61bb      	str	r3, [r7, #24]
  gpio_init_structure.Pull      = GPIO_NOPULL;
9000704c:	2300      	movs	r3, #0
9000704e:	61fb      	str	r3, [r7, #28]
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
90007050:	2302      	movs	r3, #2
90007052:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Alternate = BUS_I2C4_SDA_AF;
90007054:	2304      	movs	r3, #4
90007056:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(BUS_I2C4_SDA_GPIO_PORT, &gpio_init_structure);
90007058:	f107 0314 	add.w	r3, r7, #20
9000705c:	4619      	mov	r1, r3
9000705e:	4814      	ldr	r0, [pc, #80]	; (900070b0 <I2C4_MspInit+0xd4>)
90007060:	f005 fdc2 	bl	9000cbe8 <HAL_GPIO_Init>

  /*** Configure the I2C peripheral ***/
  /* Enable I2C clock */
  BUS_I2C4_CLK_ENABLE();
90007064:	4b11      	ldr	r3, [pc, #68]	; (900070ac <I2C4_MspInit+0xd0>)
90007066:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
9000706a:	4a10      	ldr	r2, [pc, #64]	; (900070ac <I2C4_MspInit+0xd0>)
9000706c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90007070:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
90007074:	4b0d      	ldr	r3, [pc, #52]	; (900070ac <I2C4_MspInit+0xd0>)
90007076:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
9000707a:	f003 0380 	and.w	r3, r3, #128	; 0x80
9000707e:	60bb      	str	r3, [r7, #8]
90007080:	68bb      	ldr	r3, [r7, #8]

  /* Force the I2C peripheral clock reset */
  BUS_I2C4_FORCE_RESET();
90007082:	4b0a      	ldr	r3, [pc, #40]	; (900070ac <I2C4_MspInit+0xd0>)
90007084:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
90007088:	4a08      	ldr	r2, [pc, #32]	; (900070ac <I2C4_MspInit+0xd0>)
9000708a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
9000708e:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c

  /* Release the I2C peripheral clock reset */
  BUS_I2C4_RELEASE_RESET();
90007092:	4b06      	ldr	r3, [pc, #24]	; (900070ac <I2C4_MspInit+0xd0>)
90007094:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
90007098:	4a04      	ldr	r2, [pc, #16]	; (900070ac <I2C4_MspInit+0xd0>)
9000709a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
9000709e:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
}
900070a2:	bf00      	nop
900070a4:	3728      	adds	r7, #40	; 0x28
900070a6:	46bd      	mov	sp, r7
900070a8:	bd80      	pop	{r7, pc}
900070aa:	bf00      	nop
900070ac:	58024400 	.word	0x58024400
900070b0:	58020c00 	.word	0x58020c00

900070b4 <I2C4_MspDeInit>:
  * @brief  DeInitializes I2C MSP.
  * @param  phi2c  I2C handler
  * @retval None
  */
static void I2C4_MspDeInit(I2C_HandleTypeDef *phi2c)
{
900070b4:	b580      	push	{r7, lr}
900070b6:	b088      	sub	sp, #32
900070b8:	af00      	add	r7, sp, #0
900070ba:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(phi2c);

  /* Configure I2C Tx, Rx as alternate function */
  gpio_init_structure.Pin = BUS_I2C4_SCL_PIN;
900070bc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900070c0:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_DeInit(BUS_I2C4_SCL_GPIO_PORT, gpio_init_structure.Pin );
900070c2:	68fb      	ldr	r3, [r7, #12]
900070c4:	4619      	mov	r1, r3
900070c6:	480b      	ldr	r0, [pc, #44]	; (900070f4 <I2C4_MspDeInit+0x40>)
900070c8:	f005 ff3e 	bl	9000cf48 <HAL_GPIO_DeInit>
  gpio_init_structure.Pin = BUS_I2C4_SDA_PIN;
900070cc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
900070d0:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_DeInit(BUS_I2C4_SDA_GPIO_PORT, gpio_init_structure.Pin);
900070d2:	68fb      	ldr	r3, [r7, #12]
900070d4:	4619      	mov	r1, r3
900070d6:	4807      	ldr	r0, [pc, #28]	; (900070f4 <I2C4_MspDeInit+0x40>)
900070d8:	f005 ff36 	bl	9000cf48 <HAL_GPIO_DeInit>

  /* Disable I2C clock */
  BUS_I2C4_CLK_DISABLE();
900070dc:	4b06      	ldr	r3, [pc, #24]	; (900070f8 <I2C4_MspDeInit+0x44>)
900070de:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
900070e2:	4a05      	ldr	r2, [pc, #20]	; (900070f8 <I2C4_MspDeInit+0x44>)
900070e4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
900070e8:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
}
900070ec:	bf00      	nop
900070ee:	3720      	adds	r7, #32
900070f0:	46bd      	mov	sp, r7
900070f2:	bd80      	pop	{r7, pc}
900070f4:	58020c00 	.word	0x58020c00
900070f8:	58024400 	.word	0x58024400

900070fc <I2C4_WriteReg>:
  * @param  pData      The target register value to be written
  * @param  Length     data length in bytes
  * @retval BSP status
  */
static int32_t I2C4_WriteReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{
900070fc:	b580      	push	{r7, lr}
900070fe:	b088      	sub	sp, #32
90007100:	af04      	add	r7, sp, #16
90007102:	607b      	str	r3, [r7, #4]
90007104:	4603      	mov	r3, r0
90007106:	81fb      	strh	r3, [r7, #14]
90007108:	460b      	mov	r3, r1
9000710a:	81bb      	strh	r3, [r7, #12]
9000710c:	4613      	mov	r3, r2
9000710e:	817b      	strh	r3, [r7, #10]
  if(HAL_I2C_Mem_Write(&hbus_i2c4, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
90007110:	8978      	ldrh	r0, [r7, #10]
90007112:	89ba      	ldrh	r2, [r7, #12]
90007114:	89f9      	ldrh	r1, [r7, #14]
90007116:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
9000711a:	9302      	str	r3, [sp, #8]
9000711c:	8b3b      	ldrh	r3, [r7, #24]
9000711e:	9301      	str	r3, [sp, #4]
90007120:	687b      	ldr	r3, [r7, #4]
90007122:	9300      	str	r3, [sp, #0]
90007124:	4603      	mov	r3, r0
90007126:	4807      	ldr	r0, [pc, #28]	; (90007144 <I2C4_WriteReg+0x48>)
90007128:	f006 f91e 	bl	9000d368 <HAL_I2C_Mem_Write>
9000712c:	4603      	mov	r3, r0
9000712e:	2b00      	cmp	r3, #0
90007130:	d101      	bne.n	90007136 <I2C4_WriteReg+0x3a>
  {
    return BSP_ERROR_NONE;
90007132:	2300      	movs	r3, #0
90007134:	e001      	b.n	9000713a <I2C4_WriteReg+0x3e>
  }

  return BSP_ERROR_BUS_FAILURE;
90007136:	f06f 0307 	mvn.w	r3, #7
}
9000713a:	4618      	mov	r0, r3
9000713c:	3710      	adds	r7, #16
9000713e:	46bd      	mov	sp, r7
90007140:	bd80      	pop	{r7, pc}
90007142:	bf00      	nop
90007144:	24002a30 	.word	0x24002a30

90007148 <I2C4_ReadReg>:
  * @param  pData      The target register value to be read
  * @param  Length     data length in bytes
  * @retval BSP status
  */
static int32_t I2C4_ReadReg(uint16_t DevAddr, uint16_t Reg, uint16_t MemAddSize, uint8_t *pData, uint16_t Length)
{
90007148:	b580      	push	{r7, lr}
9000714a:	b088      	sub	sp, #32
9000714c:	af04      	add	r7, sp, #16
9000714e:	607b      	str	r3, [r7, #4]
90007150:	4603      	mov	r3, r0
90007152:	81fb      	strh	r3, [r7, #14]
90007154:	460b      	mov	r3, r1
90007156:	81bb      	strh	r3, [r7, #12]
90007158:	4613      	mov	r3, r2
9000715a:	817b      	strh	r3, [r7, #10]
  if (HAL_I2C_Mem_Read(&hbus_i2c4, DevAddr, Reg, MemAddSize, pData, Length, 1000) == HAL_OK)
9000715c:	8978      	ldrh	r0, [r7, #10]
9000715e:	89ba      	ldrh	r2, [r7, #12]
90007160:	89f9      	ldrh	r1, [r7, #14]
90007162:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
90007166:	9302      	str	r3, [sp, #8]
90007168:	8b3b      	ldrh	r3, [r7, #24]
9000716a:	9301      	str	r3, [sp, #4]
9000716c:	687b      	ldr	r3, [r7, #4]
9000716e:	9300      	str	r3, [sp, #0]
90007170:	4603      	mov	r3, r0
90007172:	4807      	ldr	r0, [pc, #28]	; (90007190 <I2C4_ReadReg+0x48>)
90007174:	f006 fa0c 	bl	9000d590 <HAL_I2C_Mem_Read>
90007178:	4603      	mov	r3, r0
9000717a:	2b00      	cmp	r3, #0
9000717c:	d101      	bne.n	90007182 <I2C4_ReadReg+0x3a>
  {
    return BSP_ERROR_NONE;
9000717e:	2300      	movs	r3, #0
90007180:	e001      	b.n	90007186 <I2C4_ReadReg+0x3e>
  }

  return BSP_ERROR_BUS_FAILURE;
90007182:	f06f 0307 	mvn.w	r3, #7
}
90007186:	4618      	mov	r0, r3
90007188:	3710      	adds	r7, #16
9000718a:	46bd      	mov	sp, r7
9000718c:	bd80      	pop	{r7, pc}
9000718e:	bf00      	nop
90007190:	24002a30 	.word	0x24002a30

90007194 <BSP_LCD_Init>:
  * @param  Instance    LCD Instance
  * @param  Orientation LCD_ORIENTATION_LANDSCAPE
  * @retval BSP status
  */
int32_t BSP_LCD_Init(uint32_t Instance, uint32_t Orientation)
{
90007194:	b580      	push	{r7, lr}
90007196:	b084      	sub	sp, #16
90007198:	af02      	add	r7, sp, #8
9000719a:	6078      	str	r0, [r7, #4]
9000719c:	6039      	str	r1, [r7, #0]
  return BSP_LCD_InitEx(Instance, Orientation, LTDC_PIXEL_FORMAT_ARGB8888, LCD_DEFAULT_WIDTH, LCD_DEFAULT_HEIGHT);
9000719e:	f44f 7388 	mov.w	r3, #272	; 0x110
900071a2:	9300      	str	r3, [sp, #0]
900071a4:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
900071a8:	2200      	movs	r2, #0
900071aa:	6839      	ldr	r1, [r7, #0]
900071ac:	6878      	ldr	r0, [r7, #4]
900071ae:	f000 f805 	bl	900071bc <BSP_LCD_InitEx>
900071b2:	4603      	mov	r3, r0
}
900071b4:	4618      	mov	r0, r3
900071b6:	3708      	adds	r7, #8
900071b8:	46bd      	mov	sp, r7
900071ba:	bd80      	pop	{r7, pc}

900071bc <BSP_LCD_InitEx>:
  * @param  Width       Display width
  * @param  Height      Display height
  * @retval BSP status
  */
int32_t BSP_LCD_InitEx(uint32_t Instance, uint32_t Orientation, uint32_t PixelFormat, uint32_t Width, uint32_t Height)
{
900071bc:	b580      	push	{r7, lr}
900071be:	b09e      	sub	sp, #120	; 0x78
900071c0:	af00      	add	r7, sp, #0
900071c2:	60f8      	str	r0, [r7, #12]
900071c4:	60b9      	str	r1, [r7, #8]
900071c6:	607a      	str	r2, [r7, #4]
900071c8:	603b      	str	r3, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
900071ca:	2300      	movs	r3, #0
900071cc:	677b      	str	r3, [r7, #116]	; 0x74
  uint32_t ltdc_pixel_format;
  uint32_t ft5336_id = 0;
900071ce:	2300      	movs	r3, #0
900071d0:	66fb      	str	r3, [r7, #108]	; 0x6c
  FT5336_Object_t ts_comp_obj;
  FT5336_IO_t     io_comp_ctx;
  MX_LTDC_LayerConfig_t config;

  if((Orientation > LCD_ORIENTATION_LANDSCAPE) || (Instance >= LCD_INSTANCES_NBR) || \
900071d2:	68bb      	ldr	r3, [r7, #8]
900071d4:	2b01      	cmp	r3, #1
900071d6:	d808      	bhi.n	900071ea <BSP_LCD_InitEx+0x2e>
900071d8:	68fb      	ldr	r3, [r7, #12]
900071da:	2b00      	cmp	r3, #0
900071dc:	d105      	bne.n	900071ea <BSP_LCD_InitEx+0x2e>
900071de:	687b      	ldr	r3, [r7, #4]
900071e0:	2b02      	cmp	r3, #2
900071e2:	d006      	beq.n	900071f2 <BSP_LCD_InitEx+0x36>
     ((PixelFormat != LCD_PIXEL_FORMAT_RGB565) && (PixelFormat != LTDC_PIXEL_FORMAT_ARGB8888)))
900071e4:	687b      	ldr	r3, [r7, #4]
900071e6:	2b00      	cmp	r3, #0
900071e8:	d003      	beq.n	900071f2 <BSP_LCD_InitEx+0x36>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900071ea:	f06f 0301 	mvn.w	r3, #1
900071ee:	677b      	str	r3, [r7, #116]	; 0x74
900071f0:	e0a8      	b.n	90007344 <BSP_LCD_InitEx+0x188>
  }
  else
  {
    if(PixelFormat == LCD_PIXEL_FORMAT_RGB565)
900071f2:	687b      	ldr	r3, [r7, #4]
900071f4:	2b02      	cmp	r3, #2
900071f6:	d109      	bne.n	9000720c <BSP_LCD_InitEx+0x50>
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_RGB565;
900071f8:	2302      	movs	r3, #2
900071fa:	673b      	str	r3, [r7, #112]	; 0x70
      Lcd_Ctx[Instance].BppFactor = 2U;
900071fc:	4a54      	ldr	r2, [pc, #336]	; (90007350 <BSP_LCD_InitEx+0x194>)
900071fe:	68fb      	ldr	r3, [r7, #12]
90007200:	015b      	lsls	r3, r3, #5
90007202:	4413      	add	r3, r2
90007204:	3310      	adds	r3, #16
90007206:	2202      	movs	r2, #2
90007208:	601a      	str	r2, [r3, #0]
9000720a:	e008      	b.n	9000721e <BSP_LCD_InitEx+0x62>
    }
    else /* LCD_PIXEL_FORMAT_RGB888 */
    {
      ltdc_pixel_format = LTDC_PIXEL_FORMAT_ARGB8888;
9000720c:	2300      	movs	r3, #0
9000720e:	673b      	str	r3, [r7, #112]	; 0x70
      Lcd_Ctx[Instance].BppFactor = 4U;
90007210:	4a4f      	ldr	r2, [pc, #316]	; (90007350 <BSP_LCD_InitEx+0x194>)
90007212:	68fb      	ldr	r3, [r7, #12]
90007214:	015b      	lsls	r3, r3, #5
90007216:	4413      	add	r3, r2
90007218:	3310      	adds	r3, #16
9000721a:	2204      	movs	r2, #4
9000721c:	601a      	str	r2, [r3, #0]
    }

    /* Store pixel format, xsize and ysize information */
    Lcd_Ctx[Instance].PixelFormat = PixelFormat;
9000721e:	4a4c      	ldr	r2, [pc, #304]	; (90007350 <BSP_LCD_InitEx+0x194>)
90007220:	68fb      	ldr	r3, [r7, #12]
90007222:	015b      	lsls	r3, r3, #5
90007224:	4413      	add	r3, r2
90007226:	330c      	adds	r3, #12
90007228:	687a      	ldr	r2, [r7, #4]
9000722a:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].XSize  = Width;
9000722c:	4a48      	ldr	r2, [pc, #288]	; (90007350 <BSP_LCD_InitEx+0x194>)
9000722e:	68fb      	ldr	r3, [r7, #12]
90007230:	015b      	lsls	r3, r3, #5
90007232:	4413      	add	r3, r2
90007234:	683a      	ldr	r2, [r7, #0]
90007236:	601a      	str	r2, [r3, #0]
    Lcd_Ctx[Instance].YSize  = Height;
90007238:	4a45      	ldr	r2, [pc, #276]	; (90007350 <BSP_LCD_InitEx+0x194>)
9000723a:	68fb      	ldr	r3, [r7, #12]
9000723c:	015b      	lsls	r3, r3, #5
9000723e:	4413      	add	r3, r2
90007240:	3304      	adds	r3, #4
90007242:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
90007246:	601a      	str	r2, [r3, #0]

    /* Initializes peripherals instance value */
    hlcd_ltdc.Instance = LTDC;
90007248:	4b42      	ldr	r3, [pc, #264]	; (90007354 <BSP_LCD_InitEx+0x198>)
9000724a:	4a43      	ldr	r2, [pc, #268]	; (90007358 <BSP_LCD_InitEx+0x19c>)
9000724c:	601a      	str	r2, [r3, #0]
    hlcd_dma2d.Instance = DMA2D;
9000724e:	4b43      	ldr	r3, [pc, #268]	; (9000735c <BSP_LCD_InitEx+0x1a0>)
90007250:	4a43      	ldr	r2, [pc, #268]	; (90007360 <BSP_LCD_InitEx+0x1a4>)
90007252:	601a      	str	r2, [r3, #0]
      {
        return BSP_ERROR_PERIPH_FAILURE;
      }
    }
#else
    LTDC_MspInit(&hlcd_ltdc);
90007254:	483f      	ldr	r0, [pc, #252]	; (90007354 <BSP_LCD_InitEx+0x198>)
90007256:	f000 fda5 	bl	90007da4 <LTDC_MspInit>
#endif

    DMA2D_MspInit(&hlcd_dma2d);
9000725a:	4840      	ldr	r0, [pc, #256]	; (9000735c <BSP_LCD_InitEx+0x1a0>)
9000725c:	f000 feac 	bl	90007fb8 <DMA2D_MspInit>

      io_comp_ctx.Init    = BSP_I2C4_Init;
90007260:	4b40      	ldr	r3, [pc, #256]	; (90007364 <BSP_LCD_InitEx+0x1a8>)
90007262:	62fb      	str	r3, [r7, #44]	; 0x2c
      io_comp_ctx.ReadReg = BSP_I2C4_ReadReg;
90007264:	4b40      	ldr	r3, [pc, #256]	; (90007368 <BSP_LCD_InitEx+0x1ac>)
90007266:	63fb      	str	r3, [r7, #60]	; 0x3c
      io_comp_ctx.Address = TS_I2C_ADDRESS;
90007268:	2370      	movs	r3, #112	; 0x70
9000726a:	86bb      	strh	r3, [r7, #52]	; 0x34
      if(FT5336_RegisterBusIO(&ts_comp_obj, &io_comp_ctx) < 0)
9000726c:	f107 022c 	add.w	r2, r7, #44	; 0x2c
90007270:	f107 0344 	add.w	r3, r7, #68	; 0x44
90007274:	4611      	mov	r1, r2
90007276:	4618      	mov	r0, r3
90007278:	f7fb f97e 	bl	90002578 <FT5336_RegisterBusIO>
9000727c:	4603      	mov	r3, r0
9000727e:	2b00      	cmp	r3, #0
90007280:	da03      	bge.n	9000728a <BSP_LCD_InitEx+0xce>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
90007282:	f06f 0304 	mvn.w	r3, #4
90007286:	677b      	str	r3, [r7, #116]	; 0x74
90007288:	e02b      	b.n	900072e2 <BSP_LCD_InitEx+0x126>
      }
      else if(FT5336_ReadID(&ts_comp_obj, &ft5336_id) < 0)
9000728a:	f107 026c 	add.w	r2, r7, #108	; 0x6c
9000728e:	f107 0344 	add.w	r3, r7, #68	; 0x44
90007292:	4611      	mov	r1, r2
90007294:	4618      	mov	r0, r3
90007296:	f7fb fa69 	bl	9000276c <FT5336_ReadID>
9000729a:	4603      	mov	r3, r0
9000729c:	2b00      	cmp	r3, #0
9000729e:	da03      	bge.n	900072a8 <BSP_LCD_InitEx+0xec>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
900072a0:	f06f 0304 	mvn.w	r3, #4
900072a4:	677b      	str	r3, [r7, #116]	; 0x74
900072a6:	e01c      	b.n	900072e2 <BSP_LCD_InitEx+0x126>
      }
      else if(ft5336_id != FT5336_ID)
900072a8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
900072aa:	2b51      	cmp	r3, #81	; 0x51
900072ac:	d003      	beq.n	900072b6 <BSP_LCD_InitEx+0xfa>
      {
        ret = BSP_ERROR_UNKNOWN_COMPONENT;
900072ae:	f06f 0306 	mvn.w	r3, #6
900072b2:	677b      	str	r3, [r7, #116]	; 0x74
900072b4:	e015      	b.n	900072e2 <BSP_LCD_InitEx+0x126>
      }
    else if(MX_LTDC_ClockConfig(&hlcd_ltdc) != HAL_OK)
900072b6:	4827      	ldr	r0, [pc, #156]	; (90007354 <BSP_LCD_InitEx+0x198>)
900072b8:	f000 f920 	bl	900074fc <MX_LTDC_ClockConfig>
900072bc:	4603      	mov	r3, r0
900072be:	2b00      	cmp	r3, #0
900072c0:	d003      	beq.n	900072ca <BSP_LCD_InitEx+0x10e>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
900072c2:	f06f 0303 	mvn.w	r3, #3
900072c6:	677b      	str	r3, [r7, #116]	; 0x74
900072c8:	e00b      	b.n	900072e2 <BSP_LCD_InitEx+0x126>
    }
    else
    {
    if(MX_LTDC_Init(&hlcd_ltdc, Width, Height) != HAL_OK)
900072ca:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
900072ce:	6839      	ldr	r1, [r7, #0]
900072d0:	4820      	ldr	r0, [pc, #128]	; (90007354 <BSP_LCD_InitEx+0x198>)
900072d2:	f000 f885 	bl	900073e0 <MX_LTDC_Init>
900072d6:	4603      	mov	r3, r0
900072d8:	2b00      	cmp	r3, #0
900072da:	d002      	beq.n	900072e2 <BSP_LCD_InitEx+0x126>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
900072dc:	f06f 0303 	mvn.w	r3, #3
900072e0:	677b      	str	r3, [r7, #116]	; 0x74
    }
    }

    if(ret == BSP_ERROR_NONE)
900072e2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
900072e4:	2b00      	cmp	r3, #0
900072e6:	d12d      	bne.n	90007344 <BSP_LCD_InitEx+0x188>
    {
      /* Before configuring LTDC layer, ensure SDRAM is initialized */
#if !defined(DATA_IN_ExtSDRAM)
      /* Initialize the SDRAM */
      if(BSP_SDRAM_Init(0) != BSP_ERROR_NONE)
900072e8:	2000      	movs	r0, #0
900072ea:	f001 f8bd 	bl	90008468 <BSP_SDRAM_Init>
900072ee:	4603      	mov	r3, r0
900072f0:	2b00      	cmp	r3, #0
900072f2:	d002      	beq.n	900072fa <BSP_LCD_InitEx+0x13e>
      {
        return BSP_ERROR_PERIPH_FAILURE;
900072f4:	f06f 0303 	mvn.w	r3, #3
900072f8:	e025      	b.n	90007346 <BSP_LCD_InitEx+0x18a>
      }
#endif /* DATA_IN_ExtSDRAM */

      /* Configure default LTDC Layer 0. This configuration can be override by calling
      BSP_LCD_ConfigLayer() at application level */
      config.X0          = 0;
900072fa:	2300      	movs	r3, #0
900072fc:	617b      	str	r3, [r7, #20]
      config.X1          = Width;
900072fe:	683b      	ldr	r3, [r7, #0]
90007300:	61bb      	str	r3, [r7, #24]
      config.Y0          = 0;
90007302:	2300      	movs	r3, #0
90007304:	61fb      	str	r3, [r7, #28]
      config.Y1          = Height;
90007306:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
9000730a:	623b      	str	r3, [r7, #32]
      config.PixelFormat = ltdc_pixel_format;
9000730c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
9000730e:	627b      	str	r3, [r7, #36]	; 0x24
      config.Address     = LCD_LAYER_0_ADDRESS;
90007310:	f04f 4350 	mov.w	r3, #3489660928	; 0xd0000000
90007314:	62bb      	str	r3, [r7, #40]	; 0x28
      if(MX_LTDC_ConfigLayer(&hlcd_ltdc, 0, &config) != HAL_OK)
90007316:	f107 0314 	add.w	r3, r7, #20
9000731a:	461a      	mov	r2, r3
9000731c:	2100      	movs	r1, #0
9000731e:	480d      	ldr	r0, [pc, #52]	; (90007354 <BSP_LCD_InitEx+0x198>)
90007320:	f000 f8aa 	bl	90007478 <MX_LTDC_ConfigLayer>
90007324:	4603      	mov	r3, r0
90007326:	2b00      	cmp	r3, #0
90007328:	d002      	beq.n	90007330 <BSP_LCD_InitEx+0x174>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
9000732a:	f06f 0303 	mvn.w	r3, #3
9000732e:	677b      	str	r3, [r7, #116]	; 0x74
      }

      /* Initialize TIM in PWM mode to control brightness */
      TIMx_PWM_Init(&hlcd_tim);
90007330:	480e      	ldr	r0, [pc, #56]	; (9000736c <BSP_LCD_InitEx+0x1b0>)
90007332:	f000 fee7 	bl	90008104 <TIMx_PWM_Init>

      /* By default the reload is activated and executed immediately */
      Lcd_Ctx[Instance].ReloadEnable = 1U;
90007336:	4a06      	ldr	r2, [pc, #24]	; (90007350 <BSP_LCD_InitEx+0x194>)
90007338:	68fb      	ldr	r3, [r7, #12]
9000733a:	015b      	lsls	r3, r3, #5
9000733c:	4413      	add	r3, r2
9000733e:	3318      	adds	r3, #24
90007340:	2201      	movs	r2, #1
90007342:	601a      	str	r2, [r3, #0]
    }
  }

  return ret;
90007344:	6f7b      	ldr	r3, [r7, #116]	; 0x74
}
90007346:	4618      	mov	r0, r3
90007348:	3778      	adds	r7, #120	; 0x78
9000734a:	46bd      	mov	sp, r7
9000734c:	bd80      	pop	{r7, pc}
9000734e:	bf00      	nop
90007350:	24002b24 	.word	0x24002b24
90007354:	24002a7c 	.word	0x24002a7c
90007358:	50001000 	.word	0x50001000
9000735c:	24002b44 	.word	0x24002b44
90007360:	52001000 	.word	0x52001000
90007364:	90006831 	.word	0x90006831
90007368:	900069cd 	.word	0x900069cd
9000736c:	24001df0 	.word	0x24001df0

90007370 <BSP_LCD_DeInit>:
  * @brief  De-Initializes the LCD resources.
  * @param  Instance    LCD Instance
  * @retval BSP status
  */
int32_t BSP_LCD_DeInit(uint32_t Instance)
{
90007370:	b580      	push	{r7, lr}
90007372:	b084      	sub	sp, #16
90007374:	af00      	add	r7, sp, #0
90007376:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
90007378:	2300      	movs	r3, #0
9000737a:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
9000737c:	687b      	ldr	r3, [r7, #4]
9000737e:	2b00      	cmp	r3, #0
90007380:	d003      	beq.n	9000738a <BSP_LCD_DeInit+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90007382:	f06f 0301 	mvn.w	r3, #1
90007386:	60fb      	str	r3, [r7, #12]
90007388:	e01c      	b.n	900073c4 <BSP_LCD_DeInit+0x54>
  }
  else
  {

#if (USE_HAL_LTDC_REGISTER_CALLBACKS == 0)
    LTDC_MspDeInit(&hlcd_ltdc);
9000738a:	4811      	ldr	r0, [pc, #68]	; (900073d0 <BSP_LCD_DeInit+0x60>)
9000738c:	f000 fdd6 	bl	90007f3c <LTDC_MspDeInit>
#endif /* (USE_HAL_LTDC_REGISTER_CALLBACKS == 0) */

    DMA2D_MspDeInit(&hlcd_dma2d);
90007390:	4810      	ldr	r0, [pc, #64]	; (900073d4 <BSP_LCD_DeInit+0x64>)
90007392:	f000 fe3f 	bl	90008014 <DMA2D_MspDeInit>

    (void)HAL_LTDC_DeInit(&hlcd_ltdc);
90007396:	480e      	ldr	r0, [pc, #56]	; (900073d0 <BSP_LCD_DeInit+0x60>)
90007398:	f006 fe3c 	bl	9000e014 <HAL_LTDC_DeInit>
    if(HAL_DMA2D_DeInit(&hlcd_dma2d) != HAL_OK)
9000739c:	480d      	ldr	r0, [pc, #52]	; (900073d4 <BSP_LCD_DeInit+0x64>)
9000739e:	f005 f837 	bl	9000c410 <HAL_DMA2D_DeInit>
900073a2:	4603      	mov	r3, r0
900073a4:	2b00      	cmp	r3, #0
900073a6:	d003      	beq.n	900073b0 <BSP_LCD_DeInit+0x40>
    {
      ret = BSP_ERROR_PERIPH_FAILURE;
900073a8:	f06f 0303 	mvn.w	r3, #3
900073ac:	60fb      	str	r3, [r7, #12]
900073ae:	e009      	b.n	900073c4 <BSP_LCD_DeInit+0x54>
    }
    else
    {
      /* DeInit TIM PWM */
      TIMx_PWM_DeInit(&hlcd_tim);
900073b0:	4809      	ldr	r0, [pc, #36]	; (900073d8 <BSP_LCD_DeInit+0x68>)
900073b2:	f000 fed1 	bl	90008158 <TIMx_PWM_DeInit>

      Lcd_Ctx[Instance].IsMspCallbacksValid = 0;
900073b6:	4a09      	ldr	r2, [pc, #36]	; (900073dc <BSP_LCD_DeInit+0x6c>)
900073b8:	687b      	ldr	r3, [r7, #4]
900073ba:	015b      	lsls	r3, r3, #5
900073bc:	4413      	add	r3, r2
900073be:	3314      	adds	r3, #20
900073c0:	2200      	movs	r2, #0
900073c2:	601a      	str	r2, [r3, #0]
    }
  }

  return ret;
900073c4:	68fb      	ldr	r3, [r7, #12]
}
900073c6:	4618      	mov	r0, r3
900073c8:	3710      	adds	r7, #16
900073ca:	46bd      	mov	sp, r7
900073cc:	bd80      	pop	{r7, pc}
900073ce:	bf00      	nop
900073d0:	24002a7c 	.word	0x24002a7c
900073d4:	24002b44 	.word	0x24002b44
900073d8:	24001df0 	.word	0x24001df0
900073dc:	24002b24 	.word	0x24002b24

900073e0 <MX_LTDC_Init>:
  * @param  Width  LTDC width
  * @param  Height LTDC height
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_LTDC_Init(LTDC_HandleTypeDef *hltdc, uint32_t Width, uint32_t Height)
{
900073e0:	b580      	push	{r7, lr}
900073e2:	b084      	sub	sp, #16
900073e4:	af00      	add	r7, sp, #0
900073e6:	60f8      	str	r0, [r7, #12]
900073e8:	60b9      	str	r1, [r7, #8]
900073ea:	607a      	str	r2, [r7, #4]
  hltdc->Instance = LTDC;
900073ec:	68fb      	ldr	r3, [r7, #12]
900073ee:	4a21      	ldr	r2, [pc, #132]	; (90007474 <MX_LTDC_Init+0x94>)
900073f0:	601a      	str	r2, [r3, #0]
  hltdc->Init.HSPolarity = LTDC_HSPOLARITY_AL;
900073f2:	68fb      	ldr	r3, [r7, #12]
900073f4:	2200      	movs	r2, #0
900073f6:	605a      	str	r2, [r3, #4]
  hltdc->Init.VSPolarity = LTDC_VSPOLARITY_AL;
900073f8:	68fb      	ldr	r3, [r7, #12]
900073fa:	2200      	movs	r2, #0
900073fc:	609a      	str	r2, [r3, #8]
  hltdc->Init.DEPolarity = LTDC_DEPOLARITY_AL;
900073fe:	68fb      	ldr	r3, [r7, #12]
90007400:	2200      	movs	r2, #0
90007402:	60da      	str	r2, [r3, #12]
  hltdc->Init.PCPolarity = LTDC_PCPOLARITY_IPC;
90007404:	68fb      	ldr	r3, [r7, #12]
90007406:	2200      	movs	r2, #0
90007408:	611a      	str	r2, [r3, #16]

  hltdc->Init.HorizontalSync     = RK043FN48H_HSYNC - 1U;
9000740a:	68fb      	ldr	r3, [r7, #12]
9000740c:	2228      	movs	r2, #40	; 0x28
9000740e:	615a      	str	r2, [r3, #20]
  hltdc->Init.AccumulatedHBP     = (RK043FN48H_HSYNC + (RK043FN48H_HBP - 11U) - 1U);
90007410:	68fb      	ldr	r3, [r7, #12]
90007412:	222a      	movs	r2, #42	; 0x2a
90007414:	61da      	str	r2, [r3, #28]
  hltdc->Init.AccumulatedActiveW = RK043FN48H_HSYNC + Width + RK043FN48H_HBP - 1U;
90007416:	68bb      	ldr	r3, [r7, #8]
90007418:	f103 0235 	add.w	r2, r3, #53	; 0x35
9000741c:	68fb      	ldr	r3, [r7, #12]
9000741e:	625a      	str	r2, [r3, #36]	; 0x24
  hltdc->Init.TotalWidth         = RK043FN48H_HSYNC + Width + (RK043FN48H_HBP - 11U) + RK043FN48H_HFP - 1U;
90007420:	68bb      	ldr	r3, [r7, #8]
90007422:	f103 024a 	add.w	r2, r3, #74	; 0x4a
90007426:	68fb      	ldr	r3, [r7, #12]
90007428:	62da      	str	r2, [r3, #44]	; 0x2c
  hltdc->Init.VerticalSync       = RK043FN48H_VSYNC - 1U;
9000742a:	68fb      	ldr	r3, [r7, #12]
9000742c:	2209      	movs	r2, #9
9000742e:	619a      	str	r2, [r3, #24]
  hltdc->Init.AccumulatedVBP     = RK043FN48H_VSYNC + RK043FN48H_VBP - 1U;
90007430:	68fb      	ldr	r3, [r7, #12]
90007432:	220b      	movs	r2, #11
90007434:	621a      	str	r2, [r3, #32]
  hltdc->Init.AccumulatedActiveH = RK043FN48H_VSYNC + Height + RK043FN48H_VBP - 1U;
90007436:	687b      	ldr	r3, [r7, #4]
90007438:	f103 020b 	add.w	r2, r3, #11
9000743c:	68fb      	ldr	r3, [r7, #12]
9000743e:	629a      	str	r2, [r3, #40]	; 0x28
  hltdc->Init.TotalHeigh         = RK043FN48H_VSYNC + Height + RK043FN48H_VBP + RK043FN48H_VFP - 1U;
90007440:	687b      	ldr	r3, [r7, #4]
90007442:	f103 020d 	add.w	r2, r3, #13
90007446:	68fb      	ldr	r3, [r7, #12]
90007448:	631a      	str	r2, [r3, #48]	; 0x30

  hltdc->Init.Backcolor.Blue  = 0xFF;
9000744a:	68fb      	ldr	r3, [r7, #12]
9000744c:	22ff      	movs	r2, #255	; 0xff
9000744e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  hltdc->Init.Backcolor.Green = 0xFF;
90007452:	68fb      	ldr	r3, [r7, #12]
90007454:	22ff      	movs	r2, #255	; 0xff
90007456:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  hltdc->Init.Backcolor.Red   = 0xFF;
9000745a:	68fb      	ldr	r3, [r7, #12]
9000745c:	22ff      	movs	r2, #255	; 0xff
9000745e:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36

  return HAL_LTDC_Init(hltdc);
90007462:	68f8      	ldr	r0, [r7, #12]
90007464:	f006 fd06 	bl	9000de74 <HAL_LTDC_Init>
90007468:	4603      	mov	r3, r0
}
9000746a:	4618      	mov	r0, r3
9000746c:	3710      	adds	r7, #16
9000746e:	46bd      	mov	sp, r7
90007470:	bd80      	pop	{r7, pc}
90007472:	bf00      	nop
90007474:	50001000 	.word	0x50001000

90007478 <MX_LTDC_ConfigLayer>:
  * @param  LayerIndex Layer 0 or 1
  * @param  Config     Layer configuration
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, uint32_t LayerIndex, MX_LTDC_LayerConfig_t *Config)
{
90007478:	b580      	push	{r7, lr}
9000747a:	b092      	sub	sp, #72	; 0x48
9000747c:	af00      	add	r7, sp, #0
9000747e:	60f8      	str	r0, [r7, #12]
90007480:	60b9      	str	r1, [r7, #8]
90007482:	607a      	str	r2, [r7, #4]
  LTDC_LayerCfgTypeDef pLayerCfg;

  pLayerCfg.WindowX0 = Config->X0;
90007484:	687b      	ldr	r3, [r7, #4]
90007486:	681b      	ldr	r3, [r3, #0]
90007488:	617b      	str	r3, [r7, #20]
  pLayerCfg.WindowX1 = Config->X1;
9000748a:	687b      	ldr	r3, [r7, #4]
9000748c:	685b      	ldr	r3, [r3, #4]
9000748e:	61bb      	str	r3, [r7, #24]
  pLayerCfg.WindowY0 = Config->Y0;
90007490:	687b      	ldr	r3, [r7, #4]
90007492:	689b      	ldr	r3, [r3, #8]
90007494:	61fb      	str	r3, [r7, #28]
  pLayerCfg.WindowY1 = Config->Y1;
90007496:	687b      	ldr	r3, [r7, #4]
90007498:	68db      	ldr	r3, [r3, #12]
9000749a:	623b      	str	r3, [r7, #32]
  pLayerCfg.PixelFormat = Config->PixelFormat;
9000749c:	687b      	ldr	r3, [r7, #4]
9000749e:	691b      	ldr	r3, [r3, #16]
900074a0:	627b      	str	r3, [r7, #36]	; 0x24
  pLayerCfg.Alpha = 255;
900074a2:	23ff      	movs	r3, #255	; 0xff
900074a4:	62bb      	str	r3, [r7, #40]	; 0x28
  pLayerCfg.Alpha0 = 0;
900074a6:	2300      	movs	r3, #0
900074a8:	62fb      	str	r3, [r7, #44]	; 0x2c
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
900074aa:	f44f 63c0 	mov.w	r3, #1536	; 0x600
900074ae:	633b      	str	r3, [r7, #48]	; 0x30
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
900074b0:	2307      	movs	r3, #7
900074b2:	637b      	str	r3, [r7, #52]	; 0x34
  pLayerCfg.FBStartAdress = Config->Address;
900074b4:	687b      	ldr	r3, [r7, #4]
900074b6:	695b      	ldr	r3, [r3, #20]
900074b8:	63bb      	str	r3, [r7, #56]	; 0x38
  pLayerCfg.ImageWidth = (Config->X1 - Config->X0);
900074ba:	687b      	ldr	r3, [r7, #4]
900074bc:	685a      	ldr	r2, [r3, #4]
900074be:	687b      	ldr	r3, [r7, #4]
900074c0:	681b      	ldr	r3, [r3, #0]
900074c2:	1ad3      	subs	r3, r2, r3
900074c4:	63fb      	str	r3, [r7, #60]	; 0x3c
  pLayerCfg.ImageHeight = (Config->Y1 - Config->Y0);
900074c6:	687b      	ldr	r3, [r7, #4]
900074c8:	68da      	ldr	r2, [r3, #12]
900074ca:	687b      	ldr	r3, [r7, #4]
900074cc:	689b      	ldr	r3, [r3, #8]
900074ce:	1ad3      	subs	r3, r2, r3
900074d0:	643b      	str	r3, [r7, #64]	; 0x40
  pLayerCfg.Backcolor.Blue = 0;
900074d2:	2300      	movs	r3, #0
900074d4:	f887 3044 	strb.w	r3, [r7, #68]	; 0x44
  pLayerCfg.Backcolor.Green = 0;
900074d8:	2300      	movs	r3, #0
900074da:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
  pLayerCfg.Backcolor.Red = 0;
900074de:	2300      	movs	r3, #0
900074e0:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46
  return HAL_LTDC_ConfigLayer(hltdc, &pLayerCfg, LayerIndex);
900074e4:	f107 0314 	add.w	r3, r7, #20
900074e8:	68ba      	ldr	r2, [r7, #8]
900074ea:	4619      	mov	r1, r3
900074ec:	68f8      	ldr	r0, [r7, #12]
900074ee:	f006 fdfc 	bl	9000e0ea <HAL_LTDC_ConfigLayer>
900074f2:	4603      	mov	r3, r0
}
900074f4:	4618      	mov	r0, r3
900074f6:	3748      	adds	r7, #72	; 0x48
900074f8:	46bd      	mov	sp, r7
900074fa:	bd80      	pop	{r7, pc}

900074fc <MX_LTDC_ClockConfig>:
  * @param  hltdc  LTDC Handle
  *         Being __weak it can be overwritten by the application
  * @retval HAL_status
  */
__weak HAL_StatusTypeDef MX_LTDC_ClockConfig(LTDC_HandleTypeDef *hltdc)
{
900074fc:	b580      	push	{r7, lr}
900074fe:	b0b2      	sub	sp, #200	; 0xc8
90007500:	af00      	add	r7, sp, #0
90007502:	6078      	str	r0, [r7, #4]
  /* LCD clock configuration */
  /* PLL3_VCO Input = HSE_VALUE/PLL3M = 5 Mhz */
  /* PLL3_VCO Output = PLL3_VCO Input * PLL3N = 800 Mhz */
  /* PLLLCDCLK = PLL3_VCO Output/PLL3R = 800/83 = 9.63 Mhz */
  /* LTDC clock frequency = PLLLCDCLK = 9.63 Mhz */
  PeriphClkInitStruct.PeriphClockSelection   = RCC_PERIPHCLK_LTDC;
90007504:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
90007508:	60fb      	str	r3, [r7, #12]
  PeriphClkInitStruct.PLL3.PLL3M = 5;
9000750a:	2305      	movs	r3, #5
9000750c:	633b      	str	r3, [r7, #48]	; 0x30
  PeriphClkInitStruct.PLL3.PLL3N = 160;
9000750e:	23a0      	movs	r3, #160	; 0xa0
90007510:	637b      	str	r3, [r7, #52]	; 0x34
  PeriphClkInitStruct.PLL3.PLL3P = 2;
90007512:	2302      	movs	r3, #2
90007514:	63bb      	str	r3, [r7, #56]	; 0x38
  PeriphClkInitStruct.PLL3.PLL3Q = 2;
90007516:	2302      	movs	r3, #2
90007518:	63fb      	str	r3, [r7, #60]	; 0x3c
  PeriphClkInitStruct.PLL3.PLL3R = 83;
9000751a:	2353      	movs	r3, #83	; 0x53
9000751c:	643b      	str	r3, [r7, #64]	; 0x40
  PeriphClkInitStruct.PLL3.PLL3VCOSEL = 0;
9000751e:	2300      	movs	r3, #0
90007520:	64bb      	str	r3, [r7, #72]	; 0x48
  PeriphClkInitStruct.PLL3.PLL3FRACN = 0;
90007522:	2300      	movs	r3, #0
90007524:	64fb      	str	r3, [r7, #76]	; 0x4c

  return HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
90007526:	f107 030c 	add.w	r3, r7, #12
9000752a:	4618      	mov	r0, r3
9000752c:	f009 fe98 	bl	90011260 <HAL_RCCEx_PeriphCLKConfig>
90007530:	4603      	mov	r3, r0
}
90007532:	4618      	mov	r0, r3
90007534:	37c8      	adds	r7, #200	; 0xc8
90007536:	46bd      	mov	sp, r7
90007538:	bd80      	pop	{r7, pc}
	...

9000753c <BSP_LCD_GetPixelFormat>:
  * @param  Instance    LCD Instance
  * @param  PixelFormat Active LCD Pixel Format
  * @retval BSP status
  */
int32_t BSP_LCD_GetPixelFormat(uint32_t Instance, uint32_t *PixelFormat)
{
9000753c:	b480      	push	{r7}
9000753e:	b085      	sub	sp, #20
90007540:	af00      	add	r7, sp, #0
90007542:	6078      	str	r0, [r7, #4]
90007544:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
90007546:	2300      	movs	r3, #0
90007548:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
9000754a:	687b      	ldr	r3, [r7, #4]
9000754c:	2b00      	cmp	r3, #0
9000754e:	d003      	beq.n	90007558 <BSP_LCD_GetPixelFormat+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90007550:	f06f 0301 	mvn.w	r3, #1
90007554:	60fb      	str	r3, [r7, #12]
90007556:	e007      	b.n	90007568 <BSP_LCD_GetPixelFormat+0x2c>
  }
  else
  {
    /* Only RGB565 format is supported */
    *PixelFormat = Lcd_Ctx[Instance].PixelFormat;
90007558:	4a07      	ldr	r2, [pc, #28]	; (90007578 <BSP_LCD_GetPixelFormat+0x3c>)
9000755a:	687b      	ldr	r3, [r7, #4]
9000755c:	015b      	lsls	r3, r3, #5
9000755e:	4413      	add	r3, r2
90007560:	330c      	adds	r3, #12
90007562:	681a      	ldr	r2, [r3, #0]
90007564:	683b      	ldr	r3, [r7, #0]
90007566:	601a      	str	r2, [r3, #0]
  }

  return ret;
90007568:	68fb      	ldr	r3, [r7, #12]
}
9000756a:	4618      	mov	r0, r3
9000756c:	3714      	adds	r7, #20
9000756e:	46bd      	mov	sp, r7
90007570:	f85d 7b04 	ldr.w	r7, [sp], #4
90007574:	4770      	bx	lr
90007576:	bf00      	nop
90007578:	24002b24 	.word	0x24002b24

9000757c <BSP_LCD_SetActiveLayer>:
  * @param  Instance    LCD Instance
  * @param  LayerIndex  LCD layer index
  * @retval BSP status
  */
int32_t BSP_LCD_SetActiveLayer(uint32_t Instance, uint32_t LayerIndex)
{
9000757c:	b480      	push	{r7}
9000757e:	b085      	sub	sp, #20
90007580:	af00      	add	r7, sp, #0
90007582:	6078      	str	r0, [r7, #4]
90007584:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
90007586:	2300      	movs	r3, #0
90007588:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
9000758a:	687b      	ldr	r3, [r7, #4]
9000758c:	2b00      	cmp	r3, #0
9000758e:	d003      	beq.n	90007598 <BSP_LCD_SetActiveLayer+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90007590:	f06f 0301 	mvn.w	r3, #1
90007594:	60fb      	str	r3, [r7, #12]
90007596:	e006      	b.n	900075a6 <BSP_LCD_SetActiveLayer+0x2a>
  }
  else
  {
    Lcd_Ctx[Instance].ActiveLayer = LayerIndex;
90007598:	4a06      	ldr	r2, [pc, #24]	; (900075b4 <BSP_LCD_SetActiveLayer+0x38>)
9000759a:	687b      	ldr	r3, [r7, #4]
9000759c:	015b      	lsls	r3, r3, #5
9000759e:	4413      	add	r3, r2
900075a0:	3308      	adds	r3, #8
900075a2:	683a      	ldr	r2, [r7, #0]
900075a4:	601a      	str	r2, [r3, #0]
  }

  return ret;
900075a6:	68fb      	ldr	r3, [r7, #12]
}
900075a8:	4618      	mov	r0, r3
900075aa:	3714      	adds	r7, #20
900075ac:	46bd      	mov	sp, r7
900075ae:	f85d 7b04 	ldr.w	r7, [sp], #4
900075b2:	4770      	bx	lr
900075b4:	24002b24 	.word	0x24002b24

900075b8 <BSP_LCD_SetLayerVisible>:
  *            @arg  ENABLE
  *            @arg  DISABLE
  * @retval BSP status
  */
int32_t BSP_LCD_SetLayerVisible(uint32_t Instance, uint32_t LayerIndex, FunctionalState State)
{
900075b8:	b480      	push	{r7}
900075ba:	b087      	sub	sp, #28
900075bc:	af00      	add	r7, sp, #0
900075be:	60f8      	str	r0, [r7, #12]
900075c0:	60b9      	str	r1, [r7, #8]
900075c2:	4613      	mov	r3, r2
900075c4:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
900075c6:	2300      	movs	r3, #0
900075c8:	617b      	str	r3, [r7, #20]

  if(Instance >= LCD_INSTANCES_NBR)
900075ca:	68fb      	ldr	r3, [r7, #12]
900075cc:	2b00      	cmp	r3, #0
900075ce:	d003      	beq.n	900075d8 <BSP_LCD_SetLayerVisible+0x20>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900075d0:	f06f 0301 	mvn.w	r3, #1
900075d4:	617b      	str	r3, [r7, #20]
900075d6:	e037      	b.n	90007648 <BSP_LCD_SetLayerVisible+0x90>
  }
  else
  {
    if(State == ENABLE)
900075d8:	79fb      	ldrb	r3, [r7, #7]
900075da:	2b01      	cmp	r3, #1
900075dc:	d112      	bne.n	90007604 <BSP_LCD_SetLayerVisible+0x4c>
    {
      __HAL_LTDC_LAYER_ENABLE(&hlcd_ltdc, LayerIndex);
900075de:	4b1e      	ldr	r3, [pc, #120]	; (90007658 <BSP_LCD_SetLayerVisible+0xa0>)
900075e0:	681b      	ldr	r3, [r3, #0]
900075e2:	461a      	mov	r2, r3
900075e4:	68bb      	ldr	r3, [r7, #8]
900075e6:	01db      	lsls	r3, r3, #7
900075e8:	4413      	add	r3, r2
900075ea:	3384      	adds	r3, #132	; 0x84
900075ec:	681b      	ldr	r3, [r3, #0]
900075ee:	4a1a      	ldr	r2, [pc, #104]	; (90007658 <BSP_LCD_SetLayerVisible+0xa0>)
900075f0:	6812      	ldr	r2, [r2, #0]
900075f2:	4611      	mov	r1, r2
900075f4:	68ba      	ldr	r2, [r7, #8]
900075f6:	01d2      	lsls	r2, r2, #7
900075f8:	440a      	add	r2, r1
900075fa:	3284      	adds	r2, #132	; 0x84
900075fc:	f043 0301 	orr.w	r3, r3, #1
90007600:	6013      	str	r3, [r2, #0]
90007602:	e011      	b.n	90007628 <BSP_LCD_SetLayerVisible+0x70>
    }
    else
    {
      __HAL_LTDC_LAYER_DISABLE(&hlcd_ltdc, LayerIndex);
90007604:	4b14      	ldr	r3, [pc, #80]	; (90007658 <BSP_LCD_SetLayerVisible+0xa0>)
90007606:	681b      	ldr	r3, [r3, #0]
90007608:	461a      	mov	r2, r3
9000760a:	68bb      	ldr	r3, [r7, #8]
9000760c:	01db      	lsls	r3, r3, #7
9000760e:	4413      	add	r3, r2
90007610:	3384      	adds	r3, #132	; 0x84
90007612:	681b      	ldr	r3, [r3, #0]
90007614:	4a10      	ldr	r2, [pc, #64]	; (90007658 <BSP_LCD_SetLayerVisible+0xa0>)
90007616:	6812      	ldr	r2, [r2, #0]
90007618:	4611      	mov	r1, r2
9000761a:	68ba      	ldr	r2, [r7, #8]
9000761c:	01d2      	lsls	r2, r2, #7
9000761e:	440a      	add	r2, r1
90007620:	3284      	adds	r2, #132	; 0x84
90007622:	f023 0301 	bic.w	r3, r3, #1
90007626:	6013      	str	r3, [r2, #0]
    }

    if(Lcd_Ctx[Instance].ReloadEnable == 1U)
90007628:	4a0c      	ldr	r2, [pc, #48]	; (9000765c <BSP_LCD_SetLayerVisible+0xa4>)
9000762a:	68fb      	ldr	r3, [r7, #12]
9000762c:	015b      	lsls	r3, r3, #5
9000762e:	4413      	add	r3, r2
90007630:	3318      	adds	r3, #24
90007632:	681b      	ldr	r3, [r3, #0]
90007634:	2b01      	cmp	r3, #1
90007636:	d107      	bne.n	90007648 <BSP_LCD_SetLayerVisible+0x90>
    {
      __HAL_LTDC_RELOAD_IMMEDIATE_CONFIG(&hlcd_ltdc);
90007638:	4b07      	ldr	r3, [pc, #28]	; (90007658 <BSP_LCD_SetLayerVisible+0xa0>)
9000763a:	681b      	ldr	r3, [r3, #0]
9000763c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
9000763e:	4b06      	ldr	r3, [pc, #24]	; (90007658 <BSP_LCD_SetLayerVisible+0xa0>)
90007640:	681b      	ldr	r3, [r3, #0]
90007642:	f042 0201 	orr.w	r2, r2, #1
90007646:	625a      	str	r2, [r3, #36]	; 0x24
    }
  }

  return ret;
90007648:	697b      	ldr	r3, [r7, #20]
}
9000764a:	4618      	mov	r0, r3
9000764c:	371c      	adds	r7, #28
9000764e:	46bd      	mov	sp, r7
90007650:	f85d 7b04 	ldr.w	r7, [sp], #4
90007654:	4770      	bx	lr
90007656:	bf00      	nop
90007658:	24002a7c 	.word	0x24002a7c
9000765c:	24002b24 	.word	0x24002b24

90007660 <BSP_LCD_GetXSize>:
  * @param  Instance  LCD Instance
  * @param  XSize     LCD width
  * @retval BSP status
  */
int32_t BSP_LCD_GetXSize(uint32_t Instance, uint32_t *XSize)
{
90007660:	b480      	push	{r7}
90007662:	b085      	sub	sp, #20
90007664:	af00      	add	r7, sp, #0
90007666:	6078      	str	r0, [r7, #4]
90007668:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
9000766a:	2300      	movs	r3, #0
9000766c:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
9000766e:	687b      	ldr	r3, [r7, #4]
90007670:	2b00      	cmp	r3, #0
90007672:	d003      	beq.n	9000767c <BSP_LCD_GetXSize+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90007674:	f06f 0301 	mvn.w	r3, #1
90007678:	60fb      	str	r3, [r7, #12]
9000767a:	e006      	b.n	9000768a <BSP_LCD_GetXSize+0x2a>
  }
  else
  {
    *XSize = Lcd_Ctx[Instance].XSize;
9000767c:	4a06      	ldr	r2, [pc, #24]	; (90007698 <BSP_LCD_GetXSize+0x38>)
9000767e:	687b      	ldr	r3, [r7, #4]
90007680:	015b      	lsls	r3, r3, #5
90007682:	4413      	add	r3, r2
90007684:	681a      	ldr	r2, [r3, #0]
90007686:	683b      	ldr	r3, [r7, #0]
90007688:	601a      	str	r2, [r3, #0]
  }

  return ret;
9000768a:	68fb      	ldr	r3, [r7, #12]
}
9000768c:	4618      	mov	r0, r3
9000768e:	3714      	adds	r7, #20
90007690:	46bd      	mov	sp, r7
90007692:	f85d 7b04 	ldr.w	r7, [sp], #4
90007696:	4770      	bx	lr
90007698:	24002b24 	.word	0x24002b24

9000769c <BSP_LCD_GetYSize>:
  * @param  Instance  LCD Instance
  * @param  YSize     LCD Height
  * @retval BSP status
  */
int32_t BSP_LCD_GetYSize(uint32_t Instance, uint32_t *YSize)
{
9000769c:	b480      	push	{r7}
9000769e:	b085      	sub	sp, #20
900076a0:	af00      	add	r7, sp, #0
900076a2:	6078      	str	r0, [r7, #4]
900076a4:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
900076a6:	2300      	movs	r3, #0
900076a8:	60fb      	str	r3, [r7, #12]

  if(Instance >= LCD_INSTANCES_NBR)
900076aa:	687b      	ldr	r3, [r7, #4]
900076ac:	2b00      	cmp	r3, #0
900076ae:	d003      	beq.n	900076b8 <BSP_LCD_GetYSize+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900076b0:	f06f 0301 	mvn.w	r3, #1
900076b4:	60fb      	str	r3, [r7, #12]
900076b6:	e007      	b.n	900076c8 <BSP_LCD_GetYSize+0x2c>
  }
  else
  {
    *YSize = Lcd_Ctx[Instance].YSize;
900076b8:	4a07      	ldr	r2, [pc, #28]	; (900076d8 <BSP_LCD_GetYSize+0x3c>)
900076ba:	687b      	ldr	r3, [r7, #4]
900076bc:	015b      	lsls	r3, r3, #5
900076be:	4413      	add	r3, r2
900076c0:	3304      	adds	r3, #4
900076c2:	681a      	ldr	r2, [r3, #0]
900076c4:	683b      	ldr	r3, [r7, #0]
900076c6:	601a      	str	r2, [r3, #0]
  }

  return ret;
900076c8:	68fb      	ldr	r3, [r7, #12]
}
900076ca:	4618      	mov	r0, r3
900076cc:	3714      	adds	r7, #20
900076ce:	46bd      	mov	sp, r7
900076d0:	f85d 7b04 	ldr.w	r7, [sp], #4
900076d4:	4770      	bx	lr
900076d6:	bf00      	nop
900076d8:	24002b24 	.word	0x24002b24

900076dc <BSP_LCD_DrawBitmap>:
  * @param  Ypos Bmp Y position in the LCD
  * @param  pBmp Pointer to Bmp picture address in the internal Flash.
  * @retval BSP status
  */
int32_t BSP_LCD_DrawBitmap(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint8_t *pBmp)
{
900076dc:	b580      	push	{r7, lr}
900076de:	b08e      	sub	sp, #56	; 0x38
900076e0:	af02      	add	r7, sp, #8
900076e2:	60f8      	str	r0, [r7, #12]
900076e4:	60b9      	str	r1, [r7, #8]
900076e6:	607a      	str	r2, [r7, #4]
900076e8:	603b      	str	r3, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
900076ea:	2300      	movs	r3, #0
900076ec:	61fb      	str	r3, [r7, #28]
  uint32_t Address;
  uint32_t input_color_mode;
  uint8_t *pbmp;

  /* Get bitmap data address offset */
  index = (uint32_t)pBmp[10] + ((uint32_t)pBmp[11] << 8) + ((uint32_t)pBmp[12] << 16)  + ((uint32_t)pBmp[13] << 24);
900076ee:	683b      	ldr	r3, [r7, #0]
900076f0:	330a      	adds	r3, #10
900076f2:	781b      	ldrb	r3, [r3, #0]
900076f4:	461a      	mov	r2, r3
900076f6:	683b      	ldr	r3, [r7, #0]
900076f8:	330b      	adds	r3, #11
900076fa:	781b      	ldrb	r3, [r3, #0]
900076fc:	021b      	lsls	r3, r3, #8
900076fe:	441a      	add	r2, r3
90007700:	683b      	ldr	r3, [r7, #0]
90007702:	330c      	adds	r3, #12
90007704:	781b      	ldrb	r3, [r3, #0]
90007706:	041b      	lsls	r3, r3, #16
90007708:	441a      	add	r2, r3
9000770a:	683b      	ldr	r3, [r7, #0]
9000770c:	330d      	adds	r3, #13
9000770e:	781b      	ldrb	r3, [r3, #0]
90007710:	061b      	lsls	r3, r3, #24
90007712:	4413      	add	r3, r2
90007714:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Read bitmap width */
  width = (uint32_t)pBmp[18] + ((uint32_t)pBmp[19] << 8) + ((uint32_t)pBmp[20] << 16)  + ((uint32_t)pBmp[21] << 24);
90007716:	683b      	ldr	r3, [r7, #0]
90007718:	3312      	adds	r3, #18
9000771a:	781b      	ldrb	r3, [r3, #0]
9000771c:	461a      	mov	r2, r3
9000771e:	683b      	ldr	r3, [r7, #0]
90007720:	3313      	adds	r3, #19
90007722:	781b      	ldrb	r3, [r3, #0]
90007724:	021b      	lsls	r3, r3, #8
90007726:	441a      	add	r2, r3
90007728:	683b      	ldr	r3, [r7, #0]
9000772a:	3314      	adds	r3, #20
9000772c:	781b      	ldrb	r3, [r3, #0]
9000772e:	041b      	lsls	r3, r3, #16
90007730:	441a      	add	r2, r3
90007732:	683b      	ldr	r3, [r7, #0]
90007734:	3315      	adds	r3, #21
90007736:	781b      	ldrb	r3, [r3, #0]
90007738:	061b      	lsls	r3, r3, #24
9000773a:	4413      	add	r3, r2
9000773c:	61bb      	str	r3, [r7, #24]

  /* Read bitmap height */
  height = (uint32_t)pBmp[22] + ((uint32_t)pBmp[23] << 8) + ((uint32_t)pBmp[24] << 16)  + ((uint32_t)pBmp[25] << 24);
9000773e:	683b      	ldr	r3, [r7, #0]
90007740:	3316      	adds	r3, #22
90007742:	781b      	ldrb	r3, [r3, #0]
90007744:	461a      	mov	r2, r3
90007746:	683b      	ldr	r3, [r7, #0]
90007748:	3317      	adds	r3, #23
9000774a:	781b      	ldrb	r3, [r3, #0]
9000774c:	021b      	lsls	r3, r3, #8
9000774e:	441a      	add	r2, r3
90007750:	683b      	ldr	r3, [r7, #0]
90007752:	3318      	adds	r3, #24
90007754:	781b      	ldrb	r3, [r3, #0]
90007756:	041b      	lsls	r3, r3, #16
90007758:	441a      	add	r2, r3
9000775a:	683b      	ldr	r3, [r7, #0]
9000775c:	3319      	adds	r3, #25
9000775e:	781b      	ldrb	r3, [r3, #0]
90007760:	061b      	lsls	r3, r3, #24
90007762:	4413      	add	r3, r2
90007764:	617b      	str	r3, [r7, #20]

  /* Read bit/pixel */
  bit_pixel = (uint32_t)pBmp[28] + ((uint32_t)pBmp[29] << 8);
90007766:	683b      	ldr	r3, [r7, #0]
90007768:	331c      	adds	r3, #28
9000776a:	781b      	ldrb	r3, [r3, #0]
9000776c:	461a      	mov	r2, r3
9000776e:	683b      	ldr	r3, [r7, #0]
90007770:	331d      	adds	r3, #29
90007772:	781b      	ldrb	r3, [r3, #0]
90007774:	021b      	lsls	r3, r3, #8
90007776:	4413      	add	r3, r2
90007778:	613b      	str	r3, [r7, #16]

  /* Set the address */
  Address = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (((Lcd_Ctx[Instance].XSize*Ypos) + Xpos)*Lcd_Ctx[Instance].BppFactor);
9000777a:	4a37      	ldr	r2, [pc, #220]	; (90007858 <BSP_LCD_DrawBitmap+0x17c>)
9000777c:	68fb      	ldr	r3, [r7, #12]
9000777e:	015b      	lsls	r3, r3, #5
90007780:	4413      	add	r3, r2
90007782:	3308      	adds	r3, #8
90007784:	681b      	ldr	r3, [r3, #0]
90007786:	4a35      	ldr	r2, [pc, #212]	; (9000785c <BSP_LCD_DrawBitmap+0x180>)
90007788:	2134      	movs	r1, #52	; 0x34
9000778a:	fb01 f303 	mul.w	r3, r1, r3
9000778e:	4413      	add	r3, r2
90007790:	335c      	adds	r3, #92	; 0x5c
90007792:	681a      	ldr	r2, [r3, #0]
90007794:	4930      	ldr	r1, [pc, #192]	; (90007858 <BSP_LCD_DrawBitmap+0x17c>)
90007796:	68fb      	ldr	r3, [r7, #12]
90007798:	015b      	lsls	r3, r3, #5
9000779a:	440b      	add	r3, r1
9000779c:	681b      	ldr	r3, [r3, #0]
9000779e:	6879      	ldr	r1, [r7, #4]
900077a0:	fb01 f103 	mul.w	r1, r1, r3
900077a4:	68bb      	ldr	r3, [r7, #8]
900077a6:	440b      	add	r3, r1
900077a8:	482b      	ldr	r0, [pc, #172]	; (90007858 <BSP_LCD_DrawBitmap+0x17c>)
900077aa:	68f9      	ldr	r1, [r7, #12]
900077ac:	0149      	lsls	r1, r1, #5
900077ae:	4401      	add	r1, r0
900077b0:	3110      	adds	r1, #16
900077b2:	6809      	ldr	r1, [r1, #0]
900077b4:	fb01 f303 	mul.w	r3, r1, r3
900077b8:	4413      	add	r3, r2
900077ba:	62bb      	str	r3, [r7, #40]	; 0x28

  /* Get the layer pixel format */
  if ((bit_pixel/8U) == 4U)
900077bc:	693b      	ldr	r3, [r7, #16]
900077be:	3b20      	subs	r3, #32
900077c0:	2b07      	cmp	r3, #7
900077c2:	d802      	bhi.n	900077ca <BSP_LCD_DrawBitmap+0xee>
  {
    input_color_mode = DMA2D_INPUT_ARGB8888;
900077c4:	2300      	movs	r3, #0
900077c6:	627b      	str	r3, [r7, #36]	; 0x24
900077c8:	e008      	b.n	900077dc <BSP_LCD_DrawBitmap+0x100>
  }
  else if ((bit_pixel/8U) == 2U)
900077ca:	693b      	ldr	r3, [r7, #16]
900077cc:	3b10      	subs	r3, #16
900077ce:	2b07      	cmp	r3, #7
900077d0:	d802      	bhi.n	900077d8 <BSP_LCD_DrawBitmap+0xfc>
  {
    input_color_mode = DMA2D_INPUT_RGB565;
900077d2:	2302      	movs	r3, #2
900077d4:	627b      	str	r3, [r7, #36]	; 0x24
900077d6:	e001      	b.n	900077dc <BSP_LCD_DrawBitmap+0x100>
  }
  else
  {
    input_color_mode = DMA2D_INPUT_RGB888;
900077d8:	2301      	movs	r3, #1
900077da:	627b      	str	r3, [r7, #36]	; 0x24
  }

  /* Bypass the bitmap header */
  pbmp = pBmp + (index + (width * (height - 1U) * (bit_pixel/8U)));
900077dc:	697b      	ldr	r3, [r7, #20]
900077de:	3b01      	subs	r3, #1
900077e0:	69ba      	ldr	r2, [r7, #24]
900077e2:	fb02 f303 	mul.w	r3, r2, r3
900077e6:	693a      	ldr	r2, [r7, #16]
900077e8:	08d2      	lsrs	r2, r2, #3
900077ea:	fb02 f203 	mul.w	r2, r2, r3
900077ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
900077f0:	4413      	add	r3, r2
900077f2:	683a      	ldr	r2, [r7, #0]
900077f4:	4413      	add	r3, r2
900077f6:	623b      	str	r3, [r7, #32]

  /* Convert picture to ARGB8888 pixel format */
  for(index=0; index < height; index++)
900077f8:	2300      	movs	r3, #0
900077fa:	62fb      	str	r3, [r7, #44]	; 0x2c
900077fc:	e023      	b.n	90007846 <BSP_LCD_DrawBitmap+0x16a>
  {
    /* Pixel format conversion */
    LL_ConvertLineToRGB(Instance, (uint32_t *)pbmp, (uint32_t *)Address, width, input_color_mode);
900077fe:	6aba      	ldr	r2, [r7, #40]	; 0x28
90007800:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90007802:	9300      	str	r3, [sp, #0]
90007804:	69bb      	ldr	r3, [r7, #24]
90007806:	6a39      	ldr	r1, [r7, #32]
90007808:	68f8      	ldr	r0, [r7, #12]
9000780a:	f000 fa77 	bl	90007cfc <LL_ConvertLineToRGB>

    /* Increment the source and destination buffers */
    Address+=  (Lcd_Ctx[Instance].XSize * Lcd_Ctx[Instance].BppFactor);
9000780e:	4a12      	ldr	r2, [pc, #72]	; (90007858 <BSP_LCD_DrawBitmap+0x17c>)
90007810:	68fb      	ldr	r3, [r7, #12]
90007812:	015b      	lsls	r3, r3, #5
90007814:	4413      	add	r3, r2
90007816:	681b      	ldr	r3, [r3, #0]
90007818:	490f      	ldr	r1, [pc, #60]	; (90007858 <BSP_LCD_DrawBitmap+0x17c>)
9000781a:	68fa      	ldr	r2, [r7, #12]
9000781c:	0152      	lsls	r2, r2, #5
9000781e:	440a      	add	r2, r1
90007820:	3210      	adds	r2, #16
90007822:	6812      	ldr	r2, [r2, #0]
90007824:	fb02 f303 	mul.w	r3, r2, r3
90007828:	6aba      	ldr	r2, [r7, #40]	; 0x28
9000782a:	4413      	add	r3, r2
9000782c:	62bb      	str	r3, [r7, #40]	; 0x28
    pbmp -= width*(bit_pixel/8U);
9000782e:	693b      	ldr	r3, [r7, #16]
90007830:	08db      	lsrs	r3, r3, #3
90007832:	69ba      	ldr	r2, [r7, #24]
90007834:	fb02 f303 	mul.w	r3, r2, r3
90007838:	425b      	negs	r3, r3
9000783a:	6a3a      	ldr	r2, [r7, #32]
9000783c:	4413      	add	r3, r2
9000783e:	623b      	str	r3, [r7, #32]
  for(index=0; index < height; index++)
90007840:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90007842:	3301      	adds	r3, #1
90007844:	62fb      	str	r3, [r7, #44]	; 0x2c
90007846:	6afa      	ldr	r2, [r7, #44]	; 0x2c
90007848:	697b      	ldr	r3, [r7, #20]
9000784a:	429a      	cmp	r2, r3
9000784c:	d3d7      	bcc.n	900077fe <BSP_LCD_DrawBitmap+0x122>
  }

  return ret;
9000784e:	69fb      	ldr	r3, [r7, #28]
}
90007850:	4618      	mov	r0, r3
90007852:	3730      	adds	r7, #48	; 0x30
90007854:	46bd      	mov	sp, r7
90007856:	bd80      	pop	{r7, pc}
90007858:	24002b24 	.word	0x24002b24
9000785c:	24002a7c 	.word	0x24002a7c

90007860 <BSP_LCD_FillRGBRect>:
  * @param  Width Rectangle width.
  * @param  Height Rectangle Height.
  * @retval BSP status.
  */
int32_t BSP_LCD_FillRGBRect(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint8_t *pData, uint32_t Width, uint32_t Height)
{
90007860:	b580      	push	{r7, lr}
90007862:	b088      	sub	sp, #32
90007864:	af00      	add	r7, sp, #0
90007866:	60f8      	str	r0, [r7, #12]
90007868:	60b9      	str	r1, [r7, #8]
9000786a:	607a      	str	r2, [r7, #4]
9000786c:	603b      	str	r3, [r7, #0]
  uint32_t i;
  uint8_t *pdata = pData;
9000786e:	683b      	ldr	r3, [r7, #0]
90007870:	61bb      	str	r3, [r7, #24]
    }
    pdata += Lcd_Ctx[Instance].BppFactor*Width;
  }
#else
  uint32_t color, j;
  for(i = 0; i < Height; i++)
90007872:	2300      	movs	r3, #0
90007874:	61fb      	str	r3, [r7, #28]
90007876:	e032      	b.n	900078de <BSP_LCD_FillRGBRect+0x7e>
  {
    for(j = 0; j < Width; j++)
90007878:	2300      	movs	r3, #0
9000787a:	617b      	str	r3, [r7, #20]
9000787c:	e028      	b.n	900078d0 <BSP_LCD_FillRGBRect+0x70>
    {
      color = (uint32_t)((uint32_t)*pdata | ((uint32_t)(*(pdata + 1U)) << 8U) | ((uint32_t)(*(pdata + 2U)) << 16U) | ((uint32_t)(*(pdata + 3U)) << 24U));
9000787e:	69bb      	ldr	r3, [r7, #24]
90007880:	781b      	ldrb	r3, [r3, #0]
90007882:	461a      	mov	r2, r3
90007884:	69bb      	ldr	r3, [r7, #24]
90007886:	3301      	adds	r3, #1
90007888:	781b      	ldrb	r3, [r3, #0]
9000788a:	021b      	lsls	r3, r3, #8
9000788c:	431a      	orrs	r2, r3
9000788e:	69bb      	ldr	r3, [r7, #24]
90007890:	3302      	adds	r3, #2
90007892:	781b      	ldrb	r3, [r3, #0]
90007894:	041b      	lsls	r3, r3, #16
90007896:	431a      	orrs	r2, r3
90007898:	69bb      	ldr	r3, [r7, #24]
9000789a:	3303      	adds	r3, #3
9000789c:	781b      	ldrb	r3, [r3, #0]
9000789e:	061b      	lsls	r3, r3, #24
900078a0:	4313      	orrs	r3, r2
900078a2:	613b      	str	r3, [r7, #16]
      (void)BSP_LCD_WritePixel(Instance, Xpos + j, Ypos + i, color);
900078a4:	68ba      	ldr	r2, [r7, #8]
900078a6:	697b      	ldr	r3, [r7, #20]
900078a8:	18d1      	adds	r1, r2, r3
900078aa:	687a      	ldr	r2, [r7, #4]
900078ac:	69fb      	ldr	r3, [r7, #28]
900078ae:	441a      	add	r2, r3
900078b0:	693b      	ldr	r3, [r7, #16]
900078b2:	68f8      	ldr	r0, [r7, #12]
900078b4:	f000 f95e 	bl	90007b74 <BSP_LCD_WritePixel>
      pdata += Lcd_Ctx[Instance].BppFactor;
900078b8:	4a0d      	ldr	r2, [pc, #52]	; (900078f0 <BSP_LCD_FillRGBRect+0x90>)
900078ba:	68fb      	ldr	r3, [r7, #12]
900078bc:	015b      	lsls	r3, r3, #5
900078be:	4413      	add	r3, r2
900078c0:	3310      	adds	r3, #16
900078c2:	681b      	ldr	r3, [r3, #0]
900078c4:	69ba      	ldr	r2, [r7, #24]
900078c6:	4413      	add	r3, r2
900078c8:	61bb      	str	r3, [r7, #24]
    for(j = 0; j < Width; j++)
900078ca:	697b      	ldr	r3, [r7, #20]
900078cc:	3301      	adds	r3, #1
900078ce:	617b      	str	r3, [r7, #20]
900078d0:	697a      	ldr	r2, [r7, #20]
900078d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
900078d4:	429a      	cmp	r2, r3
900078d6:	d3d2      	bcc.n	9000787e <BSP_LCD_FillRGBRect+0x1e>
  for(i = 0; i < Height; i++)
900078d8:	69fb      	ldr	r3, [r7, #28]
900078da:	3301      	adds	r3, #1
900078dc:	61fb      	str	r3, [r7, #28]
900078de:	69fa      	ldr	r2, [r7, #28]
900078e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
900078e2:	429a      	cmp	r2, r3
900078e4:	d3c8      	bcc.n	90007878 <BSP_LCD_FillRGBRect+0x18>
    }
  }
#endif

  return BSP_ERROR_NONE;
900078e6:	2300      	movs	r3, #0
}
900078e8:	4618      	mov	r0, r3
900078ea:	3720      	adds	r7, #32
900078ec:	46bd      	mov	sp, r7
900078ee:	bd80      	pop	{r7, pc}
900078f0:	24002b24 	.word	0x24002b24

900078f4 <BSP_LCD_DrawHLine>:
  * @param  Length  Line length
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_DrawHLine(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
900078f4:	b580      	push	{r7, lr}
900078f6:	b088      	sub	sp, #32
900078f8:	af02      	add	r7, sp, #8
900078fa:	60f8      	str	r0, [r7, #12]
900078fc:	60b9      	str	r1, [r7, #8]
900078fe:	607a      	str	r2, [r7, #4]
90007900:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the line address */
  Xaddress = hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
90007902:	4a21      	ldr	r2, [pc, #132]	; (90007988 <BSP_LCD_DrawHLine+0x94>)
90007904:	68fb      	ldr	r3, [r7, #12]
90007906:	015b      	lsls	r3, r3, #5
90007908:	4413      	add	r3, r2
9000790a:	3308      	adds	r3, #8
9000790c:	681b      	ldr	r3, [r3, #0]
9000790e:	4a1f      	ldr	r2, [pc, #124]	; (9000798c <BSP_LCD_DrawHLine+0x98>)
90007910:	2134      	movs	r1, #52	; 0x34
90007912:	fb01 f303 	mul.w	r3, r1, r3
90007916:	4413      	add	r3, r2
90007918:	335c      	adds	r3, #92	; 0x5c
9000791a:	681a      	ldr	r2, [r3, #0]
9000791c:	491a      	ldr	r1, [pc, #104]	; (90007988 <BSP_LCD_DrawHLine+0x94>)
9000791e:	68fb      	ldr	r3, [r7, #12]
90007920:	015b      	lsls	r3, r3, #5
90007922:	440b      	add	r3, r1
90007924:	3310      	adds	r3, #16
90007926:	681b      	ldr	r3, [r3, #0]
90007928:	4817      	ldr	r0, [pc, #92]	; (90007988 <BSP_LCD_DrawHLine+0x94>)
9000792a:	68f9      	ldr	r1, [r7, #12]
9000792c:	0149      	lsls	r1, r1, #5
9000792e:	4401      	add	r1, r0
90007930:	6809      	ldr	r1, [r1, #0]
90007932:	6878      	ldr	r0, [r7, #4]
90007934:	fb00 f001 	mul.w	r0, r0, r1
90007938:	68b9      	ldr	r1, [r7, #8]
9000793a:	4401      	add	r1, r0
9000793c:	fb01 f303 	mul.w	r3, r1, r3
90007940:	4413      	add	r3, r2
90007942:	617b      	str	r3, [r7, #20]

  /* Write line */
  if((Xpos + Length) > Lcd_Ctx[Instance].XSize)
90007944:	68ba      	ldr	r2, [r7, #8]
90007946:	683b      	ldr	r3, [r7, #0]
90007948:	441a      	add	r2, r3
9000794a:	490f      	ldr	r1, [pc, #60]	; (90007988 <BSP_LCD_DrawHLine+0x94>)
9000794c:	68fb      	ldr	r3, [r7, #12]
9000794e:	015b      	lsls	r3, r3, #5
90007950:	440b      	add	r3, r1
90007952:	681b      	ldr	r3, [r3, #0]
90007954:	429a      	cmp	r2, r3
90007956:	d907      	bls.n	90007968 <BSP_LCD_DrawHLine+0x74>
  {
    Length = Lcd_Ctx[Instance].XSize - Xpos;
90007958:	4a0b      	ldr	r2, [pc, #44]	; (90007988 <BSP_LCD_DrawHLine+0x94>)
9000795a:	68fb      	ldr	r3, [r7, #12]
9000795c:	015b      	lsls	r3, r3, #5
9000795e:	4413      	add	r3, r2
90007960:	681a      	ldr	r2, [r3, #0]
90007962:	68bb      	ldr	r3, [r7, #8]
90007964:	1ad3      	subs	r3, r2, r3
90007966:	603b      	str	r3, [r7, #0]
  }
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Length, 1, 0, Color);
90007968:	6979      	ldr	r1, [r7, #20]
9000796a:	6a3b      	ldr	r3, [r7, #32]
9000796c:	9301      	str	r3, [sp, #4]
9000796e:	2300      	movs	r3, #0
90007970:	9300      	str	r3, [sp, #0]
90007972:	2301      	movs	r3, #1
90007974:	683a      	ldr	r2, [r7, #0]
90007976:	68f8      	ldr	r0, [r7, #12]
90007978:	f000 f956 	bl	90007c28 <LL_FillBuffer>

  return BSP_ERROR_NONE;
9000797c:	2300      	movs	r3, #0
}
9000797e:	4618      	mov	r0, r3
90007980:	3718      	adds	r7, #24
90007982:	46bd      	mov	sp, r7
90007984:	bd80      	pop	{r7, pc}
90007986:	bf00      	nop
90007988:	24002b24 	.word	0x24002b24
9000798c:	24002a7c 	.word	0x24002a7c

90007990 <BSP_LCD_DrawVLine>:
  * @param  Length  Line length
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_DrawVLine(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
90007990:	b580      	push	{r7, lr}
90007992:	b088      	sub	sp, #32
90007994:	af02      	add	r7, sp, #8
90007996:	60f8      	str	r0, [r7, #12]
90007998:	60b9      	str	r1, [r7, #8]
9000799a:	607a      	str	r2, [r7, #4]
9000799c:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the line address */
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
9000799e:	4a24      	ldr	r2, [pc, #144]	; (90007a30 <BSP_LCD_DrawVLine+0xa0>)
900079a0:	68fb      	ldr	r3, [r7, #12]
900079a2:	015b      	lsls	r3, r3, #5
900079a4:	4413      	add	r3, r2
900079a6:	3308      	adds	r3, #8
900079a8:	681b      	ldr	r3, [r3, #0]
900079aa:	4a22      	ldr	r2, [pc, #136]	; (90007a34 <BSP_LCD_DrawVLine+0xa4>)
900079ac:	2134      	movs	r1, #52	; 0x34
900079ae:	fb01 f303 	mul.w	r3, r1, r3
900079b2:	4413      	add	r3, r2
900079b4:	335c      	adds	r3, #92	; 0x5c
900079b6:	681a      	ldr	r2, [r3, #0]
900079b8:	491d      	ldr	r1, [pc, #116]	; (90007a30 <BSP_LCD_DrawVLine+0xa0>)
900079ba:	68fb      	ldr	r3, [r7, #12]
900079bc:	015b      	lsls	r3, r3, #5
900079be:	440b      	add	r3, r1
900079c0:	3310      	adds	r3, #16
900079c2:	681b      	ldr	r3, [r3, #0]
900079c4:	481a      	ldr	r0, [pc, #104]	; (90007a30 <BSP_LCD_DrawVLine+0xa0>)
900079c6:	68f9      	ldr	r1, [r7, #12]
900079c8:	0149      	lsls	r1, r1, #5
900079ca:	4401      	add	r1, r0
900079cc:	6809      	ldr	r1, [r1, #0]
900079ce:	6878      	ldr	r0, [r7, #4]
900079d0:	fb00 f001 	mul.w	r0, r0, r1
900079d4:	68b9      	ldr	r1, [r7, #8]
900079d6:	4401      	add	r1, r0
900079d8:	fb01 f303 	mul.w	r3, r1, r3
900079dc:	4413      	add	r3, r2
900079de:	617b      	str	r3, [r7, #20]

  /* Write line */
  if((Ypos + Length) > Lcd_Ctx[Instance].YSize)
900079e0:	687a      	ldr	r2, [r7, #4]
900079e2:	683b      	ldr	r3, [r7, #0]
900079e4:	441a      	add	r2, r3
900079e6:	4912      	ldr	r1, [pc, #72]	; (90007a30 <BSP_LCD_DrawVLine+0xa0>)
900079e8:	68fb      	ldr	r3, [r7, #12]
900079ea:	015b      	lsls	r3, r3, #5
900079ec:	440b      	add	r3, r1
900079ee:	3304      	adds	r3, #4
900079f0:	681b      	ldr	r3, [r3, #0]
900079f2:	429a      	cmp	r2, r3
900079f4:	d908      	bls.n	90007a08 <BSP_LCD_DrawVLine+0x78>
  {
    Length = Lcd_Ctx[Instance].YSize - Ypos;
900079f6:	4a0e      	ldr	r2, [pc, #56]	; (90007a30 <BSP_LCD_DrawVLine+0xa0>)
900079f8:	68fb      	ldr	r3, [r7, #12]
900079fa:	015b      	lsls	r3, r3, #5
900079fc:	4413      	add	r3, r2
900079fe:	3304      	adds	r3, #4
90007a00:	681a      	ldr	r2, [r3, #0]
90007a02:	687b      	ldr	r3, [r7, #4]
90007a04:	1ad3      	subs	r3, r2, r3
90007a06:	603b      	str	r3, [r7, #0]
  }
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, 1, Length, (Lcd_Ctx[Instance].XSize - 1U), Color);
90007a08:	6979      	ldr	r1, [r7, #20]
90007a0a:	4a09      	ldr	r2, [pc, #36]	; (90007a30 <BSP_LCD_DrawVLine+0xa0>)
90007a0c:	68fb      	ldr	r3, [r7, #12]
90007a0e:	015b      	lsls	r3, r3, #5
90007a10:	4413      	add	r3, r2
90007a12:	681b      	ldr	r3, [r3, #0]
90007a14:	3b01      	subs	r3, #1
90007a16:	6a3a      	ldr	r2, [r7, #32]
90007a18:	9201      	str	r2, [sp, #4]
90007a1a:	9300      	str	r3, [sp, #0]
90007a1c:	683b      	ldr	r3, [r7, #0]
90007a1e:	2201      	movs	r2, #1
90007a20:	68f8      	ldr	r0, [r7, #12]
90007a22:	f000 f901 	bl	90007c28 <LL_FillBuffer>

  return BSP_ERROR_NONE;
90007a26:	2300      	movs	r3, #0
}
90007a28:	4618      	mov	r0, r3
90007a2a:	3718      	adds	r7, #24
90007a2c:	46bd      	mov	sp, r7
90007a2e:	bd80      	pop	{r7, pc}
90007a30:	24002b24 	.word	0x24002b24
90007a34:	24002a7c 	.word	0x24002a7c

90007a38 <BSP_LCD_FillRect>:
  * @param  Height Rectangle height
  * @param  Color RGB color
  * @retval BSP status
  */
int32_t BSP_LCD_FillRect(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
90007a38:	b580      	push	{r7, lr}
90007a3a:	b088      	sub	sp, #32
90007a3c:	af02      	add	r7, sp, #8
90007a3e:	60f8      	str	r0, [r7, #12]
90007a40:	60b9      	str	r1, [r7, #8]
90007a42:	607a      	str	r2, [r7, #4]
90007a44:	603b      	str	r3, [r7, #0]
  uint32_t  Xaddress;

  /* Get the rectangle start address */
  Xaddress = (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress) + (Lcd_Ctx[Instance].BppFactor*((Lcd_Ctx[Instance].XSize*Ypos) + Xpos));
90007a46:	4a1b      	ldr	r2, [pc, #108]	; (90007ab4 <BSP_LCD_FillRect+0x7c>)
90007a48:	68fb      	ldr	r3, [r7, #12]
90007a4a:	015b      	lsls	r3, r3, #5
90007a4c:	4413      	add	r3, r2
90007a4e:	3308      	adds	r3, #8
90007a50:	681b      	ldr	r3, [r3, #0]
90007a52:	4a19      	ldr	r2, [pc, #100]	; (90007ab8 <BSP_LCD_FillRect+0x80>)
90007a54:	2134      	movs	r1, #52	; 0x34
90007a56:	fb01 f303 	mul.w	r3, r1, r3
90007a5a:	4413      	add	r3, r2
90007a5c:	335c      	adds	r3, #92	; 0x5c
90007a5e:	681a      	ldr	r2, [r3, #0]
90007a60:	4914      	ldr	r1, [pc, #80]	; (90007ab4 <BSP_LCD_FillRect+0x7c>)
90007a62:	68fb      	ldr	r3, [r7, #12]
90007a64:	015b      	lsls	r3, r3, #5
90007a66:	440b      	add	r3, r1
90007a68:	3310      	adds	r3, #16
90007a6a:	681b      	ldr	r3, [r3, #0]
90007a6c:	4811      	ldr	r0, [pc, #68]	; (90007ab4 <BSP_LCD_FillRect+0x7c>)
90007a6e:	68f9      	ldr	r1, [r7, #12]
90007a70:	0149      	lsls	r1, r1, #5
90007a72:	4401      	add	r1, r0
90007a74:	6809      	ldr	r1, [r1, #0]
90007a76:	6878      	ldr	r0, [r7, #4]
90007a78:	fb00 f001 	mul.w	r0, r0, r1
90007a7c:	68b9      	ldr	r1, [r7, #8]
90007a7e:	4401      	add	r1, r0
90007a80:	fb01 f303 	mul.w	r3, r1, r3
90007a84:	4413      	add	r3, r2
90007a86:	617b      	str	r3, [r7, #20]

  /* Fill the rectangle */
  LL_FillBuffer(Instance, (uint32_t *)Xaddress, Width, Height, (Lcd_Ctx[Instance].XSize - Width), Color);
90007a88:	6979      	ldr	r1, [r7, #20]
90007a8a:	4a0a      	ldr	r2, [pc, #40]	; (90007ab4 <BSP_LCD_FillRect+0x7c>)
90007a8c:	68fb      	ldr	r3, [r7, #12]
90007a8e:	015b      	lsls	r3, r3, #5
90007a90:	4413      	add	r3, r2
90007a92:	681a      	ldr	r2, [r3, #0]
90007a94:	683b      	ldr	r3, [r7, #0]
90007a96:	1ad3      	subs	r3, r2, r3
90007a98:	6a7a      	ldr	r2, [r7, #36]	; 0x24
90007a9a:	9201      	str	r2, [sp, #4]
90007a9c:	9300      	str	r3, [sp, #0]
90007a9e:	6a3b      	ldr	r3, [r7, #32]
90007aa0:	683a      	ldr	r2, [r7, #0]
90007aa2:	68f8      	ldr	r0, [r7, #12]
90007aa4:	f000 f8c0 	bl	90007c28 <LL_FillBuffer>

  return BSP_ERROR_NONE;
90007aa8:	2300      	movs	r3, #0
}
90007aaa:	4618      	mov	r0, r3
90007aac:	3718      	adds	r7, #24
90007aae:	46bd      	mov	sp, r7
90007ab0:	bd80      	pop	{r7, pc}
90007ab2:	bf00      	nop
90007ab4:	24002b24 	.word	0x24002b24
90007ab8:	24002a7c 	.word	0x24002a7c

90007abc <BSP_LCD_ReadPixel>:
  * @param  Ypos Y position
  * @param  Color RGB pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_ReadPixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t *Color)
{
90007abc:	b480      	push	{r7}
90007abe:	b085      	sub	sp, #20
90007ac0:	af00      	add	r7, sp, #0
90007ac2:	60f8      	str	r0, [r7, #12]
90007ac4:	60b9      	str	r1, [r7, #8]
90007ac6:	607a      	str	r2, [r7, #4]
90007ac8:	603b      	str	r3, [r7, #0]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
90007aca:	4a28      	ldr	r2, [pc, #160]	; (90007b6c <BSP_LCD_ReadPixel+0xb0>)
90007acc:	68fb      	ldr	r3, [r7, #12]
90007ace:	015b      	lsls	r3, r3, #5
90007ad0:	4413      	add	r3, r2
90007ad2:	3308      	adds	r3, #8
90007ad4:	681b      	ldr	r3, [r3, #0]
90007ad6:	4a26      	ldr	r2, [pc, #152]	; (90007b70 <BSP_LCD_ReadPixel+0xb4>)
90007ad8:	2134      	movs	r1, #52	; 0x34
90007ada:	fb01 f303 	mul.w	r3, r1, r3
90007ade:	4413      	add	r3, r2
90007ae0:	3348      	adds	r3, #72	; 0x48
90007ae2:	681b      	ldr	r3, [r3, #0]
90007ae4:	2b00      	cmp	r3, #0
90007ae6:	d11c      	bne.n	90007b22 <BSP_LCD_ReadPixel+0x66>
  {
    /* Read data value from SDRAM memory */
    *Color = *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
90007ae8:	4a20      	ldr	r2, [pc, #128]	; (90007b6c <BSP_LCD_ReadPixel+0xb0>)
90007aea:	68fb      	ldr	r3, [r7, #12]
90007aec:	015b      	lsls	r3, r3, #5
90007aee:	4413      	add	r3, r2
90007af0:	3308      	adds	r3, #8
90007af2:	681b      	ldr	r3, [r3, #0]
90007af4:	4a1e      	ldr	r2, [pc, #120]	; (90007b70 <BSP_LCD_ReadPixel+0xb4>)
90007af6:	2134      	movs	r1, #52	; 0x34
90007af8:	fb01 f303 	mul.w	r3, r1, r3
90007afc:	4413      	add	r3, r2
90007afe:	335c      	adds	r3, #92	; 0x5c
90007b00:	681a      	ldr	r2, [r3, #0]
90007b02:	491a      	ldr	r1, [pc, #104]	; (90007b6c <BSP_LCD_ReadPixel+0xb0>)
90007b04:	68fb      	ldr	r3, [r7, #12]
90007b06:	015b      	lsls	r3, r3, #5
90007b08:	440b      	add	r3, r1
90007b0a:	681b      	ldr	r3, [r3, #0]
90007b0c:	6879      	ldr	r1, [r7, #4]
90007b0e:	fb01 f103 	mul.w	r1, r1, r3
90007b12:	68bb      	ldr	r3, [r7, #8]
90007b14:	440b      	add	r3, r1
90007b16:	009b      	lsls	r3, r3, #2
90007b18:	4413      	add	r3, r2
90007b1a:	681a      	ldr	r2, [r3, #0]
90007b1c:	683b      	ldr	r3, [r7, #0]
90007b1e:	601a      	str	r2, [r3, #0]
90007b20:	e01d      	b.n	90007b5e <BSP_LCD_ReadPixel+0xa2>
  }
  else /* if((hlcd_ltdc.LayerCfg[layer].PixelFormat == LTDC_PIXEL_FORMAT_RGB565) */
  {
    /* Read data value from SDRAM memory */
    *Color = *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos)));
90007b22:	4a12      	ldr	r2, [pc, #72]	; (90007b6c <BSP_LCD_ReadPixel+0xb0>)
90007b24:	68fb      	ldr	r3, [r7, #12]
90007b26:	015b      	lsls	r3, r3, #5
90007b28:	4413      	add	r3, r2
90007b2a:	3308      	adds	r3, #8
90007b2c:	681b      	ldr	r3, [r3, #0]
90007b2e:	4a10      	ldr	r2, [pc, #64]	; (90007b70 <BSP_LCD_ReadPixel+0xb4>)
90007b30:	2134      	movs	r1, #52	; 0x34
90007b32:	fb01 f303 	mul.w	r3, r1, r3
90007b36:	4413      	add	r3, r2
90007b38:	335c      	adds	r3, #92	; 0x5c
90007b3a:	681a      	ldr	r2, [r3, #0]
90007b3c:	490b      	ldr	r1, [pc, #44]	; (90007b6c <BSP_LCD_ReadPixel+0xb0>)
90007b3e:	68fb      	ldr	r3, [r7, #12]
90007b40:	015b      	lsls	r3, r3, #5
90007b42:	440b      	add	r3, r1
90007b44:	681b      	ldr	r3, [r3, #0]
90007b46:	6879      	ldr	r1, [r7, #4]
90007b48:	fb01 f103 	mul.w	r1, r1, r3
90007b4c:	68bb      	ldr	r3, [r7, #8]
90007b4e:	440b      	add	r3, r1
90007b50:	005b      	lsls	r3, r3, #1
90007b52:	4413      	add	r3, r2
90007b54:	881b      	ldrh	r3, [r3, #0]
90007b56:	b29b      	uxth	r3, r3
90007b58:	461a      	mov	r2, r3
90007b5a:	683b      	ldr	r3, [r7, #0]
90007b5c:	601a      	str	r2, [r3, #0]
  }

  return BSP_ERROR_NONE;
90007b5e:	2300      	movs	r3, #0
}
90007b60:	4618      	mov	r0, r3
90007b62:	3714      	adds	r7, #20
90007b64:	46bd      	mov	sp, r7
90007b66:	f85d 7b04 	ldr.w	r7, [sp], #4
90007b6a:	4770      	bx	lr
90007b6c:	24002b24 	.word	0x24002b24
90007b70:	24002a7c 	.word	0x24002a7c

90007b74 <BSP_LCD_WritePixel>:
  * @param  Ypos Y position
  * @param  Color Pixel color
  * @retval BSP status
  */
int32_t BSP_LCD_WritePixel(uint32_t Instance, uint32_t Xpos, uint32_t Ypos, uint32_t Color)
{
90007b74:	b480      	push	{r7}
90007b76:	b085      	sub	sp, #20
90007b78:	af00      	add	r7, sp, #0
90007b7a:	60f8      	str	r0, [r7, #12]
90007b7c:	60b9      	str	r1, [r7, #8]
90007b7e:	607a      	str	r2, [r7, #4]
90007b80:	603b      	str	r3, [r7, #0]
  if(hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
90007b82:	4a27      	ldr	r2, [pc, #156]	; (90007c20 <BSP_LCD_WritePixel+0xac>)
90007b84:	68fb      	ldr	r3, [r7, #12]
90007b86:	015b      	lsls	r3, r3, #5
90007b88:	4413      	add	r3, r2
90007b8a:	3308      	adds	r3, #8
90007b8c:	681b      	ldr	r3, [r3, #0]
90007b8e:	4a25      	ldr	r2, [pc, #148]	; (90007c24 <BSP_LCD_WritePixel+0xb0>)
90007b90:	2134      	movs	r1, #52	; 0x34
90007b92:	fb01 f303 	mul.w	r3, r1, r3
90007b96:	4413      	add	r3, r2
90007b98:	3348      	adds	r3, #72	; 0x48
90007b9a:	681b      	ldr	r3, [r3, #0]
90007b9c:	2b00      	cmp	r3, #0
90007b9e:	d11c      	bne.n	90007bda <BSP_LCD_WritePixel+0x66>
  {
    /* Write data value to SDRAM memory */
    *(__IO uint32_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (4U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = Color;
90007ba0:	4a1f      	ldr	r2, [pc, #124]	; (90007c20 <BSP_LCD_WritePixel+0xac>)
90007ba2:	68fb      	ldr	r3, [r7, #12]
90007ba4:	015b      	lsls	r3, r3, #5
90007ba6:	4413      	add	r3, r2
90007ba8:	3308      	adds	r3, #8
90007baa:	681b      	ldr	r3, [r3, #0]
90007bac:	4a1d      	ldr	r2, [pc, #116]	; (90007c24 <BSP_LCD_WritePixel+0xb0>)
90007bae:	2134      	movs	r1, #52	; 0x34
90007bb0:	fb01 f303 	mul.w	r3, r1, r3
90007bb4:	4413      	add	r3, r2
90007bb6:	335c      	adds	r3, #92	; 0x5c
90007bb8:	681a      	ldr	r2, [r3, #0]
90007bba:	4919      	ldr	r1, [pc, #100]	; (90007c20 <BSP_LCD_WritePixel+0xac>)
90007bbc:	68fb      	ldr	r3, [r7, #12]
90007bbe:	015b      	lsls	r3, r3, #5
90007bc0:	440b      	add	r3, r1
90007bc2:	681b      	ldr	r3, [r3, #0]
90007bc4:	6879      	ldr	r1, [r7, #4]
90007bc6:	fb01 f103 	mul.w	r1, r1, r3
90007bca:	68bb      	ldr	r3, [r7, #8]
90007bcc:	440b      	add	r3, r1
90007bce:	009b      	lsls	r3, r3, #2
90007bd0:	4413      	add	r3, r2
90007bd2:	461a      	mov	r2, r3
90007bd4:	683b      	ldr	r3, [r7, #0]
90007bd6:	6013      	str	r3, [r2, #0]
90007bd8:	e01b      	b.n	90007c12 <BSP_LCD_WritePixel+0x9e>
  }
  else
  {
    /* Write data value to SDRAM memory */
    *(__IO uint16_t*) (hlcd_ltdc.LayerCfg[Lcd_Ctx[Instance].ActiveLayer].FBStartAdress + (2U*((Ypos*Lcd_Ctx[Instance].XSize) + Xpos))) = (uint16_t)Color;
90007bda:	4a11      	ldr	r2, [pc, #68]	; (90007c20 <BSP_LCD_WritePixel+0xac>)
90007bdc:	68fb      	ldr	r3, [r7, #12]
90007bde:	015b      	lsls	r3, r3, #5
90007be0:	4413      	add	r3, r2
90007be2:	3308      	adds	r3, #8
90007be4:	681b      	ldr	r3, [r3, #0]
90007be6:	4a0f      	ldr	r2, [pc, #60]	; (90007c24 <BSP_LCD_WritePixel+0xb0>)
90007be8:	2134      	movs	r1, #52	; 0x34
90007bea:	fb01 f303 	mul.w	r3, r1, r3
90007bee:	4413      	add	r3, r2
90007bf0:	335c      	adds	r3, #92	; 0x5c
90007bf2:	681a      	ldr	r2, [r3, #0]
90007bf4:	490a      	ldr	r1, [pc, #40]	; (90007c20 <BSP_LCD_WritePixel+0xac>)
90007bf6:	68fb      	ldr	r3, [r7, #12]
90007bf8:	015b      	lsls	r3, r3, #5
90007bfa:	440b      	add	r3, r1
90007bfc:	681b      	ldr	r3, [r3, #0]
90007bfe:	6879      	ldr	r1, [r7, #4]
90007c00:	fb01 f103 	mul.w	r1, r1, r3
90007c04:	68bb      	ldr	r3, [r7, #8]
90007c06:	440b      	add	r3, r1
90007c08:	005b      	lsls	r3, r3, #1
90007c0a:	4413      	add	r3, r2
90007c0c:	683a      	ldr	r2, [r7, #0]
90007c0e:	b292      	uxth	r2, r2
90007c10:	801a      	strh	r2, [r3, #0]
  }

  return BSP_ERROR_NONE;
90007c12:	2300      	movs	r3, #0
}
90007c14:	4618      	mov	r0, r3
90007c16:	3714      	adds	r7, #20
90007c18:	46bd      	mov	sp, r7
90007c1a:	f85d 7b04 	ldr.w	r7, [sp], #4
90007c1e:	4770      	bx	lr
90007c20:	24002b24 	.word	0x24002b24
90007c24:	24002a7c 	.word	0x24002a7c

90007c28 <LL_FillBuffer>:
  * @param  ySize Buffer height
  * @param  OffLine Offset
  * @param  Color Color index
  */
static void LL_FillBuffer(uint32_t Instance, uint32_t *pDst, uint32_t xSize, uint32_t ySize, uint32_t OffLine, uint32_t Color)
{
90007c28:	b580      	push	{r7, lr}
90007c2a:	b088      	sub	sp, #32
90007c2c:	af02      	add	r7, sp, #8
90007c2e:	60f8      	str	r0, [r7, #12]
90007c30:	60b9      	str	r1, [r7, #8]
90007c32:	607a      	str	r2, [r7, #4]
90007c34:	603b      	str	r3, [r7, #0]
  uint32_t output_color_mode, input_color = Color;
90007c36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90007c38:	613b      	str	r3, [r7, #16]

  switch(Lcd_Ctx[Instance].PixelFormat)
90007c3a:	4a2d      	ldr	r2, [pc, #180]	; (90007cf0 <LL_FillBuffer+0xc8>)
90007c3c:	68fb      	ldr	r3, [r7, #12]
90007c3e:	015b      	lsls	r3, r3, #5
90007c40:	4413      	add	r3, r2
90007c42:	330c      	adds	r3, #12
90007c44:	681b      	ldr	r3, [r3, #0]
90007c46:	2b02      	cmp	r3, #2
90007c48:	d129      	bne.n	90007c9e <LL_FillBuffer+0x76>
  {
  case LCD_PIXEL_FORMAT_RGB565:
    output_color_mode = DMA2D_OUTPUT_RGB565; /* RGB565 */
90007c4a:	2302      	movs	r3, #2
90007c4c:	617b      	str	r3, [r7, #20]
    input_color = CONVERTRGB5652ARGB8888(Color);
90007c4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90007c50:	0adb      	lsrs	r3, r3, #11
90007c52:	f003 021f 	and.w	r2, r3, #31
90007c56:	4613      	mov	r3, r2
90007c58:	011b      	lsls	r3, r3, #4
90007c5a:	4413      	add	r3, r2
90007c5c:	015a      	lsls	r2, r3, #5
90007c5e:	1ad3      	subs	r3, r2, r3
90007c60:	3317      	adds	r3, #23
90007c62:	099b      	lsrs	r3, r3, #6
90007c64:	0419      	lsls	r1, r3, #16
90007c66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90007c68:	095b      	lsrs	r3, r3, #5
90007c6a:	f003 023f 	and.w	r2, r3, #63	; 0x3f
90007c6e:	4613      	mov	r3, r2
90007c70:	01db      	lsls	r3, r3, #7
90007c72:	4413      	add	r3, r2
90007c74:	005b      	lsls	r3, r3, #1
90007c76:	4413      	add	r3, r2
90007c78:	3321      	adds	r3, #33	; 0x21
90007c7a:	099b      	lsrs	r3, r3, #6
90007c7c:	021b      	lsls	r3, r3, #8
90007c7e:	4319      	orrs	r1, r3
90007c80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90007c82:	f003 021f 	and.w	r2, r3, #31
90007c86:	4613      	mov	r3, r2
90007c88:	011b      	lsls	r3, r3, #4
90007c8a:	4413      	add	r3, r2
90007c8c:	015a      	lsls	r2, r3, #5
90007c8e:	1ad3      	subs	r3, r2, r3
90007c90:	3317      	adds	r3, #23
90007c92:	099b      	lsrs	r3, r3, #6
90007c94:	430b      	orrs	r3, r1
90007c96:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
90007c9a:	613b      	str	r3, [r7, #16]
    break;
90007c9c:	e002      	b.n	90007ca4 <LL_FillBuffer+0x7c>
  case LCD_PIXEL_FORMAT_RGB888:
  default:
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
90007c9e:	2300      	movs	r3, #0
90007ca0:	617b      	str	r3, [r7, #20]
    break;
90007ca2:	bf00      	nop
  }

  /* Register to memory mode with ARGB8888 as color Mode */
  hlcd_dma2d.Init.Mode         = DMA2D_R2M;
90007ca4:	4b13      	ldr	r3, [pc, #76]	; (90007cf4 <LL_FillBuffer+0xcc>)
90007ca6:	f44f 3240 	mov.w	r2, #196608	; 0x30000
90007caa:	605a      	str	r2, [r3, #4]
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
90007cac:	4a11      	ldr	r2, [pc, #68]	; (90007cf4 <LL_FillBuffer+0xcc>)
90007cae:	697b      	ldr	r3, [r7, #20]
90007cb0:	6093      	str	r3, [r2, #8]
  hlcd_dma2d.Init.OutputOffset = OffLine;
90007cb2:	4a10      	ldr	r2, [pc, #64]	; (90007cf4 <LL_FillBuffer+0xcc>)
90007cb4:	6a3b      	ldr	r3, [r7, #32]
90007cb6:	60d3      	str	r3, [r2, #12]

  hlcd_dma2d.Instance = DMA2D;
90007cb8:	4b0e      	ldr	r3, [pc, #56]	; (90007cf4 <LL_FillBuffer+0xcc>)
90007cba:	4a0f      	ldr	r2, [pc, #60]	; (90007cf8 <LL_FillBuffer+0xd0>)
90007cbc:	601a      	str	r2, [r3, #0]

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
90007cbe:	480d      	ldr	r0, [pc, #52]	; (90007cf4 <LL_FillBuffer+0xcc>)
90007cc0:	f004 fb42 	bl	9000c348 <HAL_DMA2D_Init>
90007cc4:	4603      	mov	r3, r0
90007cc6:	2b00      	cmp	r3, #0
90007cc8:	d10e      	bne.n	90007ce8 <LL_FillBuffer+0xc0>
  {
      if (HAL_DMA2D_Start(&hlcd_dma2d, input_color, (uint32_t)pDst, xSize, ySize) == HAL_OK)
90007cca:	68ba      	ldr	r2, [r7, #8]
90007ccc:	683b      	ldr	r3, [r7, #0]
90007cce:	9300      	str	r3, [sp, #0]
90007cd0:	687b      	ldr	r3, [r7, #4]
90007cd2:	6939      	ldr	r1, [r7, #16]
90007cd4:	4807      	ldr	r0, [pc, #28]	; (90007cf4 <LL_FillBuffer+0xcc>)
90007cd6:	f004 fc1f 	bl	9000c518 <HAL_DMA2D_Start>
90007cda:	4603      	mov	r3, r0
90007cdc:	2b00      	cmp	r3, #0
90007cde:	d103      	bne.n	90007ce8 <LL_FillBuffer+0xc0>
      {
        /* Polling For DMA transfer */
      (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
90007ce0:	2132      	movs	r1, #50	; 0x32
90007ce2:	4804      	ldr	r0, [pc, #16]	; (90007cf4 <LL_FillBuffer+0xcc>)
90007ce4:	f004 fcd8 	bl	9000c698 <HAL_DMA2D_PollForTransfer>
    }
  }
}
90007ce8:	bf00      	nop
90007cea:	3718      	adds	r7, #24
90007cec:	46bd      	mov	sp, r7
90007cee:	bd80      	pop	{r7, pc}
90007cf0:	24002b24 	.word	0x24002b24
90007cf4:	24002b44 	.word	0x24002b44
90007cf8:	52001000 	.word	0x52001000

90007cfc <LL_ConvertLineToRGB>:
  * @param  pDst Output color
  * @param  xSize Buffer width
  * @param  ColorMode Input color mode
  */
static void LL_ConvertLineToRGB(uint32_t Instance, uint32_t *pSrc, uint32_t *pDst, uint32_t xSize, uint32_t ColorMode)
{
90007cfc:	b580      	push	{r7, lr}
90007cfe:	b088      	sub	sp, #32
90007d00:	af02      	add	r7, sp, #8
90007d02:	60f8      	str	r0, [r7, #12]
90007d04:	60b9      	str	r1, [r7, #8]
90007d06:	607a      	str	r2, [r7, #4]
90007d08:	603b      	str	r3, [r7, #0]
  uint32_t output_color_mode;

  switch(Lcd_Ctx[Instance].PixelFormat)
90007d0a:	4a23      	ldr	r2, [pc, #140]	; (90007d98 <LL_ConvertLineToRGB+0x9c>)
90007d0c:	68fb      	ldr	r3, [r7, #12]
90007d0e:	015b      	lsls	r3, r3, #5
90007d10:	4413      	add	r3, r2
90007d12:	330c      	adds	r3, #12
90007d14:	681b      	ldr	r3, [r3, #0]
90007d16:	2b02      	cmp	r3, #2
90007d18:	d102      	bne.n	90007d20 <LL_ConvertLineToRGB+0x24>
  {
  case LCD_PIXEL_FORMAT_RGB565:
    output_color_mode = DMA2D_OUTPUT_RGB565; /* RGB565 */
90007d1a:	2302      	movs	r3, #2
90007d1c:	617b      	str	r3, [r7, #20]
    break;
90007d1e:	e002      	b.n	90007d26 <LL_ConvertLineToRGB+0x2a>
  case LCD_PIXEL_FORMAT_RGB888:
  default:
    output_color_mode = DMA2D_OUTPUT_ARGB8888; /* ARGB8888 */
90007d20:	2300      	movs	r3, #0
90007d22:	617b      	str	r3, [r7, #20]
    break;
90007d24:	bf00      	nop
  }

  /* Configure the DMA2D Mode, Color Mode and output offset */
  hlcd_dma2d.Init.Mode         = DMA2D_M2M_PFC;
90007d26:	4b1d      	ldr	r3, [pc, #116]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d28:	f44f 3280 	mov.w	r2, #65536	; 0x10000
90007d2c:	605a      	str	r2, [r3, #4]
  hlcd_dma2d.Init.ColorMode    = output_color_mode;
90007d2e:	4a1b      	ldr	r2, [pc, #108]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d30:	697b      	ldr	r3, [r7, #20]
90007d32:	6093      	str	r3, [r2, #8]
  hlcd_dma2d.Init.OutputOffset = 0;
90007d34:	4b19      	ldr	r3, [pc, #100]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d36:	2200      	movs	r2, #0
90007d38:	60da      	str	r2, [r3, #12]

  /* Foreground Configuration */
  hlcd_dma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
90007d3a:	4b18      	ldr	r3, [pc, #96]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d3c:	2200      	movs	r2, #0
90007d3e:	64da      	str	r2, [r3, #76]	; 0x4c
  hlcd_dma2d.LayerCfg[1].InputAlpha = 0xFF;
90007d40:	4b16      	ldr	r3, [pc, #88]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d42:	22ff      	movs	r2, #255	; 0xff
90007d44:	651a      	str	r2, [r3, #80]	; 0x50
  hlcd_dma2d.LayerCfg[1].InputColorMode = ColorMode;
90007d46:	4a15      	ldr	r2, [pc, #84]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d48:	6a3b      	ldr	r3, [r7, #32]
90007d4a:	6493      	str	r3, [r2, #72]	; 0x48
  hlcd_dma2d.LayerCfg[1].InputOffset = 0;
90007d4c:	4b13      	ldr	r3, [pc, #76]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d4e:	2200      	movs	r2, #0
90007d50:	645a      	str	r2, [r3, #68]	; 0x44

  hlcd_dma2d.Instance = DMA2D;
90007d52:	4b12      	ldr	r3, [pc, #72]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d54:	4a12      	ldr	r2, [pc, #72]	; (90007da0 <LL_ConvertLineToRGB+0xa4>)
90007d56:	601a      	str	r2, [r3, #0]

  /* DMA2D Initialization */
  if(HAL_DMA2D_Init(&hlcd_dma2d) == HAL_OK)
90007d58:	4810      	ldr	r0, [pc, #64]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d5a:	f004 faf5 	bl	9000c348 <HAL_DMA2D_Init>
90007d5e:	4603      	mov	r3, r0
90007d60:	2b00      	cmp	r3, #0
90007d62:	d115      	bne.n	90007d90 <LL_ConvertLineToRGB+0x94>
  {
    if(HAL_DMA2D_ConfigLayer(&hlcd_dma2d, 1) == HAL_OK)
90007d64:	2101      	movs	r1, #1
90007d66:	480d      	ldr	r0, [pc, #52]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d68:	f004 fd80 	bl	9000c86c <HAL_DMA2D_ConfigLayer>
90007d6c:	4603      	mov	r3, r0
90007d6e:	2b00      	cmp	r3, #0
90007d70:	d10e      	bne.n	90007d90 <LL_ConvertLineToRGB+0x94>
    {
      if (HAL_DMA2D_Start(&hlcd_dma2d, (uint32_t)pSrc, (uint32_t)pDst, xSize, 1) == HAL_OK)
90007d72:	68b9      	ldr	r1, [r7, #8]
90007d74:	687a      	ldr	r2, [r7, #4]
90007d76:	2301      	movs	r3, #1
90007d78:	9300      	str	r3, [sp, #0]
90007d7a:	683b      	ldr	r3, [r7, #0]
90007d7c:	4807      	ldr	r0, [pc, #28]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d7e:	f004 fbcb 	bl	9000c518 <HAL_DMA2D_Start>
90007d82:	4603      	mov	r3, r0
90007d84:	2b00      	cmp	r3, #0
90007d86:	d103      	bne.n	90007d90 <LL_ConvertLineToRGB+0x94>
      {
        /* Polling For DMA transfer */
        (void)HAL_DMA2D_PollForTransfer(&hlcd_dma2d, 50);
90007d88:	2132      	movs	r1, #50	; 0x32
90007d8a:	4804      	ldr	r0, [pc, #16]	; (90007d9c <LL_ConvertLineToRGB+0xa0>)
90007d8c:	f004 fc84 	bl	9000c698 <HAL_DMA2D_PollForTransfer>
      }
    }
  }
}
90007d90:	bf00      	nop
90007d92:	3718      	adds	r7, #24
90007d94:	46bd      	mov	sp, r7
90007d96:	bd80      	pop	{r7, pc}
90007d98:	24002b24 	.word	0x24002b24
90007d9c:	24002b44 	.word	0x24002b44
90007da0:	52001000 	.word	0x52001000

90007da4 <LTDC_MspInit>:
  * @brief  Initialize the BSP LTDC Msp.
  * @param  hltdc  LTDC handle
  * @retval None
  */
static void LTDC_MspInit(LTDC_HandleTypeDef *hltdc)
{
90007da4:	b580      	push	{r7, lr}
90007da6:	b08e      	sub	sp, #56	; 0x38
90007da8:	af00      	add	r7, sp, #0
90007daa:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef  gpio_init_structure;

  if(hltdc->Instance == LTDC)
90007dac:	687b      	ldr	r3, [r7, #4]
90007dae:	681b      	ldr	r3, [r3, #0]
90007db0:	4a5b      	ldr	r2, [pc, #364]	; (90007f20 <LTDC_MspInit+0x17c>)
90007db2:	4293      	cmp	r3, r2
90007db4:	f040 80b0 	bne.w	90007f18 <LTDC_MspInit+0x174>
  {
    /** Enable the LTDC clock */
    __HAL_RCC_LTDC_CLK_ENABLE();
90007db8:	4b5a      	ldr	r3, [pc, #360]	; (90007f24 <LTDC_MspInit+0x180>)
90007dba:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
90007dbe:	4a59      	ldr	r2, [pc, #356]	; (90007f24 <LTDC_MspInit+0x180>)
90007dc0:	f043 0308 	orr.w	r3, r3, #8
90007dc4:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
90007dc8:	4b56      	ldr	r3, [pc, #344]	; (90007f24 <LTDC_MspInit+0x180>)
90007dca:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
90007dce:	f003 0308 	and.w	r3, r3, #8
90007dd2:	623b      	str	r3, [r7, #32]
90007dd4:	6a3b      	ldr	r3, [r7, #32]

    /* Enable GPIOs clock */
    __HAL_RCC_GPIOI_CLK_ENABLE();
90007dd6:	4b53      	ldr	r3, [pc, #332]	; (90007f24 <LTDC_MspInit+0x180>)
90007dd8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007ddc:	4a51      	ldr	r2, [pc, #324]	; (90007f24 <LTDC_MspInit+0x180>)
90007dde:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90007de2:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90007de6:	4b4f      	ldr	r3, [pc, #316]	; (90007f24 <LTDC_MspInit+0x180>)
90007de8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007dec:	f403 7380 	and.w	r3, r3, #256	; 0x100
90007df0:	61fb      	str	r3, [r7, #28]
90007df2:	69fb      	ldr	r3, [r7, #28]
    __HAL_RCC_GPIOJ_CLK_ENABLE();
90007df4:	4b4b      	ldr	r3, [pc, #300]	; (90007f24 <LTDC_MspInit+0x180>)
90007df6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007dfa:	4a4a      	ldr	r2, [pc, #296]	; (90007f24 <LTDC_MspInit+0x180>)
90007dfc:	f443 7300 	orr.w	r3, r3, #512	; 0x200
90007e00:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90007e04:	4b47      	ldr	r3, [pc, #284]	; (90007f24 <LTDC_MspInit+0x180>)
90007e06:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007e0a:	f403 7300 	and.w	r3, r3, #512	; 0x200
90007e0e:	61bb      	str	r3, [r7, #24]
90007e10:	69bb      	ldr	r3, [r7, #24]
    __HAL_RCC_GPIOK_CLK_ENABLE();
90007e12:	4b44      	ldr	r3, [pc, #272]	; (90007f24 <LTDC_MspInit+0x180>)
90007e14:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007e18:	4a42      	ldr	r2, [pc, #264]	; (90007f24 <LTDC_MspInit+0x180>)
90007e1a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
90007e1e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90007e22:	4b40      	ldr	r3, [pc, #256]	; (90007f24 <LTDC_MspInit+0x180>)
90007e24:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007e28:	f403 6380 	and.w	r3, r3, #1024	; 0x400
90007e2c:	617b      	str	r3, [r7, #20]
90007e2e:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOH_CLK_ENABLE();
90007e30:	4b3c      	ldr	r3, [pc, #240]	; (90007f24 <LTDC_MspInit+0x180>)
90007e32:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007e36:	4a3b      	ldr	r2, [pc, #236]	; (90007f24 <LTDC_MspInit+0x180>)
90007e38:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90007e3c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90007e40:	4b38      	ldr	r3, [pc, #224]	; (90007f24 <LTDC_MspInit+0x180>)
90007e42:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007e46:	f003 0380 	and.w	r3, r3, #128	; 0x80
90007e4a:	613b      	str	r3, [r7, #16]
90007e4c:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOD_CLK_ENABLE();
90007e4e:	4b35      	ldr	r3, [pc, #212]	; (90007f24 <LTDC_MspInit+0x180>)
90007e50:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007e54:	4a33      	ldr	r2, [pc, #204]	; (90007f24 <LTDC_MspInit+0x180>)
90007e56:	f043 0308 	orr.w	r3, r3, #8
90007e5a:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90007e5e:	4b31      	ldr	r3, [pc, #196]	; (90007f24 <LTDC_MspInit+0x180>)
90007e60:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90007e64:	f003 0308 	and.w	r3, r3, #8
90007e68:	60fb      	str	r3, [r7, #12]
90007e6a:	68fb      	ldr	r3, [r7, #12]

    /*** LTDC Pins configuration ***/
    /* GPIOI configuration */
    gpio_init_structure.Pin       = GPIO_PIN_0 |GPIO_PIN_1 |GPIO_PIN_9 | GPIO_PIN_12 |GPIO_PIN_14 | GPIO_PIN_15;
90007e6c:	f24d 2303 	movw	r3, #53763	; 0xd203
90007e70:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
90007e72:	2302      	movs	r3, #2
90007e74:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Pull      = GPIO_NOPULL;
90007e76:	2300      	movs	r3, #0
90007e78:	62fb      	str	r3, [r7, #44]	; 0x2c
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
90007e7a:	2302      	movs	r3, #2
90007e7c:	633b      	str	r3, [r7, #48]	; 0x30
    gpio_init_structure.Alternate = GPIO_AF14_LTDC;
90007e7e:	230e      	movs	r3, #14
90007e80:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOI, &gpio_init_structure);
90007e82:	f107 0324 	add.w	r3, r7, #36	; 0x24
90007e86:	4619      	mov	r1, r3
90007e88:	4827      	ldr	r0, [pc, #156]	; (90007f28 <LTDC_MspInit+0x184>)
90007e8a:	f004 fead 	bl	9000cbe8 <HAL_GPIO_Init>

    /* GPIOJ configuration */
    gpio_init_structure.Pin       = GPIO_PIN_All;
90007e8e:	f64f 73ff 	movw	r3, #65535	; 0xffff
90007e92:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Alternate = GPIO_AF14_LTDC;
90007e94:	230e      	movs	r3, #14
90007e96:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOJ, &gpio_init_structure);
90007e98:	f107 0324 	add.w	r3, r7, #36	; 0x24
90007e9c:	4619      	mov	r1, r3
90007e9e:	4823      	ldr	r0, [pc, #140]	; (90007f2c <LTDC_MspInit+0x188>)
90007ea0:	f004 fea2 	bl	9000cbe8 <HAL_GPIO_Init>
    /* GPIOK configuration */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | \
90007ea4:	23ff      	movs	r3, #255	; 0xff
90007ea6:	627b      	str	r3, [r7, #36]	; 0x24
                                    GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
    gpio_init_structure.Alternate = GPIO_AF14_LTDC;
90007ea8:	230e      	movs	r3, #14
90007eaa:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOK, &gpio_init_structure);
90007eac:	f107 0324 	add.w	r3, r7, #36	; 0x24
90007eb0:	4619      	mov	r1, r3
90007eb2:	481f      	ldr	r0, [pc, #124]	; (90007f30 <LTDC_MspInit+0x18c>)
90007eb4:	f004 fe98 	bl	9000cbe8 <HAL_GPIO_Init>

    /* GPIOH configuration */
    gpio_init_structure.Pin       =  GPIO_PIN_9 | GPIO_PIN_1;
90007eb8:	f240 2302 	movw	r3, #514	; 0x202
90007ebc:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
90007ebe:	2302      	movs	r3, #2
90007ec0:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Pull      = GPIO_NOPULL;
90007ec2:	2300      	movs	r3, #0
90007ec4:	62fb      	str	r3, [r7, #44]	; 0x2c
    gpio_init_structure.Speed     = GPIO_SPEED_FREQ_HIGH;
90007ec6:	2302      	movs	r3, #2
90007ec8:	633b      	str	r3, [r7, #48]	; 0x30
    gpio_init_structure.Alternate = GPIO_AF14_LTDC;
90007eca:	230e      	movs	r3, #14
90007ecc:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOH, &gpio_init_structure);
90007ece:	f107 0324 	add.w	r3, r7, #36	; 0x24
90007ed2:	4619      	mov	r1, r3
90007ed4:	4817      	ldr	r0, [pc, #92]	; (90007f34 <LTDC_MspInit+0x190>)
90007ed6:	f004 fe87 	bl	9000cbe8 <HAL_GPIO_Init>

    gpio_init_structure.Pin       = GPIO_PIN_7;     /* LCD_DISP pin has to be manually controlled */
90007eda:	2380      	movs	r3, #128	; 0x80
90007edc:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
90007ede:	2301      	movs	r3, #1
90007ee0:	62bb      	str	r3, [r7, #40]	; 0x28
    HAL_GPIO_Init(GPIOD, &gpio_init_structure);
90007ee2:	f107 0324 	add.w	r3, r7, #36	; 0x24
90007ee6:	4619      	mov	r1, r3
90007ee8:	4813      	ldr	r0, [pc, #76]	; (90007f38 <LTDC_MspInit+0x194>)
90007eea:	f004 fe7d 	bl	9000cbe8 <HAL_GPIO_Init>
    /* Assert display enable LCD_DISP pin */
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_7, GPIO_PIN_SET);
90007eee:	2201      	movs	r2, #1
90007ef0:	2180      	movs	r1, #128	; 0x80
90007ef2:	4811      	ldr	r0, [pc, #68]	; (90007f38 <LTDC_MspInit+0x194>)
90007ef4:	f005 f94a 	bl	9000d18c <HAL_GPIO_WritePin>

    /** Toggle Sw reset of LTDC IP */
    __HAL_RCC_LTDC_FORCE_RESET();
90007ef8:	4b0a      	ldr	r3, [pc, #40]	; (90007f24 <LTDC_MspInit+0x180>)
90007efa:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90007efe:	4a09      	ldr	r2, [pc, #36]	; (90007f24 <LTDC_MspInit+0x180>)
90007f00:	f043 0308 	orr.w	r3, r3, #8
90007f04:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
    __HAL_RCC_LTDC_RELEASE_RESET();
90007f08:	4b06      	ldr	r3, [pc, #24]	; (90007f24 <LTDC_MspInit+0x180>)
90007f0a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90007f0e:	4a05      	ldr	r2, [pc, #20]	; (90007f24 <LTDC_MspInit+0x180>)
90007f10:	f023 0308 	bic.w	r3, r3, #8
90007f14:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
  }
}
90007f18:	bf00      	nop
90007f1a:	3738      	adds	r7, #56	; 0x38
90007f1c:	46bd      	mov	sp, r7
90007f1e:	bd80      	pop	{r7, pc}
90007f20:	50001000 	.word	0x50001000
90007f24:	58024400 	.word	0x58024400
90007f28:	58022000 	.word	0x58022000
90007f2c:	58022400 	.word	0x58022400
90007f30:	58022800 	.word	0x58022800
90007f34:	58021c00 	.word	0x58021c00
90007f38:	58020c00 	.word	0x58020c00

90007f3c <LTDC_MspDeInit>:
  * @brief  De-Initializes the BSP LTDC Msp
  * @param  hltdc  LTDC handle
  * @retval None
  */
static void LTDC_MspDeInit(LTDC_HandleTypeDef *hltdc)
{
90007f3c:	b580      	push	{r7, lr}
90007f3e:	b088      	sub	sp, #32
90007f40:	af00      	add	r7, sp, #0
90007f42:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef  gpio_init_structure;

  if(hltdc->Instance == LTDC)
90007f44:	687b      	ldr	r3, [r7, #4]
90007f46:	681b      	ldr	r3, [r3, #0]
90007f48:	4a16      	ldr	r2, [pc, #88]	; (90007fa4 <LTDC_MspDeInit+0x68>)
90007f4a:	4293      	cmp	r3, r2
90007f4c:	d126      	bne.n	90007f9c <LTDC_MspDeInit+0x60>
  {
    /* LTDC Pins deactivation */
    /* GPIOI deactivation */
    gpio_init_structure.Pin       = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
90007f4e:	f44f 4370 	mov.w	r3, #61440	; 0xf000
90007f52:	60fb      	str	r3, [r7, #12]
    HAL_GPIO_DeInit(GPIOI, gpio_init_structure.Pin);
90007f54:	68fb      	ldr	r3, [r7, #12]
90007f56:	4619      	mov	r1, r3
90007f58:	4813      	ldr	r0, [pc, #76]	; (90007fa8 <LTDC_MspDeInit+0x6c>)
90007f5a:	f004 fff5 	bl	9000cf48 <HAL_GPIO_DeInit>

    /* GPIOJ deactivation */
    gpio_init_structure.Pin       = GPIO_PIN_All;
90007f5e:	f64f 73ff 	movw	r3, #65535	; 0xffff
90007f62:	60fb      	str	r3, [r7, #12]
    HAL_GPIO_DeInit(GPIOJ, gpio_init_structure.Pin);
90007f64:	68fb      	ldr	r3, [r7, #12]
90007f66:	4619      	mov	r1, r3
90007f68:	4810      	ldr	r0, [pc, #64]	; (90007fac <LTDC_MspDeInit+0x70>)
90007f6a:	f004 ffed 	bl	9000cf48 <HAL_GPIO_DeInit>
    /* GPIOK deactivation */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | \
90007f6e:	23ff      	movs	r3, #255	; 0xff
90007f70:	60fb      	str	r3, [r7, #12]
                                    GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
    HAL_GPIO_DeInit(GPIOK, gpio_init_structure.Pin);
90007f72:	68fb      	ldr	r3, [r7, #12]
90007f74:	4619      	mov	r1, r3
90007f76:	480e      	ldr	r0, [pc, #56]	; (90007fb0 <LTDC_MspDeInit+0x74>)
90007f78:	f004 ffe6 	bl	9000cf48 <HAL_GPIO_DeInit>

    /** Force and let in reset state LTDC */
    __HAL_RCC_LTDC_FORCE_RESET();
90007f7c:	4b0d      	ldr	r3, [pc, #52]	; (90007fb4 <LTDC_MspDeInit+0x78>)
90007f7e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90007f82:	4a0c      	ldr	r2, [pc, #48]	; (90007fb4 <LTDC_MspDeInit+0x78>)
90007f84:	f043 0308 	orr.w	r3, r3, #8
90007f88:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c

    /** Disable the LTDC */
    __HAL_RCC_LTDC_CLK_DISABLE();
90007f8c:	4b09      	ldr	r3, [pc, #36]	; (90007fb4 <LTDC_MspDeInit+0x78>)
90007f8e:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
90007f92:	4a08      	ldr	r2, [pc, #32]	; (90007fb4 <LTDC_MspDeInit+0x78>)
90007f94:	f023 0308 	bic.w	r3, r3, #8
90007f98:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
  }
}
90007f9c:	bf00      	nop
90007f9e:	3720      	adds	r7, #32
90007fa0:	46bd      	mov	sp, r7
90007fa2:	bd80      	pop	{r7, pc}
90007fa4:	50001000 	.word	0x50001000
90007fa8:	58022000 	.word	0x58022000
90007fac:	58022400 	.word	0x58022400
90007fb0:	58022800 	.word	0x58022800
90007fb4:	58024400 	.word	0x58024400

90007fb8 <DMA2D_MspInit>:
  * @brief  Initialize the BSP DMA2D Msp.
  * @param  hdma2d  DMA2D handle
  * @retval None
  */
static void DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
90007fb8:	b480      	push	{r7}
90007fba:	b085      	sub	sp, #20
90007fbc:	af00      	add	r7, sp, #0
90007fbe:	6078      	str	r0, [r7, #4]
  if(hdma2d->Instance == DMA2D)
90007fc0:	687b      	ldr	r3, [r7, #4]
90007fc2:	681b      	ldr	r3, [r3, #0]
90007fc4:	4a11      	ldr	r2, [pc, #68]	; (9000800c <DMA2D_MspInit+0x54>)
90007fc6:	4293      	cmp	r3, r2
90007fc8:	d11a      	bne.n	90008000 <DMA2D_MspInit+0x48>
  {
    /** Enable the DMA2D clock */
    __HAL_RCC_DMA2D_CLK_ENABLE();
90007fca:	4b11      	ldr	r3, [pc, #68]	; (90008010 <DMA2D_MspInit+0x58>)
90007fcc:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
90007fd0:	4a0f      	ldr	r2, [pc, #60]	; (90008010 <DMA2D_MspInit+0x58>)
90007fd2:	f043 0310 	orr.w	r3, r3, #16
90007fd6:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
90007fda:	4b0d      	ldr	r3, [pc, #52]	; (90008010 <DMA2D_MspInit+0x58>)
90007fdc:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
90007fe0:	f003 0310 	and.w	r3, r3, #16
90007fe4:	60fb      	str	r3, [r7, #12]
90007fe6:	68fb      	ldr	r3, [r7, #12]

    /** Toggle Sw reset of DMA2D IP */
    __HAL_RCC_DMA2D_FORCE_RESET();
90007fe8:	4b09      	ldr	r3, [pc, #36]	; (90008010 <DMA2D_MspInit+0x58>)
90007fea:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
90007fec:	4a08      	ldr	r2, [pc, #32]	; (90008010 <DMA2D_MspInit+0x58>)
90007fee:	f043 0310 	orr.w	r3, r3, #16
90007ff2:	67d3      	str	r3, [r2, #124]	; 0x7c
    __HAL_RCC_DMA2D_RELEASE_RESET();
90007ff4:	4b06      	ldr	r3, [pc, #24]	; (90008010 <DMA2D_MspInit+0x58>)
90007ff6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
90007ff8:	4a05      	ldr	r2, [pc, #20]	; (90008010 <DMA2D_MspInit+0x58>)
90007ffa:	f023 0310 	bic.w	r3, r3, #16
90007ffe:	67d3      	str	r3, [r2, #124]	; 0x7c
  }
}
90008000:	bf00      	nop
90008002:	3714      	adds	r7, #20
90008004:	46bd      	mov	sp, r7
90008006:	f85d 7b04 	ldr.w	r7, [sp], #4
9000800a:	4770      	bx	lr
9000800c:	52001000 	.word	0x52001000
90008010:	58024400 	.word	0x58024400

90008014 <DMA2D_MspDeInit>:
  * @brief  De-Initializes the BSP DMA2D Msp
  * @param  hdma2d  DMA2D handle
  * @retval None
  */
static void DMA2D_MspDeInit(DMA2D_HandleTypeDef *hdma2d)
{
90008014:	b580      	push	{r7, lr}
90008016:	b082      	sub	sp, #8
90008018:	af00      	add	r7, sp, #0
9000801a:	6078      	str	r0, [r7, #4]
  if(hdma2d->Instance == DMA2D)
9000801c:	687b      	ldr	r3, [r7, #4]
9000801e:	681b      	ldr	r3, [r3, #0]
90008020:	4a0b      	ldr	r2, [pc, #44]	; (90008050 <DMA2D_MspDeInit+0x3c>)
90008022:	4293      	cmp	r3, r2
90008024:	d110      	bne.n	90008048 <DMA2D_MspDeInit+0x34>
  {
    /** Disable IRQ of DMA2D IP */
    HAL_NVIC_DisableIRQ(DMA2D_IRQn);
90008026:	205a      	movs	r0, #90	; 0x5a
90008028:	f001 fb3f 	bl	900096aa <HAL_NVIC_DisableIRQ>

    /** Force and let in reset state DMA2D */
    __HAL_RCC_DMA2D_FORCE_RESET();
9000802c:	4b09      	ldr	r3, [pc, #36]	; (90008054 <DMA2D_MspDeInit+0x40>)
9000802e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
90008030:	4a08      	ldr	r2, [pc, #32]	; (90008054 <DMA2D_MspDeInit+0x40>)
90008032:	f043 0310 	orr.w	r3, r3, #16
90008036:	67d3      	str	r3, [r2, #124]	; 0x7c

    /** Disable the DMA2D */
    __HAL_RCC_DMA2D_CLK_DISABLE();
90008038:	4b06      	ldr	r3, [pc, #24]	; (90008054 <DMA2D_MspDeInit+0x40>)
9000803a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
9000803e:	4a05      	ldr	r2, [pc, #20]	; (90008054 <DMA2D_MspDeInit+0x40>)
90008040:	f023 0310 	bic.w	r3, r3, #16
90008044:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
  }
}
90008048:	bf00      	nop
9000804a:	3708      	adds	r7, #8
9000804c:	46bd      	mov	sp, r7
9000804e:	bd80      	pop	{r7, pc}
90008050:	52001000 	.word	0x52001000
90008054:	58024400 	.word	0x58024400

90008058 <TIMx_PWM_MspInit>:
  * @brief  Initializes TIM MSP.
  * @param  htim  TIM handle
  * @retval None
  */
static void TIMx_PWM_MspInit(TIM_HandleTypeDef *htim)
{
90008058:	b580      	push	{r7, lr}
9000805a:	b08a      	sub	sp, #40	; 0x28
9000805c:	af00      	add	r7, sp, #0
9000805e:	6078      	str	r0, [r7, #4]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(htim);

  GPIO_InitTypeDef GPIO_InitStruct;

  LCD_BL_CTRL_GPIO_CLK_ENABLE();
90008060:	4b18      	ldr	r3, [pc, #96]	; (900080c4 <TIMx_PWM_MspInit+0x6c>)
90008062:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90008066:	4a17      	ldr	r2, [pc, #92]	; (900080c4 <TIMx_PWM_MspInit+0x6c>)
90008068:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
9000806c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90008070:	4b14      	ldr	r3, [pc, #80]	; (900080c4 <TIMx_PWM_MspInit+0x6c>)
90008072:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90008076:	f403 6380 	and.w	r3, r3, #1024	; 0x400
9000807a:	613b      	str	r3, [r7, #16]
9000807c:	693b      	ldr	r3, [r7, #16]

  /* TIMx Peripheral clock enable */
  LCD_TIMx_CLK_ENABLE();
9000807e:	4b11      	ldr	r3, [pc, #68]	; (900080c4 <TIMx_PWM_MspInit+0x6c>)
90008080:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
90008084:	4a0f      	ldr	r2, [pc, #60]	; (900080c4 <TIMx_PWM_MspInit+0x6c>)
90008086:	f043 0302 	orr.w	r3, r3, #2
9000808a:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
9000808e:	4b0d      	ldr	r3, [pc, #52]	; (900080c4 <TIMx_PWM_MspInit+0x6c>)
90008090:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
90008094:	f003 0302 	and.w	r3, r3, #2
90008098:	60fb      	str	r3, [r7, #12]
9000809a:	68fb      	ldr	r3, [r7, #12]

  /* Timer channel configuration */
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
9000809c:	2302      	movs	r3, #2
9000809e:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
900080a0:	2300      	movs	r3, #0
900080a2:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_MEDIUM;
900080a4:	2301      	movs	r3, #1
900080a6:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Alternate = LCD_TIMx_CHANNEL_AF;
900080a8:	2303      	movs	r3, #3
900080aa:	627b      	str	r3, [r7, #36]	; 0x24
  GPIO_InitStruct.Pin       = LCD_BL_CTRL_PIN; /* BL_CTRL */
900080ac:	2301      	movs	r3, #1
900080ae:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(LCD_BL_CTRL_GPIO_PORT, &GPIO_InitStruct);
900080b0:	f107 0314 	add.w	r3, r7, #20
900080b4:	4619      	mov	r1, r3
900080b6:	4804      	ldr	r0, [pc, #16]	; (900080c8 <TIMx_PWM_MspInit+0x70>)
900080b8:	f004 fd96 	bl	9000cbe8 <HAL_GPIO_Init>
}
900080bc:	bf00      	nop
900080be:	3728      	adds	r7, #40	; 0x28
900080c0:	46bd      	mov	sp, r7
900080c2:	bd80      	pop	{r7, pc}
900080c4:	58024400 	.word	0x58024400
900080c8:	58022800 	.word	0x58022800

900080cc <TIMx_PWM_MspDeInit>:
  * @brief  De-Initializes TIM MSP.
  * @param  htim TIM handle
  * @retval None
  */
static void TIMx_PWM_MspDeInit(TIM_HandleTypeDef *htim)
{
900080cc:	b580      	push	{r7, lr}
900080ce:	b088      	sub	sp, #32
900080d0:	af00      	add	r7, sp, #0
900080d2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  GPIO_InitTypeDef GPIO_InitStruct;

  /* TIMx Peripheral clock enable */
  LCD_BL_CTRL_GPIO_CLK_DISABLE();
900080d4:	4b09      	ldr	r3, [pc, #36]	; (900080fc <TIMx_PWM_MspDeInit+0x30>)
900080d6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900080da:	4a08      	ldr	r2, [pc, #32]	; (900080fc <TIMx_PWM_MspDeInit+0x30>)
900080dc:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
900080e0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0

  /* Timer channel configuration */
  GPIO_InitStruct.Pin = LCD_BL_CTRL_PIN; /* BL_CTRL */
900080e4:	2301      	movs	r3, #1
900080e6:	60fb      	str	r3, [r7, #12]
  HAL_GPIO_DeInit(LCD_BL_CTRL_GPIO_PORT, GPIO_InitStruct.Pin);
900080e8:	68fb      	ldr	r3, [r7, #12]
900080ea:	4619      	mov	r1, r3
900080ec:	4804      	ldr	r0, [pc, #16]	; (90008100 <TIMx_PWM_MspDeInit+0x34>)
900080ee:	f004 ff2b 	bl	9000cf48 <HAL_GPIO_DeInit>
}
900080f2:	bf00      	nop
900080f4:	3720      	adds	r7, #32
900080f6:	46bd      	mov	sp, r7
900080f8:	bd80      	pop	{r7, pc}
900080fa:	bf00      	nop
900080fc:	58024400 	.word	0x58024400
90008100:	58022800 	.word	0x58022800

90008104 <TIMx_PWM_Init>:
  * @brief  Initializes TIM in PWM mode
  * @param  htim TIM handle
  * @retval None
  */
static void TIMx_PWM_Init(TIM_HandleTypeDef *htim)
{
90008104:	b580      	push	{r7, lr}
90008106:	b082      	sub	sp, #8
90008108:	af00      	add	r7, sp, #0
9000810a:	6078      	str	r0, [r7, #4]
  /* Timer_Clock = 2 x  APB2_clock = 200 MHz */
  /* PWM_freq = Timer_Clock /(Period x (Prescaler + 1))*/
  /* PWM_freq = 200 MHz /(50000 x (4 + 1)) = 800 Hz*/
  htim->Instance = LCD_TIMx;
9000810c:	687b      	ldr	r3, [r7, #4]
9000810e:	4a11      	ldr	r2, [pc, #68]	; (90008154 <TIMx_PWM_Init+0x50>)
90008110:	601a      	str	r2, [r3, #0]
  (void)HAL_TIM_PWM_DeInit(htim);
90008112:	6878      	ldr	r0, [r7, #4]
90008114:	f00c fca4 	bl	90014a60 <HAL_TIM_PWM_DeInit>

  TIMx_PWM_MspInit(htim);
90008118:	6878      	ldr	r0, [r7, #4]
9000811a:	f7ff ff9d 	bl	90008058 <TIMx_PWM_MspInit>

  htim->Init.Prescaler         = LCD_TIMX_PRESCALER_VALUE;
9000811e:	687b      	ldr	r3, [r7, #4]
90008120:	2204      	movs	r2, #4
90008122:	605a      	str	r2, [r3, #4]
  htim->Init.Period            = LCD_TIMX_PERIOD_VALUE;
90008124:	687b      	ldr	r3, [r7, #4]
90008126:	f24c 3250 	movw	r2, #50000	; 0xc350
9000812a:	60da      	str	r2, [r3, #12]
  htim->Init.ClockDivision     = 0;
9000812c:	687b      	ldr	r3, [r7, #4]
9000812e:	2200      	movs	r2, #0
90008130:	611a      	str	r2, [r3, #16]
  htim->Init.CounterMode       = TIM_COUNTERMODE_UP;
90008132:	687b      	ldr	r3, [r7, #4]
90008134:	2200      	movs	r2, #0
90008136:	609a      	str	r2, [r3, #8]
  htim->Init.RepetitionCounter = 0;
90008138:	687b      	ldr	r3, [r7, #4]
9000813a:	2200      	movs	r2, #0
9000813c:	615a      	str	r2, [r3, #20]
  htim->Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
9000813e:	687b      	ldr	r3, [r7, #4]
90008140:	2200      	movs	r2, #0
90008142:	619a      	str	r2, [r3, #24]
  (void)HAL_TIM_PWM_Init(htim);
90008144:	6878      	ldr	r0, [r7, #4]
90008146:	f00c fc34 	bl	900149b2 <HAL_TIM_PWM_Init>
}
9000814a:	bf00      	nop
9000814c:	3708      	adds	r7, #8
9000814e:	46bd      	mov	sp, r7
90008150:	bd80      	pop	{r7, pc}
90008152:	bf00      	nop
90008154:	40010400 	.word	0x40010400

90008158 <TIMx_PWM_DeInit>:
  * @brief  De-Initializes TIM in PWM mode
  * @param  htim TIM handle
  * @retval None
  */
static void TIMx_PWM_DeInit(TIM_HandleTypeDef *htim)
{
90008158:	b580      	push	{r7, lr}
9000815a:	b082      	sub	sp, #8
9000815c:	af00      	add	r7, sp, #0
9000815e:	6078      	str	r0, [r7, #4]
  htim->Instance = LCD_TIMx;
90008160:	687b      	ldr	r3, [r7, #4]
90008162:	4a06      	ldr	r2, [pc, #24]	; (9000817c <TIMx_PWM_DeInit+0x24>)
90008164:	601a      	str	r2, [r3, #0]

  /* Timer de-intialization */
  (void)HAL_TIM_PWM_DeInit(htim);
90008166:	6878      	ldr	r0, [r7, #4]
90008168:	f00c fc7a 	bl	90014a60 <HAL_TIM_PWM_DeInit>

  /* Timer Msp de-intialization */
  TIMx_PWM_MspDeInit(htim);
9000816c:	6878      	ldr	r0, [r7, #4]
9000816e:	f7ff ffad 	bl	900080cc <TIMx_PWM_MspDeInit>
}
90008172:	bf00      	nop
90008174:	3708      	adds	r7, #8
90008176:	46bd      	mov	sp, r7
90008178:	bd80      	pop	{r7, pc}
9000817a:	bf00      	nop
9000817c:	40010400 	.word	0x40010400

90008180 <BSP_MMC_Init>:
  * @brief  Initializes the MMC card device.
  * @param  Instance      SDMMC Instance
  * @retval BSP status
  */
int32_t BSP_MMC_Init(uint32_t Instance)
{
90008180:	b580      	push	{r7, lr}
90008182:	b084      	sub	sp, #16
90008184:	af00      	add	r7, sp, #0
90008186:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
90008188:	2300      	movs	r3, #0
9000818a:	60fb      	str	r3, [r7, #12]

  if(Instance >= MMC_INSTANCES_NBR)
9000818c:	687b      	ldr	r3, [r7, #4]
9000818e:	2b00      	cmp	r3, #0
90008190:	d003      	beq.n	9000819a <BSP_MMC_Init+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90008192:	f06f 0301 	mvn.w	r3, #1
90008196:	60fb      	str	r3, [r7, #12]
90008198:	e019      	b.n	900081ce <BSP_MMC_Init+0x4e>
  }
  else
  {
#if (USE_HAL_MMC_REGISTER_CALLBACKS == 0)
    /* Msp MMC initialization */
    MMC_MspInit(&hsd_sdmmc[Instance]);
9000819a:	687b      	ldr	r3, [r7, #4]
9000819c:	f44f 721d 	mov.w	r2, #628	; 0x274
900081a0:	fb02 f303 	mul.w	r3, r2, r3
900081a4:	4a0c      	ldr	r2, [pc, #48]	; (900081d8 <BSP_MMC_Init+0x58>)
900081a6:	4413      	add	r3, r2
900081a8:	4618      	mov	r0, r3
900081aa:	f000 f8e7 	bl	9000837c <MMC_MspInit>
    }
    if(ret == BSP_ERROR_NONE)
    {
#endif
      /* HAL MMC initialization */
      if(MX_MMC_SD_Init(&hsd_sdmmc[Instance]) != HAL_OK)
900081ae:	687b      	ldr	r3, [r7, #4]
900081b0:	f44f 721d 	mov.w	r2, #628	; 0x274
900081b4:	fb02 f303 	mul.w	r3, r2, r3
900081b8:	4a07      	ldr	r2, [pc, #28]	; (900081d8 <BSP_MMC_Init+0x58>)
900081ba:	4413      	add	r3, r2
900081bc:	4618      	mov	r0, r3
900081be:	f000 f80d 	bl	900081dc <MX_MMC_SD_Init>
900081c2:	4603      	mov	r3, r0
900081c4:	2b00      	cmp	r3, #0
900081c6:	d002      	beq.n	900081ce <BSP_MMC_Init+0x4e>
      {
        ret = BSP_ERROR_PERIPH_FAILURE;
900081c8:	f06f 0303 	mvn.w	r3, #3
900081cc:	60fb      	str	r3, [r7, #12]
      }
    }
#endif /* USE_HAL_MMC_REGISTER_CALLBACKS */
  }

  return  ret;
900081ce:	68fb      	ldr	r3, [r7, #12]
}
900081d0:	4618      	mov	r0, r3
900081d2:	3710      	adds	r7, #16
900081d4:	46bd      	mov	sp, r7
900081d6:	bd80      	pop	{r7, pc}
900081d8:	24002bac 	.word	0x24002bac

900081dc <MX_MMC_SD_Init>:
  * @brief  Initializes the SDMMC1 peripheral.
  * @param  hmmc SD handle
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_MMC_SD_Init(MMC_HandleTypeDef *hmmc)
{
900081dc:	b580      	push	{r7, lr}
900081de:	b084      	sub	sp, #16
900081e0:	af00      	add	r7, sp, #0
900081e2:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef ret = HAL_OK;
900081e4:	2300      	movs	r3, #0
900081e6:	73fb      	strb	r3, [r7, #15]

  hmmc->Instance                 = SDMMC1;
900081e8:	687b      	ldr	r3, [r7, #4]
900081ea:	4a0f      	ldr	r2, [pc, #60]	; (90008228 <MX_MMC_SD_Init+0x4c>)
900081ec:	601a      	str	r2, [r3, #0]
  hmmc->Init.ClockDiv            = 2;
900081ee:	687b      	ldr	r3, [r7, #4]
900081f0:	2202      	movs	r2, #2
900081f2:	615a      	str	r2, [r3, #20]
  hmmc->Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
900081f4:	687b      	ldr	r3, [r7, #4]
900081f6:	2200      	movs	r2, #0
900081f8:	609a      	str	r2, [r3, #8]
  hmmc->Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
900081fa:	687b      	ldr	r3, [r7, #4]
900081fc:	2200      	movs	r2, #0
900081fe:	605a      	str	r2, [r3, #4]
  hmmc->Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
90008200:	687b      	ldr	r3, [r7, #4]
90008202:	2200      	movs	r2, #0
90008204:	611a      	str	r2, [r3, #16]
  hmmc->Init.BusWide             = SDMMC_BUS_WIDE_8B;
90008206:	687b      	ldr	r3, [r7, #4]
90008208:	f44f 4200 	mov.w	r2, #32768	; 0x8000
9000820c:	60da      	str	r2, [r3, #12]

  /* HAL SD initialization */
  if(HAL_MMC_Init(hmmc) != HAL_OK)
9000820e:	6878      	ldr	r0, [r7, #4]
90008210:	f006 fcc8 	bl	9000eba4 <HAL_MMC_Init>
90008214:	4603      	mov	r3, r0
90008216:	2b00      	cmp	r3, #0
90008218:	d001      	beq.n	9000821e <MX_MMC_SD_Init+0x42>
  {
    ret = HAL_ERROR;
9000821a:	2301      	movs	r3, #1
9000821c:	73fb      	strb	r3, [r7, #15]
  }

  return ret;
9000821e:	7bfb      	ldrb	r3, [r7, #15]
}
90008220:	4618      	mov	r0, r3
90008222:	3710      	adds	r7, #16
90008224:	46bd      	mov	sp, r7
90008226:	bd80      	pop	{r7, pc}
90008228:	52007000 	.word	0x52007000

9000822c <BSP_MMC_ReadBlocks>:
  * @param  BlockIdx   Block index from where data is to be read
  * @param  BlocksNbr  Number of MMC blocks to read
  * @retval BSP status
  */
int32_t BSP_MMC_ReadBlocks(uint32_t Instance, uint32_t *pData, uint32_t BlockIdx, uint32_t BlocksNbr)
{
9000822c:	b580      	push	{r7, lr}
9000822e:	b088      	sub	sp, #32
90008230:	af02      	add	r7, sp, #8
90008232:	60f8      	str	r0, [r7, #12]
90008234:	60b9      	str	r1, [r7, #8]
90008236:	607a      	str	r2, [r7, #4]
90008238:	603b      	str	r3, [r7, #0]
  uint32_t timeout = MMC_READ_TIMEOUT*BlocksNbr;
9000823a:	683b      	ldr	r3, [r7, #0]
9000823c:	2264      	movs	r2, #100	; 0x64
9000823e:	fb02 f303 	mul.w	r3, r2, r3
90008242:	613b      	str	r3, [r7, #16]
  int32_t ret;

  if(Instance >= MMC_INSTANCES_NBR)
90008244:	68fb      	ldr	r3, [r7, #12]
90008246:	2b00      	cmp	r3, #0
90008248:	d003      	beq.n	90008252 <BSP_MMC_ReadBlocks+0x26>
  {
    ret = BSP_ERROR_WRONG_PARAM;
9000824a:	f06f 0301 	mvn.w	r3, #1
9000824e:	617b      	str	r3, [r7, #20]
90008250:	e016      	b.n	90008280 <BSP_MMC_ReadBlocks+0x54>
  }
  else if(HAL_MMC_ReadBlocks(&hsd_sdmmc[Instance], (uint8_t *)pData, BlockIdx, BlocksNbr, timeout) != HAL_OK)
90008252:	68fb      	ldr	r3, [r7, #12]
90008254:	f44f 721d 	mov.w	r2, #628	; 0x274
90008258:	fb02 f303 	mul.w	r3, r2, r3
9000825c:	4a0b      	ldr	r2, [pc, #44]	; (9000828c <BSP_MMC_ReadBlocks+0x60>)
9000825e:	1898      	adds	r0, r3, r2
90008260:	693b      	ldr	r3, [r7, #16]
90008262:	9300      	str	r3, [sp, #0]
90008264:	683b      	ldr	r3, [r7, #0]
90008266:	687a      	ldr	r2, [r7, #4]
90008268:	68b9      	ldr	r1, [r7, #8]
9000826a:	f006 fd79 	bl	9000ed60 <HAL_MMC_ReadBlocks>
9000826e:	4603      	mov	r3, r0
90008270:	2b00      	cmp	r3, #0
90008272:	d003      	beq.n	9000827c <BSP_MMC_ReadBlocks+0x50>
  {
    ret = BSP_ERROR_PERIPH_FAILURE;
90008274:	f06f 0303 	mvn.w	r3, #3
90008278:	617b      	str	r3, [r7, #20]
9000827a:	e001      	b.n	90008280 <BSP_MMC_ReadBlocks+0x54>
  }
  else
  {
    ret = BSP_ERROR_NONE;
9000827c:	2300      	movs	r3, #0
9000827e:	617b      	str	r3, [r7, #20]
  }
  /* Return BSP status */
  return ret;
90008280:	697b      	ldr	r3, [r7, #20]
}
90008282:	4618      	mov	r0, r3
90008284:	3718      	adds	r7, #24
90008286:	46bd      	mov	sp, r7
90008288:	bd80      	pop	{r7, pc}
9000828a:	bf00      	nop
9000828c:	24002bac 	.word	0x24002bac

90008290 <BSP_MMC_WriteBlocks>:
  * @param  BlockIdx   Block index from where data is to be written
  * @param  BlocksNbr  Number of MMC blocks to write
  * @retval BSP status
  */
int32_t BSP_MMC_WriteBlocks(uint32_t Instance, uint32_t *pData, uint32_t BlockIdx, uint32_t BlocksNbr)
{
90008290:	b580      	push	{r7, lr}
90008292:	b088      	sub	sp, #32
90008294:	af02      	add	r7, sp, #8
90008296:	60f8      	str	r0, [r7, #12]
90008298:	60b9      	str	r1, [r7, #8]
9000829a:	607a      	str	r2, [r7, #4]
9000829c:	603b      	str	r3, [r7, #0]
  uint32_t timeout = MMC_READ_TIMEOUT*BlocksNbr;
9000829e:	683b      	ldr	r3, [r7, #0]
900082a0:	2264      	movs	r2, #100	; 0x64
900082a2:	fb02 f303 	mul.w	r3, r2, r3
900082a6:	613b      	str	r3, [r7, #16]
  int32_t ret;

  if(Instance >= MMC_INSTANCES_NBR)
900082a8:	68fb      	ldr	r3, [r7, #12]
900082aa:	2b00      	cmp	r3, #0
900082ac:	d003      	beq.n	900082b6 <BSP_MMC_WriteBlocks+0x26>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900082ae:	f06f 0301 	mvn.w	r3, #1
900082b2:	617b      	str	r3, [r7, #20]
900082b4:	e016      	b.n	900082e4 <BSP_MMC_WriteBlocks+0x54>
  }
  else if(HAL_MMC_WriteBlocks(&hsd_sdmmc[Instance], (uint8_t *)pData, BlockIdx, BlocksNbr, timeout) != HAL_OK)
900082b6:	68fb      	ldr	r3, [r7, #12]
900082b8:	f44f 721d 	mov.w	r2, #628	; 0x274
900082bc:	fb02 f303 	mul.w	r3, r2, r3
900082c0:	4a0b      	ldr	r2, [pc, #44]	; (900082f0 <BSP_MMC_WriteBlocks+0x60>)
900082c2:	1898      	adds	r0, r3, r2
900082c4:	693b      	ldr	r3, [r7, #16]
900082c6:	9300      	str	r3, [sp, #0]
900082c8:	683b      	ldr	r3, [r7, #0]
900082ca:	687a      	ldr	r2, [r7, #4]
900082cc:	68b9      	ldr	r1, [r7, #8]
900082ce:	f006 fedb 	bl	9000f088 <HAL_MMC_WriteBlocks>
900082d2:	4603      	mov	r3, r0
900082d4:	2b00      	cmp	r3, #0
900082d6:	d003      	beq.n	900082e0 <BSP_MMC_WriteBlocks+0x50>
  {
    ret = BSP_ERROR_PERIPH_FAILURE;
900082d8:	f06f 0303 	mvn.w	r3, #3
900082dc:	617b      	str	r3, [r7, #20]
900082de:	e001      	b.n	900082e4 <BSP_MMC_WriteBlocks+0x54>
  }
  else
  {
    ret = BSP_ERROR_NONE;
900082e0:	2300      	movs	r3, #0
900082e2:	617b      	str	r3, [r7, #20]
  }
  /* Return BSP status */
  return ret;
900082e4:	697b      	ldr	r3, [r7, #20]
}
900082e6:	4618      	mov	r0, r3
900082e8:	3718      	adds	r7, #24
900082ea:	46bd      	mov	sp, r7
900082ec:	bd80      	pop	{r7, pc}
900082ee:	bf00      	nop
900082f0:	24002bac 	.word	0x24002bac

900082f4 <BSP_MMC_Erase>:
  * @param  StartAddr : Start byte address
  * @param  EndAddr : End byte address
  * @retval BSP status
  */
int32_t BSP_MMC_Erase(uint32_t Instance, uint32_t StartAddr, uint32_t EndAddr)
{
900082f4:	b580      	push	{r7, lr}
900082f6:	b086      	sub	sp, #24
900082f8:	af00      	add	r7, sp, #0
900082fa:	60f8      	str	r0, [r7, #12]
900082fc:	60b9      	str	r1, [r7, #8]
900082fe:	607a      	str	r2, [r7, #4]
  int32_t ret;

  if(Instance >= MMC_INSTANCES_NBR)
90008300:	68fb      	ldr	r3, [r7, #12]
90008302:	2b00      	cmp	r3, #0
90008304:	d003      	beq.n	9000830e <BSP_MMC_Erase+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90008306:	f06f 0301 	mvn.w	r3, #1
9000830a:	617b      	str	r3, [r7, #20]
9000830c:	e014      	b.n	90008338 <BSP_MMC_Erase+0x44>
  }
  else if( HAL_MMC_Erase(&hsd_sdmmc[Instance], StartAddr, EndAddr) != HAL_OK)
9000830e:	68fb      	ldr	r3, [r7, #12]
90008310:	f44f 721d 	mov.w	r2, #628	; 0x274
90008314:	fb02 f303 	mul.w	r3, r2, r3
90008318:	4a0a      	ldr	r2, [pc, #40]	; (90008344 <BSP_MMC_Erase+0x50>)
9000831a:	4413      	add	r3, r2
9000831c:	687a      	ldr	r2, [r7, #4]
9000831e:	68b9      	ldr	r1, [r7, #8]
90008320:	4618      	mov	r0, r3
90008322:	f007 f849 	bl	9000f3b8 <HAL_MMC_Erase>
90008326:	4603      	mov	r3, r0
90008328:	2b00      	cmp	r3, #0
9000832a:	d003      	beq.n	90008334 <BSP_MMC_Erase+0x40>
  {
    ret = BSP_ERROR_PERIPH_FAILURE;
9000832c:	f06f 0303 	mvn.w	r3, #3
90008330:	617b      	str	r3, [r7, #20]
90008332:	e001      	b.n	90008338 <BSP_MMC_Erase+0x44>
  }
  else
  {
    ret = BSP_ERROR_NONE;
90008334:	2300      	movs	r3, #0
90008336:	617b      	str	r3, [r7, #20]
  }

  return ret ;
90008338:	697b      	ldr	r3, [r7, #20]
}
9000833a:	4618      	mov	r0, r3
9000833c:	3718      	adds	r7, #24
9000833e:	46bd      	mov	sp, r7
90008340:	bd80      	pop	{r7, pc}
90008342:	bf00      	nop
90008344:	24002bac 	.word	0x24002bac

90008348 <BSP_MMC_GetCardState>:
  *            @arg  MMC_TRANSFER_OK: No data transfer is acting
  *            @arg  MMC_TRANSFER_BUSY: Data transfer is acting
  *            @arg  MMC_TRANSFER_ERROR: Data transfer error
  */
int32_t BSP_MMC_GetCardState(uint32_t Instance)
{
90008348:	b580      	push	{r7, lr}
9000834a:	b082      	sub	sp, #8
9000834c:	af00      	add	r7, sp, #0
9000834e:	6078      	str	r0, [r7, #4]
  return((HAL_MMC_GetCardState(&hsd_sdmmc[Instance]) == HAL_MMC_CARD_TRANSFER ) ? MMC_TRANSFER_OK : MMC_TRANSFER_BUSY);
90008350:	687b      	ldr	r3, [r7, #4]
90008352:	f44f 721d 	mov.w	r2, #628	; 0x274
90008356:	fb02 f303 	mul.w	r3, r2, r3
9000835a:	4a07      	ldr	r2, [pc, #28]	; (90008378 <BSP_MMC_GetCardState+0x30>)
9000835c:	4413      	add	r3, r2
9000835e:	4618      	mov	r0, r3
90008360:	f007 fc78 	bl	9000fc54 <HAL_MMC_GetCardState>
90008364:	4603      	mov	r3, r0
90008366:	2b04      	cmp	r3, #4
90008368:	bf14      	ite	ne
9000836a:	2301      	movne	r3, #1
9000836c:	2300      	moveq	r3, #0
9000836e:	b2db      	uxtb	r3, r3
}
90008370:	4618      	mov	r0, r3
90008372:	3708      	adds	r7, #8
90008374:	46bd      	mov	sp, r7
90008376:	bd80      	pop	{r7, pc}
90008378:	24002bac 	.word	0x24002bac

9000837c <MMC_MspInit>:
  * @brief  Initializes the MMC MSP.
  * @param  hmmc  MMC handle
  * @retval None
  */
static void MMC_MspInit(MMC_HandleTypeDef *hmmc)
{
9000837c:	b580      	push	{r7, lr}
9000837e:	b08c      	sub	sp, #48	; 0x30
90008380:	af00      	add	r7, sp, #0
90008382:	6078      	str	r0, [r7, #4]
  /* __weak function can be modified by the application */

  GPIO_InitTypeDef gpio_init_structure;

  /* Enable SDIO clock */
  __HAL_RCC_SDMMC1_CLK_ENABLE();
90008384:	4b34      	ldr	r3, [pc, #208]	; (90008458 <MMC_MspInit+0xdc>)
90008386:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
9000838a:	4a33      	ldr	r2, [pc, #204]	; (90008458 <MMC_MspInit+0xdc>)
9000838c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
90008390:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
90008394:	4b30      	ldr	r3, [pc, #192]	; (90008458 <MMC_MspInit+0xdc>)
90008396:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
9000839a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
9000839e:	61bb      	str	r3, [r7, #24]
900083a0:	69bb      	ldr	r3, [r7, #24]

  /* Enable GPIOs clock */
  __HAL_RCC_GPIOB_CLK_ENABLE();
900083a2:	4b2d      	ldr	r3, [pc, #180]	; (90008458 <MMC_MspInit+0xdc>)
900083a4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900083a8:	4a2b      	ldr	r2, [pc, #172]	; (90008458 <MMC_MspInit+0xdc>)
900083aa:	f043 0302 	orr.w	r3, r3, #2
900083ae:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
900083b2:	4b29      	ldr	r3, [pc, #164]	; (90008458 <MMC_MspInit+0xdc>)
900083b4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900083b8:	f003 0302 	and.w	r3, r3, #2
900083bc:	617b      	str	r3, [r7, #20]
900083be:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOC_CLK_ENABLE();
900083c0:	4b25      	ldr	r3, [pc, #148]	; (90008458 <MMC_MspInit+0xdc>)
900083c2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900083c6:	4a24      	ldr	r2, [pc, #144]	; (90008458 <MMC_MspInit+0xdc>)
900083c8:	f043 0304 	orr.w	r3, r3, #4
900083cc:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
900083d0:	4b21      	ldr	r3, [pc, #132]	; (90008458 <MMC_MspInit+0xdc>)
900083d2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900083d6:	f003 0304 	and.w	r3, r3, #4
900083da:	613b      	str	r3, [r7, #16]
900083dc:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOD_CLK_ENABLE();
900083de:	4b1e      	ldr	r3, [pc, #120]	; (90008458 <MMC_MspInit+0xdc>)
900083e0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900083e4:	4a1c      	ldr	r2, [pc, #112]	; (90008458 <MMC_MspInit+0xdc>)
900083e6:	f043 0308 	orr.w	r3, r3, #8
900083ea:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
900083ee:	4b1a      	ldr	r3, [pc, #104]	; (90008458 <MMC_MspInit+0xdc>)
900083f0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900083f4:	f003 0308 	and.w	r3, r3, #8
900083f8:	60fb      	str	r3, [r7, #12]
900083fa:	68fb      	ldr	r3, [r7, #12]


  /* Common GPIO configuration */
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
900083fc:	2302      	movs	r3, #2
900083fe:	623b      	str	r3, [r7, #32]
  gpio_init_structure.Pull      = GPIO_PULLUP;
90008400:	2301      	movs	r3, #1
90008402:	627b      	str	r3, [r7, #36]	; 0x24
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
90008404:	2303      	movs	r3, #3
90008406:	62bb      	str	r3, [r7, #40]	; 0x28
  gpio_init_structure.Alternate = GPIO_AF12_SDIO1;
90008408:	230c      	movs	r3, #12
9000840a:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* SDMMC GPIO CLKIN PB8, D0 PC8, D1 PC9, D2 PC10, D3 PC11, CK PC12, CMD PD2 */
  /* GPIOC configuration */
  gpio_init_structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
9000840c:	f44f 53fe 	mov.w	r3, #8128	; 0x1fc0
90008410:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
90008412:	f107 031c 	add.w	r3, r7, #28
90008416:	4619      	mov	r1, r3
90008418:	4810      	ldr	r0, [pc, #64]	; (9000845c <MMC_MspInit+0xe0>)
9000841a:	f004 fbe5 	bl	9000cbe8 <HAL_GPIO_Init>

  /* GPIOD configuration */
  gpio_init_structure.Pin = GPIO_PIN_2;
9000841e:	2304      	movs	r3, #4
90008420:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
90008422:	f107 031c 	add.w	r3, r7, #28
90008426:	4619      	mov	r1, r3
90008428:	480d      	ldr	r0, [pc, #52]	; (90008460 <MMC_MspInit+0xe4>)
9000842a:	f004 fbdd 	bl	9000cbe8 <HAL_GPIO_Init>

  gpio_init_structure.Pin = GPIO_PIN_8 | GPIO_PIN_9;
9000842e:	f44f 7340 	mov.w	r3, #768	; 0x300
90008432:	61fb      	str	r3, [r7, #28]
  HAL_GPIO_Init(GPIOB, &gpio_init_structure);
90008434:	f107 031c 	add.w	r3, r7, #28
90008438:	4619      	mov	r1, r3
9000843a:	480a      	ldr	r0, [pc, #40]	; (90008464 <MMC_MspInit+0xe8>)
9000843c:	f004 fbd4 	bl	9000cbe8 <HAL_GPIO_Init>


  /* NVIC configuration for SDIO interrupts */
  HAL_NVIC_SetPriority(SDMMC1_IRQn, 5, 0);
90008440:	2200      	movs	r2, #0
90008442:	2105      	movs	r1, #5
90008444:	2031      	movs	r0, #49	; 0x31
90008446:	f001 f908 	bl	9000965a <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDMMC1_IRQn);
9000844a:	2031      	movs	r0, #49	; 0x31
9000844c:	f001 f91f 	bl	9000968e <HAL_NVIC_EnableIRQ>
}
90008450:	bf00      	nop
90008452:	3730      	adds	r7, #48	; 0x30
90008454:	46bd      	mov	sp, r7
90008456:	bd80      	pop	{r7, pc}
90008458:	58024400 	.word	0x58024400
9000845c:	58020800 	.word	0x58020800
90008460:	58020c00 	.word	0x58020c00
90008464:	58020400 	.word	0x58020400

90008468 <BSP_SDRAM_Init>:
  * @brief  Initializes the SDRAM device.
  * @param Instance  SDRAM Instance
  * @retval BSP status
  */
int32_t BSP_SDRAM_Init(uint32_t Instance)
{
90008468:	b580      	push	{r7, lr}
9000846a:	b084      	sub	sp, #16
9000846c:	af00      	add	r7, sp, #0
9000846e:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
90008470:	2300      	movs	r3, #0
90008472:	60fb      	str	r3, [r7, #12]
  static MT48LC4M32B2_Context_t pRegMode;
  if(Instance >=SDRAM_INSTANCES_NBR)
90008474:	687b      	ldr	r3, [r7, #4]
90008476:	2b00      	cmp	r3, #0
90008478:	d003      	beq.n	90008482 <BSP_SDRAM_Init+0x1a>
  {
    ret =  BSP_ERROR_WRONG_PARAM;
9000847a:	f06f 0301 	mvn.w	r3, #1
9000847e:	60fb      	str	r3, [r7, #12]
90008480:	e044      	b.n	9000850c <BSP_SDRAM_Init+0xa4>
        return BSP_ERROR_PERIPH_FAILURE;
      }
    }
#else
    /* Msp SDRAM initialization */
    SDRAM_MspInit(&hsdram[Instance]);
90008482:	687b      	ldr	r3, [r7, #4]
90008484:	2234      	movs	r2, #52	; 0x34
90008486:	fb02 f303 	mul.w	r3, r2, r3
9000848a:	4a23      	ldr	r2, [pc, #140]	; (90008518 <BSP_SDRAM_Init+0xb0>)
9000848c:	4413      	add	r3, r2
9000848e:	4618      	mov	r0, r3
90008490:	f000 f8ce 	bl	90008630 <SDRAM_MspInit>
#endif /* USE_HAL_SDRAM_REGISTER_CALLBACKS */
    if(MX_SDRAM_BANK2_Init(&hsdram[Instance],FMC_SDRAM_ROW_BITS_NUM_12, FMC_SDRAM_MEM_BUS_WIDTH_16) != HAL_OK)
90008494:	687b      	ldr	r3, [r7, #4]
90008496:	2234      	movs	r2, #52	; 0x34
90008498:	fb02 f303 	mul.w	r3, r2, r3
9000849c:	4a1e      	ldr	r2, [pc, #120]	; (90008518 <BSP_SDRAM_Init+0xb0>)
9000849e:	4413      	add	r3, r2
900084a0:	2210      	movs	r2, #16
900084a2:	2104      	movs	r1, #4
900084a4:	4618      	mov	r0, r3
900084a6:	f000 f861 	bl	9000856c <MX_SDRAM_BANK2_Init>
900084aa:	4603      	mov	r3, r0
900084ac:	2b00      	cmp	r3, #0
900084ae:	d003      	beq.n	900084b8 <BSP_SDRAM_Init+0x50>
    {
      ret = BSP_ERROR_NO_INIT;
900084b0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900084b4:	60fb      	str	r3, [r7, #12]
900084b6:	e029      	b.n	9000850c <BSP_SDRAM_Init+0xa4>
    }
    else
    {
      /* External memory mode register configuration */
      pRegMode.TargetBank      = FMC_SDRAM_CMD_TARGET_BANK2;
900084b8:	4b18      	ldr	r3, [pc, #96]	; (9000851c <BSP_SDRAM_Init+0xb4>)
900084ba:	2208      	movs	r2, #8
900084bc:	601a      	str	r2, [r3, #0]
      pRegMode.RefreshMode     = MT48LC4M32B2_AUTOREFRESH_MODE_CMD;
900084be:	4b17      	ldr	r3, [pc, #92]	; (9000851c <BSP_SDRAM_Init+0xb4>)
900084c0:	2203      	movs	r2, #3
900084c2:	605a      	str	r2, [r3, #4]
      pRegMode.RefreshRate     = REFRESH_COUNT;
900084c4:	4b15      	ldr	r3, [pc, #84]	; (9000851c <BSP_SDRAM_Init+0xb4>)
900084c6:	f240 6203 	movw	r2, #1539	; 0x603
900084ca:	609a      	str	r2, [r3, #8]
      pRegMode.BurstLength     = MT48LC4M32B2_BURST_LENGTH_1;
900084cc:	4b13      	ldr	r3, [pc, #76]	; (9000851c <BSP_SDRAM_Init+0xb4>)
900084ce:	2200      	movs	r2, #0
900084d0:	60da      	str	r2, [r3, #12]
      pRegMode.BurstType       = MT48LC4M32B2_BURST_TYPE_SEQUENTIAL;
900084d2:	4b12      	ldr	r3, [pc, #72]	; (9000851c <BSP_SDRAM_Init+0xb4>)
900084d4:	2200      	movs	r2, #0
900084d6:	611a      	str	r2, [r3, #16]
      pRegMode.CASLatency      = MT48LC4M32B2_CAS_LATENCY_3;
900084d8:	4b10      	ldr	r3, [pc, #64]	; (9000851c <BSP_SDRAM_Init+0xb4>)
900084da:	2230      	movs	r2, #48	; 0x30
900084dc:	615a      	str	r2, [r3, #20]
      pRegMode.OperationMode   = MT48LC4M32B2_OPERATING_MODE_STANDARD;
900084de:	4b0f      	ldr	r3, [pc, #60]	; (9000851c <BSP_SDRAM_Init+0xb4>)
900084e0:	2200      	movs	r2, #0
900084e2:	619a      	str	r2, [r3, #24]
      pRegMode.WriteBurstMode  = MT48LC4M32B2_WRITEBURST_MODE_SINGLE;
900084e4:	4b0d      	ldr	r3, [pc, #52]	; (9000851c <BSP_SDRAM_Init+0xb4>)
900084e6:	f44f 7200 	mov.w	r2, #512	; 0x200
900084ea:	61da      	str	r2, [r3, #28]

      /* SDRAM initialization sequence */
      if(MT48LC4M32B2_Init(&hsdram[Instance], &pRegMode) != MT48LC4M32B2_OK)
900084ec:	687b      	ldr	r3, [r7, #4]
900084ee:	2234      	movs	r2, #52	; 0x34
900084f0:	fb02 f303 	mul.w	r3, r2, r3
900084f4:	4a08      	ldr	r2, [pc, #32]	; (90008518 <BSP_SDRAM_Init+0xb0>)
900084f6:	4413      	add	r3, r2
900084f8:	4908      	ldr	r1, [pc, #32]	; (9000851c <BSP_SDRAM_Init+0xb4>)
900084fa:	4618      	mov	r0, r3
900084fc:	f7fa fba3 	bl	90002c46 <MT48LC4M32B2_Init>
90008500:	4603      	mov	r3, r0
90008502:	2b00      	cmp	r3, #0
90008504:	d002      	beq.n	9000850c <BSP_SDRAM_Init+0xa4>
      {
        ret =  BSP_ERROR_COMPONENT_FAILURE;
90008506:	f06f 0304 	mvn.w	r3, #4
9000850a:	60fb      	str	r3, [r7, #12]
      }
    }
  }

  return ret;
9000850c:	68fb      	ldr	r3, [r7, #12]
}
9000850e:	4618      	mov	r0, r3
90008510:	3710      	adds	r7, #16
90008512:	46bd      	mov	sp, r7
90008514:	bd80      	pop	{r7, pc}
90008516:	bf00      	nop
90008518:	24002e20 	.word	0x24002e20
9000851c:	24001e3c 	.word	0x24001e3c

90008520 <BSP_SDRAM_DeInit>:
  * @brief  DeInitializes the SDRAM device.
  * @param  Instance  SDRAM Instance
  * @retval BSP status
  */
int32_t BSP_SDRAM_DeInit(uint32_t Instance)
{
90008520:	b580      	push	{r7, lr}
90008522:	b084      	sub	sp, #16
90008524:	af00      	add	r7, sp, #0
90008526:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
90008528:	2300      	movs	r3, #0
9000852a:	60fb      	str	r3, [r7, #12]

  if(Instance >= SDRAM_INSTANCES_NBR)
9000852c:	687b      	ldr	r3, [r7, #4]
9000852e:	2b00      	cmp	r3, #0
90008530:	d003      	beq.n	9000853a <BSP_SDRAM_DeInit+0x1a>
  {
    ret =  BSP_ERROR_WRONG_PARAM;
90008532:	f06f 0301 	mvn.w	r3, #1
90008536:	60fb      	str	r3, [r7, #12]
90008538:	e011      	b.n	9000855e <BSP_SDRAM_DeInit+0x3e>
  }
  else
  {
    (void)HAL_SDRAM_DeInit(&hsdram[Instance]);
9000853a:	687b      	ldr	r3, [r7, #4]
9000853c:	2234      	movs	r2, #52	; 0x34
9000853e:	fb02 f303 	mul.w	r3, r2, r3
90008542:	4a09      	ldr	r2, [pc, #36]	; (90008568 <BSP_SDRAM_DeInit+0x48>)
90008544:	4413      	add	r3, r2
90008546:	4618      	mov	r0, r3
90008548:	f00c f80c 	bl	90014564 <HAL_SDRAM_DeInit>
#if (USE_HAL_SDRAM_REGISTER_CALLBACKS == 0)
    /* SDRAM controller de-initialization */
    SDRAM_MspDeInit(&hsdram[Instance]);
9000854c:	687b      	ldr	r3, [r7, #4]
9000854e:	2234      	movs	r2, #52	; 0x34
90008550:	fb02 f303 	mul.w	r3, r2, r3
90008554:	4a04      	ldr	r2, [pc, #16]	; (90008568 <BSP_SDRAM_DeInit+0x48>)
90008556:	4413      	add	r3, r2
90008558:	4618      	mov	r0, r3
9000855a:	f000 f967 	bl	9000882c <SDRAM_MspDeInit>
#endif /* (USE_HAL_SDRAM_REGISTER_CALLBACKS == 0) */
  }

  return ret;
9000855e:	68fb      	ldr	r3, [r7, #12]
}
90008560:	4618      	mov	r0, r3
90008562:	3710      	adds	r7, #16
90008564:	46bd      	mov	sp, r7
90008566:	bd80      	pop	{r7, pc}
90008568:	24002e20 	.word	0x24002e20

9000856c <MX_SDRAM_BANK2_Init>:
  * @param  RowBitsNumber Number of row to set
  * @param  MemoryDataWidth The momory width 16 or 32bits
  * @retval HAL status
  */
__weak HAL_StatusTypeDef MX_SDRAM_BANK2_Init(SDRAM_HandleTypeDef *hSdram, uint32_t RowBitsNumber, uint32_t MemoryDataWidth)
{
9000856c:	b580      	push	{r7, lr}
9000856e:	b08c      	sub	sp, #48	; 0x30
90008570:	af00      	add	r7, sp, #0
90008572:	60f8      	str	r0, [r7, #12]
90008574:	60b9      	str	r1, [r7, #8]
90008576:	607a      	str	r2, [r7, #4]
  FMC_SDRAM_TimingTypeDef sdram_timing;

  /* SDRAM device configuration */
  hsdram->Instance = FMC_SDRAM_DEVICE;
90008578:	4b20      	ldr	r3, [pc, #128]	; (900085fc <MX_SDRAM_BANK2_Init+0x90>)
9000857a:	4a21      	ldr	r2, [pc, #132]	; (90008600 <MX_SDRAM_BANK2_Init+0x94>)
9000857c:	601a      	str	r2, [r3, #0]

  /* SDRAM handle configuration */
  hSdram->Init.SDBank             = FMC_SDRAM_BANK2;
9000857e:	68fb      	ldr	r3, [r7, #12]
90008580:	2201      	movs	r2, #1
90008582:	605a      	str	r2, [r3, #4]
  hSdram->Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
90008584:	68fb      	ldr	r3, [r7, #12]
90008586:	2200      	movs	r2, #0
90008588:	609a      	str	r2, [r3, #8]
  hSdram->Init.RowBitsNumber      = RowBitsNumber;
9000858a:	68fb      	ldr	r3, [r7, #12]
9000858c:	68ba      	ldr	r2, [r7, #8]
9000858e:	60da      	str	r2, [r3, #12]
  hSdram->Init.MemoryDataWidth    = MemoryDataWidth;
90008590:	68fb      	ldr	r3, [r7, #12]
90008592:	687a      	ldr	r2, [r7, #4]
90008594:	611a      	str	r2, [r3, #16]
  hsdram->Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
90008596:	4b19      	ldr	r3, [pc, #100]	; (900085fc <MX_SDRAM_BANK2_Init+0x90>)
90008598:	2240      	movs	r2, #64	; 0x40
9000859a:	615a      	str	r2, [r3, #20]
  hSdram->Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_3;
9000859c:	68fb      	ldr	r3, [r7, #12]
9000859e:	f44f 72c0 	mov.w	r2, #384	; 0x180
900085a2:	619a      	str	r2, [r3, #24]
  hSdram->Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
900085a4:	68fb      	ldr	r3, [r7, #12]
900085a6:	2200      	movs	r2, #0
900085a8:	61da      	str	r2, [r3, #28]
  hSdram->Init.SDClockPeriod      = FMC_SDRAM_CLOCK_PERIOD_2;
900085aa:	68fb      	ldr	r3, [r7, #12]
900085ac:	f44f 6200 	mov.w	r2, #2048	; 0x800
900085b0:	621a      	str	r2, [r3, #32]
  hSdram->Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
900085b2:	68fb      	ldr	r3, [r7, #12]
900085b4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
900085b8:	625a      	str	r2, [r3, #36]	; 0x24
  hSdram->Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
900085ba:	68fb      	ldr	r3, [r7, #12]
900085bc:	2200      	movs	r2, #0
900085be:	629a      	str	r2, [r3, #40]	; 0x28

  /* Timing configuration for as SDRAM */
  sdram_timing.LoadToActiveDelay    = 2;
900085c0:	2302      	movs	r3, #2
900085c2:	617b      	str	r3, [r7, #20]
  sdram_timing.ExitSelfRefreshDelay = 7;
900085c4:	2307      	movs	r3, #7
900085c6:	61bb      	str	r3, [r7, #24]
  sdram_timing.SelfRefreshTime      = 4;
900085c8:	2304      	movs	r3, #4
900085ca:	61fb      	str	r3, [r7, #28]
  sdram_timing.RowCycleDelay        = 7;
900085cc:	2307      	movs	r3, #7
900085ce:	623b      	str	r3, [r7, #32]
  sdram_timing.WriteRecoveryTime    = 2;
900085d0:	2302      	movs	r3, #2
900085d2:	627b      	str	r3, [r7, #36]	; 0x24
  sdram_timing.RPDelay              = 2;
900085d4:	2302      	movs	r3, #2
900085d6:	62bb      	str	r3, [r7, #40]	; 0x28
  sdram_timing.RCDDelay             = 2;
900085d8:	2302      	movs	r3, #2
900085da:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* SDRAM controller initialization */
  if(HAL_SDRAM_Init(hSdram, &sdram_timing) != HAL_OK)
900085dc:	f107 0314 	add.w	r3, r7, #20
900085e0:	4619      	mov	r1, r3
900085e2:	68f8      	ldr	r0, [r7, #12]
900085e4:	f00b ff82 	bl	900144ec <HAL_SDRAM_Init>
900085e8:	4603      	mov	r3, r0
900085ea:	2b00      	cmp	r3, #0
900085ec:	d001      	beq.n	900085f2 <MX_SDRAM_BANK2_Init+0x86>
  {
    return  HAL_ERROR;
900085ee:	2301      	movs	r3, #1
900085f0:	e000      	b.n	900085f4 <MX_SDRAM_BANK2_Init+0x88>
  }
  return HAL_OK;
900085f2:	2300      	movs	r3, #0
}
900085f4:	4618      	mov	r0, r3
900085f6:	3730      	adds	r7, #48	; 0x30
900085f8:	46bd      	mov	sp, r7
900085fa:	bd80      	pop	{r7, pc}
900085fc:	24002e20 	.word	0x24002e20
90008600:	52004140 	.word	0x52004140

90008604 <BSP_SDRAM_IRQHandler>:
  * @brief  This function handles SDRAM MDMA interrupt request.
  * @param  Instance SDRAM instance
  * @retval None
  */
void BSP_SDRAM_IRQHandler(uint32_t Instance)
{
90008604:	b580      	push	{r7, lr}
90008606:	b082      	sub	sp, #8
90008608:	af00      	add	r7, sp, #0
9000860a:	6078      	str	r0, [r7, #4]
  HAL_MDMA_IRQHandler(hsdram[Instance].hmdma);
9000860c:	4a07      	ldr	r2, [pc, #28]	; (9000862c <BSP_SDRAM_IRQHandler+0x28>)
9000860e:	687b      	ldr	r3, [r7, #4]
90008610:	2134      	movs	r1, #52	; 0x34
90008612:	fb01 f303 	mul.w	r3, r1, r3
90008616:	4413      	add	r3, r2
90008618:	3330      	adds	r3, #48	; 0x30
9000861a:	681b      	ldr	r3, [r3, #0]
9000861c:	4618      	mov	r0, r3
9000861e:	f006 f863 	bl	9000e6e8 <HAL_MDMA_IRQHandler>
}
90008622:	bf00      	nop
90008624:	3708      	adds	r7, #8
90008626:	46bd      	mov	sp, r7
90008628:	bd80      	pop	{r7, pc}
9000862a:	bf00      	nop
9000862c:	24002e20 	.word	0x24002e20

90008630 <SDRAM_MspInit>:
  * @brief  Initializes SDRAM MSP.
  * @param  hSdram SDRAM handle
  * @retval None
  */
static void SDRAM_MspInit(SDRAM_HandleTypeDef  *hSdram)
{
90008630:	b580      	push	{r7, lr}
90008632:	b08e      	sub	sp, #56	; 0x38
90008634:	af00      	add	r7, sp, #0
90008636:	6078      	str	r0, [r7, #4]
  static MDMA_HandleTypeDef mdma_handle;
  GPIO_InitTypeDef gpio_init_structure;

  /* Enable FMC clock */
  __HAL_RCC_FMC_CLK_ENABLE();
90008638:	4b73      	ldr	r3, [pc, #460]	; (90008808 <SDRAM_MspInit+0x1d8>)
9000863a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
9000863e:	4a72      	ldr	r2, [pc, #456]	; (90008808 <SDRAM_MspInit+0x1d8>)
90008640:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
90008644:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
90008648:	4b6f      	ldr	r3, [pc, #444]	; (90008808 <SDRAM_MspInit+0x1d8>)
9000864a:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
9000864e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
90008652:	623b      	str	r3, [r7, #32]
90008654:	6a3b      	ldr	r3, [r7, #32]

  /* Enable chosen MDMAx clock */
  SDRAM_MDMAx_CLK_ENABLE();
90008656:	4b6c      	ldr	r3, [pc, #432]	; (90008808 <SDRAM_MspInit+0x1d8>)
90008658:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
9000865c:	4a6a      	ldr	r2, [pc, #424]	; (90008808 <SDRAM_MspInit+0x1d8>)
9000865e:	f043 0301 	orr.w	r3, r3, #1
90008662:	f8c2 30d4 	str.w	r3, [r2, #212]	; 0xd4
90008666:	4b68      	ldr	r3, [pc, #416]	; (90008808 <SDRAM_MspInit+0x1d8>)
90008668:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
9000866c:	f003 0301 	and.w	r3, r3, #1
90008670:	61fb      	str	r3, [r7, #28]
90008672:	69fb      	ldr	r3, [r7, #28]

  /* Enable GPIOs clock */
  __HAL_RCC_GPIOD_CLK_ENABLE();
90008674:	4b64      	ldr	r3, [pc, #400]	; (90008808 <SDRAM_MspInit+0x1d8>)
90008676:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
9000867a:	4a63      	ldr	r2, [pc, #396]	; (90008808 <SDRAM_MspInit+0x1d8>)
9000867c:	f043 0308 	orr.w	r3, r3, #8
90008680:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
90008684:	4b60      	ldr	r3, [pc, #384]	; (90008808 <SDRAM_MspInit+0x1d8>)
90008686:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
9000868a:	f003 0308 	and.w	r3, r3, #8
9000868e:	61bb      	str	r3, [r7, #24]
90008690:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOE_CLK_ENABLE();
90008692:	4b5d      	ldr	r3, [pc, #372]	; (90008808 <SDRAM_MspInit+0x1d8>)
90008694:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90008698:	4a5b      	ldr	r2, [pc, #364]	; (90008808 <SDRAM_MspInit+0x1d8>)
9000869a:	f043 0310 	orr.w	r3, r3, #16
9000869e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
900086a2:	4b59      	ldr	r3, [pc, #356]	; (90008808 <SDRAM_MspInit+0x1d8>)
900086a4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900086a8:	f003 0310 	and.w	r3, r3, #16
900086ac:	617b      	str	r3, [r7, #20]
900086ae:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOF_CLK_ENABLE();
900086b0:	4b55      	ldr	r3, [pc, #340]	; (90008808 <SDRAM_MspInit+0x1d8>)
900086b2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900086b6:	4a54      	ldr	r2, [pc, #336]	; (90008808 <SDRAM_MspInit+0x1d8>)
900086b8:	f043 0320 	orr.w	r3, r3, #32
900086bc:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
900086c0:	4b51      	ldr	r3, [pc, #324]	; (90008808 <SDRAM_MspInit+0x1d8>)
900086c2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900086c6:	f003 0320 	and.w	r3, r3, #32
900086ca:	613b      	str	r3, [r7, #16]
900086cc:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOG_CLK_ENABLE();
900086ce:	4b4e      	ldr	r3, [pc, #312]	; (90008808 <SDRAM_MspInit+0x1d8>)
900086d0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900086d4:	4a4c      	ldr	r2, [pc, #304]	; (90008808 <SDRAM_MspInit+0x1d8>)
900086d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
900086da:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
900086de:	4b4a      	ldr	r3, [pc, #296]	; (90008808 <SDRAM_MspInit+0x1d8>)
900086e0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900086e4:	f003 0340 	and.w	r3, r3, #64	; 0x40
900086e8:	60fb      	str	r3, [r7, #12]
900086ea:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOH_CLK_ENABLE();
900086ec:	4b46      	ldr	r3, [pc, #280]	; (90008808 <SDRAM_MspInit+0x1d8>)
900086ee:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
900086f2:	4a45      	ldr	r2, [pc, #276]	; (90008808 <SDRAM_MspInit+0x1d8>)
900086f4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
900086f8:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
900086fc:	4b42      	ldr	r3, [pc, #264]	; (90008808 <SDRAM_MspInit+0x1d8>)
900086fe:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
90008702:	f003 0380 	and.w	r3, r3, #128	; 0x80
90008706:	60bb      	str	r3, [r7, #8]
90008708:	68bb      	ldr	r3, [r7, #8]

  /* Common GPIO configuration */
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
9000870a:	2302      	movs	r3, #2
9000870c:	62bb      	str	r3, [r7, #40]	; 0x28
  gpio_init_structure.Pull      = GPIO_PULLUP;
9000870e:	2301      	movs	r3, #1
90008710:	62fb      	str	r3, [r7, #44]	; 0x2c
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
90008712:	2303      	movs	r3, #3
90008714:	633b      	str	r3, [r7, #48]	; 0x30
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
90008716:	230c      	movs	r3, #12
90008718:	637b      	str	r3, [r7, #52]	; 0x34

  /* GPIOD configuration */
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8| GPIO_PIN_9 | GPIO_PIN_10 |\
9000871a:	f24c 7303 	movw	r3, #50947	; 0xc703
9000871e:	627b      	str	r3, [r7, #36]	; 0x24
                              GPIO_PIN_14 | GPIO_PIN_15;


  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
90008720:	f107 0324 	add.w	r3, r7, #36	; 0x24
90008724:	4619      	mov	r1, r3
90008726:	4839      	ldr	r0, [pc, #228]	; (9000880c <SDRAM_MspInit+0x1dc>)
90008728:	f004 fa5e 	bl	9000cbe8 <HAL_GPIO_Init>

  /* GPIOE configuration */
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
9000872c:	f64f 7383 	movw	r3, #65411	; 0xff83
90008730:	627b      	str	r3, [r7, #36]	; 0x24
                              GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;

  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
90008732:	f107 0324 	add.w	r3, r7, #36	; 0x24
90008736:	4619      	mov	r1, r3
90008738:	4835      	ldr	r0, [pc, #212]	; (90008810 <SDRAM_MspInit+0x1e0>)
9000873a:	f004 fa55 	bl	9000cbe8 <HAL_GPIO_Init>

  /* GPIOF configuration */
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
9000873e:	f64f 033f 	movw	r3, #63551	; 0xf83f
90008742:	627b      	str	r3, [r7, #36]	; 0x24
                              GPIO_PIN_5 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;

  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
90008744:	f107 0324 	add.w	r3, r7, #36	; 0x24
90008748:	4619      	mov	r1, r3
9000874a:	4832      	ldr	r0, [pc, #200]	; (90008814 <SDRAM_MspInit+0x1e4>)
9000874c:	f004 fa4c 	bl	9000cbe8 <HAL_GPIO_Init>

  /* GPIOG configuration */
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_8 | GPIO_PIN_15;
90008750:	f248 1333 	movw	r3, #33075	; 0x8133
90008754:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
90008756:	f107 0324 	add.w	r3, r7, #36	; 0x24
9000875a:	4619      	mov	r1, r3
9000875c:	482e      	ldr	r0, [pc, #184]	; (90008818 <SDRAM_MspInit+0x1e8>)
9000875e:	f004 fa43 	bl	9000cbe8 <HAL_GPIO_Init>

  /* GPIOH configuration */
  gpio_init_structure.Pin   = GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7 ;
90008762:	23e0      	movs	r3, #224	; 0xe0
90008764:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOH, &gpio_init_structure);
90008766:	f107 0324 	add.w	r3, r7, #36	; 0x24
9000876a:	4619      	mov	r1, r3
9000876c:	482b      	ldr	r0, [pc, #172]	; (9000881c <SDRAM_MspInit+0x1ec>)
9000876e:	f004 fa3b 	bl	9000cbe8 <HAL_GPIO_Init>



  /* Configure common MDMA parameters */
  mdma_handle.Init.Request = MDMA_REQUEST_SW;
90008772:	4b2b      	ldr	r3, [pc, #172]	; (90008820 <SDRAM_MspInit+0x1f0>)
90008774:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
90008778:	605a      	str	r2, [r3, #4]
  mdma_handle.Init.TransferTriggerMode = MDMA_BLOCK_TRANSFER;
9000877a:	4b29      	ldr	r3, [pc, #164]	; (90008820 <SDRAM_MspInit+0x1f0>)
9000877c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
90008780:	609a      	str	r2, [r3, #8]
  mdma_handle.Init.Priority = MDMA_PRIORITY_HIGH;
90008782:	4b27      	ldr	r3, [pc, #156]	; (90008820 <SDRAM_MspInit+0x1f0>)
90008784:	2280      	movs	r2, #128	; 0x80
90008786:	60da      	str	r2, [r3, #12]
  mdma_handle.Init.Endianness = MDMA_LITTLE_ENDIANNESS_PRESERVE;
90008788:	4b25      	ldr	r3, [pc, #148]	; (90008820 <SDRAM_MspInit+0x1f0>)
9000878a:	2200      	movs	r2, #0
9000878c:	611a      	str	r2, [r3, #16]
  mdma_handle.Init.SourceInc = MDMA_SRC_INC_WORD;
9000878e:	4b24      	ldr	r3, [pc, #144]	; (90008820 <SDRAM_MspInit+0x1f0>)
90008790:	f240 2202 	movw	r2, #514	; 0x202
90008794:	615a      	str	r2, [r3, #20]
  mdma_handle.Init.DestinationInc = MDMA_DEST_INC_WORD;
90008796:	4b22      	ldr	r3, [pc, #136]	; (90008820 <SDRAM_MspInit+0x1f0>)
90008798:	f640 0208 	movw	r2, #2056	; 0x808
9000879c:	619a      	str	r2, [r3, #24]
  mdma_handle.Init.SourceDataSize = MDMA_SRC_DATASIZE_WORD;
9000879e:	4b20      	ldr	r3, [pc, #128]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087a0:	2220      	movs	r2, #32
900087a2:	61da      	str	r2, [r3, #28]
  mdma_handle.Init.DestDataSize = MDMA_DEST_DATASIZE_WORD;
900087a4:	4b1e      	ldr	r3, [pc, #120]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087a6:	2280      	movs	r2, #128	; 0x80
900087a8:	621a      	str	r2, [r3, #32]
  mdma_handle.Init.DataAlignment = MDMA_DATAALIGN_PACKENABLE;
900087aa:	4b1d      	ldr	r3, [pc, #116]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087ac:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
900087b0:	625a      	str	r2, [r3, #36]	; 0x24
  mdma_handle.Init.SourceBurst = MDMA_SOURCE_BURST_SINGLE;
900087b2:	4b1b      	ldr	r3, [pc, #108]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087b4:	2200      	movs	r2, #0
900087b6:	62da      	str	r2, [r3, #44]	; 0x2c
  mdma_handle.Init.DestBurst = MDMA_DEST_BURST_SINGLE;
900087b8:	4b19      	ldr	r3, [pc, #100]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087ba:	2200      	movs	r2, #0
900087bc:	631a      	str	r2, [r3, #48]	; 0x30
  mdma_handle.Init.BufferTransferLength = 128;
900087be:	4b18      	ldr	r3, [pc, #96]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087c0:	2280      	movs	r2, #128	; 0x80
900087c2:	629a      	str	r2, [r3, #40]	; 0x28
  mdma_handle.Init.SourceBlockAddressOffset = 0;
900087c4:	4b16      	ldr	r3, [pc, #88]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087c6:	2200      	movs	r2, #0
900087c8:	635a      	str	r2, [r3, #52]	; 0x34
  mdma_handle.Init.DestBlockAddressOffset = 0;
900087ca:	4b15      	ldr	r3, [pc, #84]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087cc:	2200      	movs	r2, #0
900087ce:	639a      	str	r2, [r3, #56]	; 0x38


  mdma_handle.Instance = SDRAM_MDMAx_CHANNEL;
900087d0:	4b13      	ldr	r3, [pc, #76]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087d2:	4a14      	ldr	r2, [pc, #80]	; (90008824 <SDRAM_MspInit+0x1f4>)
900087d4:	601a      	str	r2, [r3, #0]

   /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hmdma, mdma_handle);
900087d6:	4b14      	ldr	r3, [pc, #80]	; (90008828 <SDRAM_MspInit+0x1f8>)
900087d8:	4a11      	ldr	r2, [pc, #68]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087da:	631a      	str	r2, [r3, #48]	; 0x30
900087dc:	4b10      	ldr	r3, [pc, #64]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087de:	4a12      	ldr	r2, [pc, #72]	; (90008828 <SDRAM_MspInit+0x1f8>)
900087e0:	641a      	str	r2, [r3, #64]	; 0x40

  /* Deinitialize the stream for new transfer */
  HAL_MDMA_DeInit(&mdma_handle);
900087e2:	480f      	ldr	r0, [pc, #60]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087e4:	f005 fea6 	bl	9000e534 <HAL_MDMA_DeInit>

  /* Configure the DMA stream */
  HAL_MDMA_Init(&mdma_handle);
900087e8:	480d      	ldr	r0, [pc, #52]	; (90008820 <SDRAM_MspInit+0x1f0>)
900087ea:	f005 fe57 	bl	9000e49c <HAL_MDMA_Init>

  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_MDMAx_IRQn, 0x0F, 0);
900087ee:	2200      	movs	r2, #0
900087f0:	210f      	movs	r1, #15
900087f2:	207a      	movs	r0, #122	; 0x7a
900087f4:	f000 ff31 	bl	9000965a <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_MDMAx_IRQn);
900087f8:	207a      	movs	r0, #122	; 0x7a
900087fa:	f000 ff48 	bl	9000968e <HAL_NVIC_EnableIRQ>
}
900087fe:	bf00      	nop
90008800:	3738      	adds	r7, #56	; 0x38
90008802:	46bd      	mov	sp, r7
90008804:	bd80      	pop	{r7, pc}
90008806:	bf00      	nop
90008808:	58024400 	.word	0x58024400
9000880c:	58020c00 	.word	0x58020c00
90008810:	58021000 	.word	0x58021000
90008814:	58021400 	.word	0x58021400
90008818:	58021800 	.word	0x58021800
9000881c:	58021c00 	.word	0x58021c00
90008820:	24001e5c 	.word	0x24001e5c
90008824:	52000040 	.word	0x52000040
90008828:	24002e20 	.word	0x24002e20

9000882c <SDRAM_MspDeInit>:
  * @brief  DeInitializes SDRAM MSP.
  * @param  hSdram SDRAM handle
  * @retval None
  */
static void SDRAM_MspDeInit(SDRAM_HandleTypeDef  *hSdram)
{
9000882c:	b580      	push	{r7, lr}
9000882e:	b082      	sub	sp, #8
90008830:	af00      	add	r7, sp, #0
90008832:	6078      	str	r0, [r7, #4]

  /* Prevent unused argument(s) compilation warning */
  UNUSED(hSdram);

  /* Disable NVIC configuration for DMA interrupt */
  HAL_NVIC_DisableIRQ(SDRAM_MDMAx_IRQn);
90008834:	207a      	movs	r0, #122	; 0x7a
90008836:	f000 ff38 	bl	900096aa <HAL_NVIC_DisableIRQ>

  /* Deinitialize the stream for new transfer */
  mdma_handle.Instance = SDRAM_MDMAx_CHANNEL;
9000883a:	4b05      	ldr	r3, [pc, #20]	; (90008850 <SDRAM_MspDeInit+0x24>)
9000883c:	4a05      	ldr	r2, [pc, #20]	; (90008854 <SDRAM_MspDeInit+0x28>)
9000883e:	601a      	str	r2, [r3, #0]
  (void)HAL_MDMA_DeInit(&mdma_handle);
90008840:	4803      	ldr	r0, [pc, #12]	; (90008850 <SDRAM_MspDeInit+0x24>)
90008842:	f005 fe77 	bl	9000e534 <HAL_MDMA_DeInit>
}
90008846:	bf00      	nop
90008848:	3708      	adds	r7, #8
9000884a:	46bd      	mov	sp, r7
9000884c:	bd80      	pop	{r7, pc}
9000884e:	bf00      	nop
90008850:	24001ec8 	.word	0x24001ec8
90008854:	52000040 	.word	0x52000040

90008858 <BSP_TS_Init>:
  * @param  Instance TS instance. Could be only 0.
  * @param  TS_Init  TS Init structure
  * @retval BSP status
  */
int32_t BSP_TS_Init(uint32_t Instance, TS_Init_t *TS_Init)
{
90008858:	b580      	push	{r7, lr}
9000885a:	b088      	sub	sp, #32
9000885c:	af00      	add	r7, sp, #0
9000885e:	6078      	str	r0, [r7, #4]
90008860:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
90008862:	2300      	movs	r3, #0
90008864:	61fb      	str	r3, [r7, #28]

  if((Instance >=TS_INSTANCES_NBR) || (TS_Init->Width == 0U) ||( TS_Init->Width > TS_MAX_WIDTH) ||\
90008866:	687b      	ldr	r3, [r7, #4]
90008868:	2b00      	cmp	r3, #0
9000886a:	d11c      	bne.n	900088a6 <BSP_TS_Init+0x4e>
9000886c:	683b      	ldr	r3, [r7, #0]
9000886e:	681b      	ldr	r3, [r3, #0]
90008870:	2b00      	cmp	r3, #0
90008872:	d018      	beq.n	900088a6 <BSP_TS_Init+0x4e>
90008874:	683b      	ldr	r3, [r7, #0]
90008876:	681b      	ldr	r3, [r3, #0]
90008878:	f5b3 7ff0 	cmp.w	r3, #480	; 0x1e0
9000887c:	d813      	bhi.n	900088a6 <BSP_TS_Init+0x4e>
                         (TS_Init->Height == 0U) ||( TS_Init->Height > TS_MAX_HEIGHT) ||\
9000887e:	683b      	ldr	r3, [r7, #0]
90008880:	685b      	ldr	r3, [r3, #4]
  if((Instance >=TS_INSTANCES_NBR) || (TS_Init->Width == 0U) ||( TS_Init->Width > TS_MAX_WIDTH) ||\
90008882:	2b00      	cmp	r3, #0
90008884:	d00f      	beq.n	900088a6 <BSP_TS_Init+0x4e>
                         (TS_Init->Height == 0U) ||( TS_Init->Height > TS_MAX_HEIGHT) ||\
90008886:	683b      	ldr	r3, [r7, #0]
90008888:	685b      	ldr	r3, [r3, #4]
9000888a:	f5b3 7f88 	cmp.w	r3, #272	; 0x110
9000888e:	d80a      	bhi.n	900088a6 <BSP_TS_Init+0x4e>
                         (TS_Init->Accuracy > TS_MIN((TS_Init->Width), (TS_Init->Height))))
90008890:	683b      	ldr	r3, [r7, #0]
90008892:	68da      	ldr	r2, [r3, #12]
90008894:	683b      	ldr	r3, [r7, #0]
90008896:	6819      	ldr	r1, [r3, #0]
90008898:	683b      	ldr	r3, [r7, #0]
9000889a:	685b      	ldr	r3, [r3, #4]
9000889c:	428b      	cmp	r3, r1
9000889e:	bf28      	it	cs
900088a0:	460b      	movcs	r3, r1
                         (TS_Init->Height == 0U) ||( TS_Init->Height > TS_MAX_HEIGHT) ||\
900088a2:	429a      	cmp	r2, r3
900088a4:	d903      	bls.n	900088ae <BSP_TS_Init+0x56>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900088a6:	f06f 0301 	mvn.w	r3, #1
900088aa:	61fb      	str	r3, [r7, #28]
900088ac:	e06e      	b.n	9000898c <BSP_TS_Init+0x134>
  }
  else
  {
    if(FT5336_Probe(Instance) != BSP_ERROR_NONE)
900088ae:	6878      	ldr	r0, [r7, #4]
900088b0:	f000 fc34 	bl	9000911c <FT5336_Probe>
900088b4:	4603      	mov	r3, r0
900088b6:	2b00      	cmp	r3, #0
900088b8:	d003      	beq.n	900088c2 <BSP_TS_Init+0x6a>
    {
      ret = BSP_ERROR_NO_INIT;
900088ba:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900088be:	61fb      	str	r3, [r7, #28]
900088c0:	e064      	b.n	9000898c <BSP_TS_Init+0x134>
    else
    {
      TS_Capabilities_t Capabilities;
      uint32_t i;
      /* Store parameters on TS context */
      Ts_Ctx[Instance].Width             = TS_Init->Width;
900088c2:	683b      	ldr	r3, [r7, #0]
900088c4:	681a      	ldr	r2, [r3, #0]
900088c6:	4934      	ldr	r1, [pc, #208]	; (90008998 <BSP_TS_Init+0x140>)
900088c8:	687b      	ldr	r3, [r7, #4]
900088ca:	019b      	lsls	r3, r3, #6
900088cc:	440b      	add	r3, r1
900088ce:	601a      	str	r2, [r3, #0]
      Ts_Ctx[Instance].Height            = TS_Init->Height;
900088d0:	683b      	ldr	r3, [r7, #0]
900088d2:	685a      	ldr	r2, [r3, #4]
900088d4:	4930      	ldr	r1, [pc, #192]	; (90008998 <BSP_TS_Init+0x140>)
900088d6:	687b      	ldr	r3, [r7, #4]
900088d8:	019b      	lsls	r3, r3, #6
900088da:	440b      	add	r3, r1
900088dc:	3304      	adds	r3, #4
900088de:	601a      	str	r2, [r3, #0]
      Ts_Ctx[Instance].Orientation       = TS_Init->Orientation;
900088e0:	683b      	ldr	r3, [r7, #0]
900088e2:	689a      	ldr	r2, [r3, #8]
900088e4:	492c      	ldr	r1, [pc, #176]	; (90008998 <BSP_TS_Init+0x140>)
900088e6:	687b      	ldr	r3, [r7, #4]
900088e8:	019b      	lsls	r3, r3, #6
900088ea:	440b      	add	r3, r1
900088ec:	3308      	adds	r3, #8
900088ee:	601a      	str	r2, [r3, #0]
      Ts_Ctx[Instance].Accuracy          = TS_Init->Accuracy;
900088f0:	683b      	ldr	r3, [r7, #0]
900088f2:	68da      	ldr	r2, [r3, #12]
900088f4:	4928      	ldr	r1, [pc, #160]	; (90008998 <BSP_TS_Init+0x140>)
900088f6:	687b      	ldr	r3, [r7, #4]
900088f8:	019b      	lsls	r3, r3, #6
900088fa:	440b      	add	r3, r1
900088fc:	330c      	adds	r3, #12
900088fe:	601a      	str	r2, [r3, #0]
      /* Get capabilities to retrieve maximum values of X and Y */
        if (Ts_Drv->GetCapabilities(Ts_CompObj[Instance], &Capabilities) < 0)
90008900:	4b26      	ldr	r3, [pc, #152]	; (9000899c <BSP_TS_Init+0x144>)
90008902:	681b      	ldr	r3, [r3, #0]
90008904:	69db      	ldr	r3, [r3, #28]
90008906:	4926      	ldr	r1, [pc, #152]	; (900089a0 <BSP_TS_Init+0x148>)
90008908:	687a      	ldr	r2, [r7, #4]
9000890a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
9000890e:	f107 010c 	add.w	r1, r7, #12
90008912:	4610      	mov	r0, r2
90008914:	4798      	blx	r3
90008916:	4603      	mov	r3, r0
90008918:	2b00      	cmp	r3, #0
9000891a:	da03      	bge.n	90008924 <BSP_TS_Init+0xcc>
      {
        ret = BSP_ERROR_COMPONENT_FAILURE;
9000891c:	f06f 0304 	mvn.w	r3, #4
90008920:	61fb      	str	r3, [r7, #28]
90008922:	e033      	b.n	9000898c <BSP_TS_Init+0x134>
      }
      else
      {
        /* Store maximum X and Y on context */
        Ts_Ctx[Instance].MaxX = Capabilities.MaxXl;
90008924:	693a      	ldr	r2, [r7, #16]
90008926:	491c      	ldr	r1, [pc, #112]	; (90008998 <BSP_TS_Init+0x140>)
90008928:	687b      	ldr	r3, [r7, #4]
9000892a:	019b      	lsls	r3, r3, #6
9000892c:	440b      	add	r3, r1
9000892e:	3310      	adds	r3, #16
90008930:	601a      	str	r2, [r3, #0]
        Ts_Ctx[Instance].MaxY = Capabilities.MaxYl;
90008932:	697a      	ldr	r2, [r7, #20]
90008934:	4918      	ldr	r1, [pc, #96]	; (90008998 <BSP_TS_Init+0x140>)
90008936:	687b      	ldr	r3, [r7, #4]
90008938:	019b      	lsls	r3, r3, #6
9000893a:	440b      	add	r3, r1
9000893c:	3314      	adds	r3, #20
9000893e:	601a      	str	r2, [r3, #0]
        /* Initialize previous position in order to always detect first touch */
        for(i = 0; i < TS_TOUCH_NBR; i++)
90008940:	2300      	movs	r3, #0
90008942:	61bb      	str	r3, [r7, #24]
90008944:	e01f      	b.n	90008986 <BSP_TS_Init+0x12e>
        {
          Ts_Ctx[Instance].PreviousX[i] = TS_Init->Width + TS_Init->Accuracy + 1U;
90008946:	683b      	ldr	r3, [r7, #0]
90008948:	681a      	ldr	r2, [r3, #0]
9000894a:	683b      	ldr	r3, [r7, #0]
9000894c:	68db      	ldr	r3, [r3, #12]
9000894e:	4413      	add	r3, r2
90008950:	1c5a      	adds	r2, r3, #1
90008952:	4811      	ldr	r0, [pc, #68]	; (90008998 <BSP_TS_Init+0x140>)
90008954:	687b      	ldr	r3, [r7, #4]
90008956:	0119      	lsls	r1, r3, #4
90008958:	69bb      	ldr	r3, [r7, #24]
9000895a:	440b      	add	r3, r1
9000895c:	3306      	adds	r3, #6
9000895e:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
          Ts_Ctx[Instance].PreviousY[i] = TS_Init->Height + TS_Init->Accuracy + 1U;
90008962:	683b      	ldr	r3, [r7, #0]
90008964:	685a      	ldr	r2, [r3, #4]
90008966:	683b      	ldr	r3, [r7, #0]
90008968:	68db      	ldr	r3, [r3, #12]
9000896a:	4413      	add	r3, r2
9000896c:	1c5a      	adds	r2, r3, #1
9000896e:	480a      	ldr	r0, [pc, #40]	; (90008998 <BSP_TS_Init+0x140>)
90008970:	687b      	ldr	r3, [r7, #4]
90008972:	0119      	lsls	r1, r3, #4
90008974:	69bb      	ldr	r3, [r7, #24]
90008976:	440b      	add	r3, r1
90008978:	330a      	adds	r3, #10
9000897a:	009b      	lsls	r3, r3, #2
9000897c:	4403      	add	r3, r0
9000897e:	605a      	str	r2, [r3, #4]
        for(i = 0; i < TS_TOUCH_NBR; i++)
90008980:	69bb      	ldr	r3, [r7, #24]
90008982:	3301      	adds	r3, #1
90008984:	61bb      	str	r3, [r7, #24]
90008986:	69bb      	ldr	r3, [r7, #24]
90008988:	2b04      	cmp	r3, #4
9000898a:	d9dc      	bls.n	90008946 <BSP_TS_Init+0xee>
        }
      }
    }
  }

  return ret;
9000898c:	69fb      	ldr	r3, [r7, #28]
}
9000898e:	4618      	mov	r0, r3
90008990:	3720      	adds	r7, #32
90008992:	46bd      	mov	sp, r7
90008994:	bd80      	pop	{r7, pc}
90008996:	bf00      	nop
90008998:	24001f44 	.word	0x24001f44
9000899c:	24001f34 	.word	0x24001f34
900089a0:	24001f40 	.word	0x24001f40

900089a4 <BSP_TS_DeInit>:
  * @brief  De-Initializes the touch screen functionalities
  * @param  Instance TS instance. Could be only 0.
  * @retval BSP status
  */
int32_t BSP_TS_DeInit(uint32_t Instance)
{
900089a4:	b580      	push	{r7, lr}
900089a6:	b084      	sub	sp, #16
900089a8:	af00      	add	r7, sp, #0
900089aa:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
900089ac:	2300      	movs	r3, #0
900089ae:	60fb      	str	r3, [r7, #12]

  if(Instance >=TS_INSTANCES_NBR)
900089b0:	687b      	ldr	r3, [r7, #4]
900089b2:	2b00      	cmp	r3, #0
900089b4:	d003      	beq.n	900089be <BSP_TS_DeInit+0x1a>
  {
    ret = BSP_ERROR_WRONG_PARAM;
900089b6:	f06f 0301 	mvn.w	r3, #1
900089ba:	60fb      	str	r3, [r7, #12]
900089bc:	e00e      	b.n	900089dc <BSP_TS_DeInit+0x38>
  }
  else
  {
    if(Ts_Drv->DeInit(Ts_CompObj[Instance]) < 0)
900089be:	4b0a      	ldr	r3, [pc, #40]	; (900089e8 <BSP_TS_DeInit+0x44>)
900089c0:	681b      	ldr	r3, [r3, #0]
900089c2:	685b      	ldr	r3, [r3, #4]
900089c4:	4909      	ldr	r1, [pc, #36]	; (900089ec <BSP_TS_DeInit+0x48>)
900089c6:	687a      	ldr	r2, [r7, #4]
900089c8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
900089cc:	4610      	mov	r0, r2
900089ce:	4798      	blx	r3
900089d0:	4603      	mov	r3, r0
900089d2:	2b00      	cmp	r3, #0
900089d4:	da02      	bge.n	900089dc <BSP_TS_DeInit+0x38>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
900089d6:	f06f 0304 	mvn.w	r3, #4
900089da:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
900089dc:	68fb      	ldr	r3, [r7, #12]
}
900089de:	4618      	mov	r0, r3
900089e0:	3710      	adds	r7, #16
900089e2:	46bd      	mov	sp, r7
900089e4:	bd80      	pop	{r7, pc}
900089e6:	bf00      	nop
900089e8:	24001f34 	.word	0x24001f34
900089ec:	24001f40 	.word	0x24001f40

900089f0 <BSP_TS_GetState>:
  * @param  Instance  TS instance. Could be only 0.
  * @param  TS_State  Pointer to touch screen current state structure
  * @retval BSP status
  */
int32_t BSP_TS_GetState(uint32_t Instance, TS_State_t *TS_State)
{
900089f0:	b580      	push	{r7, lr}
900089f2:	b08a      	sub	sp, #40	; 0x28
900089f4:	af00      	add	r7, sp, #0
900089f6:	6078      	str	r0, [r7, #4]
900089f8:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
900089fa:	2300      	movs	r3, #0
900089fc:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t x_oriented, y_oriented;
  uint32_t x_diff, y_diff;

  if(Instance >= TS_INSTANCES_NBR)
900089fe:	687b      	ldr	r3, [r7, #4]
90008a00:	2b00      	cmp	r3, #0
90008a02:	d003      	beq.n	90008a0c <BSP_TS_GetState+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90008a04:	f06f 0301 	mvn.w	r3, #1
90008a08:	627b      	str	r3, [r7, #36]	; 0x24
90008a0a:	e0f9      	b.n	90008c00 <BSP_TS_GetState+0x210>
  else
  {
    FT5336_State_t state;

    /* Get each touch coordinates */
    if(Ts_Drv->GetState(Ts_CompObj[Instance], &state) < 0)
90008a0c:	4b7f      	ldr	r3, [pc, #508]	; (90008c0c <BSP_TS_GetState+0x21c>)
90008a0e:	681b      	ldr	r3, [r3, #0]
90008a10:	691b      	ldr	r3, [r3, #16]
90008a12:	497f      	ldr	r1, [pc, #508]	; (90008c10 <BSP_TS_GetState+0x220>)
90008a14:	687a      	ldr	r2, [r7, #4]
90008a16:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
90008a1a:	f107 0108 	add.w	r1, r7, #8
90008a1e:	4610      	mov	r0, r2
90008a20:	4798      	blx	r3
90008a22:	4603      	mov	r3, r0
90008a24:	2b00      	cmp	r3, #0
90008a26:	da03      	bge.n	90008a30 <BSP_TS_GetState+0x40>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
90008a28:	f06f 0304 	mvn.w	r3, #4
90008a2c:	627b      	str	r3, [r7, #36]	; 0x24
90008a2e:	e0e7      	b.n	90008c00 <BSP_TS_GetState+0x210>
    }/* Check and update the number of touches active detected */
    else if(state.TouchDetected != 0U)
90008a30:	68bb      	ldr	r3, [r7, #8]
90008a32:	2b00      	cmp	r3, #0
90008a34:	f000 80d1 	beq.w	90008bda <BSP_TS_GetState+0x1ea>
    {
      x_oriented = state.TouchX;
90008a38:	68fb      	ldr	r3, [r7, #12]
90008a3a:	623b      	str	r3, [r7, #32]
      y_oriented = state.TouchY;
90008a3c:	693b      	ldr	r3, [r7, #16]
90008a3e:	61fb      	str	r3, [r7, #28]

      if((Ts_Ctx[Instance].Orientation & TS_SWAP_XY) == TS_SWAP_XY)
90008a40:	4a74      	ldr	r2, [pc, #464]	; (90008c14 <BSP_TS_GetState+0x224>)
90008a42:	687b      	ldr	r3, [r7, #4]
90008a44:	019b      	lsls	r3, r3, #6
90008a46:	4413      	add	r3, r2
90008a48:	3308      	adds	r3, #8
90008a4a:	681b      	ldr	r3, [r3, #0]
90008a4c:	f003 0308 	and.w	r3, r3, #8
90008a50:	2b00      	cmp	r3, #0
90008a52:	d003      	beq.n	90008a5c <BSP_TS_GetState+0x6c>
      {
        x_oriented = state.TouchY;
90008a54:	693b      	ldr	r3, [r7, #16]
90008a56:	623b      	str	r3, [r7, #32]
        y_oriented = state.TouchX;
90008a58:	68fb      	ldr	r3, [r7, #12]
90008a5a:	61fb      	str	r3, [r7, #28]
      }

      if((Ts_Ctx[Instance].Orientation & TS_SWAP_X) == TS_SWAP_X)
90008a5c:	4a6d      	ldr	r2, [pc, #436]	; (90008c14 <BSP_TS_GetState+0x224>)
90008a5e:	687b      	ldr	r3, [r7, #4]
90008a60:	019b      	lsls	r3, r3, #6
90008a62:	4413      	add	r3, r2
90008a64:	3308      	adds	r3, #8
90008a66:	681b      	ldr	r3, [r3, #0]
90008a68:	f003 0302 	and.w	r3, r3, #2
90008a6c:	2b00      	cmp	r3, #0
90008a6e:	d009      	beq.n	90008a84 <BSP_TS_GetState+0x94>
      {
        x_oriented = Ts_Ctx[Instance].MaxX - state.TouchX - 1UL;
90008a70:	4a68      	ldr	r2, [pc, #416]	; (90008c14 <BSP_TS_GetState+0x224>)
90008a72:	687b      	ldr	r3, [r7, #4]
90008a74:	019b      	lsls	r3, r3, #6
90008a76:	4413      	add	r3, r2
90008a78:	3310      	adds	r3, #16
90008a7a:	681a      	ldr	r2, [r3, #0]
90008a7c:	68fb      	ldr	r3, [r7, #12]
90008a7e:	1ad3      	subs	r3, r2, r3
90008a80:	3b01      	subs	r3, #1
90008a82:	623b      	str	r3, [r7, #32]
      }

      if((Ts_Ctx[Instance].Orientation & TS_SWAP_Y) == TS_SWAP_Y)
90008a84:	4a63      	ldr	r2, [pc, #396]	; (90008c14 <BSP_TS_GetState+0x224>)
90008a86:	687b      	ldr	r3, [r7, #4]
90008a88:	019b      	lsls	r3, r3, #6
90008a8a:	4413      	add	r3, r2
90008a8c:	3308      	adds	r3, #8
90008a8e:	681b      	ldr	r3, [r3, #0]
90008a90:	f003 0304 	and.w	r3, r3, #4
90008a94:	2b00      	cmp	r3, #0
90008a96:	d008      	beq.n	90008aaa <BSP_TS_GetState+0xba>
      {
        y_oriented = Ts_Ctx[Instance].MaxY - state.TouchY;
90008a98:	4a5e      	ldr	r2, [pc, #376]	; (90008c14 <BSP_TS_GetState+0x224>)
90008a9a:	687b      	ldr	r3, [r7, #4]
90008a9c:	019b      	lsls	r3, r3, #6
90008a9e:	4413      	add	r3, r2
90008aa0:	3314      	adds	r3, #20
90008aa2:	681a      	ldr	r2, [r3, #0]
90008aa4:	693b      	ldr	r3, [r7, #16]
90008aa6:	1ad3      	subs	r3, r2, r3
90008aa8:	61fb      	str	r3, [r7, #28]
      }

      /* Apply boundary */
      TS_State->TouchX = (x_oriented * Ts_Ctx[Instance].Width) / Ts_Ctx[Instance].MaxX;
90008aaa:	4a5a      	ldr	r2, [pc, #360]	; (90008c14 <BSP_TS_GetState+0x224>)
90008aac:	687b      	ldr	r3, [r7, #4]
90008aae:	019b      	lsls	r3, r3, #6
90008ab0:	4413      	add	r3, r2
90008ab2:	681b      	ldr	r3, [r3, #0]
90008ab4:	6a3a      	ldr	r2, [r7, #32]
90008ab6:	fb02 f203 	mul.w	r2, r2, r3
90008aba:	4956      	ldr	r1, [pc, #344]	; (90008c14 <BSP_TS_GetState+0x224>)
90008abc:	687b      	ldr	r3, [r7, #4]
90008abe:	019b      	lsls	r3, r3, #6
90008ac0:	440b      	add	r3, r1
90008ac2:	3310      	adds	r3, #16
90008ac4:	681b      	ldr	r3, [r3, #0]
90008ac6:	fbb2 f2f3 	udiv	r2, r2, r3
90008aca:	683b      	ldr	r3, [r7, #0]
90008acc:	605a      	str	r2, [r3, #4]
      TS_State->TouchY = (y_oriented * Ts_Ctx[Instance].Height) / Ts_Ctx[Instance].MaxY;
90008ace:	4a51      	ldr	r2, [pc, #324]	; (90008c14 <BSP_TS_GetState+0x224>)
90008ad0:	687b      	ldr	r3, [r7, #4]
90008ad2:	019b      	lsls	r3, r3, #6
90008ad4:	4413      	add	r3, r2
90008ad6:	3304      	adds	r3, #4
90008ad8:	681b      	ldr	r3, [r3, #0]
90008ada:	69fa      	ldr	r2, [r7, #28]
90008adc:	fb02 f203 	mul.w	r2, r2, r3
90008ae0:	494c      	ldr	r1, [pc, #304]	; (90008c14 <BSP_TS_GetState+0x224>)
90008ae2:	687b      	ldr	r3, [r7, #4]
90008ae4:	019b      	lsls	r3, r3, #6
90008ae6:	440b      	add	r3, r1
90008ae8:	3314      	adds	r3, #20
90008aea:	681b      	ldr	r3, [r3, #0]
90008aec:	fbb2 f2f3 	udiv	r2, r2, r3
90008af0:	683b      	ldr	r3, [r7, #0]
90008af2:	609a      	str	r2, [r3, #8]
      /* Store Current TS state */
      TS_State->TouchDetected = state.TouchDetected;
90008af4:	68ba      	ldr	r2, [r7, #8]
90008af6:	683b      	ldr	r3, [r7, #0]
90008af8:	601a      	str	r2, [r3, #0]

      /* Check accuracy */
      x_diff = (TS_State->TouchX > Ts_Ctx[Instance].PreviousX[0])?
90008afa:	683b      	ldr	r3, [r7, #0]
90008afc:	685a      	ldr	r2, [r3, #4]
90008afe:	4945      	ldr	r1, [pc, #276]	; (90008c14 <BSP_TS_GetState+0x224>)
90008b00:	687b      	ldr	r3, [r7, #4]
90008b02:	019b      	lsls	r3, r3, #6
90008b04:	440b      	add	r3, r1
90008b06:	3318      	adds	r3, #24
90008b08:	681b      	ldr	r3, [r3, #0]
        (TS_State->TouchX - Ts_Ctx[Instance].PreviousX[0]):
90008b0a:	429a      	cmp	r2, r3
90008b0c:	d909      	bls.n	90008b22 <BSP_TS_GetState+0x132>
90008b0e:	683b      	ldr	r3, [r7, #0]
90008b10:	685a      	ldr	r2, [r3, #4]
90008b12:	4940      	ldr	r1, [pc, #256]	; (90008c14 <BSP_TS_GetState+0x224>)
90008b14:	687b      	ldr	r3, [r7, #4]
90008b16:	019b      	lsls	r3, r3, #6
90008b18:	440b      	add	r3, r1
90008b1a:	3318      	adds	r3, #24
90008b1c:	681b      	ldr	r3, [r3, #0]
90008b1e:	1ad3      	subs	r3, r2, r3
90008b20:	e008      	b.n	90008b34 <BSP_TS_GetState+0x144>
        (Ts_Ctx[Instance].PreviousX[0] - TS_State->TouchX);
90008b22:	4a3c      	ldr	r2, [pc, #240]	; (90008c14 <BSP_TS_GetState+0x224>)
90008b24:	687b      	ldr	r3, [r7, #4]
90008b26:	019b      	lsls	r3, r3, #6
90008b28:	4413      	add	r3, r2
90008b2a:	3318      	adds	r3, #24
90008b2c:	681a      	ldr	r2, [r3, #0]
90008b2e:	683b      	ldr	r3, [r7, #0]
90008b30:	685b      	ldr	r3, [r3, #4]
        (TS_State->TouchX - Ts_Ctx[Instance].PreviousX[0]):
90008b32:	1ad3      	subs	r3, r2, r3
      x_diff = (TS_State->TouchX > Ts_Ctx[Instance].PreviousX[0])?
90008b34:	61bb      	str	r3, [r7, #24]

        y_diff = (TS_State->TouchY > Ts_Ctx[Instance].PreviousY[0])?
90008b36:	683b      	ldr	r3, [r7, #0]
90008b38:	689a      	ldr	r2, [r3, #8]
90008b3a:	4936      	ldr	r1, [pc, #216]	; (90008c14 <BSP_TS_GetState+0x224>)
90008b3c:	687b      	ldr	r3, [r7, #4]
90008b3e:	019b      	lsls	r3, r3, #6
90008b40:	440b      	add	r3, r1
90008b42:	332c      	adds	r3, #44	; 0x2c
90008b44:	681b      	ldr	r3, [r3, #0]
          (TS_State->TouchY - Ts_Ctx[Instance].PreviousY[0]):
90008b46:	429a      	cmp	r2, r3
90008b48:	d909      	bls.n	90008b5e <BSP_TS_GetState+0x16e>
90008b4a:	683b      	ldr	r3, [r7, #0]
90008b4c:	689a      	ldr	r2, [r3, #8]
90008b4e:	4931      	ldr	r1, [pc, #196]	; (90008c14 <BSP_TS_GetState+0x224>)
90008b50:	687b      	ldr	r3, [r7, #4]
90008b52:	019b      	lsls	r3, r3, #6
90008b54:	440b      	add	r3, r1
90008b56:	332c      	adds	r3, #44	; 0x2c
90008b58:	681b      	ldr	r3, [r3, #0]
90008b5a:	1ad3      	subs	r3, r2, r3
90008b5c:	e008      	b.n	90008b70 <BSP_TS_GetState+0x180>
          (Ts_Ctx[Instance].PreviousY[0] - TS_State->TouchY);
90008b5e:	4a2d      	ldr	r2, [pc, #180]	; (90008c14 <BSP_TS_GetState+0x224>)
90008b60:	687b      	ldr	r3, [r7, #4]
90008b62:	019b      	lsls	r3, r3, #6
90008b64:	4413      	add	r3, r2
90008b66:	332c      	adds	r3, #44	; 0x2c
90008b68:	681a      	ldr	r2, [r3, #0]
90008b6a:	683b      	ldr	r3, [r7, #0]
90008b6c:	689b      	ldr	r3, [r3, #8]
          (TS_State->TouchY - Ts_Ctx[Instance].PreviousY[0]):
90008b6e:	1ad3      	subs	r3, r2, r3
        y_diff = (TS_State->TouchY > Ts_Ctx[Instance].PreviousY[0])?
90008b70:	617b      	str	r3, [r7, #20]


          if ((x_diff > Ts_Ctx[Instance].Accuracy) || (y_diff > Ts_Ctx[Instance].Accuracy))
90008b72:	4a28      	ldr	r2, [pc, #160]	; (90008c14 <BSP_TS_GetState+0x224>)
90008b74:	687b      	ldr	r3, [r7, #4]
90008b76:	019b      	lsls	r3, r3, #6
90008b78:	4413      	add	r3, r2
90008b7a:	330c      	adds	r3, #12
90008b7c:	681b      	ldr	r3, [r3, #0]
90008b7e:	69ba      	ldr	r2, [r7, #24]
90008b80:	429a      	cmp	r2, r3
90008b82:	d808      	bhi.n	90008b96 <BSP_TS_GetState+0x1a6>
90008b84:	4a23      	ldr	r2, [pc, #140]	; (90008c14 <BSP_TS_GetState+0x224>)
90008b86:	687b      	ldr	r3, [r7, #4]
90008b88:	019b      	lsls	r3, r3, #6
90008b8a:	4413      	add	r3, r2
90008b8c:	330c      	adds	r3, #12
90008b8e:	681b      	ldr	r3, [r3, #0]
90008b90:	697a      	ldr	r2, [r7, #20]
90008b92:	429a      	cmp	r2, r3
90008b94:	d910      	bls.n	90008bb8 <BSP_TS_GetState+0x1c8>
          {
            /* New touch detected */
            Ts_Ctx[Instance].PreviousX[0] = TS_State->TouchX;
90008b96:	683b      	ldr	r3, [r7, #0]
90008b98:	685a      	ldr	r2, [r3, #4]
90008b9a:	491e      	ldr	r1, [pc, #120]	; (90008c14 <BSP_TS_GetState+0x224>)
90008b9c:	687b      	ldr	r3, [r7, #4]
90008b9e:	019b      	lsls	r3, r3, #6
90008ba0:	440b      	add	r3, r1
90008ba2:	3318      	adds	r3, #24
90008ba4:	601a      	str	r2, [r3, #0]
            Ts_Ctx[Instance].PreviousY[0] = TS_State->TouchY;
90008ba6:	683b      	ldr	r3, [r7, #0]
90008ba8:	689a      	ldr	r2, [r3, #8]
90008baa:	491a      	ldr	r1, [pc, #104]	; (90008c14 <BSP_TS_GetState+0x224>)
90008bac:	687b      	ldr	r3, [r7, #4]
90008bae:	019b      	lsls	r3, r3, #6
90008bb0:	440b      	add	r3, r1
90008bb2:	332c      	adds	r3, #44	; 0x2c
90008bb4:	601a      	str	r2, [r3, #0]
90008bb6:	e023      	b.n	90008c00 <BSP_TS_GetState+0x210>
          }
          else
          {
            TS_State->TouchX = Ts_Ctx[Instance].PreviousX[0];
90008bb8:	4a16      	ldr	r2, [pc, #88]	; (90008c14 <BSP_TS_GetState+0x224>)
90008bba:	687b      	ldr	r3, [r7, #4]
90008bbc:	019b      	lsls	r3, r3, #6
90008bbe:	4413      	add	r3, r2
90008bc0:	3318      	adds	r3, #24
90008bc2:	681a      	ldr	r2, [r3, #0]
90008bc4:	683b      	ldr	r3, [r7, #0]
90008bc6:	605a      	str	r2, [r3, #4]
            TS_State->TouchY = Ts_Ctx[Instance].PreviousY[0];
90008bc8:	4a12      	ldr	r2, [pc, #72]	; (90008c14 <BSP_TS_GetState+0x224>)
90008bca:	687b      	ldr	r3, [r7, #4]
90008bcc:	019b      	lsls	r3, r3, #6
90008bce:	4413      	add	r3, r2
90008bd0:	332c      	adds	r3, #44	; 0x2c
90008bd2:	681a      	ldr	r2, [r3, #0]
90008bd4:	683b      	ldr	r3, [r7, #0]
90008bd6:	609a      	str	r2, [r3, #8]
90008bd8:	e012      	b.n	90008c00 <BSP_TS_GetState+0x210>
          }
    }
    else
    {
      TS_State->TouchDetected = 0U;
90008bda:	683b      	ldr	r3, [r7, #0]
90008bdc:	2200      	movs	r2, #0
90008bde:	601a      	str	r2, [r3, #0]
      TS_State->TouchX = Ts_Ctx[Instance].PreviousX[0];
90008be0:	4a0c      	ldr	r2, [pc, #48]	; (90008c14 <BSP_TS_GetState+0x224>)
90008be2:	687b      	ldr	r3, [r7, #4]
90008be4:	019b      	lsls	r3, r3, #6
90008be6:	4413      	add	r3, r2
90008be8:	3318      	adds	r3, #24
90008bea:	681a      	ldr	r2, [r3, #0]
90008bec:	683b      	ldr	r3, [r7, #0]
90008bee:	605a      	str	r2, [r3, #4]
      TS_State->TouchY = Ts_Ctx[Instance].PreviousY[0];
90008bf0:	4a08      	ldr	r2, [pc, #32]	; (90008c14 <BSP_TS_GetState+0x224>)
90008bf2:	687b      	ldr	r3, [r7, #4]
90008bf4:	019b      	lsls	r3, r3, #6
90008bf6:	4413      	add	r3, r2
90008bf8:	332c      	adds	r3, #44	; 0x2c
90008bfa:	681a      	ldr	r2, [r3, #0]
90008bfc:	683b      	ldr	r3, [r7, #0]
90008bfe:	609a      	str	r2, [r3, #8]
    }
}

return ret;
90008c00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
90008c02:	4618      	mov	r0, r3
90008c04:	3728      	adds	r7, #40	; 0x28
90008c06:	46bd      	mov	sp, r7
90008c08:	bd80      	pop	{r7, pc}
90008c0a:	bf00      	nop
90008c0c:	24001f34 	.word	0x24001f34
90008c10:	24001f40 	.word	0x24001f40
90008c14:	24001f44 	.word	0x24001f44

90008c18 <BSP_TS_Get_MultiTouchState>:
  * @param  Instance  TS instance. Could be only 0.
  * @param  TS_State  Pointer to touch screen current state structure
  * @retval BSP status
  */
int32_t BSP_TS_Get_MultiTouchState(uint32_t Instance, TS_MultiTouch_State_t *TS_State)
{
90008c18:	b580      	push	{r7, lr}
90008c1a:	b0a2      	sub	sp, #136	; 0x88
90008c1c:	af00      	add	r7, sp, #0
90008c1e:	6078      	str	r0, [r7, #4]
90008c20:	6039      	str	r1, [r7, #0]
 int32_t ret = BSP_ERROR_NONE;
90008c22:	2300      	movs	r3, #0
90008c24:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  uint32_t index;
  uint32_t x_oriented, y_oriented;
  uint32_t x_diff, y_diff;

  if(Instance >= TS_INSTANCES_NBR)
90008c28:	687b      	ldr	r3, [r7, #4]
90008c2a:	2b00      	cmp	r3, #0
90008c2c:	d004      	beq.n	90008c38 <BSP_TS_Get_MultiTouchState+0x20>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90008c2e:	f06f 0301 	mvn.w	r3, #1
90008c32:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
90008c36:	e1ab      	b.n	90008f90 <BSP_TS_Get_MultiTouchState+0x378>
  else
  {
    FT5336_MultiTouch_State_t state;

    /* Get each touch coordinates */
    if(Ts_Drv->GetMultiTouchState(Ts_CompObj[Instance], &state) < 0)
90008c38:	4bbe      	ldr	r3, [pc, #760]	; (90008f34 <BSP_TS_Get_MultiTouchState+0x31c>)
90008c3a:	681b      	ldr	r3, [r3, #0]
90008c3c:	695b      	ldr	r3, [r3, #20]
90008c3e:	49be      	ldr	r1, [pc, #760]	; (90008f38 <BSP_TS_Get_MultiTouchState+0x320>)
90008c40:	687a      	ldr	r2, [r7, #4]
90008c42:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
90008c46:	f107 0108 	add.w	r1, r7, #8
90008c4a:	4610      	mov	r0, r2
90008c4c:	4798      	blx	r3
90008c4e:	4603      	mov	r3, r0
90008c50:	2b00      	cmp	r3, #0
90008c52:	da04      	bge.n	90008c5e <BSP_TS_Get_MultiTouchState+0x46>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
90008c54:	f06f 0304 	mvn.w	r3, #4
90008c58:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
90008c5c:	e198      	b.n	90008f90 <BSP_TS_Get_MultiTouchState+0x378>
    }
    else
    {
      /* Check and update the number of touches active detected */
      if(state.TouchDetected != 0U)
90008c5e:	68bb      	ldr	r3, [r7, #8]
90008c60:	2b00      	cmp	r3, #0
90008c62:	f000 8160 	beq.w	90008f26 <BSP_TS_Get_MultiTouchState+0x30e>
    {
      for(index = 0; index < state.TouchDetected; index++)
90008c66:	2300      	movs	r3, #0
90008c68:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
90008c6c:	e154      	b.n	90008f18 <BSP_TS_Get_MultiTouchState+0x300>
      {
          x_oriented = state.TouchX[index];
90008c6e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008c72:	009b      	lsls	r3, r3, #2
90008c74:	f107 0288 	add.w	r2, r7, #136	; 0x88
90008c78:	4413      	add	r3, r2
90008c7a:	f853 3c7c 	ldr.w	r3, [r3, #-124]
90008c7e:	67fb      	str	r3, [r7, #124]	; 0x7c
          y_oriented = state.TouchY[index];
90008c80:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008c84:	3306      	adds	r3, #6
90008c86:	009b      	lsls	r3, r3, #2
90008c88:	f107 0288 	add.w	r2, r7, #136	; 0x88
90008c8c:	4413      	add	r3, r2
90008c8e:	f853 3c80 	ldr.w	r3, [r3, #-128]
90008c92:	67bb      	str	r3, [r7, #120]	; 0x78

        if((Ts_Ctx[Instance].Orientation & TS_SWAP_XY) == TS_SWAP_XY)
90008c94:	4aa9      	ldr	r2, [pc, #676]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008c96:	687b      	ldr	r3, [r7, #4]
90008c98:	019b      	lsls	r3, r3, #6
90008c9a:	4413      	add	r3, r2
90008c9c:	3308      	adds	r3, #8
90008c9e:	681b      	ldr	r3, [r3, #0]
90008ca0:	f003 0308 	and.w	r3, r3, #8
90008ca4:	2b00      	cmp	r3, #0
90008ca6:	d012      	beq.n	90008cce <BSP_TS_Get_MultiTouchState+0xb6>
        {
            x_oriented = state.TouchY[index];
90008ca8:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008cac:	3306      	adds	r3, #6
90008cae:	009b      	lsls	r3, r3, #2
90008cb0:	f107 0288 	add.w	r2, r7, #136	; 0x88
90008cb4:	4413      	add	r3, r2
90008cb6:	f853 3c80 	ldr.w	r3, [r3, #-128]
90008cba:	67fb      	str	r3, [r7, #124]	; 0x7c
            y_oriented = state.TouchX[index];
90008cbc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008cc0:	009b      	lsls	r3, r3, #2
90008cc2:	f107 0288 	add.w	r2, r7, #136	; 0x88
90008cc6:	4413      	add	r3, r2
90008cc8:	f853 3c7c 	ldr.w	r3, [r3, #-124]
90008ccc:	67bb      	str	r3, [r7, #120]	; 0x78
        }

        if((Ts_Ctx[Instance].Orientation & TS_SWAP_X) == TS_SWAP_X)
90008cce:	4a9b      	ldr	r2, [pc, #620]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008cd0:	687b      	ldr	r3, [r7, #4]
90008cd2:	019b      	lsls	r3, r3, #6
90008cd4:	4413      	add	r3, r2
90008cd6:	3308      	adds	r3, #8
90008cd8:	681b      	ldr	r3, [r3, #0]
90008cda:	f003 0302 	and.w	r3, r3, #2
90008cde:	2b00      	cmp	r3, #0
90008ce0:	d010      	beq.n	90008d04 <BSP_TS_Get_MultiTouchState+0xec>
        {
            x_oriented = Ts_Ctx[Instance].MaxX - state.TouchX[index] - 1UL;
90008ce2:	4a96      	ldr	r2, [pc, #600]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008ce4:	687b      	ldr	r3, [r7, #4]
90008ce6:	019b      	lsls	r3, r3, #6
90008ce8:	4413      	add	r3, r2
90008cea:	3310      	adds	r3, #16
90008cec:	681a      	ldr	r2, [r3, #0]
90008cee:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008cf2:	009b      	lsls	r3, r3, #2
90008cf4:	f107 0188 	add.w	r1, r7, #136	; 0x88
90008cf8:	440b      	add	r3, r1
90008cfa:	f853 3c7c 	ldr.w	r3, [r3, #-124]
90008cfe:	1ad3      	subs	r3, r2, r3
90008d00:	3b01      	subs	r3, #1
90008d02:	67fb      	str	r3, [r7, #124]	; 0x7c
        }

        if((Ts_Ctx[Instance].Orientation & TS_SWAP_Y) == TS_SWAP_Y)
90008d04:	4a8d      	ldr	r2, [pc, #564]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008d06:	687b      	ldr	r3, [r7, #4]
90008d08:	019b      	lsls	r3, r3, #6
90008d0a:	4413      	add	r3, r2
90008d0c:	3308      	adds	r3, #8
90008d0e:	681b      	ldr	r3, [r3, #0]
90008d10:	f003 0304 	and.w	r3, r3, #4
90008d14:	2b00      	cmp	r3, #0
90008d16:	d010      	beq.n	90008d3a <BSP_TS_Get_MultiTouchState+0x122>
        {
            y_oriented = Ts_Ctx[Instance].MaxY - state.TouchY[index];
90008d18:	4a88      	ldr	r2, [pc, #544]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008d1a:	687b      	ldr	r3, [r7, #4]
90008d1c:	019b      	lsls	r3, r3, #6
90008d1e:	4413      	add	r3, r2
90008d20:	3314      	adds	r3, #20
90008d22:	681a      	ldr	r2, [r3, #0]
90008d24:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008d28:	3306      	adds	r3, #6
90008d2a:	009b      	lsls	r3, r3, #2
90008d2c:	f107 0188 	add.w	r1, r7, #136	; 0x88
90008d30:	440b      	add	r3, r1
90008d32:	f853 3c80 	ldr.w	r3, [r3, #-128]
90008d36:	1ad3      	subs	r3, r2, r3
90008d38:	67bb      	str	r3, [r7, #120]	; 0x78
        }

        /* Apply boundary */
          TS_State->TouchX[index] = (x_oriented * Ts_Ctx[Instance].Width) / Ts_Ctx[Instance].MaxX;
90008d3a:	4a80      	ldr	r2, [pc, #512]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008d3c:	687b      	ldr	r3, [r7, #4]
90008d3e:	019b      	lsls	r3, r3, #6
90008d40:	4413      	add	r3, r2
90008d42:	681b      	ldr	r3, [r3, #0]
90008d44:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
90008d46:	fb02 f203 	mul.w	r2, r2, r3
90008d4a:	497c      	ldr	r1, [pc, #496]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008d4c:	687b      	ldr	r3, [r7, #4]
90008d4e:	019b      	lsls	r3, r3, #6
90008d50:	440b      	add	r3, r1
90008d52:	3310      	adds	r3, #16
90008d54:	681b      	ldr	r3, [r3, #0]
90008d56:	fbb2 f2f3 	udiv	r2, r2, r3
90008d5a:	6839      	ldr	r1, [r7, #0]
90008d5c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008d60:	009b      	lsls	r3, r3, #2
90008d62:	440b      	add	r3, r1
90008d64:	605a      	str	r2, [r3, #4]
          TS_State->TouchY[index] = (y_oriented * Ts_Ctx[Instance].Height) / Ts_Ctx[Instance].MaxY;
90008d66:	4a75      	ldr	r2, [pc, #468]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008d68:	687b      	ldr	r3, [r7, #4]
90008d6a:	019b      	lsls	r3, r3, #6
90008d6c:	4413      	add	r3, r2
90008d6e:	3304      	adds	r3, #4
90008d70:	681b      	ldr	r3, [r3, #0]
90008d72:	6fba      	ldr	r2, [r7, #120]	; 0x78
90008d74:	fb02 f203 	mul.w	r2, r2, r3
90008d78:	4970      	ldr	r1, [pc, #448]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008d7a:	687b      	ldr	r3, [r7, #4]
90008d7c:	019b      	lsls	r3, r3, #6
90008d7e:	440b      	add	r3, r1
90008d80:	3314      	adds	r3, #20
90008d82:	681b      	ldr	r3, [r3, #0]
90008d84:	fbb2 f1f3 	udiv	r1, r2, r3
90008d88:	683b      	ldr	r3, [r7, #0]
90008d8a:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
90008d8e:	3206      	adds	r2, #6
90008d90:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
          /* Store Current TS state */
          TS_State->TouchDetected = state.TouchDetected;
90008d94:	68ba      	ldr	r2, [r7, #8]
90008d96:	683b      	ldr	r3, [r7, #0]
90008d98:	601a      	str	r2, [r3, #0]

        /* Check accuracy */
          x_diff = (TS_State->TouchX[index] > Ts_Ctx[Instance].PreviousX[index])?
90008d9a:	683a      	ldr	r2, [r7, #0]
90008d9c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008da0:	009b      	lsls	r3, r3, #2
90008da2:	4413      	add	r3, r2
90008da4:	685a      	ldr	r2, [r3, #4]
90008da6:	4865      	ldr	r0, [pc, #404]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008da8:	687b      	ldr	r3, [r7, #4]
90008daa:	0119      	lsls	r1, r3, #4
90008dac:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008db0:	440b      	add	r3, r1
90008db2:	3306      	adds	r3, #6
90008db4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
                   (TS_State->TouchX[index] - Ts_Ctx[Instance].PreviousX[index]):
90008db8:	429a      	cmp	r2, r3
90008dba:	d910      	bls.n	90008dde <BSP_TS_Get_MultiTouchState+0x1c6>
90008dbc:	683a      	ldr	r2, [r7, #0]
90008dbe:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008dc2:	009b      	lsls	r3, r3, #2
90008dc4:	4413      	add	r3, r2
90008dc6:	685a      	ldr	r2, [r3, #4]
90008dc8:	485c      	ldr	r0, [pc, #368]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008dca:	687b      	ldr	r3, [r7, #4]
90008dcc:	0119      	lsls	r1, r3, #4
90008dce:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008dd2:	440b      	add	r3, r1
90008dd4:	3306      	adds	r3, #6
90008dd6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
90008dda:	1ad3      	subs	r3, r2, r3
90008ddc:	e00f      	b.n	90008dfe <BSP_TS_Get_MultiTouchState+0x1e6>
                   (Ts_Ctx[Instance].PreviousX[index] - TS_State->TouchX[index]);
90008dde:	4957      	ldr	r1, [pc, #348]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008de0:	687b      	ldr	r3, [r7, #4]
90008de2:	011a      	lsls	r2, r3, #4
90008de4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008de8:	4413      	add	r3, r2
90008dea:	3306      	adds	r3, #6
90008dec:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
90008df0:	6839      	ldr	r1, [r7, #0]
90008df2:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008df6:	009b      	lsls	r3, r3, #2
90008df8:	440b      	add	r3, r1
90008dfa:	685b      	ldr	r3, [r3, #4]
                   (TS_State->TouchX[index] - Ts_Ctx[Instance].PreviousX[index]):
90008dfc:	1ad3      	subs	r3, r2, r3
          x_diff = (TS_State->TouchX[index] > Ts_Ctx[Instance].PreviousX[index])?
90008dfe:	677b      	str	r3, [r7, #116]	; 0x74

          y_diff = (TS_State->TouchY[index] > Ts_Ctx[Instance].PreviousY[index])?
90008e00:	683b      	ldr	r3, [r7, #0]
90008e02:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
90008e06:	3206      	adds	r2, #6
90008e08:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
90008e0c:	484b      	ldr	r0, [pc, #300]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008e0e:	687b      	ldr	r3, [r7, #4]
90008e10:	0119      	lsls	r1, r3, #4
90008e12:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008e16:	440b      	add	r3, r1
90008e18:	330a      	adds	r3, #10
90008e1a:	009b      	lsls	r3, r3, #2
90008e1c:	4403      	add	r3, r0
90008e1e:	685b      	ldr	r3, [r3, #4]
                   (TS_State->TouchY[index] - Ts_Ctx[Instance].PreviousY[index]):
90008e20:	429a      	cmp	r2, r3
90008e22:	d911      	bls.n	90008e48 <BSP_TS_Get_MultiTouchState+0x230>
90008e24:	683b      	ldr	r3, [r7, #0]
90008e26:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
90008e2a:	3206      	adds	r2, #6
90008e2c:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
90008e30:	4842      	ldr	r0, [pc, #264]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008e32:	687b      	ldr	r3, [r7, #4]
90008e34:	0119      	lsls	r1, r3, #4
90008e36:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008e3a:	440b      	add	r3, r1
90008e3c:	330a      	adds	r3, #10
90008e3e:	009b      	lsls	r3, r3, #2
90008e40:	4403      	add	r3, r0
90008e42:	685b      	ldr	r3, [r3, #4]
90008e44:	1ad3      	subs	r3, r2, r3
90008e46:	e010      	b.n	90008e6a <BSP_TS_Get_MultiTouchState+0x252>
                   (Ts_Ctx[Instance].PreviousY[index] - TS_State->TouchY[index]);
90008e48:	493c      	ldr	r1, [pc, #240]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008e4a:	687b      	ldr	r3, [r7, #4]
90008e4c:	011a      	lsls	r2, r3, #4
90008e4e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008e52:	4413      	add	r3, r2
90008e54:	330a      	adds	r3, #10
90008e56:	009b      	lsls	r3, r3, #2
90008e58:	440b      	add	r3, r1
90008e5a:	685a      	ldr	r2, [r3, #4]
90008e5c:	683b      	ldr	r3, [r7, #0]
90008e5e:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
90008e62:	3106      	adds	r1, #6
90008e64:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
                   (TS_State->TouchY[index] - Ts_Ctx[Instance].PreviousY[index]):
90008e68:	1ad3      	subs	r3, r2, r3
          y_diff = (TS_State->TouchY[index] > Ts_Ctx[Instance].PreviousY[index])?
90008e6a:	673b      	str	r3, [r7, #112]	; 0x70

          if ((x_diff > Ts_Ctx[Instance].Accuracy) || (y_diff > Ts_Ctx[Instance].Accuracy))
90008e6c:	4a33      	ldr	r2, [pc, #204]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008e6e:	687b      	ldr	r3, [r7, #4]
90008e70:	019b      	lsls	r3, r3, #6
90008e72:	4413      	add	r3, r2
90008e74:	330c      	adds	r3, #12
90008e76:	681b      	ldr	r3, [r3, #0]
90008e78:	6f7a      	ldr	r2, [r7, #116]	; 0x74
90008e7a:	429a      	cmp	r2, r3
90008e7c:	d808      	bhi.n	90008e90 <BSP_TS_Get_MultiTouchState+0x278>
90008e7e:	4a2f      	ldr	r2, [pc, #188]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008e80:	687b      	ldr	r3, [r7, #4]
90008e82:	019b      	lsls	r3, r3, #6
90008e84:	4413      	add	r3, r2
90008e86:	330c      	adds	r3, #12
90008e88:	681b      	ldr	r3, [r3, #0]
90008e8a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
90008e8c:	429a      	cmp	r2, r3
90008e8e:	d91f      	bls.n	90008ed0 <BSP_TS_Get_MultiTouchState+0x2b8>
            {
              /* New touch detected */
            Ts_Ctx[Instance].PreviousX[index] = TS_State->TouchX[index];
90008e90:	683a      	ldr	r2, [r7, #0]
90008e92:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008e96:	009b      	lsls	r3, r3, #2
90008e98:	4413      	add	r3, r2
90008e9a:	685a      	ldr	r2, [r3, #4]
90008e9c:	4827      	ldr	r0, [pc, #156]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008e9e:	687b      	ldr	r3, [r7, #4]
90008ea0:	0119      	lsls	r1, r3, #4
90008ea2:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008ea6:	440b      	add	r3, r1
90008ea8:	3306      	adds	r3, #6
90008eaa:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
            Ts_Ctx[Instance].PreviousY[index] = TS_State->TouchY[index];
90008eae:	683b      	ldr	r3, [r7, #0]
90008eb0:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
90008eb4:	3206      	adds	r2, #6
90008eb6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
90008eba:	4820      	ldr	r0, [pc, #128]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008ebc:	687b      	ldr	r3, [r7, #4]
90008ebe:	0119      	lsls	r1, r3, #4
90008ec0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008ec4:	440b      	add	r3, r1
90008ec6:	330a      	adds	r3, #10
90008ec8:	009b      	lsls	r3, r3, #2
90008eca:	4403      	add	r3, r0
90008ecc:	605a      	str	r2, [r3, #4]
90008ece:	e01e      	b.n	90008f0e <BSP_TS_Get_MultiTouchState+0x2f6>
            }
            else
            {
            TS_State->TouchX[index] = Ts_Ctx[Instance].PreviousX[index];
90008ed0:	491a      	ldr	r1, [pc, #104]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008ed2:	687b      	ldr	r3, [r7, #4]
90008ed4:	011a      	lsls	r2, r3, #4
90008ed6:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008eda:	4413      	add	r3, r2
90008edc:	3306      	adds	r3, #6
90008ede:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
90008ee2:	6839      	ldr	r1, [r7, #0]
90008ee4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008ee8:	009b      	lsls	r3, r3, #2
90008eea:	440b      	add	r3, r1
90008eec:	605a      	str	r2, [r3, #4]
            TS_State->TouchY[index] = Ts_Ctx[Instance].PreviousY[index];
90008eee:	4913      	ldr	r1, [pc, #76]	; (90008f3c <BSP_TS_Get_MultiTouchState+0x324>)
90008ef0:	687b      	ldr	r3, [r7, #4]
90008ef2:	011a      	lsls	r2, r3, #4
90008ef4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008ef8:	4413      	add	r3, r2
90008efa:	330a      	adds	r3, #10
90008efc:	009b      	lsls	r3, r3, #2
90008efe:	440b      	add	r3, r1
90008f00:	6859      	ldr	r1, [r3, #4]
90008f02:	683b      	ldr	r3, [r7, #0]
90008f04:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
90008f08:	3206      	adds	r2, #6
90008f0a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      for(index = 0; index < state.TouchDetected; index++)
90008f0e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008f12:	3301      	adds	r3, #1
90008f14:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
90008f18:	68bb      	ldr	r3, [r7, #8]
90008f1a:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
90008f1e:	429a      	cmp	r2, r3
90008f20:	f4ff aea5 	bcc.w	90008c6e <BSP_TS_Get_MultiTouchState+0x56>
90008f24:	e034      	b.n	90008f90 <BSP_TS_Get_MultiTouchState+0x378>
            }
      }
    }
    else
    {
      TS_State->TouchDetected = 0U;
90008f26:	683b      	ldr	r3, [r7, #0]
90008f28:	2200      	movs	r2, #0
90008f2a:	601a      	str	r2, [r3, #0]
        for(index = 0; index < TS_TOUCH_NBR; index++)
90008f2c:	2300      	movs	r3, #0
90008f2e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
90008f32:	e029      	b.n	90008f88 <BSP_TS_Get_MultiTouchState+0x370>
90008f34:	24001f34 	.word	0x24001f34
90008f38:	24001f40 	.word	0x24001f40
90008f3c:	24001f44 	.word	0x24001f44
        {
          TS_State->TouchX[index] = Ts_Ctx[Instance].PreviousX[index];
90008f40:	4916      	ldr	r1, [pc, #88]	; (90008f9c <BSP_TS_Get_MultiTouchState+0x384>)
90008f42:	687b      	ldr	r3, [r7, #4]
90008f44:	011a      	lsls	r2, r3, #4
90008f46:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008f4a:	4413      	add	r3, r2
90008f4c:	3306      	adds	r3, #6
90008f4e:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
90008f52:	6839      	ldr	r1, [r7, #0]
90008f54:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008f58:	009b      	lsls	r3, r3, #2
90008f5a:	440b      	add	r3, r1
90008f5c:	605a      	str	r2, [r3, #4]
          TS_State->TouchY[index] = Ts_Ctx[Instance].PreviousY[index];
90008f5e:	490f      	ldr	r1, [pc, #60]	; (90008f9c <BSP_TS_Get_MultiTouchState+0x384>)
90008f60:	687b      	ldr	r3, [r7, #4]
90008f62:	011a      	lsls	r2, r3, #4
90008f64:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008f68:	4413      	add	r3, r2
90008f6a:	330a      	adds	r3, #10
90008f6c:	009b      	lsls	r3, r3, #2
90008f6e:	440b      	add	r3, r1
90008f70:	6859      	ldr	r1, [r3, #4]
90008f72:	683b      	ldr	r3, [r7, #0]
90008f74:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
90008f78:	3206      	adds	r2, #6
90008f7a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for(index = 0; index < TS_TOUCH_NBR; index++)
90008f7e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008f82:	3301      	adds	r3, #1
90008f84:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
90008f88:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
90008f8c:	2b04      	cmp	r3, #4
90008f8e:	d9d7      	bls.n	90008f40 <BSP_TS_Get_MultiTouchState+0x328>
        }
      }
    }
  }

  return ret;
90008f90:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
}
90008f94:	4618      	mov	r0, r3
90008f96:	3788      	adds	r7, #136	; 0x88
90008f98:	46bd      	mov	sp, r7
90008f9a:	bd80      	pop	{r7, pc}
90008f9c:	24001f44 	.word	0x24001f44

90008fa0 <BSP_TS_GestureConfig>:
  * @param  Instance      TS instance. Could be only 0.
  * @param  GestureConfig Pointer to gesture configuration structure
  * @retval BSP status
  */
int32_t BSP_TS_GestureConfig(uint32_t Instance, TS_Gesture_Config_t *GestureConfig)
{
90008fa0:	b580      	push	{r7, lr}
90008fa2:	b084      	sub	sp, #16
90008fa4:	af00      	add	r7, sp, #0
90008fa6:	6078      	str	r0, [r7, #4]
90008fa8:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
90008faa:	2300      	movs	r3, #0
90008fac:	60fb      	str	r3, [r7, #12]

  if(Instance >=TS_INSTANCES_NBR)
90008fae:	687b      	ldr	r3, [r7, #4]
90008fb0:	2b00      	cmp	r3, #0
90008fb2:	d003      	beq.n	90008fbc <BSP_TS_GestureConfig+0x1c>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90008fb4:	f06f 0301 	mvn.w	r3, #1
90008fb8:	60fb      	str	r3, [r7, #12]
90008fba:	e00f      	b.n	90008fdc <BSP_TS_GestureConfig+0x3c>
  }
  else
  {
    if(Ts_Drv->GestureConfig(Ts_CompObj[Instance], GestureConfig) < 0)
90008fbc:	4b0a      	ldr	r3, [pc, #40]	; (90008fe8 <BSP_TS_GestureConfig+0x48>)
90008fbe:	681b      	ldr	r3, [r3, #0]
90008fc0:	689b      	ldr	r3, [r3, #8]
90008fc2:	490a      	ldr	r1, [pc, #40]	; (90008fec <BSP_TS_GestureConfig+0x4c>)
90008fc4:	687a      	ldr	r2, [r7, #4]
90008fc6:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
90008fca:	6839      	ldr	r1, [r7, #0]
90008fcc:	4610      	mov	r0, r2
90008fce:	4798      	blx	r3
90008fd0:	4603      	mov	r3, r0
90008fd2:	2b00      	cmp	r3, #0
90008fd4:	da02      	bge.n	90008fdc <BSP_TS_GestureConfig+0x3c>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
90008fd6:	f06f 0304 	mvn.w	r3, #4
90008fda:	60fb      	str	r3, [r7, #12]
    }
  }

  return ret;
90008fdc:	68fb      	ldr	r3, [r7, #12]
}
90008fde:	4618      	mov	r0, r3
90008fe0:	3710      	adds	r7, #16
90008fe2:	46bd      	mov	sp, r7
90008fe4:	bd80      	pop	{r7, pc}
90008fe6:	bf00      	nop
90008fe8:	24001f34 	.word	0x24001f34
90008fec:	24001f40 	.word	0x24001f40

90008ff0 <BSP_TS_GetGestureId>:
  * @param  Instance   TS instance. Could be only 0.
  * @param  GestureId  Pointer to gesture ID
  * @retval BSP status
  */
int32_t BSP_TS_GetGestureId(uint32_t Instance, uint32_t *GestureId)
{
90008ff0:	b580      	push	{r7, lr}
90008ff2:	b084      	sub	sp, #16
90008ff4:	af00      	add	r7, sp, #0
90008ff6:	6078      	str	r0, [r7, #4]
90008ff8:	6039      	str	r1, [r7, #0]
  int32_t ret = BSP_ERROR_NONE;
90008ffa:	2300      	movs	r3, #0
90008ffc:	60fb      	str	r3, [r7, #12]
  uint8_t tmp = 0;
90008ffe:	2300      	movs	r3, #0
90009000:	72fb      	strb	r3, [r7, #11]

  if(Instance >=TS_INSTANCES_NBR)
90009002:	687b      	ldr	r3, [r7, #4]
90009004:	2b00      	cmp	r3, #0
90009006:	d003      	beq.n	90009010 <BSP_TS_GetGestureId+0x20>
  {
    ret = BSP_ERROR_WRONG_PARAM;
90009008:	f06f 0301 	mvn.w	r3, #1
9000900c:	60fb      	str	r3, [r7, #12]
9000900e:	e07c      	b.n	9000910a <BSP_TS_GetGestureId+0x11a>
  }/* Get gesture Id */
  else if(Ts_Drv->GetGesture(Ts_CompObj[Instance], &tmp)  < 0)
90009010:	4b40      	ldr	r3, [pc, #256]	; (90009114 <BSP_TS_GetGestureId+0x124>)
90009012:	681b      	ldr	r3, [r3, #0]
90009014:	699b      	ldr	r3, [r3, #24]
90009016:	4940      	ldr	r1, [pc, #256]	; (90009118 <BSP_TS_GetGestureId+0x128>)
90009018:	687a      	ldr	r2, [r7, #4]
9000901a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
9000901e:	f107 010b 	add.w	r1, r7, #11
90009022:	4610      	mov	r0, r2
90009024:	4798      	blx	r3
90009026:	4603      	mov	r3, r0
90009028:	2b00      	cmp	r3, #0
9000902a:	da03      	bge.n	90009034 <BSP_TS_GetGestureId+0x44>
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
9000902c:	f06f 0304 	mvn.w	r3, #4
90009030:	60fb      	str	r3, [r7, #12]
90009032:	e06a      	b.n	9000910a <BSP_TS_GetGestureId+0x11a>
  }
  else
  {
    /* Remap gesture Id to a TS_Gesture_Id_t value */
    switch(tmp)
90009034:	7afb      	ldrb	r3, [r7, #11]
90009036:	2b49      	cmp	r3, #73	; 0x49
90009038:	d05f      	beq.n	900090fa <BSP_TS_GetGestureId+0x10a>
9000903a:	2b49      	cmp	r3, #73	; 0x49
9000903c:	dc61      	bgt.n	90009102 <BSP_TS_GetGestureId+0x112>
9000903e:	2b1c      	cmp	r3, #28
90009040:	dc40      	bgt.n	900090c4 <BSP_TS_GetGestureId+0xd4>
90009042:	2b00      	cmp	r3, #0
90009044:	db5d      	blt.n	90009102 <BSP_TS_GetGestureId+0x112>
90009046:	2b1c      	cmp	r3, #28
90009048:	d85b      	bhi.n	90009102 <BSP_TS_GetGestureId+0x112>
9000904a:	a201      	add	r2, pc, #4	; (adr r2, 90009050 <BSP_TS_GetGestureId+0x60>)
9000904c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90009050:	900090cb 	.word	0x900090cb
90009054:	90009103 	.word	0x90009103
90009058:	90009103 	.word	0x90009103
9000905c:	90009103 	.word	0x90009103
90009060:	90009103 	.word	0x90009103
90009064:	90009103 	.word	0x90009103
90009068:	90009103 	.word	0x90009103
9000906c:	90009103 	.word	0x90009103
90009070:	90009103 	.word	0x90009103
90009074:	90009103 	.word	0x90009103
90009078:	90009103 	.word	0x90009103
9000907c:	90009103 	.word	0x90009103
90009080:	90009103 	.word	0x90009103
90009084:	90009103 	.word	0x90009103
90009088:	90009103 	.word	0x90009103
9000908c:	90009103 	.word	0x90009103
90009090:	900090d3 	.word	0x900090d3
90009094:	90009103 	.word	0x90009103
90009098:	90009103 	.word	0x90009103
9000909c:	90009103 	.word	0x90009103
900090a0:	900090db 	.word	0x900090db
900090a4:	90009103 	.word	0x90009103
900090a8:	90009103 	.word	0x90009103
900090ac:	90009103 	.word	0x90009103
900090b0:	900090e3 	.word	0x900090e3
900090b4:	90009103 	.word	0x90009103
900090b8:	90009103 	.word	0x90009103
900090bc:	90009103 	.word	0x90009103
900090c0:	900090eb 	.word	0x900090eb
900090c4:	2b48      	cmp	r3, #72	; 0x48
900090c6:	d014      	beq.n	900090f2 <BSP_TS_GetGestureId+0x102>
900090c8:	e01b      	b.n	90009102 <BSP_TS_GetGestureId+0x112>
    {
    case FT5336_GEST_ID_NO_GESTURE :
      *GestureId = GESTURE_ID_NO_GESTURE;
900090ca:	683b      	ldr	r3, [r7, #0]
900090cc:	2200      	movs	r2, #0
900090ce:	601a      	str	r2, [r3, #0]
      break;
900090d0:	e01b      	b.n	9000910a <BSP_TS_GetGestureId+0x11a>
    case FT5336_GEST_ID_MOVE_UP :
      *GestureId = GESTURE_ID_MOVE_UP;
900090d2:	683b      	ldr	r3, [r7, #0]
900090d4:	2201      	movs	r2, #1
900090d6:	601a      	str	r2, [r3, #0]
      break;
900090d8:	e017      	b.n	9000910a <BSP_TS_GetGestureId+0x11a>
    case FT5336_GEST_ID_MOVE_RIGHT :
      *GestureId = GESTURE_ID_MOVE_RIGHT;
900090da:	683b      	ldr	r3, [r7, #0]
900090dc:	2202      	movs	r2, #2
900090de:	601a      	str	r2, [r3, #0]
      break;
900090e0:	e013      	b.n	9000910a <BSP_TS_GetGestureId+0x11a>
    case FT5336_GEST_ID_MOVE_DOWN :
      *GestureId = GESTURE_ID_MOVE_DOWN;
900090e2:	683b      	ldr	r3, [r7, #0]
900090e4:	2203      	movs	r2, #3
900090e6:	601a      	str	r2, [r3, #0]
      break;
900090e8:	e00f      	b.n	9000910a <BSP_TS_GetGestureId+0x11a>
    case FT5336_GEST_ID_MOVE_LEFT :
      *GestureId = GESTURE_ID_MOVE_LEFT;
900090ea:	683b      	ldr	r3, [r7, #0]
900090ec:	2204      	movs	r2, #4
900090ee:	601a      	str	r2, [r3, #0]
      break;
900090f0:	e00b      	b.n	9000910a <BSP_TS_GetGestureId+0x11a>
    case FT5336_GEST_ID_ZOOM_IN :
      *GestureId = GESTURE_ID_ZOOM_IN;
900090f2:	683b      	ldr	r3, [r7, #0]
900090f4:	2205      	movs	r2, #5
900090f6:	601a      	str	r2, [r3, #0]
      break;
900090f8:	e007      	b.n	9000910a <BSP_TS_GetGestureId+0x11a>
    case FT5336_GEST_ID_ZOOM_OUT :
      *GestureId = GESTURE_ID_ZOOM_OUT;
900090fa:	683b      	ldr	r3, [r7, #0]
900090fc:	2206      	movs	r2, #6
900090fe:	601a      	str	r2, [r3, #0]
      break;
90009100:	e003      	b.n	9000910a <BSP_TS_GetGestureId+0x11a>
    default :
      *GestureId = GESTURE_ID_NO_GESTURE;
90009102:	683b      	ldr	r3, [r7, #0]
90009104:	2200      	movs	r2, #0
90009106:	601a      	str	r2, [r3, #0]
      break;
90009108:	bf00      	nop
    }
  }

  return ret;
9000910a:	68fb      	ldr	r3, [r7, #12]
}
9000910c:	4618      	mov	r0, r3
9000910e:	3710      	adds	r7, #16
90009110:	46bd      	mov	sp, r7
90009112:	bd80      	pop	{r7, pc}
90009114:	24001f34 	.word	0x24001f34
90009118:	24001f40 	.word	0x24001f40

9000911c <FT5336_Probe>:
  * @brief  Register Bus IOs if component ID is OK
  * @param  Instance TS instance. Could be only 0.
  * @retval BSP status
  */
static int32_t FT5336_Probe(uint32_t Instance)
{
9000911c:	b580      	push	{r7, lr}
9000911e:	b08a      	sub	sp, #40	; 0x28
90009120:	af00      	add	r7, sp, #0
90009122:	6078      	str	r0, [r7, #4]
  int32_t ret = BSP_ERROR_NONE;
90009124:	2300      	movs	r3, #0
90009126:	627b      	str	r3, [r7, #36]	; 0x24
  FT5336_IO_t              IOCtx;
  static FT5336_Object_t   FT5336Obj;
  uint32_t ft5336_id       = 0;
90009128:	2300      	movs	r3, #0
9000912a:	60bb      	str	r3, [r7, #8]

  /* Configure the touch screen driver */
  IOCtx.Address     = TS_I2C_ADDRESS;
9000912c:	2370      	movs	r3, #112	; 0x70
9000912e:	82bb      	strh	r3, [r7, #20]
  IOCtx.Init        = BSP_I2C4_Init;
90009130:	4b23      	ldr	r3, [pc, #140]	; (900091c0 <FT5336_Probe+0xa4>)
90009132:	60fb      	str	r3, [r7, #12]
  IOCtx.DeInit      = BSP_I2C4_DeInit;
90009134:	4b23      	ldr	r3, [pc, #140]	; (900091c4 <FT5336_Probe+0xa8>)
90009136:	613b      	str	r3, [r7, #16]
  IOCtx.ReadReg     = BSP_I2C4_ReadReg;
90009138:	4b23      	ldr	r3, [pc, #140]	; (900091c8 <FT5336_Probe+0xac>)
9000913a:	61fb      	str	r3, [r7, #28]
  IOCtx.WriteReg    = BSP_I2C4_WriteReg;
9000913c:	4b23      	ldr	r3, [pc, #140]	; (900091cc <FT5336_Probe+0xb0>)
9000913e:	61bb      	str	r3, [r7, #24]
  IOCtx.GetTick     = BSP_GetTick;
90009140:	4b23      	ldr	r3, [pc, #140]	; (900091d0 <FT5336_Probe+0xb4>)
90009142:	623b      	str	r3, [r7, #32]

  if(FT5336_RegisterBusIO (&FT5336Obj, &IOCtx) != FT5336_OK)
90009144:	f107 030c 	add.w	r3, r7, #12
90009148:	4619      	mov	r1, r3
9000914a:	4822      	ldr	r0, [pc, #136]	; (900091d4 <FT5336_Probe+0xb8>)
9000914c:	f7f9 fa14 	bl	90002578 <FT5336_RegisterBusIO>
90009150:	4603      	mov	r3, r0
90009152:	2b00      	cmp	r3, #0
90009154:	d003      	beq.n	9000915e <FT5336_Probe+0x42>
  {
    ret = BSP_ERROR_BUS_FAILURE;
90009156:	f06f 0307 	mvn.w	r3, #7
9000915a:	627b      	str	r3, [r7, #36]	; 0x24
9000915c:	e02a      	b.n	900091b4 <FT5336_Probe+0x98>
  }
  else if(FT5336_ReadID(&FT5336Obj, &ft5336_id) != FT5336_OK)
9000915e:	f107 0308 	add.w	r3, r7, #8
90009162:	4619      	mov	r1, r3
90009164:	481b      	ldr	r0, [pc, #108]	; (900091d4 <FT5336_Probe+0xb8>)
90009166:	f7f9 fb01 	bl	9000276c <FT5336_ReadID>
9000916a:	4603      	mov	r3, r0
9000916c:	2b00      	cmp	r3, #0
9000916e:	d003      	beq.n	90009178 <FT5336_Probe+0x5c>
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
90009170:	f06f 0304 	mvn.w	r3, #4
90009174:	627b      	str	r3, [r7, #36]	; 0x24
90009176:	e01d      	b.n	900091b4 <FT5336_Probe+0x98>
  }
  else if(ft5336_id != FT5336_ID)
90009178:	68bb      	ldr	r3, [r7, #8]
9000917a:	2b51      	cmp	r3, #81	; 0x51
9000917c:	d003      	beq.n	90009186 <FT5336_Probe+0x6a>
  {
    ret = BSP_ERROR_UNKNOWN_COMPONENT;
9000917e:	f06f 0306 	mvn.w	r3, #6
90009182:	627b      	str	r3, [r7, #36]	; 0x24
90009184:	e016      	b.n	900091b4 <FT5336_Probe+0x98>
  }
  else
  {
    Ts_CompObj[Instance] = &FT5336Obj;
90009186:	4a14      	ldr	r2, [pc, #80]	; (900091d8 <FT5336_Probe+0xbc>)
90009188:	687b      	ldr	r3, [r7, #4]
9000918a:	4912      	ldr	r1, [pc, #72]	; (900091d4 <FT5336_Probe+0xb8>)
9000918c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    Ts_Drv = (TS_Drv_t *) &FT5336_TS_Driver;
90009190:	4b12      	ldr	r3, [pc, #72]	; (900091dc <FT5336_Probe+0xc0>)
90009192:	4a13      	ldr	r2, [pc, #76]	; (900091e0 <FT5336_Probe+0xc4>)
90009194:	601a      	str	r2, [r3, #0]

    if(Ts_Drv->Init(Ts_CompObj[Instance]) != FT5336_OK)
90009196:	4b11      	ldr	r3, [pc, #68]	; (900091dc <FT5336_Probe+0xc0>)
90009198:	681b      	ldr	r3, [r3, #0]
9000919a:	681b      	ldr	r3, [r3, #0]
9000919c:	490e      	ldr	r1, [pc, #56]	; (900091d8 <FT5336_Probe+0xbc>)
9000919e:	687a      	ldr	r2, [r7, #4]
900091a0:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
900091a4:	4610      	mov	r0, r2
900091a6:	4798      	blx	r3
900091a8:	4603      	mov	r3, r0
900091aa:	2b00      	cmp	r3, #0
900091ac:	d002      	beq.n	900091b4 <FT5336_Probe+0x98>
    {
      ret = BSP_ERROR_COMPONENT_FAILURE;
900091ae:	f06f 0304 	mvn.w	r3, #4
900091b2:	627b      	str	r3, [r7, #36]	; 0x24
    }
  }

  return ret;
900091b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
900091b6:	4618      	mov	r0, r3
900091b8:	3728      	adds	r7, #40	; 0x28
900091ba:	46bd      	mov	sp, r7
900091bc:	bd80      	pop	{r7, pc}
900091be:	bf00      	nop
900091c0:	90006831 	.word	0x90006831
900091c4:	900068a5 	.word	0x900068a5
900091c8:	900069cd 	.word	0x900069cd
900091cc:	90006971 	.word	0x90006971
900091d0:	90006ae1 	.word	0x90006ae1
900091d4:	24001f84 	.word	0x24001f84
900091d8:	24001f40 	.word	0x24001f40
900091dc:	24001f34 	.word	0x24001f34
900091e0:	24000000 	.word	0x24000000

900091e4 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
900091e4:	b480      	push	{r7}
900091e6:	af00      	add	r7, sp, #0
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */
    
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
900091e8:	4b29      	ldr	r3, [pc, #164]	; (90009290 <SystemInit+0xac>)
900091ea:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
900091ee:	4a28      	ldr	r2, [pc, #160]	; (90009290 <SystemInit+0xac>)
900091f0:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
900091f4:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
900091f8:	4b26      	ldr	r3, [pc, #152]	; (90009294 <SystemInit+0xb0>)
900091fa:	681b      	ldr	r3, [r3, #0]
900091fc:	4a25      	ldr	r2, [pc, #148]	; (90009294 <SystemInit+0xb0>)
900091fe:	f043 0301 	orr.w	r3, r3, #1
90009202:	6013      	str	r3, [r2, #0]
  
  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
90009204:	4b23      	ldr	r3, [pc, #140]	; (90009294 <SystemInit+0xb0>)
90009206:	2200      	movs	r2, #0
90009208:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, CSSON , CSION,RC48ON, CSIKERON PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
9000920a:	4b22      	ldr	r3, [pc, #136]	; (90009294 <SystemInit+0xb0>)
9000920c:	681a      	ldr	r2, [r3, #0]
9000920e:	4921      	ldr	r1, [pc, #132]	; (90009294 <SystemInit+0xb0>)
90009210:	4b21      	ldr	r3, [pc, #132]	; (90009298 <SystemInit+0xb4>)
90009212:	4013      	ands	r3, r2
90009214:	600b      	str	r3, [r1, #0]

  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
90009216:	4b1f      	ldr	r3, [pc, #124]	; (90009294 <SystemInit+0xb0>)
90009218:	2200      	movs	r2, #0
9000921a:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
9000921c:	4b1d      	ldr	r3, [pc, #116]	; (90009294 <SystemInit+0xb0>)
9000921e:	2200      	movs	r2, #0
90009220:	61da      	str	r2, [r3, #28]
  
  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
90009222:	4b1c      	ldr	r3, [pc, #112]	; (90009294 <SystemInit+0xb0>)
90009224:	2200      	movs	r2, #0
90009226:	621a      	str	r2, [r3, #32]

  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x00000000;
90009228:	4b1a      	ldr	r3, [pc, #104]	; (90009294 <SystemInit+0xb0>)
9000922a:	2200      	movs	r2, #0
9000922c:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000000;
9000922e:	4b19      	ldr	r3, [pc, #100]	; (90009294 <SystemInit+0xb0>)
90009230:	2200      	movs	r2, #0
90009232:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x00000000;
90009234:	4b17      	ldr	r3, [pc, #92]	; (90009294 <SystemInit+0xb0>)
90009236:	2200      	movs	r2, #0
90009238:	631a      	str	r2, [r3, #48]	; 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
9000923a:	4b16      	ldr	r3, [pc, #88]	; (90009294 <SystemInit+0xb0>)
9000923c:	2200      	movs	r2, #0
9000923e:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x00000000;
90009240:	4b14      	ldr	r3, [pc, #80]	; (90009294 <SystemInit+0xb0>)
90009242:	2200      	movs	r2, #0
90009244:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */
  
  RCC->PLL2FRACR = 0x00000000;
90009246:	4b13      	ldr	r3, [pc, #76]	; (90009294 <SystemInit+0xb0>)
90009248:	2200      	movs	r2, #0
9000924a:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x00000000;
9000924c:	4b11      	ldr	r3, [pc, #68]	; (90009294 <SystemInit+0xb0>)
9000924e:	2200      	movs	r2, #0
90009250:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
90009252:	4b10      	ldr	r3, [pc, #64]	; (90009294 <SystemInit+0xb0>)
90009254:	2200      	movs	r2, #0
90009256:	645a      	str	r2, [r3, #68]	; 0x44
  
  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
90009258:	4b0e      	ldr	r3, [pc, #56]	; (90009294 <SystemInit+0xb0>)
9000925a:	681b      	ldr	r3, [r3, #0]
9000925c:	4a0d      	ldr	r2, [pc, #52]	; (90009294 <SystemInit+0xb0>)
9000925e:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
90009262:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
90009264:	4b0b      	ldr	r3, [pc, #44]	; (90009294 <SystemInit+0xb0>)
90009266:	2200      	movs	r2, #0
90009268:	661a      	str	r2, [r3, #96]	; 0x60

  /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
9000926a:	4b0c      	ldr	r3, [pc, #48]	; (9000929c <SystemInit+0xb8>)
9000926c:	681a      	ldr	r2, [r3, #0]
9000926e:	4b0c      	ldr	r3, [pc, #48]	; (900092a0 <SystemInit+0xbc>)
90009270:	4013      	ands	r3, r2
90009272:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90009276:	d202      	bcs.n	9000927e <SystemInit+0x9a>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x00000001U;
90009278:	4b0a      	ldr	r3, [pc, #40]	; (900092a4 <SystemInit+0xc0>)
9000927a:	2201      	movs	r2, #1
9000927c:	601a      	str	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET;       /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = APPLICATION_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation to APPLICATION_ADDRESS in preprocessor defines */
9000927e:	4b04      	ldr	r3, [pc, #16]	; (90009290 <SystemInit+0xac>)
90009280:	f04f 4210 	mov.w	r2, #2415919104	; 0x90000000
90009284:	609a      	str	r2, [r3, #8]
#endif  


}
90009286:	bf00      	nop
90009288:	46bd      	mov	sp, r7
9000928a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000928e:	4770      	bx	lr
90009290:	e000ed00 	.word	0xe000ed00
90009294:	58024400 	.word	0x58024400
90009298:	eaf6ed7f 	.word	0xeaf6ed7f
9000929c:	5c001000 	.word	0x5c001000
900092a0:	ffff0000 	.word	0xffff0000
900092a4:	51008108 	.word	0x51008108

900092a8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
900092a8:	b580      	push	{r7, lr}
900092aa:	b082      	sub	sp, #8
900092ac:	af00      	add	r7, sp, #0
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
900092ae:	2003      	movs	r0, #3
900092b0:	f000 f9c8 	bl	90009644 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
900092b4:	f007 fe14 	bl	90010ee0 <HAL_RCC_GetSysClockFreq>
900092b8:	4602      	mov	r2, r0
900092ba:	4b15      	ldr	r3, [pc, #84]	; (90009310 <HAL_Init+0x68>)
900092bc:	699b      	ldr	r3, [r3, #24]
900092be:	0a1b      	lsrs	r3, r3, #8
900092c0:	f003 030f 	and.w	r3, r3, #15
900092c4:	4913      	ldr	r1, [pc, #76]	; (90009314 <HAL_Init+0x6c>)
900092c6:	5ccb      	ldrb	r3, [r1, r3]
900092c8:	f003 031f 	and.w	r3, r3, #31
900092cc:	fa22 f303 	lsr.w	r3, r2, r3
900092d0:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
900092d2:	4b0f      	ldr	r3, [pc, #60]	; (90009310 <HAL_Init+0x68>)
900092d4:	699b      	ldr	r3, [r3, #24]
900092d6:	f003 030f 	and.w	r3, r3, #15
900092da:	4a0e      	ldr	r2, [pc, #56]	; (90009314 <HAL_Init+0x6c>)
900092dc:	5cd3      	ldrb	r3, [r2, r3]
900092de:	f003 031f 	and.w	r3, r3, #31
900092e2:	687a      	ldr	r2, [r7, #4]
900092e4:	fa22 f303 	lsr.w	r3, r2, r3
900092e8:	4a0b      	ldr	r2, [pc, #44]	; (90009318 <HAL_Init+0x70>)
900092ea:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
900092ec:	4a0b      	ldr	r2, [pc, #44]	; (9000931c <HAL_Init+0x74>)
900092ee:	687b      	ldr	r3, [r7, #4]
900092f0:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
900092f2:	200f      	movs	r0, #15
900092f4:	f000 f81c 	bl	90009330 <HAL_InitTick>
900092f8:	4603      	mov	r3, r0
900092fa:	2b00      	cmp	r3, #0
900092fc:	d001      	beq.n	90009302 <HAL_Init+0x5a>
  {
    return HAL_ERROR;
900092fe:	2301      	movs	r3, #1
90009300:	e002      	b.n	90009308 <HAL_Init+0x60>
  }

  /* Init the low level hardware */
  HAL_MspInit();
90009302:	f000 f80d 	bl	90009320 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
90009306:	2300      	movs	r3, #0
}
90009308:	4618      	mov	r0, r3
9000930a:	3708      	adds	r7, #8
9000930c:	46bd      	mov	sp, r7
9000930e:	bd80      	pop	{r7, pc}
90009310:	58024400 	.word	0x58024400
90009314:	9001e8a8 	.word	0x9001e8a8
90009318:	24000094 	.word	0x24000094
9000931c:	24000090 	.word	0x24000090

90009320 <HAL_MspInit>:
/**
  * @brief  Initializes the MSP.
  * @retval None
  */
__weak void HAL_MspInit(void)
{
90009320:	b480      	push	{r7}
90009322:	af00      	add	r7, sp, #0
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
90009324:	bf00      	nop
90009326:	46bd      	mov	sp, r7
90009328:	f85d 7b04 	ldr.w	r7, [sp], #4
9000932c:	4770      	bx	lr
	...

90009330 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
90009330:	b580      	push	{r7, lr}
90009332:	b082      	sub	sp, #8
90009334:	af00      	add	r7, sp, #0
90009336:	6078      	str	r0, [r7, #4]
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
90009338:	4b15      	ldr	r3, [pc, #84]	; (90009390 <HAL_InitTick+0x60>)
9000933a:	781b      	ldrb	r3, [r3, #0]
9000933c:	2b00      	cmp	r3, #0
9000933e:	d101      	bne.n	90009344 <HAL_InitTick+0x14>
  {
    return HAL_ERROR;
90009340:	2301      	movs	r3, #1
90009342:	e021      	b.n	90009388 <HAL_InitTick+0x58>
  }

    /* Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
90009344:	4b13      	ldr	r3, [pc, #76]	; (90009394 <HAL_InitTick+0x64>)
90009346:	681a      	ldr	r2, [r3, #0]
90009348:	4b11      	ldr	r3, [pc, #68]	; (90009390 <HAL_InitTick+0x60>)
9000934a:	781b      	ldrb	r3, [r3, #0]
9000934c:	4619      	mov	r1, r3
9000934e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
90009352:	fbb3 f3f1 	udiv	r3, r3, r1
90009356:	fbb2 f3f3 	udiv	r3, r2, r3
9000935a:	4618      	mov	r0, r3
9000935c:	f000 f9b3 	bl	900096c6 <HAL_SYSTICK_Config>
90009360:	4603      	mov	r3, r0
90009362:	2b00      	cmp	r3, #0
90009364:	d001      	beq.n	9000936a <HAL_InitTick+0x3a>
    {
      return HAL_ERROR;
90009366:	2301      	movs	r3, #1
90009368:	e00e      	b.n	90009388 <HAL_InitTick+0x58>
    }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
9000936a:	687b      	ldr	r3, [r7, #4]
9000936c:	2b0f      	cmp	r3, #15
9000936e:	d80a      	bhi.n	90009386 <HAL_InitTick+0x56>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
90009370:	2200      	movs	r2, #0
90009372:	6879      	ldr	r1, [r7, #4]
90009374:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90009378:	f000 f96f 	bl	9000965a <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
9000937c:	4a06      	ldr	r2, [pc, #24]	; (90009398 <HAL_InitTick+0x68>)
9000937e:	687b      	ldr	r3, [r7, #4]
90009380:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
90009382:	2300      	movs	r3, #0
90009384:	e000      	b.n	90009388 <HAL_InitTick+0x58>
    return HAL_ERROR;
90009386:	2301      	movs	r3, #1
}
90009388:	4618      	mov	r0, r3
9000938a:	3708      	adds	r7, #8
9000938c:	46bd      	mov	sp, r7
9000938e:	bd80      	pop	{r7, pc}
90009390:	2400009c 	.word	0x2400009c
90009394:	24000090 	.word	0x24000090
90009398:	24000098 	.word	0x24000098

9000939c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
9000939c:	b480      	push	{r7}
9000939e:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
900093a0:	4b06      	ldr	r3, [pc, #24]	; (900093bc <HAL_IncTick+0x20>)
900093a2:	781b      	ldrb	r3, [r3, #0]
900093a4:	461a      	mov	r2, r3
900093a6:	4b06      	ldr	r3, [pc, #24]	; (900093c0 <HAL_IncTick+0x24>)
900093a8:	681b      	ldr	r3, [r3, #0]
900093aa:	4413      	add	r3, r2
900093ac:	4a04      	ldr	r2, [pc, #16]	; (900093c0 <HAL_IncTick+0x24>)
900093ae:	6013      	str	r3, [r2, #0]
}
900093b0:	bf00      	nop
900093b2:	46bd      	mov	sp, r7
900093b4:	f85d 7b04 	ldr.w	r7, [sp], #4
900093b8:	4770      	bx	lr
900093ba:	bf00      	nop
900093bc:	2400009c 	.word	0x2400009c
900093c0:	24002e54 	.word	0x24002e54

900093c4 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
900093c4:	b480      	push	{r7}
900093c6:	af00      	add	r7, sp, #0
  return uwTick;
900093c8:	4b03      	ldr	r3, [pc, #12]	; (900093d8 <HAL_GetTick+0x14>)
900093ca:	681b      	ldr	r3, [r3, #0]
}
900093cc:	4618      	mov	r0, r3
900093ce:	46bd      	mov	sp, r7
900093d0:	f85d 7b04 	ldr.w	r7, [sp], #4
900093d4:	4770      	bx	lr
900093d6:	bf00      	nop
900093d8:	24002e54 	.word	0x24002e54

900093dc <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
900093dc:	b580      	push	{r7, lr}
900093de:	b084      	sub	sp, #16
900093e0:	af00      	add	r7, sp, #0
900093e2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
900093e4:	f7ff ffee 	bl	900093c4 <HAL_GetTick>
900093e8:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
900093ea:	687b      	ldr	r3, [r7, #4]
900093ec:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
900093ee:	68fb      	ldr	r3, [r7, #12]
900093f0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
900093f4:	d005      	beq.n	90009402 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
900093f6:	4b0a      	ldr	r3, [pc, #40]	; (90009420 <HAL_Delay+0x44>)
900093f8:	781b      	ldrb	r3, [r3, #0]
900093fa:	461a      	mov	r2, r3
900093fc:	68fb      	ldr	r3, [r7, #12]
900093fe:	4413      	add	r3, r2
90009400:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
90009402:	bf00      	nop
90009404:	f7ff ffde 	bl	900093c4 <HAL_GetTick>
90009408:	4602      	mov	r2, r0
9000940a:	68bb      	ldr	r3, [r7, #8]
9000940c:	1ad3      	subs	r3, r2, r3
9000940e:	68fa      	ldr	r2, [r7, #12]
90009410:	429a      	cmp	r2, r3
90009412:	d8f7      	bhi.n	90009404 <HAL_Delay+0x28>
  {
  }
}
90009414:	bf00      	nop
90009416:	bf00      	nop
90009418:	3710      	adds	r7, #16
9000941a:	46bd      	mov	sp, r7
9000941c:	bd80      	pop	{r7, pc}
9000941e:	bf00      	nop
90009420:	2400009c 	.word	0x2400009c

90009424 <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
90009424:	b480      	push	{r7}
90009426:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
90009428:	4b03      	ldr	r3, [pc, #12]	; (90009438 <HAL_GetREVID+0x14>)
9000942a:	681b      	ldr	r3, [r3, #0]
9000942c:	0c1b      	lsrs	r3, r3, #16
}
9000942e:	4618      	mov	r0, r3
90009430:	46bd      	mov	sp, r7
90009432:	f85d 7b04 	ldr.w	r7, [sp], #4
90009436:	4770      	bx	lr
90009438:	5c001000 	.word	0x5c001000

9000943c <HAL_EnableCompensationCell>:
  * @note   The I/O compensation cell can be used only when the device supply
  *         voltage ranges from 1.62 to 2.0 V and from 2.7 to 3.6 V.
  * @retval None
  */
void HAL_EnableCompensationCell(void)
{
9000943c:	b480      	push	{r7}
9000943e:	af00      	add	r7, sp, #0
  SET_BIT(SYSCFG->CCCSR, SYSCFG_CCCSR_EN) ;
90009440:	4b05      	ldr	r3, [pc, #20]	; (90009458 <HAL_EnableCompensationCell+0x1c>)
90009442:	6a1b      	ldr	r3, [r3, #32]
90009444:	4a04      	ldr	r2, [pc, #16]	; (90009458 <HAL_EnableCompensationCell+0x1c>)
90009446:	f043 0301 	orr.w	r3, r3, #1
9000944a:	6213      	str	r3, [r2, #32]
}
9000944c:	bf00      	nop
9000944e:	46bd      	mov	sp, r7
90009450:	f85d 7b04 	ldr.w	r7, [sp], #4
90009454:	4770      	bx	lr
90009456:	bf00      	nop
90009458:	58000400 	.word	0x58000400

9000945c <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
9000945c:	b480      	push	{r7}
9000945e:	b085      	sub	sp, #20
90009460:	af00      	add	r7, sp, #0
90009462:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
90009464:	687b      	ldr	r3, [r7, #4]
90009466:	f003 0307 	and.w	r3, r3, #7
9000946a:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
9000946c:	4b0b      	ldr	r3, [pc, #44]	; (9000949c <__NVIC_SetPriorityGrouping+0x40>)
9000946e:	68db      	ldr	r3, [r3, #12]
90009470:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
90009472:	68ba      	ldr	r2, [r7, #8]
90009474:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
90009478:	4013      	ands	r3, r2
9000947a:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
9000947c:	68fb      	ldr	r3, [r7, #12]
9000947e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
90009480:	68bb      	ldr	r3, [r7, #8]
90009482:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
90009484:	4b06      	ldr	r3, [pc, #24]	; (900094a0 <__NVIC_SetPriorityGrouping+0x44>)
90009486:	4313      	orrs	r3, r2
90009488:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
9000948a:	4a04      	ldr	r2, [pc, #16]	; (9000949c <__NVIC_SetPriorityGrouping+0x40>)
9000948c:	68bb      	ldr	r3, [r7, #8]
9000948e:	60d3      	str	r3, [r2, #12]
}
90009490:	bf00      	nop
90009492:	3714      	adds	r7, #20
90009494:	46bd      	mov	sp, r7
90009496:	f85d 7b04 	ldr.w	r7, [sp], #4
9000949a:	4770      	bx	lr
9000949c:	e000ed00 	.word	0xe000ed00
900094a0:	05fa0000 	.word	0x05fa0000

900094a4 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
900094a4:	b480      	push	{r7}
900094a6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
900094a8:	4b04      	ldr	r3, [pc, #16]	; (900094bc <__NVIC_GetPriorityGrouping+0x18>)
900094aa:	68db      	ldr	r3, [r3, #12]
900094ac:	0a1b      	lsrs	r3, r3, #8
900094ae:	f003 0307 	and.w	r3, r3, #7
}
900094b2:	4618      	mov	r0, r3
900094b4:	46bd      	mov	sp, r7
900094b6:	f85d 7b04 	ldr.w	r7, [sp], #4
900094ba:	4770      	bx	lr
900094bc:	e000ed00 	.word	0xe000ed00

900094c0 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
900094c0:	b480      	push	{r7}
900094c2:	b083      	sub	sp, #12
900094c4:	af00      	add	r7, sp, #0
900094c6:	4603      	mov	r3, r0
900094c8:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
900094ca:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
900094ce:	2b00      	cmp	r3, #0
900094d0:	db0b      	blt.n	900094ea <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
900094d2:	88fb      	ldrh	r3, [r7, #6]
900094d4:	f003 021f 	and.w	r2, r3, #31
900094d8:	4907      	ldr	r1, [pc, #28]	; (900094f8 <__NVIC_EnableIRQ+0x38>)
900094da:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
900094de:	095b      	lsrs	r3, r3, #5
900094e0:	2001      	movs	r0, #1
900094e2:	fa00 f202 	lsl.w	r2, r0, r2
900094e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
900094ea:	bf00      	nop
900094ec:	370c      	adds	r7, #12
900094ee:	46bd      	mov	sp, r7
900094f0:	f85d 7b04 	ldr.w	r7, [sp], #4
900094f4:	4770      	bx	lr
900094f6:	bf00      	nop
900094f8:	e000e100 	.word	0xe000e100

900094fc <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
900094fc:	b480      	push	{r7}
900094fe:	b083      	sub	sp, #12
90009500:	af00      	add	r7, sp, #0
90009502:	4603      	mov	r3, r0
90009504:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
90009506:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
9000950a:	2b00      	cmp	r3, #0
9000950c:	db12      	blt.n	90009534 <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
9000950e:	88fb      	ldrh	r3, [r7, #6]
90009510:	f003 021f 	and.w	r2, r3, #31
90009514:	490a      	ldr	r1, [pc, #40]	; (90009540 <__NVIC_DisableIRQ+0x44>)
90009516:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
9000951a:	095b      	lsrs	r3, r3, #5
9000951c:	2001      	movs	r0, #1
9000951e:	fa00 f202 	lsl.w	r2, r0, r2
90009522:	3320      	adds	r3, #32
90009524:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
90009528:	f3bf 8f4f 	dsb	sy
}
9000952c:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
9000952e:	f3bf 8f6f 	isb	sy
}
90009532:	bf00      	nop
    __DSB();
    __ISB();
  }
}
90009534:	bf00      	nop
90009536:	370c      	adds	r7, #12
90009538:	46bd      	mov	sp, r7
9000953a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000953e:	4770      	bx	lr
90009540:	e000e100 	.word	0xe000e100

90009544 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
90009544:	b480      	push	{r7}
90009546:	b083      	sub	sp, #12
90009548:	af00      	add	r7, sp, #0
9000954a:	4603      	mov	r3, r0
9000954c:	6039      	str	r1, [r7, #0]
9000954e:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
90009550:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
90009554:	2b00      	cmp	r3, #0
90009556:	db0a      	blt.n	9000956e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
90009558:	683b      	ldr	r3, [r7, #0]
9000955a:	b2da      	uxtb	r2, r3
9000955c:	490c      	ldr	r1, [pc, #48]	; (90009590 <__NVIC_SetPriority+0x4c>)
9000955e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
90009562:	0112      	lsls	r2, r2, #4
90009564:	b2d2      	uxtb	r2, r2
90009566:	440b      	add	r3, r1
90009568:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
9000956c:	e00a      	b.n	90009584 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
9000956e:	683b      	ldr	r3, [r7, #0]
90009570:	b2da      	uxtb	r2, r3
90009572:	4908      	ldr	r1, [pc, #32]	; (90009594 <__NVIC_SetPriority+0x50>)
90009574:	88fb      	ldrh	r3, [r7, #6]
90009576:	f003 030f 	and.w	r3, r3, #15
9000957a:	3b04      	subs	r3, #4
9000957c:	0112      	lsls	r2, r2, #4
9000957e:	b2d2      	uxtb	r2, r2
90009580:	440b      	add	r3, r1
90009582:	761a      	strb	r2, [r3, #24]
}
90009584:	bf00      	nop
90009586:	370c      	adds	r7, #12
90009588:	46bd      	mov	sp, r7
9000958a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000958e:	4770      	bx	lr
90009590:	e000e100 	.word	0xe000e100
90009594:	e000ed00 	.word	0xe000ed00

90009598 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
90009598:	b480      	push	{r7}
9000959a:	b089      	sub	sp, #36	; 0x24
9000959c:	af00      	add	r7, sp, #0
9000959e:	60f8      	str	r0, [r7, #12]
900095a0:	60b9      	str	r1, [r7, #8]
900095a2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
900095a4:	68fb      	ldr	r3, [r7, #12]
900095a6:	f003 0307 	and.w	r3, r3, #7
900095aa:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
900095ac:	69fb      	ldr	r3, [r7, #28]
900095ae:	f1c3 0307 	rsb	r3, r3, #7
900095b2:	2b04      	cmp	r3, #4
900095b4:	bf28      	it	cs
900095b6:	2304      	movcs	r3, #4
900095b8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
900095ba:	69fb      	ldr	r3, [r7, #28]
900095bc:	3304      	adds	r3, #4
900095be:	2b06      	cmp	r3, #6
900095c0:	d902      	bls.n	900095c8 <NVIC_EncodePriority+0x30>
900095c2:	69fb      	ldr	r3, [r7, #28]
900095c4:	3b03      	subs	r3, #3
900095c6:	e000      	b.n	900095ca <NVIC_EncodePriority+0x32>
900095c8:	2300      	movs	r3, #0
900095ca:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
900095cc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
900095d0:	69bb      	ldr	r3, [r7, #24]
900095d2:	fa02 f303 	lsl.w	r3, r2, r3
900095d6:	43da      	mvns	r2, r3
900095d8:	68bb      	ldr	r3, [r7, #8]
900095da:	401a      	ands	r2, r3
900095dc:	697b      	ldr	r3, [r7, #20]
900095de:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
900095e0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
900095e4:	697b      	ldr	r3, [r7, #20]
900095e6:	fa01 f303 	lsl.w	r3, r1, r3
900095ea:	43d9      	mvns	r1, r3
900095ec:	687b      	ldr	r3, [r7, #4]
900095ee:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
900095f0:	4313      	orrs	r3, r2
         );
}
900095f2:	4618      	mov	r0, r3
900095f4:	3724      	adds	r7, #36	; 0x24
900095f6:	46bd      	mov	sp, r7
900095f8:	f85d 7b04 	ldr.w	r7, [sp], #4
900095fc:	4770      	bx	lr
	...

90009600 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
90009600:	b580      	push	{r7, lr}
90009602:	b082      	sub	sp, #8
90009604:	af00      	add	r7, sp, #0
90009606:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
90009608:	687b      	ldr	r3, [r7, #4]
9000960a:	3b01      	subs	r3, #1
9000960c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
90009610:	d301      	bcc.n	90009616 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
90009612:	2301      	movs	r3, #1
90009614:	e00f      	b.n	90009636 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
90009616:	4a0a      	ldr	r2, [pc, #40]	; (90009640 <SysTick_Config+0x40>)
90009618:	687b      	ldr	r3, [r7, #4]
9000961a:	3b01      	subs	r3, #1
9000961c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
9000961e:	210f      	movs	r1, #15
90009620:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90009624:	f7ff ff8e 	bl	90009544 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
90009628:	4b05      	ldr	r3, [pc, #20]	; (90009640 <SysTick_Config+0x40>)
9000962a:	2200      	movs	r2, #0
9000962c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
9000962e:	4b04      	ldr	r3, [pc, #16]	; (90009640 <SysTick_Config+0x40>)
90009630:	2207      	movs	r2, #7
90009632:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
90009634:	2300      	movs	r3, #0
}
90009636:	4618      	mov	r0, r3
90009638:	3708      	adds	r7, #8
9000963a:	46bd      	mov	sp, r7
9000963c:	bd80      	pop	{r7, pc}
9000963e:	bf00      	nop
90009640:	e000e010 	.word	0xe000e010

90009644 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
90009644:	b580      	push	{r7, lr}
90009646:	b082      	sub	sp, #8
90009648:	af00      	add	r7, sp, #0
9000964a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
9000964c:	6878      	ldr	r0, [r7, #4]
9000964e:	f7ff ff05 	bl	9000945c <__NVIC_SetPriorityGrouping>
}
90009652:	bf00      	nop
90009654:	3708      	adds	r7, #8
90009656:	46bd      	mov	sp, r7
90009658:	bd80      	pop	{r7, pc}

9000965a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
9000965a:	b580      	push	{r7, lr}
9000965c:	b086      	sub	sp, #24
9000965e:	af00      	add	r7, sp, #0
90009660:	4603      	mov	r3, r0
90009662:	60b9      	str	r1, [r7, #8]
90009664:	607a      	str	r2, [r7, #4]
90009666:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
90009668:	f7ff ff1c 	bl	900094a4 <__NVIC_GetPriorityGrouping>
9000966c:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
9000966e:	687a      	ldr	r2, [r7, #4]
90009670:	68b9      	ldr	r1, [r7, #8]
90009672:	6978      	ldr	r0, [r7, #20]
90009674:	f7ff ff90 	bl	90009598 <NVIC_EncodePriority>
90009678:	4602      	mov	r2, r0
9000967a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
9000967e:	4611      	mov	r1, r2
90009680:	4618      	mov	r0, r3
90009682:	f7ff ff5f 	bl	90009544 <__NVIC_SetPriority>
}
90009686:	bf00      	nop
90009688:	3718      	adds	r7, #24
9000968a:	46bd      	mov	sp, r7
9000968c:	bd80      	pop	{r7, pc}

9000968e <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
9000968e:	b580      	push	{r7, lr}
90009690:	b082      	sub	sp, #8
90009692:	af00      	add	r7, sp, #0
90009694:	4603      	mov	r3, r0
90009696:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
90009698:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
9000969c:	4618      	mov	r0, r3
9000969e:	f7ff ff0f 	bl	900094c0 <__NVIC_EnableIRQ>
}
900096a2:	bf00      	nop
900096a4:	3708      	adds	r7, #8
900096a6:	46bd      	mov	sp, r7
900096a8:	bd80      	pop	{r7, pc}

900096aa <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
900096aa:	b580      	push	{r7, lr}
900096ac:	b082      	sub	sp, #8
900096ae:	af00      	add	r7, sp, #0
900096b0:	4603      	mov	r3, r0
900096b2:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
900096b4:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
900096b8:	4618      	mov	r0, r3
900096ba:	f7ff ff1f 	bl	900094fc <__NVIC_DisableIRQ>
}
900096be:	bf00      	nop
900096c0:	3708      	adds	r7, #8
900096c2:	46bd      	mov	sp, r7
900096c4:	bd80      	pop	{r7, pc}

900096c6 <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
900096c6:	b580      	push	{r7, lr}
900096c8:	b082      	sub	sp, #8
900096ca:	af00      	add	r7, sp, #0
900096cc:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
900096ce:	6878      	ldr	r0, [r7, #4]
900096d0:	f7ff ff96 	bl	90009600 <SysTick_Config>
900096d4:	4603      	mov	r3, r0
}
900096d6:	4618      	mov	r0, r3
900096d8:	3708      	adds	r7, #8
900096da:	46bd      	mov	sp, r7
900096dc:	bd80      	pop	{r7, pc}
	...

900096e0 <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
void HAL_MPU_Disable(void)
{
900096e0:	b480      	push	{r7}
900096e2:	af00      	add	r7, sp, #0
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
900096e4:	f3bf 8f5f 	dmb	sy
}
900096e8:	bf00      	nop
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
900096ea:	4b07      	ldr	r3, [pc, #28]	; (90009708 <HAL_MPU_Disable+0x28>)
900096ec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
900096ee:	4a06      	ldr	r2, [pc, #24]	; (90009708 <HAL_MPU_Disable+0x28>)
900096f0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
900096f4:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
900096f6:	4b05      	ldr	r3, [pc, #20]	; (9000970c <HAL_MPU_Disable+0x2c>)
900096f8:	2200      	movs	r2, #0
900096fa:	605a      	str	r2, [r3, #4]
}
900096fc:	bf00      	nop
900096fe:	46bd      	mov	sp, r7
90009700:	f85d 7b04 	ldr.w	r7, [sp], #4
90009704:	4770      	bx	lr
90009706:	bf00      	nop
90009708:	e000ed00 	.word	0xe000ed00
9000970c:	e000ed90 	.word	0xe000ed90

90009710 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
90009710:	b480      	push	{r7}
90009712:	b083      	sub	sp, #12
90009714:	af00      	add	r7, sp, #0
90009716:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
90009718:	4a0b      	ldr	r2, [pc, #44]	; (90009748 <HAL_MPU_Enable+0x38>)
9000971a:	687b      	ldr	r3, [r7, #4]
9000971c:	f043 0301 	orr.w	r3, r3, #1
90009720:	6053      	str	r3, [r2, #4]

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
90009722:	4b0a      	ldr	r3, [pc, #40]	; (9000974c <HAL_MPU_Enable+0x3c>)
90009724:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90009726:	4a09      	ldr	r2, [pc, #36]	; (9000974c <HAL_MPU_Enable+0x3c>)
90009728:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
9000972c:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
9000972e:	f3bf 8f4f 	dsb	sy
}
90009732:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
90009734:	f3bf 8f6f 	isb	sy
}
90009738:	bf00      	nop

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
9000973a:	bf00      	nop
9000973c:	370c      	adds	r7, #12
9000973e:	46bd      	mov	sp, r7
90009740:	f85d 7b04 	ldr.w	r7, [sp], #4
90009744:	4770      	bx	lr
90009746:	bf00      	nop
90009748:	e000ed90 	.word	0xe000ed90
9000974c:	e000ed00 	.word	0xe000ed00

90009750 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
90009750:	b480      	push	{r7}
90009752:	b083      	sub	sp, #12
90009754:	af00      	add	r7, sp, #0
90009756:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
90009758:	687b      	ldr	r3, [r7, #4]
9000975a:	785a      	ldrb	r2, [r3, #1]
9000975c:	4b1d      	ldr	r3, [pc, #116]	; (900097d4 <HAL_MPU_ConfigRegion+0x84>)
9000975e:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
90009760:	687b      	ldr	r3, [r7, #4]
90009762:	781b      	ldrb	r3, [r3, #0]
90009764:	2b00      	cmp	r3, #0
90009766:	d029      	beq.n	900097bc <HAL_MPU_ConfigRegion+0x6c>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
90009768:	4a1a      	ldr	r2, [pc, #104]	; (900097d4 <HAL_MPU_ConfigRegion+0x84>)
9000976a:	687b      	ldr	r3, [r7, #4]
9000976c:	685b      	ldr	r3, [r3, #4]
9000976e:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
90009770:	687b      	ldr	r3, [r7, #4]
90009772:	7b1b      	ldrb	r3, [r3, #12]
90009774:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
90009776:	687b      	ldr	r3, [r7, #4]
90009778:	7adb      	ldrb	r3, [r3, #11]
9000977a:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
9000977c:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
9000977e:	687b      	ldr	r3, [r7, #4]
90009780:	7a9b      	ldrb	r3, [r3, #10]
90009782:	04db      	lsls	r3, r3, #19
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
90009784:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
90009786:	687b      	ldr	r3, [r7, #4]
90009788:	7b5b      	ldrb	r3, [r3, #13]
9000978a:	049b      	lsls	r3, r3, #18
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
9000978c:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
9000978e:	687b      	ldr	r3, [r7, #4]
90009790:	7b9b      	ldrb	r3, [r3, #14]
90009792:	045b      	lsls	r3, r3, #17
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
90009794:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
90009796:	687b      	ldr	r3, [r7, #4]
90009798:	7bdb      	ldrb	r3, [r3, #15]
9000979a:	041b      	lsls	r3, r3, #16
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
9000979c:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
9000979e:	687b      	ldr	r3, [r7, #4]
900097a0:	7a5b      	ldrb	r3, [r3, #9]
900097a2:	021b      	lsls	r3, r3, #8
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
900097a4:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
900097a6:	687b      	ldr	r3, [r7, #4]
900097a8:	7a1b      	ldrb	r3, [r3, #8]
900097aa:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
900097ac:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
900097ae:	687a      	ldr	r2, [r7, #4]
900097b0:	7812      	ldrb	r2, [r2, #0]
900097b2:	4611      	mov	r1, r2
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
900097b4:	4a07      	ldr	r2, [pc, #28]	; (900097d4 <HAL_MPU_ConfigRegion+0x84>)
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
900097b6:	430b      	orrs	r3, r1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
900097b8:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
900097ba:	e005      	b.n	900097c8 <HAL_MPU_ConfigRegion+0x78>
    MPU->RBAR = 0x00;
900097bc:	4b05      	ldr	r3, [pc, #20]	; (900097d4 <HAL_MPU_ConfigRegion+0x84>)
900097be:	2200      	movs	r2, #0
900097c0:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
900097c2:	4b04      	ldr	r3, [pc, #16]	; (900097d4 <HAL_MPU_ConfigRegion+0x84>)
900097c4:	2200      	movs	r2, #0
900097c6:	611a      	str	r2, [r3, #16]
}
900097c8:	bf00      	nop
900097ca:	370c      	adds	r7, #12
900097cc:	46bd      	mov	sp, r7
900097ce:	f85d 7b04 	ldr.w	r7, [sp], #4
900097d2:	4770      	bx	lr
900097d4:	e000ed90 	.word	0xe000ed90

900097d8 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
900097d8:	b580      	push	{r7, lr}
900097da:	b086      	sub	sp, #24
900097dc:	af00      	add	r7, sp, #0
900097de:	6078      	str	r0, [r7, #4]
  uint32_t registerValue;
  uint32_t tickstart = HAL_GetTick();
900097e0:	f7ff fdf0 	bl	900093c4 <HAL_GetTick>
900097e4:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
900097e6:	687b      	ldr	r3, [r7, #4]
900097e8:	2b00      	cmp	r3, #0
900097ea:	d101      	bne.n	900097f0 <HAL_DMA_Init+0x18>
  {
    return HAL_ERROR;
900097ec:	2301      	movs	r3, #1
900097ee:	e316      	b.n	90009e1e <HAL_DMA_Init+0x646>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
900097f0:	687b      	ldr	r3, [r7, #4]
900097f2:	681b      	ldr	r3, [r3, #0]
900097f4:	4a66      	ldr	r2, [pc, #408]	; (90009990 <HAL_DMA_Init+0x1b8>)
900097f6:	4293      	cmp	r3, r2
900097f8:	d04a      	beq.n	90009890 <HAL_DMA_Init+0xb8>
900097fa:	687b      	ldr	r3, [r7, #4]
900097fc:	681b      	ldr	r3, [r3, #0]
900097fe:	4a65      	ldr	r2, [pc, #404]	; (90009994 <HAL_DMA_Init+0x1bc>)
90009800:	4293      	cmp	r3, r2
90009802:	d045      	beq.n	90009890 <HAL_DMA_Init+0xb8>
90009804:	687b      	ldr	r3, [r7, #4]
90009806:	681b      	ldr	r3, [r3, #0]
90009808:	4a63      	ldr	r2, [pc, #396]	; (90009998 <HAL_DMA_Init+0x1c0>)
9000980a:	4293      	cmp	r3, r2
9000980c:	d040      	beq.n	90009890 <HAL_DMA_Init+0xb8>
9000980e:	687b      	ldr	r3, [r7, #4]
90009810:	681b      	ldr	r3, [r3, #0]
90009812:	4a62      	ldr	r2, [pc, #392]	; (9000999c <HAL_DMA_Init+0x1c4>)
90009814:	4293      	cmp	r3, r2
90009816:	d03b      	beq.n	90009890 <HAL_DMA_Init+0xb8>
90009818:	687b      	ldr	r3, [r7, #4]
9000981a:	681b      	ldr	r3, [r3, #0]
9000981c:	4a60      	ldr	r2, [pc, #384]	; (900099a0 <HAL_DMA_Init+0x1c8>)
9000981e:	4293      	cmp	r3, r2
90009820:	d036      	beq.n	90009890 <HAL_DMA_Init+0xb8>
90009822:	687b      	ldr	r3, [r7, #4]
90009824:	681b      	ldr	r3, [r3, #0]
90009826:	4a5f      	ldr	r2, [pc, #380]	; (900099a4 <HAL_DMA_Init+0x1cc>)
90009828:	4293      	cmp	r3, r2
9000982a:	d031      	beq.n	90009890 <HAL_DMA_Init+0xb8>
9000982c:	687b      	ldr	r3, [r7, #4]
9000982e:	681b      	ldr	r3, [r3, #0]
90009830:	4a5d      	ldr	r2, [pc, #372]	; (900099a8 <HAL_DMA_Init+0x1d0>)
90009832:	4293      	cmp	r3, r2
90009834:	d02c      	beq.n	90009890 <HAL_DMA_Init+0xb8>
90009836:	687b      	ldr	r3, [r7, #4]
90009838:	681b      	ldr	r3, [r3, #0]
9000983a:	4a5c      	ldr	r2, [pc, #368]	; (900099ac <HAL_DMA_Init+0x1d4>)
9000983c:	4293      	cmp	r3, r2
9000983e:	d027      	beq.n	90009890 <HAL_DMA_Init+0xb8>
90009840:	687b      	ldr	r3, [r7, #4]
90009842:	681b      	ldr	r3, [r3, #0]
90009844:	4a5a      	ldr	r2, [pc, #360]	; (900099b0 <HAL_DMA_Init+0x1d8>)
90009846:	4293      	cmp	r3, r2
90009848:	d022      	beq.n	90009890 <HAL_DMA_Init+0xb8>
9000984a:	687b      	ldr	r3, [r7, #4]
9000984c:	681b      	ldr	r3, [r3, #0]
9000984e:	4a59      	ldr	r2, [pc, #356]	; (900099b4 <HAL_DMA_Init+0x1dc>)
90009850:	4293      	cmp	r3, r2
90009852:	d01d      	beq.n	90009890 <HAL_DMA_Init+0xb8>
90009854:	687b      	ldr	r3, [r7, #4]
90009856:	681b      	ldr	r3, [r3, #0]
90009858:	4a57      	ldr	r2, [pc, #348]	; (900099b8 <HAL_DMA_Init+0x1e0>)
9000985a:	4293      	cmp	r3, r2
9000985c:	d018      	beq.n	90009890 <HAL_DMA_Init+0xb8>
9000985e:	687b      	ldr	r3, [r7, #4]
90009860:	681b      	ldr	r3, [r3, #0]
90009862:	4a56      	ldr	r2, [pc, #344]	; (900099bc <HAL_DMA_Init+0x1e4>)
90009864:	4293      	cmp	r3, r2
90009866:	d013      	beq.n	90009890 <HAL_DMA_Init+0xb8>
90009868:	687b      	ldr	r3, [r7, #4]
9000986a:	681b      	ldr	r3, [r3, #0]
9000986c:	4a54      	ldr	r2, [pc, #336]	; (900099c0 <HAL_DMA_Init+0x1e8>)
9000986e:	4293      	cmp	r3, r2
90009870:	d00e      	beq.n	90009890 <HAL_DMA_Init+0xb8>
90009872:	687b      	ldr	r3, [r7, #4]
90009874:	681b      	ldr	r3, [r3, #0]
90009876:	4a53      	ldr	r2, [pc, #332]	; (900099c4 <HAL_DMA_Init+0x1ec>)
90009878:	4293      	cmp	r3, r2
9000987a:	d009      	beq.n	90009890 <HAL_DMA_Init+0xb8>
9000987c:	687b      	ldr	r3, [r7, #4]
9000987e:	681b      	ldr	r3, [r3, #0]
90009880:	4a51      	ldr	r2, [pc, #324]	; (900099c8 <HAL_DMA_Init+0x1f0>)
90009882:	4293      	cmp	r3, r2
90009884:	d004      	beq.n	90009890 <HAL_DMA_Init+0xb8>
90009886:	687b      	ldr	r3, [r7, #4]
90009888:	681b      	ldr	r3, [r3, #0]
9000988a:	4a50      	ldr	r2, [pc, #320]	; (900099cc <HAL_DMA_Init+0x1f4>)
9000988c:	4293      	cmp	r3, r2
9000988e:	d101      	bne.n	90009894 <HAL_DMA_Init+0xbc>
90009890:	2301      	movs	r3, #1
90009892:	e000      	b.n	90009896 <HAL_DMA_Init+0xbe>
90009894:	2300      	movs	r3, #0
90009896:	2b00      	cmp	r3, #0
90009898:	f000 813b 	beq.w	90009b12 <HAL_DMA_Init+0x33a>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
9000989c:	687b      	ldr	r3, [r7, #4]
9000989e:	2202      	movs	r2, #2
900098a0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
900098a4:	687b      	ldr	r3, [r7, #4]
900098a6:	2200      	movs	r2, #0
900098a8:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
900098ac:	687b      	ldr	r3, [r7, #4]
900098ae:	681b      	ldr	r3, [r3, #0]
900098b0:	4a37      	ldr	r2, [pc, #220]	; (90009990 <HAL_DMA_Init+0x1b8>)
900098b2:	4293      	cmp	r3, r2
900098b4:	d04a      	beq.n	9000994c <HAL_DMA_Init+0x174>
900098b6:	687b      	ldr	r3, [r7, #4]
900098b8:	681b      	ldr	r3, [r3, #0]
900098ba:	4a36      	ldr	r2, [pc, #216]	; (90009994 <HAL_DMA_Init+0x1bc>)
900098bc:	4293      	cmp	r3, r2
900098be:	d045      	beq.n	9000994c <HAL_DMA_Init+0x174>
900098c0:	687b      	ldr	r3, [r7, #4]
900098c2:	681b      	ldr	r3, [r3, #0]
900098c4:	4a34      	ldr	r2, [pc, #208]	; (90009998 <HAL_DMA_Init+0x1c0>)
900098c6:	4293      	cmp	r3, r2
900098c8:	d040      	beq.n	9000994c <HAL_DMA_Init+0x174>
900098ca:	687b      	ldr	r3, [r7, #4]
900098cc:	681b      	ldr	r3, [r3, #0]
900098ce:	4a33      	ldr	r2, [pc, #204]	; (9000999c <HAL_DMA_Init+0x1c4>)
900098d0:	4293      	cmp	r3, r2
900098d2:	d03b      	beq.n	9000994c <HAL_DMA_Init+0x174>
900098d4:	687b      	ldr	r3, [r7, #4]
900098d6:	681b      	ldr	r3, [r3, #0]
900098d8:	4a31      	ldr	r2, [pc, #196]	; (900099a0 <HAL_DMA_Init+0x1c8>)
900098da:	4293      	cmp	r3, r2
900098dc:	d036      	beq.n	9000994c <HAL_DMA_Init+0x174>
900098de:	687b      	ldr	r3, [r7, #4]
900098e0:	681b      	ldr	r3, [r3, #0]
900098e2:	4a30      	ldr	r2, [pc, #192]	; (900099a4 <HAL_DMA_Init+0x1cc>)
900098e4:	4293      	cmp	r3, r2
900098e6:	d031      	beq.n	9000994c <HAL_DMA_Init+0x174>
900098e8:	687b      	ldr	r3, [r7, #4]
900098ea:	681b      	ldr	r3, [r3, #0]
900098ec:	4a2e      	ldr	r2, [pc, #184]	; (900099a8 <HAL_DMA_Init+0x1d0>)
900098ee:	4293      	cmp	r3, r2
900098f0:	d02c      	beq.n	9000994c <HAL_DMA_Init+0x174>
900098f2:	687b      	ldr	r3, [r7, #4]
900098f4:	681b      	ldr	r3, [r3, #0]
900098f6:	4a2d      	ldr	r2, [pc, #180]	; (900099ac <HAL_DMA_Init+0x1d4>)
900098f8:	4293      	cmp	r3, r2
900098fa:	d027      	beq.n	9000994c <HAL_DMA_Init+0x174>
900098fc:	687b      	ldr	r3, [r7, #4]
900098fe:	681b      	ldr	r3, [r3, #0]
90009900:	4a2b      	ldr	r2, [pc, #172]	; (900099b0 <HAL_DMA_Init+0x1d8>)
90009902:	4293      	cmp	r3, r2
90009904:	d022      	beq.n	9000994c <HAL_DMA_Init+0x174>
90009906:	687b      	ldr	r3, [r7, #4]
90009908:	681b      	ldr	r3, [r3, #0]
9000990a:	4a2a      	ldr	r2, [pc, #168]	; (900099b4 <HAL_DMA_Init+0x1dc>)
9000990c:	4293      	cmp	r3, r2
9000990e:	d01d      	beq.n	9000994c <HAL_DMA_Init+0x174>
90009910:	687b      	ldr	r3, [r7, #4]
90009912:	681b      	ldr	r3, [r3, #0]
90009914:	4a28      	ldr	r2, [pc, #160]	; (900099b8 <HAL_DMA_Init+0x1e0>)
90009916:	4293      	cmp	r3, r2
90009918:	d018      	beq.n	9000994c <HAL_DMA_Init+0x174>
9000991a:	687b      	ldr	r3, [r7, #4]
9000991c:	681b      	ldr	r3, [r3, #0]
9000991e:	4a27      	ldr	r2, [pc, #156]	; (900099bc <HAL_DMA_Init+0x1e4>)
90009920:	4293      	cmp	r3, r2
90009922:	d013      	beq.n	9000994c <HAL_DMA_Init+0x174>
90009924:	687b      	ldr	r3, [r7, #4]
90009926:	681b      	ldr	r3, [r3, #0]
90009928:	4a25      	ldr	r2, [pc, #148]	; (900099c0 <HAL_DMA_Init+0x1e8>)
9000992a:	4293      	cmp	r3, r2
9000992c:	d00e      	beq.n	9000994c <HAL_DMA_Init+0x174>
9000992e:	687b      	ldr	r3, [r7, #4]
90009930:	681b      	ldr	r3, [r3, #0]
90009932:	4a24      	ldr	r2, [pc, #144]	; (900099c4 <HAL_DMA_Init+0x1ec>)
90009934:	4293      	cmp	r3, r2
90009936:	d009      	beq.n	9000994c <HAL_DMA_Init+0x174>
90009938:	687b      	ldr	r3, [r7, #4]
9000993a:	681b      	ldr	r3, [r3, #0]
9000993c:	4a22      	ldr	r2, [pc, #136]	; (900099c8 <HAL_DMA_Init+0x1f0>)
9000993e:	4293      	cmp	r3, r2
90009940:	d004      	beq.n	9000994c <HAL_DMA_Init+0x174>
90009942:	687b      	ldr	r3, [r7, #4]
90009944:	681b      	ldr	r3, [r3, #0]
90009946:	4a21      	ldr	r2, [pc, #132]	; (900099cc <HAL_DMA_Init+0x1f4>)
90009948:	4293      	cmp	r3, r2
9000994a:	d108      	bne.n	9000995e <HAL_DMA_Init+0x186>
9000994c:	687b      	ldr	r3, [r7, #4]
9000994e:	681b      	ldr	r3, [r3, #0]
90009950:	681a      	ldr	r2, [r3, #0]
90009952:	687b      	ldr	r3, [r7, #4]
90009954:	681b      	ldr	r3, [r3, #0]
90009956:	f022 0201 	bic.w	r2, r2, #1
9000995a:	601a      	str	r2, [r3, #0]
9000995c:	e007      	b.n	9000996e <HAL_DMA_Init+0x196>
9000995e:	687b      	ldr	r3, [r7, #4]
90009960:	681b      	ldr	r3, [r3, #0]
90009962:	681a      	ldr	r2, [r3, #0]
90009964:	687b      	ldr	r3, [r7, #4]
90009966:	681b      	ldr	r3, [r3, #0]
90009968:	f022 0201 	bic.w	r2, r2, #1
9000996c:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
9000996e:	e02f      	b.n	900099d0 <HAL_DMA_Init+0x1f8>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
90009970:	f7ff fd28 	bl	900093c4 <HAL_GetTick>
90009974:	4602      	mov	r2, r0
90009976:	693b      	ldr	r3, [r7, #16]
90009978:	1ad3      	subs	r3, r2, r3
9000997a:	2b05      	cmp	r3, #5
9000997c:	d928      	bls.n	900099d0 <HAL_DMA_Init+0x1f8>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
9000997e:	687b      	ldr	r3, [r7, #4]
90009980:	2220      	movs	r2, #32
90009982:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
90009984:	687b      	ldr	r3, [r7, #4]
90009986:	2203      	movs	r2, #3
90009988:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        return HAL_ERROR;
9000998c:	2301      	movs	r3, #1
9000998e:	e246      	b.n	90009e1e <HAL_DMA_Init+0x646>
90009990:	40020010 	.word	0x40020010
90009994:	40020028 	.word	0x40020028
90009998:	40020040 	.word	0x40020040
9000999c:	40020058 	.word	0x40020058
900099a0:	40020070 	.word	0x40020070
900099a4:	40020088 	.word	0x40020088
900099a8:	400200a0 	.word	0x400200a0
900099ac:	400200b8 	.word	0x400200b8
900099b0:	40020410 	.word	0x40020410
900099b4:	40020428 	.word	0x40020428
900099b8:	40020440 	.word	0x40020440
900099bc:	40020458 	.word	0x40020458
900099c0:	40020470 	.word	0x40020470
900099c4:	40020488 	.word	0x40020488
900099c8:	400204a0 	.word	0x400204a0
900099cc:	400204b8 	.word	0x400204b8
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
900099d0:	687b      	ldr	r3, [r7, #4]
900099d2:	681b      	ldr	r3, [r3, #0]
900099d4:	681b      	ldr	r3, [r3, #0]
900099d6:	f003 0301 	and.w	r3, r3, #1
900099da:	2b00      	cmp	r3, #0
900099dc:	d1c8      	bne.n	90009970 <HAL_DMA_Init+0x198>
      }
    }

    /* Get the CR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
900099de:	687b      	ldr	r3, [r7, #4]
900099e0:	681b      	ldr	r3, [r3, #0]
900099e2:	681b      	ldr	r3, [r3, #0]
900099e4:	617b      	str	r3, [r7, #20]

    /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
900099e6:	697a      	ldr	r2, [r7, #20]
900099e8:	4b83      	ldr	r3, [pc, #524]	; (90009bf8 <HAL_DMA_Init+0x420>)
900099ea:	4013      	ands	r3, r2
900099ec:	617b      	str	r3, [r7, #20]
                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

    /* Prepare the DMA Stream configuration */
    registerValue |=  hdma->Init.Direction           |
900099ee:	687b      	ldr	r3, [r7, #4]
900099f0:	689a      	ldr	r2, [r3, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
900099f2:	687b      	ldr	r3, [r7, #4]
900099f4:	68db      	ldr	r3, [r3, #12]
    registerValue |=  hdma->Init.Direction           |
900099f6:	431a      	orrs	r2, r3
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
900099f8:	687b      	ldr	r3, [r7, #4]
900099fa:	691b      	ldr	r3, [r3, #16]
900099fc:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
900099fe:	687b      	ldr	r3, [r7, #4]
90009a00:	695b      	ldr	r3, [r3, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
90009a02:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
90009a04:	687b      	ldr	r3, [r7, #4]
90009a06:	699b      	ldr	r3, [r3, #24]
90009a08:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
90009a0a:	687b      	ldr	r3, [r7, #4]
90009a0c:	69db      	ldr	r3, [r3, #28]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
90009a0e:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
90009a10:	687b      	ldr	r3, [r7, #4]
90009a12:	6a1b      	ldr	r3, [r3, #32]
90009a14:	4313      	orrs	r3, r2
    registerValue |=  hdma->Init.Direction           |
90009a16:	697a      	ldr	r2, [r7, #20]
90009a18:	4313      	orrs	r3, r2
90009a1a:	617b      	str	r3, [r7, #20]

    /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
90009a1c:	687b      	ldr	r3, [r7, #4]
90009a1e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90009a20:	2b04      	cmp	r3, #4
90009a22:	d107      	bne.n	90009a34 <HAL_DMA_Init+0x25c>
    {
      /* Get memory burst and peripheral burst */
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
90009a24:	687b      	ldr	r3, [r7, #4]
90009a26:	6ada      	ldr	r2, [r3, #44]	; 0x2c
90009a28:	687b      	ldr	r3, [r7, #4]
90009a2a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90009a2c:	4313      	orrs	r3, r2
90009a2e:	697a      	ldr	r2, [r7, #20]
90009a30:	4313      	orrs	r3, r2
90009a32:	617b      	str	r3, [r7, #20]
    }

    /* Work around for Errata 2.22: UART/USART- DMA transfer lock: DMA stream could be
                                    lock when transferring data to/from USART/UART */
#if (STM32H7_DEV_ID == 0x450UL)
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
90009a34:	4b71      	ldr	r3, [pc, #452]	; (90009bfc <HAL_DMA_Init+0x424>)
90009a36:	681a      	ldr	r2, [r3, #0]
90009a38:	4b71      	ldr	r3, [pc, #452]	; (90009c00 <HAL_DMA_Init+0x428>)
90009a3a:	4013      	ands	r3, r2
90009a3c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90009a40:	d328      	bcc.n	90009a94 <HAL_DMA_Init+0x2bc>
    {
#endif /* STM32H7_DEV_ID == 0x450UL */
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
90009a42:	687b      	ldr	r3, [r7, #4]
90009a44:	685b      	ldr	r3, [r3, #4]
90009a46:	2b28      	cmp	r3, #40	; 0x28
90009a48:	d903      	bls.n	90009a52 <HAL_DMA_Init+0x27a>
90009a4a:	687b      	ldr	r3, [r7, #4]
90009a4c:	685b      	ldr	r3, [r3, #4]
90009a4e:	2b2e      	cmp	r3, #46	; 0x2e
90009a50:	d917      	bls.n	90009a82 <HAL_DMA_Init+0x2aa>
90009a52:	687b      	ldr	r3, [r7, #4]
90009a54:	685b      	ldr	r3, [r3, #4]
90009a56:	2b3e      	cmp	r3, #62	; 0x3e
90009a58:	d903      	bls.n	90009a62 <HAL_DMA_Init+0x28a>
90009a5a:	687b      	ldr	r3, [r7, #4]
90009a5c:	685b      	ldr	r3, [r3, #4]
90009a5e:	2b42      	cmp	r3, #66	; 0x42
90009a60:	d90f      	bls.n	90009a82 <HAL_DMA_Init+0x2aa>
90009a62:	687b      	ldr	r3, [r7, #4]
90009a64:	685b      	ldr	r3, [r3, #4]
90009a66:	2b46      	cmp	r3, #70	; 0x46
90009a68:	d903      	bls.n	90009a72 <HAL_DMA_Init+0x29a>
90009a6a:	687b      	ldr	r3, [r7, #4]
90009a6c:	685b      	ldr	r3, [r3, #4]
90009a6e:	2b48      	cmp	r3, #72	; 0x48
90009a70:	d907      	bls.n	90009a82 <HAL_DMA_Init+0x2aa>
90009a72:	687b      	ldr	r3, [r7, #4]
90009a74:	685b      	ldr	r3, [r3, #4]
90009a76:	2b4e      	cmp	r3, #78	; 0x4e
90009a78:	d905      	bls.n	90009a86 <HAL_DMA_Init+0x2ae>
90009a7a:	687b      	ldr	r3, [r7, #4]
90009a7c:	685b      	ldr	r3, [r3, #4]
90009a7e:	2b52      	cmp	r3, #82	; 0x52
90009a80:	d801      	bhi.n	90009a86 <HAL_DMA_Init+0x2ae>
90009a82:	2301      	movs	r3, #1
90009a84:	e000      	b.n	90009a88 <HAL_DMA_Init+0x2b0>
90009a86:	2300      	movs	r3, #0
90009a88:	2b00      	cmp	r3, #0
90009a8a:	d003      	beq.n	90009a94 <HAL_DMA_Init+0x2bc>
      {
        registerValue |= DMA_SxCR_TRBUFF;
90009a8c:	697b      	ldr	r3, [r7, #20]
90009a8e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
90009a92:	617b      	str	r3, [r7, #20]
#if (STM32H7_DEV_ID == 0x450UL)
    }
#endif /* STM32H7_DEV_ID == 0x450UL */

    /* Write to DMA Stream CR register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
90009a94:	687b      	ldr	r3, [r7, #4]
90009a96:	681b      	ldr	r3, [r3, #0]
90009a98:	697a      	ldr	r2, [r7, #20]
90009a9a:	601a      	str	r2, [r3, #0]

    /* Get the FCR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
90009a9c:	687b      	ldr	r3, [r7, #4]
90009a9e:	681b      	ldr	r3, [r3, #0]
90009aa0:	695b      	ldr	r3, [r3, #20]
90009aa2:	617b      	str	r3, [r7, #20]

    /* Clear Direct mode and FIFO threshold bits */
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
90009aa4:	697b      	ldr	r3, [r7, #20]
90009aa6:	f023 0307 	bic.w	r3, r3, #7
90009aaa:	617b      	str	r3, [r7, #20]

    /* Prepare the DMA Stream FIFO configuration */
    registerValue |= hdma->Init.FIFOMode;
90009aac:	687b      	ldr	r3, [r7, #4]
90009aae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90009ab0:	697a      	ldr	r2, [r7, #20]
90009ab2:	4313      	orrs	r3, r2
90009ab4:	617b      	str	r3, [r7, #20]

    /* the FIFO threshold is not used when the FIFO mode is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
90009ab6:	687b      	ldr	r3, [r7, #4]
90009ab8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90009aba:	2b04      	cmp	r3, #4
90009abc:	d117      	bne.n	90009aee <HAL_DMA_Init+0x316>
    {
      /* Get the FIFO threshold */
      registerValue |= hdma->Init.FIFOThreshold;
90009abe:	687b      	ldr	r3, [r7, #4]
90009ac0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90009ac2:	697a      	ldr	r2, [r7, #20]
90009ac4:	4313      	orrs	r3, r2
90009ac6:	617b      	str	r3, [r7, #20]

      /* Check compatibility between FIFO threshold level and size of the memory burst */
      /* for INCR4, INCR8, INCR16 */
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
90009ac8:	687b      	ldr	r3, [r7, #4]
90009aca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90009acc:	2b00      	cmp	r3, #0
90009ace:	d00e      	beq.n	90009aee <HAL_DMA_Init+0x316>
      {
        if (DMA_CheckFifoParam(hdma) != HAL_OK)
90009ad0:	6878      	ldr	r0, [r7, #4]
90009ad2:	f002 faaf 	bl	9000c034 <DMA_CheckFifoParam>
90009ad6:	4603      	mov	r3, r0
90009ad8:	2b00      	cmp	r3, #0
90009ada:	d008      	beq.n	90009aee <HAL_DMA_Init+0x316>
        {
          /* Update error code */
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
90009adc:	687b      	ldr	r3, [r7, #4]
90009ade:	2240      	movs	r2, #64	; 0x40
90009ae0:	655a      	str	r2, [r3, #84]	; 0x54

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
90009ae2:	687b      	ldr	r3, [r7, #4]
90009ae4:	2201      	movs	r2, #1
90009ae6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          return HAL_ERROR;
90009aea:	2301      	movs	r3, #1
90009aec:	e197      	b.n	90009e1e <HAL_DMA_Init+0x646>
        }
      }
    }

    /* Write to DMA Stream FCR */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
90009aee:	687b      	ldr	r3, [r7, #4]
90009af0:	681b      	ldr	r3, [r3, #0]
90009af2:	697a      	ldr	r2, [r7, #20]
90009af4:	615a      	str	r2, [r3, #20]

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
       DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
90009af6:	6878      	ldr	r0, [r7, #4]
90009af8:	f002 f9ea 	bl	9000bed0 <DMA_CalcBaseAndBitshift>
90009afc:	4603      	mov	r3, r0
90009afe:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
90009b00:	687b      	ldr	r3, [r7, #4]
90009b02:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
90009b04:	f003 031f 	and.w	r3, r3, #31
90009b08:	223f      	movs	r2, #63	; 0x3f
90009b0a:	409a      	lsls	r2, r3
90009b0c:	68bb      	ldr	r3, [r7, #8]
90009b0e:	609a      	str	r2, [r3, #8]
90009b10:	e0cd      	b.n	90009cae <HAL_DMA_Init+0x4d6>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
90009b12:	687b      	ldr	r3, [r7, #4]
90009b14:	681b      	ldr	r3, [r3, #0]
90009b16:	4a3b      	ldr	r2, [pc, #236]	; (90009c04 <HAL_DMA_Init+0x42c>)
90009b18:	4293      	cmp	r3, r2
90009b1a:	d022      	beq.n	90009b62 <HAL_DMA_Init+0x38a>
90009b1c:	687b      	ldr	r3, [r7, #4]
90009b1e:	681b      	ldr	r3, [r3, #0]
90009b20:	4a39      	ldr	r2, [pc, #228]	; (90009c08 <HAL_DMA_Init+0x430>)
90009b22:	4293      	cmp	r3, r2
90009b24:	d01d      	beq.n	90009b62 <HAL_DMA_Init+0x38a>
90009b26:	687b      	ldr	r3, [r7, #4]
90009b28:	681b      	ldr	r3, [r3, #0]
90009b2a:	4a38      	ldr	r2, [pc, #224]	; (90009c0c <HAL_DMA_Init+0x434>)
90009b2c:	4293      	cmp	r3, r2
90009b2e:	d018      	beq.n	90009b62 <HAL_DMA_Init+0x38a>
90009b30:	687b      	ldr	r3, [r7, #4]
90009b32:	681b      	ldr	r3, [r3, #0]
90009b34:	4a36      	ldr	r2, [pc, #216]	; (90009c10 <HAL_DMA_Init+0x438>)
90009b36:	4293      	cmp	r3, r2
90009b38:	d013      	beq.n	90009b62 <HAL_DMA_Init+0x38a>
90009b3a:	687b      	ldr	r3, [r7, #4]
90009b3c:	681b      	ldr	r3, [r3, #0]
90009b3e:	4a35      	ldr	r2, [pc, #212]	; (90009c14 <HAL_DMA_Init+0x43c>)
90009b40:	4293      	cmp	r3, r2
90009b42:	d00e      	beq.n	90009b62 <HAL_DMA_Init+0x38a>
90009b44:	687b      	ldr	r3, [r7, #4]
90009b46:	681b      	ldr	r3, [r3, #0]
90009b48:	4a33      	ldr	r2, [pc, #204]	; (90009c18 <HAL_DMA_Init+0x440>)
90009b4a:	4293      	cmp	r3, r2
90009b4c:	d009      	beq.n	90009b62 <HAL_DMA_Init+0x38a>
90009b4e:	687b      	ldr	r3, [r7, #4]
90009b50:	681b      	ldr	r3, [r3, #0]
90009b52:	4a32      	ldr	r2, [pc, #200]	; (90009c1c <HAL_DMA_Init+0x444>)
90009b54:	4293      	cmp	r3, r2
90009b56:	d004      	beq.n	90009b62 <HAL_DMA_Init+0x38a>
90009b58:	687b      	ldr	r3, [r7, #4]
90009b5a:	681b      	ldr	r3, [r3, #0]
90009b5c:	4a30      	ldr	r2, [pc, #192]	; (90009c20 <HAL_DMA_Init+0x448>)
90009b5e:	4293      	cmp	r3, r2
90009b60:	d101      	bne.n	90009b66 <HAL_DMA_Init+0x38e>
90009b62:	2301      	movs	r3, #1
90009b64:	e000      	b.n	90009b68 <HAL_DMA_Init+0x390>
90009b66:	2300      	movs	r3, #0
90009b68:	2b00      	cmp	r3, #0
90009b6a:	f000 8097 	beq.w	90009c9c <HAL_DMA_Init+0x4c4>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
90009b6e:	687b      	ldr	r3, [r7, #4]
90009b70:	681b      	ldr	r3, [r3, #0]
90009b72:	4a24      	ldr	r2, [pc, #144]	; (90009c04 <HAL_DMA_Init+0x42c>)
90009b74:	4293      	cmp	r3, r2
90009b76:	d021      	beq.n	90009bbc <HAL_DMA_Init+0x3e4>
90009b78:	687b      	ldr	r3, [r7, #4]
90009b7a:	681b      	ldr	r3, [r3, #0]
90009b7c:	4a22      	ldr	r2, [pc, #136]	; (90009c08 <HAL_DMA_Init+0x430>)
90009b7e:	4293      	cmp	r3, r2
90009b80:	d01c      	beq.n	90009bbc <HAL_DMA_Init+0x3e4>
90009b82:	687b      	ldr	r3, [r7, #4]
90009b84:	681b      	ldr	r3, [r3, #0]
90009b86:	4a21      	ldr	r2, [pc, #132]	; (90009c0c <HAL_DMA_Init+0x434>)
90009b88:	4293      	cmp	r3, r2
90009b8a:	d017      	beq.n	90009bbc <HAL_DMA_Init+0x3e4>
90009b8c:	687b      	ldr	r3, [r7, #4]
90009b8e:	681b      	ldr	r3, [r3, #0]
90009b90:	4a1f      	ldr	r2, [pc, #124]	; (90009c10 <HAL_DMA_Init+0x438>)
90009b92:	4293      	cmp	r3, r2
90009b94:	d012      	beq.n	90009bbc <HAL_DMA_Init+0x3e4>
90009b96:	687b      	ldr	r3, [r7, #4]
90009b98:	681b      	ldr	r3, [r3, #0]
90009b9a:	4a1e      	ldr	r2, [pc, #120]	; (90009c14 <HAL_DMA_Init+0x43c>)
90009b9c:	4293      	cmp	r3, r2
90009b9e:	d00d      	beq.n	90009bbc <HAL_DMA_Init+0x3e4>
90009ba0:	687b      	ldr	r3, [r7, #4]
90009ba2:	681b      	ldr	r3, [r3, #0]
90009ba4:	4a1c      	ldr	r2, [pc, #112]	; (90009c18 <HAL_DMA_Init+0x440>)
90009ba6:	4293      	cmp	r3, r2
90009ba8:	d008      	beq.n	90009bbc <HAL_DMA_Init+0x3e4>
90009baa:	687b      	ldr	r3, [r7, #4]
90009bac:	681b      	ldr	r3, [r3, #0]
90009bae:	4a1b      	ldr	r2, [pc, #108]	; (90009c1c <HAL_DMA_Init+0x444>)
90009bb0:	4293      	cmp	r3, r2
90009bb2:	d003      	beq.n	90009bbc <HAL_DMA_Init+0x3e4>
90009bb4:	687b      	ldr	r3, [r7, #4]
90009bb6:	681b      	ldr	r3, [r3, #0]
90009bb8:	4a19      	ldr	r2, [pc, #100]	; (90009c20 <HAL_DMA_Init+0x448>)
90009bba:	4293      	cmp	r3, r2
90009bbc:	bf00      	nop
      /* Check the request parameter */
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
90009bbe:	687b      	ldr	r3, [r7, #4]
90009bc0:	2202      	movs	r2, #2
90009bc2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
90009bc6:	687b      	ldr	r3, [r7, #4]
90009bc8:	2200      	movs	r2, #0
90009bca:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Get the CR register value */
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
90009bce:	687b      	ldr	r3, [r7, #4]
90009bd0:	681b      	ldr	r3, [r3, #0]
90009bd2:	681b      	ldr	r3, [r3, #0]
90009bd4:	617b      	str	r3, [r7, #20]

    /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, MEM2MEM, DBM and CT bits */
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
90009bd6:	697a      	ldr	r2, [r7, #20]
90009bd8:	4b12      	ldr	r3, [pc, #72]	; (90009c24 <HAL_DMA_Init+0x44c>)
90009bda:	4013      	ands	r3, r2
90009bdc:	617b      	str	r3, [r7, #20]
                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \
                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \
                                  BDMA_CCR_CT));

    /* Prepare the DMA Channel configuration */
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
90009bde:	687b      	ldr	r3, [r7, #4]
90009be0:	689b      	ldr	r3, [r3, #8]
90009be2:	2b40      	cmp	r3, #64	; 0x40
90009be4:	d020      	beq.n	90009c28 <HAL_DMA_Init+0x450>
90009be6:	687b      	ldr	r3, [r7, #4]
90009be8:	689b      	ldr	r3, [r3, #8]
90009bea:	2b80      	cmp	r3, #128	; 0x80
90009bec:	d102      	bne.n	90009bf4 <HAL_DMA_Init+0x41c>
90009bee:	f44f 4380 	mov.w	r3, #16384	; 0x4000
90009bf2:	e01a      	b.n	90009c2a <HAL_DMA_Init+0x452>
90009bf4:	2300      	movs	r3, #0
90009bf6:	e018      	b.n	90009c2a <HAL_DMA_Init+0x452>
90009bf8:	fe10803f 	.word	0xfe10803f
90009bfc:	5c001000 	.word	0x5c001000
90009c00:	ffff0000 	.word	0xffff0000
90009c04:	58025408 	.word	0x58025408
90009c08:	5802541c 	.word	0x5802541c
90009c0c:	58025430 	.word	0x58025430
90009c10:	58025444 	.word	0x58025444
90009c14:	58025458 	.word	0x58025458
90009c18:	5802546c 	.word	0x5802546c
90009c1c:	58025480 	.word	0x58025480
90009c20:	58025494 	.word	0x58025494
90009c24:	fffe000f 	.word	0xfffe000f
90009c28:	2310      	movs	r3, #16
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
90009c2a:	687a      	ldr	r2, [r7, #4]
90009c2c:	68d2      	ldr	r2, [r2, #12]
90009c2e:	08d2      	lsrs	r2, r2, #3
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
90009c30:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
90009c32:	687b      	ldr	r3, [r7, #4]
90009c34:	691b      	ldr	r3, [r3, #16]
90009c36:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
90009c38:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
90009c3a:	687b      	ldr	r3, [r7, #4]
90009c3c:	695b      	ldr	r3, [r3, #20]
90009c3e:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
90009c40:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
90009c42:	687b      	ldr	r3, [r7, #4]
90009c44:	699b      	ldr	r3, [r3, #24]
90009c46:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
90009c48:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
90009c4a:	687b      	ldr	r3, [r7, #4]
90009c4c:	69db      	ldr	r3, [r3, #28]
90009c4e:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
90009c50:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
90009c52:	687b      	ldr	r3, [r7, #4]
90009c54:	6a1b      	ldr	r3, [r3, #32]
90009c56:	091b      	lsrs	r3, r3, #4
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
90009c58:	4313      	orrs	r3, r2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
90009c5a:	697a      	ldr	r2, [r7, #20]
90009c5c:	4313      	orrs	r3, r2
90009c5e:	617b      	str	r3, [r7, #20]

    /* Write to DMA Channel CR register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
90009c60:	687b      	ldr	r3, [r7, #4]
90009c62:	681b      	ldr	r3, [r3, #0]
90009c64:	697a      	ldr	r2, [r7, #20]
90009c66:	601a      	str	r2, [r3, #0]

    /* calculation of the channel index */
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
90009c68:	687b      	ldr	r3, [r7, #4]
90009c6a:	681b      	ldr	r3, [r3, #0]
90009c6c:	461a      	mov	r2, r3
90009c6e:	4b6e      	ldr	r3, [pc, #440]	; (90009e28 <HAL_DMA_Init+0x650>)
90009c70:	4413      	add	r3, r2
90009c72:	4a6e      	ldr	r2, [pc, #440]	; (90009e2c <HAL_DMA_Init+0x654>)
90009c74:	fba2 2303 	umull	r2, r3, r2, r3
90009c78:	091b      	lsrs	r3, r3, #4
90009c7a:	009a      	lsls	r2, r3, #2
90009c7c:	687b      	ldr	r3, [r7, #4]
90009c7e:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
90009c80:	6878      	ldr	r0, [r7, #4]
90009c82:	f002 f925 	bl	9000bed0 <DMA_CalcBaseAndBitshift>
90009c86:	4603      	mov	r3, r0
90009c88:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
90009c8a:	687b      	ldr	r3, [r7, #4]
90009c8c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
90009c8e:	f003 031f 	and.w	r3, r3, #31
90009c92:	2201      	movs	r2, #1
90009c94:	409a      	lsls	r2, r3
90009c96:	68fb      	ldr	r3, [r7, #12]
90009c98:	605a      	str	r2, [r3, #4]
90009c9a:	e008      	b.n	90009cae <HAL_DMA_Init+0x4d6>
  }
  else
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
90009c9c:	687b      	ldr	r3, [r7, #4]
90009c9e:	2240      	movs	r2, #64	; 0x40
90009ca0:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
90009ca2:	687b      	ldr	r3, [r7, #4]
90009ca4:	2203      	movs	r2, #3
90009ca6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    return HAL_ERROR;
90009caa:	2301      	movs	r3, #1
90009cac:	e0b7      	b.n	90009e1e <HAL_DMA_Init+0x646>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
90009cae:	687b      	ldr	r3, [r7, #4]
90009cb0:	681b      	ldr	r3, [r3, #0]
90009cb2:	4a5f      	ldr	r2, [pc, #380]	; (90009e30 <HAL_DMA_Init+0x658>)
90009cb4:	4293      	cmp	r3, r2
90009cb6:	d072      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009cb8:	687b      	ldr	r3, [r7, #4]
90009cba:	681b      	ldr	r3, [r3, #0]
90009cbc:	4a5d      	ldr	r2, [pc, #372]	; (90009e34 <HAL_DMA_Init+0x65c>)
90009cbe:	4293      	cmp	r3, r2
90009cc0:	d06d      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009cc2:	687b      	ldr	r3, [r7, #4]
90009cc4:	681b      	ldr	r3, [r3, #0]
90009cc6:	4a5c      	ldr	r2, [pc, #368]	; (90009e38 <HAL_DMA_Init+0x660>)
90009cc8:	4293      	cmp	r3, r2
90009cca:	d068      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009ccc:	687b      	ldr	r3, [r7, #4]
90009cce:	681b      	ldr	r3, [r3, #0]
90009cd0:	4a5a      	ldr	r2, [pc, #360]	; (90009e3c <HAL_DMA_Init+0x664>)
90009cd2:	4293      	cmp	r3, r2
90009cd4:	d063      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009cd6:	687b      	ldr	r3, [r7, #4]
90009cd8:	681b      	ldr	r3, [r3, #0]
90009cda:	4a59      	ldr	r2, [pc, #356]	; (90009e40 <HAL_DMA_Init+0x668>)
90009cdc:	4293      	cmp	r3, r2
90009cde:	d05e      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009ce0:	687b      	ldr	r3, [r7, #4]
90009ce2:	681b      	ldr	r3, [r3, #0]
90009ce4:	4a57      	ldr	r2, [pc, #348]	; (90009e44 <HAL_DMA_Init+0x66c>)
90009ce6:	4293      	cmp	r3, r2
90009ce8:	d059      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009cea:	687b      	ldr	r3, [r7, #4]
90009cec:	681b      	ldr	r3, [r3, #0]
90009cee:	4a56      	ldr	r2, [pc, #344]	; (90009e48 <HAL_DMA_Init+0x670>)
90009cf0:	4293      	cmp	r3, r2
90009cf2:	d054      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009cf4:	687b      	ldr	r3, [r7, #4]
90009cf6:	681b      	ldr	r3, [r3, #0]
90009cf8:	4a54      	ldr	r2, [pc, #336]	; (90009e4c <HAL_DMA_Init+0x674>)
90009cfa:	4293      	cmp	r3, r2
90009cfc:	d04f      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009cfe:	687b      	ldr	r3, [r7, #4]
90009d00:	681b      	ldr	r3, [r3, #0]
90009d02:	4a53      	ldr	r2, [pc, #332]	; (90009e50 <HAL_DMA_Init+0x678>)
90009d04:	4293      	cmp	r3, r2
90009d06:	d04a      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d08:	687b      	ldr	r3, [r7, #4]
90009d0a:	681b      	ldr	r3, [r3, #0]
90009d0c:	4a51      	ldr	r2, [pc, #324]	; (90009e54 <HAL_DMA_Init+0x67c>)
90009d0e:	4293      	cmp	r3, r2
90009d10:	d045      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d12:	687b      	ldr	r3, [r7, #4]
90009d14:	681b      	ldr	r3, [r3, #0]
90009d16:	4a50      	ldr	r2, [pc, #320]	; (90009e58 <HAL_DMA_Init+0x680>)
90009d18:	4293      	cmp	r3, r2
90009d1a:	d040      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d1c:	687b      	ldr	r3, [r7, #4]
90009d1e:	681b      	ldr	r3, [r3, #0]
90009d20:	4a4e      	ldr	r2, [pc, #312]	; (90009e5c <HAL_DMA_Init+0x684>)
90009d22:	4293      	cmp	r3, r2
90009d24:	d03b      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d26:	687b      	ldr	r3, [r7, #4]
90009d28:	681b      	ldr	r3, [r3, #0]
90009d2a:	4a4d      	ldr	r2, [pc, #308]	; (90009e60 <HAL_DMA_Init+0x688>)
90009d2c:	4293      	cmp	r3, r2
90009d2e:	d036      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d30:	687b      	ldr	r3, [r7, #4]
90009d32:	681b      	ldr	r3, [r3, #0]
90009d34:	4a4b      	ldr	r2, [pc, #300]	; (90009e64 <HAL_DMA_Init+0x68c>)
90009d36:	4293      	cmp	r3, r2
90009d38:	d031      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d3a:	687b      	ldr	r3, [r7, #4]
90009d3c:	681b      	ldr	r3, [r3, #0]
90009d3e:	4a4a      	ldr	r2, [pc, #296]	; (90009e68 <HAL_DMA_Init+0x690>)
90009d40:	4293      	cmp	r3, r2
90009d42:	d02c      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d44:	687b      	ldr	r3, [r7, #4]
90009d46:	681b      	ldr	r3, [r3, #0]
90009d48:	4a48      	ldr	r2, [pc, #288]	; (90009e6c <HAL_DMA_Init+0x694>)
90009d4a:	4293      	cmp	r3, r2
90009d4c:	d027      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d4e:	687b      	ldr	r3, [r7, #4]
90009d50:	681b      	ldr	r3, [r3, #0]
90009d52:	4a47      	ldr	r2, [pc, #284]	; (90009e70 <HAL_DMA_Init+0x698>)
90009d54:	4293      	cmp	r3, r2
90009d56:	d022      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d58:	687b      	ldr	r3, [r7, #4]
90009d5a:	681b      	ldr	r3, [r3, #0]
90009d5c:	4a45      	ldr	r2, [pc, #276]	; (90009e74 <HAL_DMA_Init+0x69c>)
90009d5e:	4293      	cmp	r3, r2
90009d60:	d01d      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d62:	687b      	ldr	r3, [r7, #4]
90009d64:	681b      	ldr	r3, [r3, #0]
90009d66:	4a44      	ldr	r2, [pc, #272]	; (90009e78 <HAL_DMA_Init+0x6a0>)
90009d68:	4293      	cmp	r3, r2
90009d6a:	d018      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d6c:	687b      	ldr	r3, [r7, #4]
90009d6e:	681b      	ldr	r3, [r3, #0]
90009d70:	4a42      	ldr	r2, [pc, #264]	; (90009e7c <HAL_DMA_Init+0x6a4>)
90009d72:	4293      	cmp	r3, r2
90009d74:	d013      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d76:	687b      	ldr	r3, [r7, #4]
90009d78:	681b      	ldr	r3, [r3, #0]
90009d7a:	4a41      	ldr	r2, [pc, #260]	; (90009e80 <HAL_DMA_Init+0x6a8>)
90009d7c:	4293      	cmp	r3, r2
90009d7e:	d00e      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d80:	687b      	ldr	r3, [r7, #4]
90009d82:	681b      	ldr	r3, [r3, #0]
90009d84:	4a3f      	ldr	r2, [pc, #252]	; (90009e84 <HAL_DMA_Init+0x6ac>)
90009d86:	4293      	cmp	r3, r2
90009d88:	d009      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d8a:	687b      	ldr	r3, [r7, #4]
90009d8c:	681b      	ldr	r3, [r3, #0]
90009d8e:	4a3e      	ldr	r2, [pc, #248]	; (90009e88 <HAL_DMA_Init+0x6b0>)
90009d90:	4293      	cmp	r3, r2
90009d92:	d004      	beq.n	90009d9e <HAL_DMA_Init+0x5c6>
90009d94:	687b      	ldr	r3, [r7, #4]
90009d96:	681b      	ldr	r3, [r3, #0]
90009d98:	4a3c      	ldr	r2, [pc, #240]	; (90009e8c <HAL_DMA_Init+0x6b4>)
90009d9a:	4293      	cmp	r3, r2
90009d9c:	d101      	bne.n	90009da2 <HAL_DMA_Init+0x5ca>
90009d9e:	2301      	movs	r3, #1
90009da0:	e000      	b.n	90009da4 <HAL_DMA_Init+0x5cc>
90009da2:	2300      	movs	r3, #0
90009da4:	2b00      	cmp	r3, #0
90009da6:	d032      	beq.n	90009e0e <HAL_DMA_Init+0x636>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
    */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
90009da8:	6878      	ldr	r0, [r7, #4]
90009daa:	f002 f9bf 	bl	9000c12c <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
90009dae:	687b      	ldr	r3, [r7, #4]
90009db0:	689b      	ldr	r3, [r3, #8]
90009db2:	2b80      	cmp	r3, #128	; 0x80
90009db4:	d102      	bne.n	90009dbc <HAL_DMA_Init+0x5e4>
    {
      /* if memory to memory force the request to 0*/
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
90009db6:	687b      	ldr	r3, [r7, #4]
90009db8:	2200      	movs	r2, #0
90009dba:	605a      	str	r2, [r3, #4]
    }

    /* Set peripheral request  to DMAMUX channel */
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
90009dbc:	687b      	ldr	r3, [r7, #4]
90009dbe:	685a      	ldr	r2, [r3, #4]
90009dc0:	687b      	ldr	r3, [r7, #4]
90009dc2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
90009dc4:	b2d2      	uxtb	r2, r2
90009dc6:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
90009dc8:	687b      	ldr	r3, [r7, #4]
90009dca:	6e5b      	ldr	r3, [r3, #100]	; 0x64
90009dcc:	687a      	ldr	r2, [r7, #4]
90009dce:	6e92      	ldr	r2, [r2, #104]	; 0x68
90009dd0:	605a      	str	r2, [r3, #4]

    /* Initialize parameters for DMAMUX request generator :
    if the DMA request is DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR7
    */
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
90009dd2:	687b      	ldr	r3, [r7, #4]
90009dd4:	685b      	ldr	r3, [r3, #4]
90009dd6:	2b00      	cmp	r3, #0
90009dd8:	d010      	beq.n	90009dfc <HAL_DMA_Init+0x624>
90009dda:	687b      	ldr	r3, [r7, #4]
90009ddc:	685b      	ldr	r3, [r3, #4]
90009dde:	2b08      	cmp	r3, #8
90009de0:	d80c      	bhi.n	90009dfc <HAL_DMA_Init+0x624>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
90009de2:	6878      	ldr	r0, [r7, #4]
90009de4:	f002 fa3c 	bl	9000c260 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
90009de8:	687b      	ldr	r3, [r7, #4]
90009dea:	6edb      	ldr	r3, [r3, #108]	; 0x6c
90009dec:	2200      	movs	r2, #0
90009dee:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
90009df0:	687b      	ldr	r3, [r7, #4]
90009df2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90009df4:	687a      	ldr	r2, [r7, #4]
90009df6:	6f52      	ldr	r2, [r2, #116]	; 0x74
90009df8:	605a      	str	r2, [r3, #4]
90009dfa:	e008      	b.n	90009e0e <HAL_DMA_Init+0x636>
    }
    else
    {
      hdma->DMAmuxRequestGen = 0U;
90009dfc:	687b      	ldr	r3, [r7, #4]
90009dfe:	2200      	movs	r2, #0
90009e00:	66da      	str	r2, [r3, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatus = 0U;
90009e02:	687b      	ldr	r3, [r7, #4]
90009e04:	2200      	movs	r2, #0
90009e06:	671a      	str	r2, [r3, #112]	; 0x70
      hdma->DMAmuxRequestGenStatusMask = 0U;
90009e08:	687b      	ldr	r3, [r7, #4]
90009e0a:	2200      	movs	r2, #0
90009e0c:	675a      	str	r2, [r3, #116]	; 0x74
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
90009e0e:	687b      	ldr	r3, [r7, #4]
90009e10:	2200      	movs	r2, #0
90009e12:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
90009e14:	687b      	ldr	r3, [r7, #4]
90009e16:	2201      	movs	r2, #1
90009e18:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
90009e1c:	2300      	movs	r3, #0
}
90009e1e:	4618      	mov	r0, r3
90009e20:	3718      	adds	r7, #24
90009e22:	46bd      	mov	sp, r7
90009e24:	bd80      	pop	{r7, pc}
90009e26:	bf00      	nop
90009e28:	a7fdabf8 	.word	0xa7fdabf8
90009e2c:	cccccccd 	.word	0xcccccccd
90009e30:	40020010 	.word	0x40020010
90009e34:	40020028 	.word	0x40020028
90009e38:	40020040 	.word	0x40020040
90009e3c:	40020058 	.word	0x40020058
90009e40:	40020070 	.word	0x40020070
90009e44:	40020088 	.word	0x40020088
90009e48:	400200a0 	.word	0x400200a0
90009e4c:	400200b8 	.word	0x400200b8
90009e50:	40020410 	.word	0x40020410
90009e54:	40020428 	.word	0x40020428
90009e58:	40020440 	.word	0x40020440
90009e5c:	40020458 	.word	0x40020458
90009e60:	40020470 	.word	0x40020470
90009e64:	40020488 	.word	0x40020488
90009e68:	400204a0 	.word	0x400204a0
90009e6c:	400204b8 	.word	0x400204b8
90009e70:	58025408 	.word	0x58025408
90009e74:	5802541c 	.word	0x5802541c
90009e78:	58025430 	.word	0x58025430
90009e7c:	58025444 	.word	0x58025444
90009e80:	58025458 	.word	0x58025458
90009e84:	5802546c 	.word	0x5802546c
90009e88:	58025480 	.word	0x58025480
90009e8c:	58025494 	.word	0x58025494

90009e90 <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
90009e90:	b580      	push	{r7, lr}
90009e92:	b084      	sub	sp, #16
90009e94:	af00      	add	r7, sp, #0
90009e96:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
90009e98:	687b      	ldr	r3, [r7, #4]
90009e9a:	2b00      	cmp	r3, #0
90009e9c:	d101      	bne.n	90009ea2 <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
90009e9e:	2301      	movs	r3, #1
90009ea0:	e1a8      	b.n	9000a1f4 <HAL_DMA_DeInit+0x364>
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
90009ea2:	687b      	ldr	r3, [r7, #4]
90009ea4:	681b      	ldr	r3, [r3, #0]
90009ea6:	4a82      	ldr	r2, [pc, #520]	; (9000a0b0 <HAL_DMA_DeInit+0x220>)
90009ea8:	4293      	cmp	r3, r2
90009eaa:	d04a      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009eac:	687b      	ldr	r3, [r7, #4]
90009eae:	681b      	ldr	r3, [r3, #0]
90009eb0:	4a80      	ldr	r2, [pc, #512]	; (9000a0b4 <HAL_DMA_DeInit+0x224>)
90009eb2:	4293      	cmp	r3, r2
90009eb4:	d045      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009eb6:	687b      	ldr	r3, [r7, #4]
90009eb8:	681b      	ldr	r3, [r3, #0]
90009eba:	4a7f      	ldr	r2, [pc, #508]	; (9000a0b8 <HAL_DMA_DeInit+0x228>)
90009ebc:	4293      	cmp	r3, r2
90009ebe:	d040      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009ec0:	687b      	ldr	r3, [r7, #4]
90009ec2:	681b      	ldr	r3, [r3, #0]
90009ec4:	4a7d      	ldr	r2, [pc, #500]	; (9000a0bc <HAL_DMA_DeInit+0x22c>)
90009ec6:	4293      	cmp	r3, r2
90009ec8:	d03b      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009eca:	687b      	ldr	r3, [r7, #4]
90009ecc:	681b      	ldr	r3, [r3, #0]
90009ece:	4a7c      	ldr	r2, [pc, #496]	; (9000a0c0 <HAL_DMA_DeInit+0x230>)
90009ed0:	4293      	cmp	r3, r2
90009ed2:	d036      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009ed4:	687b      	ldr	r3, [r7, #4]
90009ed6:	681b      	ldr	r3, [r3, #0]
90009ed8:	4a7a      	ldr	r2, [pc, #488]	; (9000a0c4 <HAL_DMA_DeInit+0x234>)
90009eda:	4293      	cmp	r3, r2
90009edc:	d031      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009ede:	687b      	ldr	r3, [r7, #4]
90009ee0:	681b      	ldr	r3, [r3, #0]
90009ee2:	4a79      	ldr	r2, [pc, #484]	; (9000a0c8 <HAL_DMA_DeInit+0x238>)
90009ee4:	4293      	cmp	r3, r2
90009ee6:	d02c      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009ee8:	687b      	ldr	r3, [r7, #4]
90009eea:	681b      	ldr	r3, [r3, #0]
90009eec:	4a77      	ldr	r2, [pc, #476]	; (9000a0cc <HAL_DMA_DeInit+0x23c>)
90009eee:	4293      	cmp	r3, r2
90009ef0:	d027      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009ef2:	687b      	ldr	r3, [r7, #4]
90009ef4:	681b      	ldr	r3, [r3, #0]
90009ef6:	4a76      	ldr	r2, [pc, #472]	; (9000a0d0 <HAL_DMA_DeInit+0x240>)
90009ef8:	4293      	cmp	r3, r2
90009efa:	d022      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009efc:	687b      	ldr	r3, [r7, #4]
90009efe:	681b      	ldr	r3, [r3, #0]
90009f00:	4a74      	ldr	r2, [pc, #464]	; (9000a0d4 <HAL_DMA_DeInit+0x244>)
90009f02:	4293      	cmp	r3, r2
90009f04:	d01d      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009f06:	687b      	ldr	r3, [r7, #4]
90009f08:	681b      	ldr	r3, [r3, #0]
90009f0a:	4a73      	ldr	r2, [pc, #460]	; (9000a0d8 <HAL_DMA_DeInit+0x248>)
90009f0c:	4293      	cmp	r3, r2
90009f0e:	d018      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009f10:	687b      	ldr	r3, [r7, #4]
90009f12:	681b      	ldr	r3, [r3, #0]
90009f14:	4a71      	ldr	r2, [pc, #452]	; (9000a0dc <HAL_DMA_DeInit+0x24c>)
90009f16:	4293      	cmp	r3, r2
90009f18:	d013      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009f1a:	687b      	ldr	r3, [r7, #4]
90009f1c:	681b      	ldr	r3, [r3, #0]
90009f1e:	4a70      	ldr	r2, [pc, #448]	; (9000a0e0 <HAL_DMA_DeInit+0x250>)
90009f20:	4293      	cmp	r3, r2
90009f22:	d00e      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009f24:	687b      	ldr	r3, [r7, #4]
90009f26:	681b      	ldr	r3, [r3, #0]
90009f28:	4a6e      	ldr	r2, [pc, #440]	; (9000a0e4 <HAL_DMA_DeInit+0x254>)
90009f2a:	4293      	cmp	r3, r2
90009f2c:	d009      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009f2e:	687b      	ldr	r3, [r7, #4]
90009f30:	681b      	ldr	r3, [r3, #0]
90009f32:	4a6d      	ldr	r2, [pc, #436]	; (9000a0e8 <HAL_DMA_DeInit+0x258>)
90009f34:	4293      	cmp	r3, r2
90009f36:	d004      	beq.n	90009f42 <HAL_DMA_DeInit+0xb2>
90009f38:	687b      	ldr	r3, [r7, #4]
90009f3a:	681b      	ldr	r3, [r3, #0]
90009f3c:	4a6b      	ldr	r2, [pc, #428]	; (9000a0ec <HAL_DMA_DeInit+0x25c>)
90009f3e:	4293      	cmp	r3, r2
90009f40:	d108      	bne.n	90009f54 <HAL_DMA_DeInit+0xc4>
90009f42:	687b      	ldr	r3, [r7, #4]
90009f44:	681b      	ldr	r3, [r3, #0]
90009f46:	681a      	ldr	r2, [r3, #0]
90009f48:	687b      	ldr	r3, [r7, #4]
90009f4a:	681b      	ldr	r3, [r3, #0]
90009f4c:	f022 0201 	bic.w	r2, r2, #1
90009f50:	601a      	str	r2, [r3, #0]
90009f52:	e007      	b.n	90009f64 <HAL_DMA_DeInit+0xd4>
90009f54:	687b      	ldr	r3, [r7, #4]
90009f56:	681b      	ldr	r3, [r3, #0]
90009f58:	681a      	ldr	r2, [r3, #0]
90009f5a:	687b      	ldr	r3, [r7, #4]
90009f5c:	681b      	ldr	r3, [r3, #0]
90009f5e:	f022 0201 	bic.w	r2, r2, #1
90009f62:	601a      	str	r2, [r3, #0]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
90009f64:	687b      	ldr	r3, [r7, #4]
90009f66:	681b      	ldr	r3, [r3, #0]
90009f68:	4a51      	ldr	r2, [pc, #324]	; (9000a0b0 <HAL_DMA_DeInit+0x220>)
90009f6a:	4293      	cmp	r3, r2
90009f6c:	d04a      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009f6e:	687b      	ldr	r3, [r7, #4]
90009f70:	681b      	ldr	r3, [r3, #0]
90009f72:	4a50      	ldr	r2, [pc, #320]	; (9000a0b4 <HAL_DMA_DeInit+0x224>)
90009f74:	4293      	cmp	r3, r2
90009f76:	d045      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009f78:	687b      	ldr	r3, [r7, #4]
90009f7a:	681b      	ldr	r3, [r3, #0]
90009f7c:	4a4e      	ldr	r2, [pc, #312]	; (9000a0b8 <HAL_DMA_DeInit+0x228>)
90009f7e:	4293      	cmp	r3, r2
90009f80:	d040      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009f82:	687b      	ldr	r3, [r7, #4]
90009f84:	681b      	ldr	r3, [r3, #0]
90009f86:	4a4d      	ldr	r2, [pc, #308]	; (9000a0bc <HAL_DMA_DeInit+0x22c>)
90009f88:	4293      	cmp	r3, r2
90009f8a:	d03b      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009f8c:	687b      	ldr	r3, [r7, #4]
90009f8e:	681b      	ldr	r3, [r3, #0]
90009f90:	4a4b      	ldr	r2, [pc, #300]	; (9000a0c0 <HAL_DMA_DeInit+0x230>)
90009f92:	4293      	cmp	r3, r2
90009f94:	d036      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009f96:	687b      	ldr	r3, [r7, #4]
90009f98:	681b      	ldr	r3, [r3, #0]
90009f9a:	4a4a      	ldr	r2, [pc, #296]	; (9000a0c4 <HAL_DMA_DeInit+0x234>)
90009f9c:	4293      	cmp	r3, r2
90009f9e:	d031      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009fa0:	687b      	ldr	r3, [r7, #4]
90009fa2:	681b      	ldr	r3, [r3, #0]
90009fa4:	4a48      	ldr	r2, [pc, #288]	; (9000a0c8 <HAL_DMA_DeInit+0x238>)
90009fa6:	4293      	cmp	r3, r2
90009fa8:	d02c      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009faa:	687b      	ldr	r3, [r7, #4]
90009fac:	681b      	ldr	r3, [r3, #0]
90009fae:	4a47      	ldr	r2, [pc, #284]	; (9000a0cc <HAL_DMA_DeInit+0x23c>)
90009fb0:	4293      	cmp	r3, r2
90009fb2:	d027      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009fb4:	687b      	ldr	r3, [r7, #4]
90009fb6:	681b      	ldr	r3, [r3, #0]
90009fb8:	4a45      	ldr	r2, [pc, #276]	; (9000a0d0 <HAL_DMA_DeInit+0x240>)
90009fba:	4293      	cmp	r3, r2
90009fbc:	d022      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009fbe:	687b      	ldr	r3, [r7, #4]
90009fc0:	681b      	ldr	r3, [r3, #0]
90009fc2:	4a44      	ldr	r2, [pc, #272]	; (9000a0d4 <HAL_DMA_DeInit+0x244>)
90009fc4:	4293      	cmp	r3, r2
90009fc6:	d01d      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009fc8:	687b      	ldr	r3, [r7, #4]
90009fca:	681b      	ldr	r3, [r3, #0]
90009fcc:	4a42      	ldr	r2, [pc, #264]	; (9000a0d8 <HAL_DMA_DeInit+0x248>)
90009fce:	4293      	cmp	r3, r2
90009fd0:	d018      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009fd2:	687b      	ldr	r3, [r7, #4]
90009fd4:	681b      	ldr	r3, [r3, #0]
90009fd6:	4a41      	ldr	r2, [pc, #260]	; (9000a0dc <HAL_DMA_DeInit+0x24c>)
90009fd8:	4293      	cmp	r3, r2
90009fda:	d013      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009fdc:	687b      	ldr	r3, [r7, #4]
90009fde:	681b      	ldr	r3, [r3, #0]
90009fe0:	4a3f      	ldr	r2, [pc, #252]	; (9000a0e0 <HAL_DMA_DeInit+0x250>)
90009fe2:	4293      	cmp	r3, r2
90009fe4:	d00e      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009fe6:	687b      	ldr	r3, [r7, #4]
90009fe8:	681b      	ldr	r3, [r3, #0]
90009fea:	4a3e      	ldr	r2, [pc, #248]	; (9000a0e4 <HAL_DMA_DeInit+0x254>)
90009fec:	4293      	cmp	r3, r2
90009fee:	d009      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009ff0:	687b      	ldr	r3, [r7, #4]
90009ff2:	681b      	ldr	r3, [r3, #0]
90009ff4:	4a3c      	ldr	r2, [pc, #240]	; (9000a0e8 <HAL_DMA_DeInit+0x258>)
90009ff6:	4293      	cmp	r3, r2
90009ff8:	d004      	beq.n	9000a004 <HAL_DMA_DeInit+0x174>
90009ffa:	687b      	ldr	r3, [r7, #4]
90009ffc:	681b      	ldr	r3, [r3, #0]
90009ffe:	4a3b      	ldr	r2, [pc, #236]	; (9000a0ec <HAL_DMA_DeInit+0x25c>)
9000a000:	4293      	cmp	r3, r2
9000a002:	d101      	bne.n	9000a008 <HAL_DMA_DeInit+0x178>
9000a004:	2301      	movs	r3, #1
9000a006:	e000      	b.n	9000a00a <HAL_DMA_DeInit+0x17a>
9000a008:	2300      	movs	r3, #0
9000a00a:	2b00      	cmp	r3, #0
9000a00c:	d025      	beq.n	9000a05a <HAL_DMA_DeInit+0x1ca>
  {
    /* Reset DMA Streamx control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
9000a00e:	687b      	ldr	r3, [r7, #4]
9000a010:	681b      	ldr	r3, [r3, #0]
9000a012:	2200      	movs	r2, #0
9000a014:	601a      	str	r2, [r3, #0]

    /* Reset DMA Streamx number of data to transfer register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
9000a016:	687b      	ldr	r3, [r7, #4]
9000a018:	681b      	ldr	r3, [r3, #0]
9000a01a:	2200      	movs	r2, #0
9000a01c:	605a      	str	r2, [r3, #4]

    /* Reset DMA Streamx peripheral address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
9000a01e:	687b      	ldr	r3, [r7, #4]
9000a020:	681b      	ldr	r3, [r3, #0]
9000a022:	2200      	movs	r2, #0
9000a024:	609a      	str	r2, [r3, #8]

    /* Reset DMA Streamx memory 0 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
9000a026:	687b      	ldr	r3, [r7, #4]
9000a028:	681b      	ldr	r3, [r3, #0]
9000a02a:	2200      	movs	r2, #0
9000a02c:	60da      	str	r2, [r3, #12]

    /* Reset DMA Streamx memory 1 address register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
9000a02e:	687b      	ldr	r3, [r7, #4]
9000a030:	681b      	ldr	r3, [r3, #0]
9000a032:	2200      	movs	r2, #0
9000a034:	611a      	str	r2, [r3, #16]

    /* Reset DMA Streamx FIFO control register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
9000a036:	687b      	ldr	r3, [r7, #4]
9000a038:	681b      	ldr	r3, [r3, #0]
9000a03a:	2221      	movs	r2, #33	; 0x21
9000a03c:	615a      	str	r2, [r3, #20]

    /* Get DMA steam Base Address */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
9000a03e:	6878      	ldr	r0, [r7, #4]
9000a040:	f001 ff46 	bl	9000bed0 <DMA_CalcBaseAndBitshift>
9000a044:	4603      	mov	r3, r0
9000a046:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
9000a048:	687b      	ldr	r3, [r7, #4]
9000a04a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000a04c:	f003 031f 	and.w	r3, r3, #31
9000a050:	223f      	movs	r2, #63	; 0x3f
9000a052:	409a      	lsls	r2, r3
9000a054:	68bb      	ldr	r3, [r7, #8]
9000a056:	609a      	str	r2, [r3, #8]
9000a058:	e081      	b.n	9000a15e <HAL_DMA_DeInit+0x2ce>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
9000a05a:	687b      	ldr	r3, [r7, #4]
9000a05c:	681b      	ldr	r3, [r3, #0]
9000a05e:	4a24      	ldr	r2, [pc, #144]	; (9000a0f0 <HAL_DMA_DeInit+0x260>)
9000a060:	4293      	cmp	r3, r2
9000a062:	d022      	beq.n	9000a0aa <HAL_DMA_DeInit+0x21a>
9000a064:	687b      	ldr	r3, [r7, #4]
9000a066:	681b      	ldr	r3, [r3, #0]
9000a068:	4a22      	ldr	r2, [pc, #136]	; (9000a0f4 <HAL_DMA_DeInit+0x264>)
9000a06a:	4293      	cmp	r3, r2
9000a06c:	d01d      	beq.n	9000a0aa <HAL_DMA_DeInit+0x21a>
9000a06e:	687b      	ldr	r3, [r7, #4]
9000a070:	681b      	ldr	r3, [r3, #0]
9000a072:	4a21      	ldr	r2, [pc, #132]	; (9000a0f8 <HAL_DMA_DeInit+0x268>)
9000a074:	4293      	cmp	r3, r2
9000a076:	d018      	beq.n	9000a0aa <HAL_DMA_DeInit+0x21a>
9000a078:	687b      	ldr	r3, [r7, #4]
9000a07a:	681b      	ldr	r3, [r3, #0]
9000a07c:	4a1f      	ldr	r2, [pc, #124]	; (9000a0fc <HAL_DMA_DeInit+0x26c>)
9000a07e:	4293      	cmp	r3, r2
9000a080:	d013      	beq.n	9000a0aa <HAL_DMA_DeInit+0x21a>
9000a082:	687b      	ldr	r3, [r7, #4]
9000a084:	681b      	ldr	r3, [r3, #0]
9000a086:	4a1e      	ldr	r2, [pc, #120]	; (9000a100 <HAL_DMA_DeInit+0x270>)
9000a088:	4293      	cmp	r3, r2
9000a08a:	d00e      	beq.n	9000a0aa <HAL_DMA_DeInit+0x21a>
9000a08c:	687b      	ldr	r3, [r7, #4]
9000a08e:	681b      	ldr	r3, [r3, #0]
9000a090:	4a1c      	ldr	r2, [pc, #112]	; (9000a104 <HAL_DMA_DeInit+0x274>)
9000a092:	4293      	cmp	r3, r2
9000a094:	d009      	beq.n	9000a0aa <HAL_DMA_DeInit+0x21a>
9000a096:	687b      	ldr	r3, [r7, #4]
9000a098:	681b      	ldr	r3, [r3, #0]
9000a09a:	4a1b      	ldr	r2, [pc, #108]	; (9000a108 <HAL_DMA_DeInit+0x278>)
9000a09c:	4293      	cmp	r3, r2
9000a09e:	d004      	beq.n	9000a0aa <HAL_DMA_DeInit+0x21a>
9000a0a0:	687b      	ldr	r3, [r7, #4]
9000a0a2:	681b      	ldr	r3, [r3, #0]
9000a0a4:	4a19      	ldr	r2, [pc, #100]	; (9000a10c <HAL_DMA_DeInit+0x27c>)
9000a0a6:	4293      	cmp	r3, r2
9000a0a8:	d132      	bne.n	9000a110 <HAL_DMA_DeInit+0x280>
9000a0aa:	2301      	movs	r3, #1
9000a0ac:	e031      	b.n	9000a112 <HAL_DMA_DeInit+0x282>
9000a0ae:	bf00      	nop
9000a0b0:	40020010 	.word	0x40020010
9000a0b4:	40020028 	.word	0x40020028
9000a0b8:	40020040 	.word	0x40020040
9000a0bc:	40020058 	.word	0x40020058
9000a0c0:	40020070 	.word	0x40020070
9000a0c4:	40020088 	.word	0x40020088
9000a0c8:	400200a0 	.word	0x400200a0
9000a0cc:	400200b8 	.word	0x400200b8
9000a0d0:	40020410 	.word	0x40020410
9000a0d4:	40020428 	.word	0x40020428
9000a0d8:	40020440 	.word	0x40020440
9000a0dc:	40020458 	.word	0x40020458
9000a0e0:	40020470 	.word	0x40020470
9000a0e4:	40020488 	.word	0x40020488
9000a0e8:	400204a0 	.word	0x400204a0
9000a0ec:	400204b8 	.word	0x400204b8
9000a0f0:	58025408 	.word	0x58025408
9000a0f4:	5802541c 	.word	0x5802541c
9000a0f8:	58025430 	.word	0x58025430
9000a0fc:	58025444 	.word	0x58025444
9000a100:	58025458 	.word	0x58025458
9000a104:	5802546c 	.word	0x5802546c
9000a108:	58025480 	.word	0x58025480
9000a10c:	58025494 	.word	0x58025494
9000a110:	2300      	movs	r3, #0
9000a112:	2b00      	cmp	r3, #0
9000a114:	d021      	beq.n	9000a15a <HAL_DMA_DeInit+0x2ca>
  {
    /* Reset DMA Channel control register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
9000a116:	687b      	ldr	r3, [r7, #4]
9000a118:	681b      	ldr	r3, [r3, #0]
9000a11a:	2200      	movs	r2, #0
9000a11c:	601a      	str	r2, [r3, #0]

    /* Reset DMA Channel Number of Data to Transfer register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
9000a11e:	687b      	ldr	r3, [r7, #4]
9000a120:	681b      	ldr	r3, [r3, #0]
9000a122:	2200      	movs	r2, #0
9000a124:	605a      	str	r2, [r3, #4]

    /* Reset DMA Channel peripheral address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
9000a126:	687b      	ldr	r3, [r7, #4]
9000a128:	681b      	ldr	r3, [r3, #0]
9000a12a:	2200      	movs	r2, #0
9000a12c:	609a      	str	r2, [r3, #8]

    /* Reset DMA Channel memory 0 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
9000a12e:	687b      	ldr	r3, [r7, #4]
9000a130:	681b      	ldr	r3, [r3, #0]
9000a132:	2200      	movs	r2, #0
9000a134:	60da      	str	r2, [r3, #12]

    /* Reset DMA Channel memory 1 address register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
9000a136:	687b      	ldr	r3, [r7, #4]
9000a138:	681b      	ldr	r3, [r3, #0]
9000a13a:	2200      	movs	r2, #0
9000a13c:	611a      	str	r2, [r3, #16]

    /* Get DMA steam Base Address */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
9000a13e:	6878      	ldr	r0, [r7, #4]
9000a140:	f001 fec6 	bl	9000bed0 <DMA_CalcBaseAndBitshift>
9000a144:	4603      	mov	r3, r0
9000a146:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags at correct offset within the register */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
9000a148:	687b      	ldr	r3, [r7, #4]
9000a14a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000a14c:	f003 031f 	and.w	r3, r3, #31
9000a150:	2201      	movs	r2, #1
9000a152:	409a      	lsls	r2, r3
9000a154:	68fb      	ldr	r3, [r7, #12]
9000a156:	605a      	str	r2, [r3, #4]
9000a158:	e001      	b.n	9000a15e <HAL_DMA_DeInit+0x2ce>
  }
  else
  {
    /* Return error status */
    return HAL_ERROR;
9000a15a:	2301      	movs	r3, #1
9000a15c:	e04a      	b.n	9000a1f4 <HAL_DMA_DeInit+0x364>
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
#endif /* BDMA1 */
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
9000a15e:	6878      	ldr	r0, [r7, #4]
9000a160:	f001 ffe4 	bl	9000c12c <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->DMAmuxChannel != 0U)
9000a164:	687b      	ldr	r3, [r7, #4]
9000a166:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000a168:	2b00      	cmp	r3, #0
9000a16a:	d008      	beq.n	9000a17e <HAL_DMA_DeInit+0x2ee>
    {
      /* Resett he DMAMUX channel that corresponds to the DMA stream */
      hdma->DMAmuxChannel->CCR = 0U;
9000a16c:	687b      	ldr	r3, [r7, #4]
9000a16e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000a170:	2200      	movs	r2, #0
9000a172:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
9000a174:	687b      	ldr	r3, [r7, #4]
9000a176:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000a178:	687a      	ldr	r2, [r7, #4]
9000a17a:	6e92      	ldr	r2, [r2, #104]	; 0x68
9000a17c:	605a      	str	r2, [r3, #4]
    }

    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
9000a17e:	687b      	ldr	r3, [r7, #4]
9000a180:	685b      	ldr	r3, [r3, #4]
9000a182:	2b00      	cmp	r3, #0
9000a184:	d00f      	beq.n	9000a1a6 <HAL_DMA_DeInit+0x316>
9000a186:	687b      	ldr	r3, [r7, #4]
9000a188:	685b      	ldr	r3, [r3, #4]
9000a18a:	2b08      	cmp	r3, #8
9000a18c:	d80b      	bhi.n	9000a1a6 <HAL_DMA_DeInit+0x316>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
9000a18e:	6878      	ldr	r0, [r7, #4]
9000a190:	f002 f866 	bl	9000c260 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
9000a194:	687b      	ldr	r3, [r7, #4]
9000a196:	6edb      	ldr	r3, [r3, #108]	; 0x6c
9000a198:	2200      	movs	r2, #0
9000a19a:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
9000a19c:	687b      	ldr	r3, [r7, #4]
9000a19e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
9000a1a0:	687a      	ldr	r2, [r7, #4]
9000a1a2:	6f52      	ldr	r2, [r2, #116]	; 0x74
9000a1a4:	605a      	str	r2, [r3, #4]
    }

    hdma->DMAmuxRequestGen = 0U;
9000a1a6:	687b      	ldr	r3, [r7, #4]
9000a1a8:	2200      	movs	r2, #0
9000a1aa:	66da      	str	r2, [r3, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatus = 0U;
9000a1ac:	687b      	ldr	r3, [r7, #4]
9000a1ae:	2200      	movs	r2, #0
9000a1b0:	671a      	str	r2, [r3, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 0U;
9000a1b2:	687b      	ldr	r3, [r7, #4]
9000a1b4:	2200      	movs	r2, #0
9000a1b6:	675a      	str	r2, [r3, #116]	; 0x74
  }


  /* Clean callbacks */
  hdma->XferCpltCallback       = NULL;
9000a1b8:	687b      	ldr	r3, [r7, #4]
9000a1ba:	2200      	movs	r2, #0
9000a1bc:	63da      	str	r2, [r3, #60]	; 0x3c
  hdma->XferHalfCpltCallback   = NULL;
9000a1be:	687b      	ldr	r3, [r7, #4]
9000a1c0:	2200      	movs	r2, #0
9000a1c2:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->XferM1CpltCallback     = NULL;
9000a1c4:	687b      	ldr	r3, [r7, #4]
9000a1c6:	2200      	movs	r2, #0
9000a1c8:	645a      	str	r2, [r3, #68]	; 0x44
  hdma->XferM1HalfCpltCallback = NULL;
9000a1ca:	687b      	ldr	r3, [r7, #4]
9000a1cc:	2200      	movs	r2, #0
9000a1ce:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->XferErrorCallback      = NULL;
9000a1d0:	687b      	ldr	r3, [r7, #4]
9000a1d2:	2200      	movs	r2, #0
9000a1d4:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->XferAbortCallback      = NULL;
9000a1d6:	687b      	ldr	r3, [r7, #4]
9000a1d8:	2200      	movs	r2, #0
9000a1da:	651a      	str	r2, [r3, #80]	; 0x50

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
9000a1dc:	687b      	ldr	r3, [r7, #4]
9000a1de:	2200      	movs	r2, #0
9000a1e0:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
9000a1e2:	687b      	ldr	r3, [r7, #4]
9000a1e4:	2200      	movs	r2, #0
9000a1e6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
9000a1ea:	687b      	ldr	r3, [r7, #4]
9000a1ec:	2200      	movs	r2, #0
9000a1ee:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
9000a1f2:	2300      	movs	r3, #0
}
9000a1f4:	4618      	mov	r0, r3
9000a1f6:	3710      	adds	r7, #16
9000a1f8:	46bd      	mov	sp, r7
9000a1fa:	bd80      	pop	{r7, pc}

9000a1fc <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
9000a1fc:	b580      	push	{r7, lr}
9000a1fe:	b086      	sub	sp, #24
9000a200:	af00      	add	r7, sp, #0
9000a202:	60f8      	str	r0, [r7, #12]
9000a204:	60b9      	str	r1, [r7, #8]
9000a206:	607a      	str	r2, [r7, #4]
9000a208:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
9000a20a:	2300      	movs	r3, #0
9000a20c:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
9000a20e:	68fb      	ldr	r3, [r7, #12]
9000a210:	2b00      	cmp	r3, #0
9000a212:	d101      	bne.n	9000a218 <HAL_DMA_Start_IT+0x1c>
  {
    return HAL_ERROR;
9000a214:	2301      	movs	r3, #1
9000a216:	e226      	b.n	9000a666 <HAL_DMA_Start_IT+0x46a>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
9000a218:	68fb      	ldr	r3, [r7, #12]
9000a21a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
9000a21e:	2b01      	cmp	r3, #1
9000a220:	d101      	bne.n	9000a226 <HAL_DMA_Start_IT+0x2a>
9000a222:	2302      	movs	r3, #2
9000a224:	e21f      	b.n	9000a666 <HAL_DMA_Start_IT+0x46a>
9000a226:	68fb      	ldr	r3, [r7, #12]
9000a228:	2201      	movs	r2, #1
9000a22a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
9000a22e:	68fb      	ldr	r3, [r7, #12]
9000a230:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
9000a234:	b2db      	uxtb	r3, r3
9000a236:	2b01      	cmp	r3, #1
9000a238:	f040 820a 	bne.w	9000a650 <HAL_DMA_Start_IT+0x454>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
9000a23c:	68fb      	ldr	r3, [r7, #12]
9000a23e:	2202      	movs	r2, #2
9000a240:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
9000a244:	68fb      	ldr	r3, [r7, #12]
9000a246:	2200      	movs	r2, #0
9000a248:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
9000a24a:	68fb      	ldr	r3, [r7, #12]
9000a24c:	681b      	ldr	r3, [r3, #0]
9000a24e:	4a68      	ldr	r2, [pc, #416]	; (9000a3f0 <HAL_DMA_Start_IT+0x1f4>)
9000a250:	4293      	cmp	r3, r2
9000a252:	d04a      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a254:	68fb      	ldr	r3, [r7, #12]
9000a256:	681b      	ldr	r3, [r3, #0]
9000a258:	4a66      	ldr	r2, [pc, #408]	; (9000a3f4 <HAL_DMA_Start_IT+0x1f8>)
9000a25a:	4293      	cmp	r3, r2
9000a25c:	d045      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a25e:	68fb      	ldr	r3, [r7, #12]
9000a260:	681b      	ldr	r3, [r3, #0]
9000a262:	4a65      	ldr	r2, [pc, #404]	; (9000a3f8 <HAL_DMA_Start_IT+0x1fc>)
9000a264:	4293      	cmp	r3, r2
9000a266:	d040      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a268:	68fb      	ldr	r3, [r7, #12]
9000a26a:	681b      	ldr	r3, [r3, #0]
9000a26c:	4a63      	ldr	r2, [pc, #396]	; (9000a3fc <HAL_DMA_Start_IT+0x200>)
9000a26e:	4293      	cmp	r3, r2
9000a270:	d03b      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a272:	68fb      	ldr	r3, [r7, #12]
9000a274:	681b      	ldr	r3, [r3, #0]
9000a276:	4a62      	ldr	r2, [pc, #392]	; (9000a400 <HAL_DMA_Start_IT+0x204>)
9000a278:	4293      	cmp	r3, r2
9000a27a:	d036      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a27c:	68fb      	ldr	r3, [r7, #12]
9000a27e:	681b      	ldr	r3, [r3, #0]
9000a280:	4a60      	ldr	r2, [pc, #384]	; (9000a404 <HAL_DMA_Start_IT+0x208>)
9000a282:	4293      	cmp	r3, r2
9000a284:	d031      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a286:	68fb      	ldr	r3, [r7, #12]
9000a288:	681b      	ldr	r3, [r3, #0]
9000a28a:	4a5f      	ldr	r2, [pc, #380]	; (9000a408 <HAL_DMA_Start_IT+0x20c>)
9000a28c:	4293      	cmp	r3, r2
9000a28e:	d02c      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a290:	68fb      	ldr	r3, [r7, #12]
9000a292:	681b      	ldr	r3, [r3, #0]
9000a294:	4a5d      	ldr	r2, [pc, #372]	; (9000a40c <HAL_DMA_Start_IT+0x210>)
9000a296:	4293      	cmp	r3, r2
9000a298:	d027      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a29a:	68fb      	ldr	r3, [r7, #12]
9000a29c:	681b      	ldr	r3, [r3, #0]
9000a29e:	4a5c      	ldr	r2, [pc, #368]	; (9000a410 <HAL_DMA_Start_IT+0x214>)
9000a2a0:	4293      	cmp	r3, r2
9000a2a2:	d022      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a2a4:	68fb      	ldr	r3, [r7, #12]
9000a2a6:	681b      	ldr	r3, [r3, #0]
9000a2a8:	4a5a      	ldr	r2, [pc, #360]	; (9000a414 <HAL_DMA_Start_IT+0x218>)
9000a2aa:	4293      	cmp	r3, r2
9000a2ac:	d01d      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a2ae:	68fb      	ldr	r3, [r7, #12]
9000a2b0:	681b      	ldr	r3, [r3, #0]
9000a2b2:	4a59      	ldr	r2, [pc, #356]	; (9000a418 <HAL_DMA_Start_IT+0x21c>)
9000a2b4:	4293      	cmp	r3, r2
9000a2b6:	d018      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a2b8:	68fb      	ldr	r3, [r7, #12]
9000a2ba:	681b      	ldr	r3, [r3, #0]
9000a2bc:	4a57      	ldr	r2, [pc, #348]	; (9000a41c <HAL_DMA_Start_IT+0x220>)
9000a2be:	4293      	cmp	r3, r2
9000a2c0:	d013      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a2c2:	68fb      	ldr	r3, [r7, #12]
9000a2c4:	681b      	ldr	r3, [r3, #0]
9000a2c6:	4a56      	ldr	r2, [pc, #344]	; (9000a420 <HAL_DMA_Start_IT+0x224>)
9000a2c8:	4293      	cmp	r3, r2
9000a2ca:	d00e      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a2cc:	68fb      	ldr	r3, [r7, #12]
9000a2ce:	681b      	ldr	r3, [r3, #0]
9000a2d0:	4a54      	ldr	r2, [pc, #336]	; (9000a424 <HAL_DMA_Start_IT+0x228>)
9000a2d2:	4293      	cmp	r3, r2
9000a2d4:	d009      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a2d6:	68fb      	ldr	r3, [r7, #12]
9000a2d8:	681b      	ldr	r3, [r3, #0]
9000a2da:	4a53      	ldr	r2, [pc, #332]	; (9000a428 <HAL_DMA_Start_IT+0x22c>)
9000a2dc:	4293      	cmp	r3, r2
9000a2de:	d004      	beq.n	9000a2ea <HAL_DMA_Start_IT+0xee>
9000a2e0:	68fb      	ldr	r3, [r7, #12]
9000a2e2:	681b      	ldr	r3, [r3, #0]
9000a2e4:	4a51      	ldr	r2, [pc, #324]	; (9000a42c <HAL_DMA_Start_IT+0x230>)
9000a2e6:	4293      	cmp	r3, r2
9000a2e8:	d108      	bne.n	9000a2fc <HAL_DMA_Start_IT+0x100>
9000a2ea:	68fb      	ldr	r3, [r7, #12]
9000a2ec:	681b      	ldr	r3, [r3, #0]
9000a2ee:	681a      	ldr	r2, [r3, #0]
9000a2f0:	68fb      	ldr	r3, [r7, #12]
9000a2f2:	681b      	ldr	r3, [r3, #0]
9000a2f4:	f022 0201 	bic.w	r2, r2, #1
9000a2f8:	601a      	str	r2, [r3, #0]
9000a2fa:	e007      	b.n	9000a30c <HAL_DMA_Start_IT+0x110>
9000a2fc:	68fb      	ldr	r3, [r7, #12]
9000a2fe:	681b      	ldr	r3, [r3, #0]
9000a300:	681a      	ldr	r2, [r3, #0]
9000a302:	68fb      	ldr	r3, [r7, #12]
9000a304:	681b      	ldr	r3, [r3, #0]
9000a306:	f022 0201 	bic.w	r2, r2, #1
9000a30a:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
9000a30c:	683b      	ldr	r3, [r7, #0]
9000a30e:	687a      	ldr	r2, [r7, #4]
9000a310:	68b9      	ldr	r1, [r7, #8]
9000a312:	68f8      	ldr	r0, [r7, #12]
9000a314:	f001 fc30 	bl	9000bb78 <DMA_SetConfig>

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
9000a318:	68fb      	ldr	r3, [r7, #12]
9000a31a:	681b      	ldr	r3, [r3, #0]
9000a31c:	4a34      	ldr	r2, [pc, #208]	; (9000a3f0 <HAL_DMA_Start_IT+0x1f4>)
9000a31e:	4293      	cmp	r3, r2
9000a320:	d04a      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a322:	68fb      	ldr	r3, [r7, #12]
9000a324:	681b      	ldr	r3, [r3, #0]
9000a326:	4a33      	ldr	r2, [pc, #204]	; (9000a3f4 <HAL_DMA_Start_IT+0x1f8>)
9000a328:	4293      	cmp	r3, r2
9000a32a:	d045      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a32c:	68fb      	ldr	r3, [r7, #12]
9000a32e:	681b      	ldr	r3, [r3, #0]
9000a330:	4a31      	ldr	r2, [pc, #196]	; (9000a3f8 <HAL_DMA_Start_IT+0x1fc>)
9000a332:	4293      	cmp	r3, r2
9000a334:	d040      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a336:	68fb      	ldr	r3, [r7, #12]
9000a338:	681b      	ldr	r3, [r3, #0]
9000a33a:	4a30      	ldr	r2, [pc, #192]	; (9000a3fc <HAL_DMA_Start_IT+0x200>)
9000a33c:	4293      	cmp	r3, r2
9000a33e:	d03b      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a340:	68fb      	ldr	r3, [r7, #12]
9000a342:	681b      	ldr	r3, [r3, #0]
9000a344:	4a2e      	ldr	r2, [pc, #184]	; (9000a400 <HAL_DMA_Start_IT+0x204>)
9000a346:	4293      	cmp	r3, r2
9000a348:	d036      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a34a:	68fb      	ldr	r3, [r7, #12]
9000a34c:	681b      	ldr	r3, [r3, #0]
9000a34e:	4a2d      	ldr	r2, [pc, #180]	; (9000a404 <HAL_DMA_Start_IT+0x208>)
9000a350:	4293      	cmp	r3, r2
9000a352:	d031      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a354:	68fb      	ldr	r3, [r7, #12]
9000a356:	681b      	ldr	r3, [r3, #0]
9000a358:	4a2b      	ldr	r2, [pc, #172]	; (9000a408 <HAL_DMA_Start_IT+0x20c>)
9000a35a:	4293      	cmp	r3, r2
9000a35c:	d02c      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a35e:	68fb      	ldr	r3, [r7, #12]
9000a360:	681b      	ldr	r3, [r3, #0]
9000a362:	4a2a      	ldr	r2, [pc, #168]	; (9000a40c <HAL_DMA_Start_IT+0x210>)
9000a364:	4293      	cmp	r3, r2
9000a366:	d027      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a368:	68fb      	ldr	r3, [r7, #12]
9000a36a:	681b      	ldr	r3, [r3, #0]
9000a36c:	4a28      	ldr	r2, [pc, #160]	; (9000a410 <HAL_DMA_Start_IT+0x214>)
9000a36e:	4293      	cmp	r3, r2
9000a370:	d022      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a372:	68fb      	ldr	r3, [r7, #12]
9000a374:	681b      	ldr	r3, [r3, #0]
9000a376:	4a27      	ldr	r2, [pc, #156]	; (9000a414 <HAL_DMA_Start_IT+0x218>)
9000a378:	4293      	cmp	r3, r2
9000a37a:	d01d      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a37c:	68fb      	ldr	r3, [r7, #12]
9000a37e:	681b      	ldr	r3, [r3, #0]
9000a380:	4a25      	ldr	r2, [pc, #148]	; (9000a418 <HAL_DMA_Start_IT+0x21c>)
9000a382:	4293      	cmp	r3, r2
9000a384:	d018      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a386:	68fb      	ldr	r3, [r7, #12]
9000a388:	681b      	ldr	r3, [r3, #0]
9000a38a:	4a24      	ldr	r2, [pc, #144]	; (9000a41c <HAL_DMA_Start_IT+0x220>)
9000a38c:	4293      	cmp	r3, r2
9000a38e:	d013      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a390:	68fb      	ldr	r3, [r7, #12]
9000a392:	681b      	ldr	r3, [r3, #0]
9000a394:	4a22      	ldr	r2, [pc, #136]	; (9000a420 <HAL_DMA_Start_IT+0x224>)
9000a396:	4293      	cmp	r3, r2
9000a398:	d00e      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a39a:	68fb      	ldr	r3, [r7, #12]
9000a39c:	681b      	ldr	r3, [r3, #0]
9000a39e:	4a21      	ldr	r2, [pc, #132]	; (9000a424 <HAL_DMA_Start_IT+0x228>)
9000a3a0:	4293      	cmp	r3, r2
9000a3a2:	d009      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a3a4:	68fb      	ldr	r3, [r7, #12]
9000a3a6:	681b      	ldr	r3, [r3, #0]
9000a3a8:	4a1f      	ldr	r2, [pc, #124]	; (9000a428 <HAL_DMA_Start_IT+0x22c>)
9000a3aa:	4293      	cmp	r3, r2
9000a3ac:	d004      	beq.n	9000a3b8 <HAL_DMA_Start_IT+0x1bc>
9000a3ae:	68fb      	ldr	r3, [r7, #12]
9000a3b0:	681b      	ldr	r3, [r3, #0]
9000a3b2:	4a1e      	ldr	r2, [pc, #120]	; (9000a42c <HAL_DMA_Start_IT+0x230>)
9000a3b4:	4293      	cmp	r3, r2
9000a3b6:	d101      	bne.n	9000a3bc <HAL_DMA_Start_IT+0x1c0>
9000a3b8:	2301      	movs	r3, #1
9000a3ba:	e000      	b.n	9000a3be <HAL_DMA_Start_IT+0x1c2>
9000a3bc:	2300      	movs	r3, #0
9000a3be:	2b00      	cmp	r3, #0
9000a3c0:	d036      	beq.n	9000a430 <HAL_DMA_Start_IT+0x234>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
9000a3c2:	68fb      	ldr	r3, [r7, #12]
9000a3c4:	681b      	ldr	r3, [r3, #0]
9000a3c6:	681b      	ldr	r3, [r3, #0]
9000a3c8:	f023 021e 	bic.w	r2, r3, #30
9000a3cc:	68fb      	ldr	r3, [r7, #12]
9000a3ce:	681b      	ldr	r3, [r3, #0]
9000a3d0:	f042 0216 	orr.w	r2, r2, #22
9000a3d4:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
9000a3d6:	68fb      	ldr	r3, [r7, #12]
9000a3d8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000a3da:	2b00      	cmp	r3, #0
9000a3dc:	d03e      	beq.n	9000a45c <HAL_DMA_Start_IT+0x260>
      {
        /* Enable Half Transfer IT if corresponding Callback is set */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
9000a3de:	68fb      	ldr	r3, [r7, #12]
9000a3e0:	681b      	ldr	r3, [r3, #0]
9000a3e2:	681a      	ldr	r2, [r3, #0]
9000a3e4:	68fb      	ldr	r3, [r7, #12]
9000a3e6:	681b      	ldr	r3, [r3, #0]
9000a3e8:	f042 0208 	orr.w	r2, r2, #8
9000a3ec:	601a      	str	r2, [r3, #0]
9000a3ee:	e035      	b.n	9000a45c <HAL_DMA_Start_IT+0x260>
9000a3f0:	40020010 	.word	0x40020010
9000a3f4:	40020028 	.word	0x40020028
9000a3f8:	40020040 	.word	0x40020040
9000a3fc:	40020058 	.word	0x40020058
9000a400:	40020070 	.word	0x40020070
9000a404:	40020088 	.word	0x40020088
9000a408:	400200a0 	.word	0x400200a0
9000a40c:	400200b8 	.word	0x400200b8
9000a410:	40020410 	.word	0x40020410
9000a414:	40020428 	.word	0x40020428
9000a418:	40020440 	.word	0x40020440
9000a41c:	40020458 	.word	0x40020458
9000a420:	40020470 	.word	0x40020470
9000a424:	40020488 	.word	0x40020488
9000a428:	400204a0 	.word	0x400204a0
9000a42c:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA channel */
    {
      /* Enable Common interrupts */
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
9000a430:	68fb      	ldr	r3, [r7, #12]
9000a432:	681b      	ldr	r3, [r3, #0]
9000a434:	681b      	ldr	r3, [r3, #0]
9000a436:	f023 020e 	bic.w	r2, r3, #14
9000a43a:	68fb      	ldr	r3, [r7, #12]
9000a43c:	681b      	ldr	r3, [r3, #0]
9000a43e:	f042 020a 	orr.w	r2, r2, #10
9000a442:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
9000a444:	68fb      	ldr	r3, [r7, #12]
9000a446:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000a448:	2b00      	cmp	r3, #0
9000a44a:	d007      	beq.n	9000a45c <HAL_DMA_Start_IT+0x260>
      {
        /*Enable Half Transfer IT if corresponding Callback is set */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
9000a44c:	68fb      	ldr	r3, [r7, #12]
9000a44e:	681b      	ldr	r3, [r3, #0]
9000a450:	681a      	ldr	r2, [r3, #0]
9000a452:	68fb      	ldr	r3, [r7, #12]
9000a454:	681b      	ldr	r3, [r3, #0]
9000a456:	f042 0204 	orr.w	r2, r2, #4
9000a45a:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
9000a45c:	68fb      	ldr	r3, [r7, #12]
9000a45e:	681b      	ldr	r3, [r3, #0]
9000a460:	4a83      	ldr	r2, [pc, #524]	; (9000a670 <HAL_DMA_Start_IT+0x474>)
9000a462:	4293      	cmp	r3, r2
9000a464:	d072      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a466:	68fb      	ldr	r3, [r7, #12]
9000a468:	681b      	ldr	r3, [r3, #0]
9000a46a:	4a82      	ldr	r2, [pc, #520]	; (9000a674 <HAL_DMA_Start_IT+0x478>)
9000a46c:	4293      	cmp	r3, r2
9000a46e:	d06d      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a470:	68fb      	ldr	r3, [r7, #12]
9000a472:	681b      	ldr	r3, [r3, #0]
9000a474:	4a80      	ldr	r2, [pc, #512]	; (9000a678 <HAL_DMA_Start_IT+0x47c>)
9000a476:	4293      	cmp	r3, r2
9000a478:	d068      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a47a:	68fb      	ldr	r3, [r7, #12]
9000a47c:	681b      	ldr	r3, [r3, #0]
9000a47e:	4a7f      	ldr	r2, [pc, #508]	; (9000a67c <HAL_DMA_Start_IT+0x480>)
9000a480:	4293      	cmp	r3, r2
9000a482:	d063      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a484:	68fb      	ldr	r3, [r7, #12]
9000a486:	681b      	ldr	r3, [r3, #0]
9000a488:	4a7d      	ldr	r2, [pc, #500]	; (9000a680 <HAL_DMA_Start_IT+0x484>)
9000a48a:	4293      	cmp	r3, r2
9000a48c:	d05e      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a48e:	68fb      	ldr	r3, [r7, #12]
9000a490:	681b      	ldr	r3, [r3, #0]
9000a492:	4a7c      	ldr	r2, [pc, #496]	; (9000a684 <HAL_DMA_Start_IT+0x488>)
9000a494:	4293      	cmp	r3, r2
9000a496:	d059      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a498:	68fb      	ldr	r3, [r7, #12]
9000a49a:	681b      	ldr	r3, [r3, #0]
9000a49c:	4a7a      	ldr	r2, [pc, #488]	; (9000a688 <HAL_DMA_Start_IT+0x48c>)
9000a49e:	4293      	cmp	r3, r2
9000a4a0:	d054      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a4a2:	68fb      	ldr	r3, [r7, #12]
9000a4a4:	681b      	ldr	r3, [r3, #0]
9000a4a6:	4a79      	ldr	r2, [pc, #484]	; (9000a68c <HAL_DMA_Start_IT+0x490>)
9000a4a8:	4293      	cmp	r3, r2
9000a4aa:	d04f      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a4ac:	68fb      	ldr	r3, [r7, #12]
9000a4ae:	681b      	ldr	r3, [r3, #0]
9000a4b0:	4a77      	ldr	r2, [pc, #476]	; (9000a690 <HAL_DMA_Start_IT+0x494>)
9000a4b2:	4293      	cmp	r3, r2
9000a4b4:	d04a      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a4b6:	68fb      	ldr	r3, [r7, #12]
9000a4b8:	681b      	ldr	r3, [r3, #0]
9000a4ba:	4a76      	ldr	r2, [pc, #472]	; (9000a694 <HAL_DMA_Start_IT+0x498>)
9000a4bc:	4293      	cmp	r3, r2
9000a4be:	d045      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a4c0:	68fb      	ldr	r3, [r7, #12]
9000a4c2:	681b      	ldr	r3, [r3, #0]
9000a4c4:	4a74      	ldr	r2, [pc, #464]	; (9000a698 <HAL_DMA_Start_IT+0x49c>)
9000a4c6:	4293      	cmp	r3, r2
9000a4c8:	d040      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a4ca:	68fb      	ldr	r3, [r7, #12]
9000a4cc:	681b      	ldr	r3, [r3, #0]
9000a4ce:	4a73      	ldr	r2, [pc, #460]	; (9000a69c <HAL_DMA_Start_IT+0x4a0>)
9000a4d0:	4293      	cmp	r3, r2
9000a4d2:	d03b      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a4d4:	68fb      	ldr	r3, [r7, #12]
9000a4d6:	681b      	ldr	r3, [r3, #0]
9000a4d8:	4a71      	ldr	r2, [pc, #452]	; (9000a6a0 <HAL_DMA_Start_IT+0x4a4>)
9000a4da:	4293      	cmp	r3, r2
9000a4dc:	d036      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a4de:	68fb      	ldr	r3, [r7, #12]
9000a4e0:	681b      	ldr	r3, [r3, #0]
9000a4e2:	4a70      	ldr	r2, [pc, #448]	; (9000a6a4 <HAL_DMA_Start_IT+0x4a8>)
9000a4e4:	4293      	cmp	r3, r2
9000a4e6:	d031      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a4e8:	68fb      	ldr	r3, [r7, #12]
9000a4ea:	681b      	ldr	r3, [r3, #0]
9000a4ec:	4a6e      	ldr	r2, [pc, #440]	; (9000a6a8 <HAL_DMA_Start_IT+0x4ac>)
9000a4ee:	4293      	cmp	r3, r2
9000a4f0:	d02c      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a4f2:	68fb      	ldr	r3, [r7, #12]
9000a4f4:	681b      	ldr	r3, [r3, #0]
9000a4f6:	4a6d      	ldr	r2, [pc, #436]	; (9000a6ac <HAL_DMA_Start_IT+0x4b0>)
9000a4f8:	4293      	cmp	r3, r2
9000a4fa:	d027      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a4fc:	68fb      	ldr	r3, [r7, #12]
9000a4fe:	681b      	ldr	r3, [r3, #0]
9000a500:	4a6b      	ldr	r2, [pc, #428]	; (9000a6b0 <HAL_DMA_Start_IT+0x4b4>)
9000a502:	4293      	cmp	r3, r2
9000a504:	d022      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a506:	68fb      	ldr	r3, [r7, #12]
9000a508:	681b      	ldr	r3, [r3, #0]
9000a50a:	4a6a      	ldr	r2, [pc, #424]	; (9000a6b4 <HAL_DMA_Start_IT+0x4b8>)
9000a50c:	4293      	cmp	r3, r2
9000a50e:	d01d      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a510:	68fb      	ldr	r3, [r7, #12]
9000a512:	681b      	ldr	r3, [r3, #0]
9000a514:	4a68      	ldr	r2, [pc, #416]	; (9000a6b8 <HAL_DMA_Start_IT+0x4bc>)
9000a516:	4293      	cmp	r3, r2
9000a518:	d018      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a51a:	68fb      	ldr	r3, [r7, #12]
9000a51c:	681b      	ldr	r3, [r3, #0]
9000a51e:	4a67      	ldr	r2, [pc, #412]	; (9000a6bc <HAL_DMA_Start_IT+0x4c0>)
9000a520:	4293      	cmp	r3, r2
9000a522:	d013      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a524:	68fb      	ldr	r3, [r7, #12]
9000a526:	681b      	ldr	r3, [r3, #0]
9000a528:	4a65      	ldr	r2, [pc, #404]	; (9000a6c0 <HAL_DMA_Start_IT+0x4c4>)
9000a52a:	4293      	cmp	r3, r2
9000a52c:	d00e      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a52e:	68fb      	ldr	r3, [r7, #12]
9000a530:	681b      	ldr	r3, [r3, #0]
9000a532:	4a64      	ldr	r2, [pc, #400]	; (9000a6c4 <HAL_DMA_Start_IT+0x4c8>)
9000a534:	4293      	cmp	r3, r2
9000a536:	d009      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a538:	68fb      	ldr	r3, [r7, #12]
9000a53a:	681b      	ldr	r3, [r3, #0]
9000a53c:	4a62      	ldr	r2, [pc, #392]	; (9000a6c8 <HAL_DMA_Start_IT+0x4cc>)
9000a53e:	4293      	cmp	r3, r2
9000a540:	d004      	beq.n	9000a54c <HAL_DMA_Start_IT+0x350>
9000a542:	68fb      	ldr	r3, [r7, #12]
9000a544:	681b      	ldr	r3, [r3, #0]
9000a546:	4a61      	ldr	r2, [pc, #388]	; (9000a6cc <HAL_DMA_Start_IT+0x4d0>)
9000a548:	4293      	cmp	r3, r2
9000a54a:	d101      	bne.n	9000a550 <HAL_DMA_Start_IT+0x354>
9000a54c:	2301      	movs	r3, #1
9000a54e:	e000      	b.n	9000a552 <HAL_DMA_Start_IT+0x356>
9000a550:	2300      	movs	r3, #0
9000a552:	2b00      	cmp	r3, #0
9000a554:	d01a      	beq.n	9000a58c <HAL_DMA_Start_IT+0x390>
    {
      /* Check if DMAMUX Synchronization is enabled */
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
9000a556:	68fb      	ldr	r3, [r7, #12]
9000a558:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000a55a:	681b      	ldr	r3, [r3, #0]
9000a55c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
9000a560:	2b00      	cmp	r3, #0
9000a562:	d007      	beq.n	9000a574 <HAL_DMA_Start_IT+0x378>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
9000a564:	68fb      	ldr	r3, [r7, #12]
9000a566:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000a568:	681a      	ldr	r2, [r3, #0]
9000a56a:	68fb      	ldr	r3, [r7, #12]
9000a56c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000a56e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
9000a572:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
9000a574:	68fb      	ldr	r3, [r7, #12]
9000a576:	6edb      	ldr	r3, [r3, #108]	; 0x6c
9000a578:	2b00      	cmp	r3, #0
9000a57a:	d007      	beq.n	9000a58c <HAL_DMA_Start_IT+0x390>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
9000a57c:	68fb      	ldr	r3, [r7, #12]
9000a57e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
9000a580:	681a      	ldr	r2, [r3, #0]
9000a582:	68fb      	ldr	r3, [r7, #12]
9000a584:	6edb      	ldr	r3, [r3, #108]	; 0x6c
9000a586:	f442 7280 	orr.w	r2, r2, #256	; 0x100
9000a58a:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
9000a58c:	68fb      	ldr	r3, [r7, #12]
9000a58e:	681b      	ldr	r3, [r3, #0]
9000a590:	4a37      	ldr	r2, [pc, #220]	; (9000a670 <HAL_DMA_Start_IT+0x474>)
9000a592:	4293      	cmp	r3, r2
9000a594:	d04a      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a596:	68fb      	ldr	r3, [r7, #12]
9000a598:	681b      	ldr	r3, [r3, #0]
9000a59a:	4a36      	ldr	r2, [pc, #216]	; (9000a674 <HAL_DMA_Start_IT+0x478>)
9000a59c:	4293      	cmp	r3, r2
9000a59e:	d045      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a5a0:	68fb      	ldr	r3, [r7, #12]
9000a5a2:	681b      	ldr	r3, [r3, #0]
9000a5a4:	4a34      	ldr	r2, [pc, #208]	; (9000a678 <HAL_DMA_Start_IT+0x47c>)
9000a5a6:	4293      	cmp	r3, r2
9000a5a8:	d040      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a5aa:	68fb      	ldr	r3, [r7, #12]
9000a5ac:	681b      	ldr	r3, [r3, #0]
9000a5ae:	4a33      	ldr	r2, [pc, #204]	; (9000a67c <HAL_DMA_Start_IT+0x480>)
9000a5b0:	4293      	cmp	r3, r2
9000a5b2:	d03b      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a5b4:	68fb      	ldr	r3, [r7, #12]
9000a5b6:	681b      	ldr	r3, [r3, #0]
9000a5b8:	4a31      	ldr	r2, [pc, #196]	; (9000a680 <HAL_DMA_Start_IT+0x484>)
9000a5ba:	4293      	cmp	r3, r2
9000a5bc:	d036      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a5be:	68fb      	ldr	r3, [r7, #12]
9000a5c0:	681b      	ldr	r3, [r3, #0]
9000a5c2:	4a30      	ldr	r2, [pc, #192]	; (9000a684 <HAL_DMA_Start_IT+0x488>)
9000a5c4:	4293      	cmp	r3, r2
9000a5c6:	d031      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a5c8:	68fb      	ldr	r3, [r7, #12]
9000a5ca:	681b      	ldr	r3, [r3, #0]
9000a5cc:	4a2e      	ldr	r2, [pc, #184]	; (9000a688 <HAL_DMA_Start_IT+0x48c>)
9000a5ce:	4293      	cmp	r3, r2
9000a5d0:	d02c      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a5d2:	68fb      	ldr	r3, [r7, #12]
9000a5d4:	681b      	ldr	r3, [r3, #0]
9000a5d6:	4a2d      	ldr	r2, [pc, #180]	; (9000a68c <HAL_DMA_Start_IT+0x490>)
9000a5d8:	4293      	cmp	r3, r2
9000a5da:	d027      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a5dc:	68fb      	ldr	r3, [r7, #12]
9000a5de:	681b      	ldr	r3, [r3, #0]
9000a5e0:	4a2b      	ldr	r2, [pc, #172]	; (9000a690 <HAL_DMA_Start_IT+0x494>)
9000a5e2:	4293      	cmp	r3, r2
9000a5e4:	d022      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a5e6:	68fb      	ldr	r3, [r7, #12]
9000a5e8:	681b      	ldr	r3, [r3, #0]
9000a5ea:	4a2a      	ldr	r2, [pc, #168]	; (9000a694 <HAL_DMA_Start_IT+0x498>)
9000a5ec:	4293      	cmp	r3, r2
9000a5ee:	d01d      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a5f0:	68fb      	ldr	r3, [r7, #12]
9000a5f2:	681b      	ldr	r3, [r3, #0]
9000a5f4:	4a28      	ldr	r2, [pc, #160]	; (9000a698 <HAL_DMA_Start_IT+0x49c>)
9000a5f6:	4293      	cmp	r3, r2
9000a5f8:	d018      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a5fa:	68fb      	ldr	r3, [r7, #12]
9000a5fc:	681b      	ldr	r3, [r3, #0]
9000a5fe:	4a27      	ldr	r2, [pc, #156]	; (9000a69c <HAL_DMA_Start_IT+0x4a0>)
9000a600:	4293      	cmp	r3, r2
9000a602:	d013      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a604:	68fb      	ldr	r3, [r7, #12]
9000a606:	681b      	ldr	r3, [r3, #0]
9000a608:	4a25      	ldr	r2, [pc, #148]	; (9000a6a0 <HAL_DMA_Start_IT+0x4a4>)
9000a60a:	4293      	cmp	r3, r2
9000a60c:	d00e      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a60e:	68fb      	ldr	r3, [r7, #12]
9000a610:	681b      	ldr	r3, [r3, #0]
9000a612:	4a24      	ldr	r2, [pc, #144]	; (9000a6a4 <HAL_DMA_Start_IT+0x4a8>)
9000a614:	4293      	cmp	r3, r2
9000a616:	d009      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a618:	68fb      	ldr	r3, [r7, #12]
9000a61a:	681b      	ldr	r3, [r3, #0]
9000a61c:	4a22      	ldr	r2, [pc, #136]	; (9000a6a8 <HAL_DMA_Start_IT+0x4ac>)
9000a61e:	4293      	cmp	r3, r2
9000a620:	d004      	beq.n	9000a62c <HAL_DMA_Start_IT+0x430>
9000a622:	68fb      	ldr	r3, [r7, #12]
9000a624:	681b      	ldr	r3, [r3, #0]
9000a626:	4a21      	ldr	r2, [pc, #132]	; (9000a6ac <HAL_DMA_Start_IT+0x4b0>)
9000a628:	4293      	cmp	r3, r2
9000a62a:	d108      	bne.n	9000a63e <HAL_DMA_Start_IT+0x442>
9000a62c:	68fb      	ldr	r3, [r7, #12]
9000a62e:	681b      	ldr	r3, [r3, #0]
9000a630:	681a      	ldr	r2, [r3, #0]
9000a632:	68fb      	ldr	r3, [r7, #12]
9000a634:	681b      	ldr	r3, [r3, #0]
9000a636:	f042 0201 	orr.w	r2, r2, #1
9000a63a:	601a      	str	r2, [r3, #0]
9000a63c:	e012      	b.n	9000a664 <HAL_DMA_Start_IT+0x468>
9000a63e:	68fb      	ldr	r3, [r7, #12]
9000a640:	681b      	ldr	r3, [r3, #0]
9000a642:	681a      	ldr	r2, [r3, #0]
9000a644:	68fb      	ldr	r3, [r7, #12]
9000a646:	681b      	ldr	r3, [r3, #0]
9000a648:	f042 0201 	orr.w	r2, r2, #1
9000a64c:	601a      	str	r2, [r3, #0]
9000a64e:	e009      	b.n	9000a664 <HAL_DMA_Start_IT+0x468>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
9000a650:	68fb      	ldr	r3, [r7, #12]
9000a652:	f44f 6200 	mov.w	r2, #2048	; 0x800
9000a656:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hdma);
9000a658:	68fb      	ldr	r3, [r7, #12]
9000a65a:	2200      	movs	r2, #0
9000a65c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Return error status */
    status = HAL_ERROR;
9000a660:	2301      	movs	r3, #1
9000a662:	75fb      	strb	r3, [r7, #23]
  }

  return status;
9000a664:	7dfb      	ldrb	r3, [r7, #23]
}
9000a666:	4618      	mov	r0, r3
9000a668:	3718      	adds	r7, #24
9000a66a:	46bd      	mov	sp, r7
9000a66c:	bd80      	pop	{r7, pc}
9000a66e:	bf00      	nop
9000a670:	40020010 	.word	0x40020010
9000a674:	40020028 	.word	0x40020028
9000a678:	40020040 	.word	0x40020040
9000a67c:	40020058 	.word	0x40020058
9000a680:	40020070 	.word	0x40020070
9000a684:	40020088 	.word	0x40020088
9000a688:	400200a0 	.word	0x400200a0
9000a68c:	400200b8 	.word	0x400200b8
9000a690:	40020410 	.word	0x40020410
9000a694:	40020428 	.word	0x40020428
9000a698:	40020440 	.word	0x40020440
9000a69c:	40020458 	.word	0x40020458
9000a6a0:	40020470 	.word	0x40020470
9000a6a4:	40020488 	.word	0x40020488
9000a6a8:	400204a0 	.word	0x400204a0
9000a6ac:	400204b8 	.word	0x400204b8
9000a6b0:	58025408 	.word	0x58025408
9000a6b4:	5802541c 	.word	0x5802541c
9000a6b8:	58025430 	.word	0x58025430
9000a6bc:	58025444 	.word	0x58025444
9000a6c0:	58025458 	.word	0x58025458
9000a6c4:	5802546c 	.word	0x5802546c
9000a6c8:	58025480 	.word	0x58025480
9000a6cc:	58025494 	.word	0x58025494

9000a6d0 <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
9000a6d0:	b580      	push	{r7, lr}
9000a6d2:	b086      	sub	sp, #24
9000a6d4:	af00      	add	r7, sp, #0
9000a6d6:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;
  const __IO uint32_t *enableRegister;

  uint32_t tickstart = HAL_GetTick();
9000a6d8:	f7fe fe74 	bl	900093c4 <HAL_GetTick>
9000a6dc:	6138      	str	r0, [r7, #16]

 /* Check the DMA peripheral handle */
  if(hdma == NULL)
9000a6de:	687b      	ldr	r3, [r7, #4]
9000a6e0:	2b00      	cmp	r3, #0
9000a6e2:	d101      	bne.n	9000a6e8 <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
9000a6e4:	2301      	movs	r3, #1
9000a6e6:	e2dc      	b.n	9000aca2 <HAL_DMA_Abort+0x5d2>
  }

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
9000a6e8:	687b      	ldr	r3, [r7, #4]
9000a6ea:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
9000a6ee:	b2db      	uxtb	r3, r3
9000a6f0:	2b02      	cmp	r3, #2
9000a6f2:	d008      	beq.n	9000a706 <HAL_DMA_Abort+0x36>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
9000a6f4:	687b      	ldr	r3, [r7, #4]
9000a6f6:	2280      	movs	r2, #128	; 0x80
9000a6f8:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
9000a6fa:	687b      	ldr	r3, [r7, #4]
9000a6fc:	2200      	movs	r2, #0
9000a6fe:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
9000a702:	2301      	movs	r3, #1
9000a704:	e2cd      	b.n	9000aca2 <HAL_DMA_Abort+0x5d2>
  }
  else
  {
    /* Disable all the transfer interrupts */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
9000a706:	687b      	ldr	r3, [r7, #4]
9000a708:	681b      	ldr	r3, [r3, #0]
9000a70a:	4a76      	ldr	r2, [pc, #472]	; (9000a8e4 <HAL_DMA_Abort+0x214>)
9000a70c:	4293      	cmp	r3, r2
9000a70e:	d04a      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a710:	687b      	ldr	r3, [r7, #4]
9000a712:	681b      	ldr	r3, [r3, #0]
9000a714:	4a74      	ldr	r2, [pc, #464]	; (9000a8e8 <HAL_DMA_Abort+0x218>)
9000a716:	4293      	cmp	r3, r2
9000a718:	d045      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a71a:	687b      	ldr	r3, [r7, #4]
9000a71c:	681b      	ldr	r3, [r3, #0]
9000a71e:	4a73      	ldr	r2, [pc, #460]	; (9000a8ec <HAL_DMA_Abort+0x21c>)
9000a720:	4293      	cmp	r3, r2
9000a722:	d040      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a724:	687b      	ldr	r3, [r7, #4]
9000a726:	681b      	ldr	r3, [r3, #0]
9000a728:	4a71      	ldr	r2, [pc, #452]	; (9000a8f0 <HAL_DMA_Abort+0x220>)
9000a72a:	4293      	cmp	r3, r2
9000a72c:	d03b      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a72e:	687b      	ldr	r3, [r7, #4]
9000a730:	681b      	ldr	r3, [r3, #0]
9000a732:	4a70      	ldr	r2, [pc, #448]	; (9000a8f4 <HAL_DMA_Abort+0x224>)
9000a734:	4293      	cmp	r3, r2
9000a736:	d036      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a738:	687b      	ldr	r3, [r7, #4]
9000a73a:	681b      	ldr	r3, [r3, #0]
9000a73c:	4a6e      	ldr	r2, [pc, #440]	; (9000a8f8 <HAL_DMA_Abort+0x228>)
9000a73e:	4293      	cmp	r3, r2
9000a740:	d031      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a742:	687b      	ldr	r3, [r7, #4]
9000a744:	681b      	ldr	r3, [r3, #0]
9000a746:	4a6d      	ldr	r2, [pc, #436]	; (9000a8fc <HAL_DMA_Abort+0x22c>)
9000a748:	4293      	cmp	r3, r2
9000a74a:	d02c      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a74c:	687b      	ldr	r3, [r7, #4]
9000a74e:	681b      	ldr	r3, [r3, #0]
9000a750:	4a6b      	ldr	r2, [pc, #428]	; (9000a900 <HAL_DMA_Abort+0x230>)
9000a752:	4293      	cmp	r3, r2
9000a754:	d027      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a756:	687b      	ldr	r3, [r7, #4]
9000a758:	681b      	ldr	r3, [r3, #0]
9000a75a:	4a6a      	ldr	r2, [pc, #424]	; (9000a904 <HAL_DMA_Abort+0x234>)
9000a75c:	4293      	cmp	r3, r2
9000a75e:	d022      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a760:	687b      	ldr	r3, [r7, #4]
9000a762:	681b      	ldr	r3, [r3, #0]
9000a764:	4a68      	ldr	r2, [pc, #416]	; (9000a908 <HAL_DMA_Abort+0x238>)
9000a766:	4293      	cmp	r3, r2
9000a768:	d01d      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a76a:	687b      	ldr	r3, [r7, #4]
9000a76c:	681b      	ldr	r3, [r3, #0]
9000a76e:	4a67      	ldr	r2, [pc, #412]	; (9000a90c <HAL_DMA_Abort+0x23c>)
9000a770:	4293      	cmp	r3, r2
9000a772:	d018      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a774:	687b      	ldr	r3, [r7, #4]
9000a776:	681b      	ldr	r3, [r3, #0]
9000a778:	4a65      	ldr	r2, [pc, #404]	; (9000a910 <HAL_DMA_Abort+0x240>)
9000a77a:	4293      	cmp	r3, r2
9000a77c:	d013      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a77e:	687b      	ldr	r3, [r7, #4]
9000a780:	681b      	ldr	r3, [r3, #0]
9000a782:	4a64      	ldr	r2, [pc, #400]	; (9000a914 <HAL_DMA_Abort+0x244>)
9000a784:	4293      	cmp	r3, r2
9000a786:	d00e      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a788:	687b      	ldr	r3, [r7, #4]
9000a78a:	681b      	ldr	r3, [r3, #0]
9000a78c:	4a62      	ldr	r2, [pc, #392]	; (9000a918 <HAL_DMA_Abort+0x248>)
9000a78e:	4293      	cmp	r3, r2
9000a790:	d009      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a792:	687b      	ldr	r3, [r7, #4]
9000a794:	681b      	ldr	r3, [r3, #0]
9000a796:	4a61      	ldr	r2, [pc, #388]	; (9000a91c <HAL_DMA_Abort+0x24c>)
9000a798:	4293      	cmp	r3, r2
9000a79a:	d004      	beq.n	9000a7a6 <HAL_DMA_Abort+0xd6>
9000a79c:	687b      	ldr	r3, [r7, #4]
9000a79e:	681b      	ldr	r3, [r3, #0]
9000a7a0:	4a5f      	ldr	r2, [pc, #380]	; (9000a920 <HAL_DMA_Abort+0x250>)
9000a7a2:	4293      	cmp	r3, r2
9000a7a4:	d101      	bne.n	9000a7aa <HAL_DMA_Abort+0xda>
9000a7a6:	2301      	movs	r3, #1
9000a7a8:	e000      	b.n	9000a7ac <HAL_DMA_Abort+0xdc>
9000a7aa:	2300      	movs	r3, #0
9000a7ac:	2b00      	cmp	r3, #0
9000a7ae:	d013      	beq.n	9000a7d8 <HAL_DMA_Abort+0x108>
    {
       /* Disable DMA All Interrupts  */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
9000a7b0:	687b      	ldr	r3, [r7, #4]
9000a7b2:	681b      	ldr	r3, [r3, #0]
9000a7b4:	681a      	ldr	r2, [r3, #0]
9000a7b6:	687b      	ldr	r3, [r7, #4]
9000a7b8:	681b      	ldr	r3, [r3, #0]
9000a7ba:	f022 021e 	bic.w	r2, r2, #30
9000a7be:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
9000a7c0:	687b      	ldr	r3, [r7, #4]
9000a7c2:	681b      	ldr	r3, [r3, #0]
9000a7c4:	695a      	ldr	r2, [r3, #20]
9000a7c6:	687b      	ldr	r3, [r7, #4]
9000a7c8:	681b      	ldr	r3, [r3, #0]
9000a7ca:	f022 0280 	bic.w	r2, r2, #128	; 0x80
9000a7ce:	615a      	str	r2, [r3, #20]

      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));
9000a7d0:	687b      	ldr	r3, [r7, #4]
9000a7d2:	681b      	ldr	r3, [r3, #0]
9000a7d4:	617b      	str	r3, [r7, #20]
9000a7d6:	e00a      	b.n	9000a7ee <HAL_DMA_Abort+0x11e>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
9000a7d8:	687b      	ldr	r3, [r7, #4]
9000a7da:	681b      	ldr	r3, [r3, #0]
9000a7dc:	681a      	ldr	r2, [r3, #0]
9000a7de:	687b      	ldr	r3, [r7, #4]
9000a7e0:	681b      	ldr	r3, [r3, #0]
9000a7e2:	f022 020e 	bic.w	r2, r2, #14
9000a7e6:	601a      	str	r2, [r3, #0]

      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));
9000a7e8:	687b      	ldr	r3, [r7, #4]
9000a7ea:	681b      	ldr	r3, [r3, #0]
9000a7ec:	617b      	str	r3, [r7, #20]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
9000a7ee:	687b      	ldr	r3, [r7, #4]
9000a7f0:	681b      	ldr	r3, [r3, #0]
9000a7f2:	4a3c      	ldr	r2, [pc, #240]	; (9000a8e4 <HAL_DMA_Abort+0x214>)
9000a7f4:	4293      	cmp	r3, r2
9000a7f6:	d072      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a7f8:	687b      	ldr	r3, [r7, #4]
9000a7fa:	681b      	ldr	r3, [r3, #0]
9000a7fc:	4a3a      	ldr	r2, [pc, #232]	; (9000a8e8 <HAL_DMA_Abort+0x218>)
9000a7fe:	4293      	cmp	r3, r2
9000a800:	d06d      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a802:	687b      	ldr	r3, [r7, #4]
9000a804:	681b      	ldr	r3, [r3, #0]
9000a806:	4a39      	ldr	r2, [pc, #228]	; (9000a8ec <HAL_DMA_Abort+0x21c>)
9000a808:	4293      	cmp	r3, r2
9000a80a:	d068      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a80c:	687b      	ldr	r3, [r7, #4]
9000a80e:	681b      	ldr	r3, [r3, #0]
9000a810:	4a37      	ldr	r2, [pc, #220]	; (9000a8f0 <HAL_DMA_Abort+0x220>)
9000a812:	4293      	cmp	r3, r2
9000a814:	d063      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a816:	687b      	ldr	r3, [r7, #4]
9000a818:	681b      	ldr	r3, [r3, #0]
9000a81a:	4a36      	ldr	r2, [pc, #216]	; (9000a8f4 <HAL_DMA_Abort+0x224>)
9000a81c:	4293      	cmp	r3, r2
9000a81e:	d05e      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a820:	687b      	ldr	r3, [r7, #4]
9000a822:	681b      	ldr	r3, [r3, #0]
9000a824:	4a34      	ldr	r2, [pc, #208]	; (9000a8f8 <HAL_DMA_Abort+0x228>)
9000a826:	4293      	cmp	r3, r2
9000a828:	d059      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a82a:	687b      	ldr	r3, [r7, #4]
9000a82c:	681b      	ldr	r3, [r3, #0]
9000a82e:	4a33      	ldr	r2, [pc, #204]	; (9000a8fc <HAL_DMA_Abort+0x22c>)
9000a830:	4293      	cmp	r3, r2
9000a832:	d054      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a834:	687b      	ldr	r3, [r7, #4]
9000a836:	681b      	ldr	r3, [r3, #0]
9000a838:	4a31      	ldr	r2, [pc, #196]	; (9000a900 <HAL_DMA_Abort+0x230>)
9000a83a:	4293      	cmp	r3, r2
9000a83c:	d04f      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a83e:	687b      	ldr	r3, [r7, #4]
9000a840:	681b      	ldr	r3, [r3, #0]
9000a842:	4a30      	ldr	r2, [pc, #192]	; (9000a904 <HAL_DMA_Abort+0x234>)
9000a844:	4293      	cmp	r3, r2
9000a846:	d04a      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a848:	687b      	ldr	r3, [r7, #4]
9000a84a:	681b      	ldr	r3, [r3, #0]
9000a84c:	4a2e      	ldr	r2, [pc, #184]	; (9000a908 <HAL_DMA_Abort+0x238>)
9000a84e:	4293      	cmp	r3, r2
9000a850:	d045      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a852:	687b      	ldr	r3, [r7, #4]
9000a854:	681b      	ldr	r3, [r3, #0]
9000a856:	4a2d      	ldr	r2, [pc, #180]	; (9000a90c <HAL_DMA_Abort+0x23c>)
9000a858:	4293      	cmp	r3, r2
9000a85a:	d040      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a85c:	687b      	ldr	r3, [r7, #4]
9000a85e:	681b      	ldr	r3, [r3, #0]
9000a860:	4a2b      	ldr	r2, [pc, #172]	; (9000a910 <HAL_DMA_Abort+0x240>)
9000a862:	4293      	cmp	r3, r2
9000a864:	d03b      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a866:	687b      	ldr	r3, [r7, #4]
9000a868:	681b      	ldr	r3, [r3, #0]
9000a86a:	4a2a      	ldr	r2, [pc, #168]	; (9000a914 <HAL_DMA_Abort+0x244>)
9000a86c:	4293      	cmp	r3, r2
9000a86e:	d036      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a870:	687b      	ldr	r3, [r7, #4]
9000a872:	681b      	ldr	r3, [r3, #0]
9000a874:	4a28      	ldr	r2, [pc, #160]	; (9000a918 <HAL_DMA_Abort+0x248>)
9000a876:	4293      	cmp	r3, r2
9000a878:	d031      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a87a:	687b      	ldr	r3, [r7, #4]
9000a87c:	681b      	ldr	r3, [r3, #0]
9000a87e:	4a27      	ldr	r2, [pc, #156]	; (9000a91c <HAL_DMA_Abort+0x24c>)
9000a880:	4293      	cmp	r3, r2
9000a882:	d02c      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a884:	687b      	ldr	r3, [r7, #4]
9000a886:	681b      	ldr	r3, [r3, #0]
9000a888:	4a25      	ldr	r2, [pc, #148]	; (9000a920 <HAL_DMA_Abort+0x250>)
9000a88a:	4293      	cmp	r3, r2
9000a88c:	d027      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a88e:	687b      	ldr	r3, [r7, #4]
9000a890:	681b      	ldr	r3, [r3, #0]
9000a892:	4a24      	ldr	r2, [pc, #144]	; (9000a924 <HAL_DMA_Abort+0x254>)
9000a894:	4293      	cmp	r3, r2
9000a896:	d022      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a898:	687b      	ldr	r3, [r7, #4]
9000a89a:	681b      	ldr	r3, [r3, #0]
9000a89c:	4a22      	ldr	r2, [pc, #136]	; (9000a928 <HAL_DMA_Abort+0x258>)
9000a89e:	4293      	cmp	r3, r2
9000a8a0:	d01d      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a8a2:	687b      	ldr	r3, [r7, #4]
9000a8a4:	681b      	ldr	r3, [r3, #0]
9000a8a6:	4a21      	ldr	r2, [pc, #132]	; (9000a92c <HAL_DMA_Abort+0x25c>)
9000a8a8:	4293      	cmp	r3, r2
9000a8aa:	d018      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a8ac:	687b      	ldr	r3, [r7, #4]
9000a8ae:	681b      	ldr	r3, [r3, #0]
9000a8b0:	4a1f      	ldr	r2, [pc, #124]	; (9000a930 <HAL_DMA_Abort+0x260>)
9000a8b2:	4293      	cmp	r3, r2
9000a8b4:	d013      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a8b6:	687b      	ldr	r3, [r7, #4]
9000a8b8:	681b      	ldr	r3, [r3, #0]
9000a8ba:	4a1e      	ldr	r2, [pc, #120]	; (9000a934 <HAL_DMA_Abort+0x264>)
9000a8bc:	4293      	cmp	r3, r2
9000a8be:	d00e      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a8c0:	687b      	ldr	r3, [r7, #4]
9000a8c2:	681b      	ldr	r3, [r3, #0]
9000a8c4:	4a1c      	ldr	r2, [pc, #112]	; (9000a938 <HAL_DMA_Abort+0x268>)
9000a8c6:	4293      	cmp	r3, r2
9000a8c8:	d009      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a8ca:	687b      	ldr	r3, [r7, #4]
9000a8cc:	681b      	ldr	r3, [r3, #0]
9000a8ce:	4a1b      	ldr	r2, [pc, #108]	; (9000a93c <HAL_DMA_Abort+0x26c>)
9000a8d0:	4293      	cmp	r3, r2
9000a8d2:	d004      	beq.n	9000a8de <HAL_DMA_Abort+0x20e>
9000a8d4:	687b      	ldr	r3, [r7, #4]
9000a8d6:	681b      	ldr	r3, [r3, #0]
9000a8d8:	4a19      	ldr	r2, [pc, #100]	; (9000a940 <HAL_DMA_Abort+0x270>)
9000a8da:	4293      	cmp	r3, r2
9000a8dc:	d132      	bne.n	9000a944 <HAL_DMA_Abort+0x274>
9000a8de:	2301      	movs	r3, #1
9000a8e0:	e031      	b.n	9000a946 <HAL_DMA_Abort+0x276>
9000a8e2:	bf00      	nop
9000a8e4:	40020010 	.word	0x40020010
9000a8e8:	40020028 	.word	0x40020028
9000a8ec:	40020040 	.word	0x40020040
9000a8f0:	40020058 	.word	0x40020058
9000a8f4:	40020070 	.word	0x40020070
9000a8f8:	40020088 	.word	0x40020088
9000a8fc:	400200a0 	.word	0x400200a0
9000a900:	400200b8 	.word	0x400200b8
9000a904:	40020410 	.word	0x40020410
9000a908:	40020428 	.word	0x40020428
9000a90c:	40020440 	.word	0x40020440
9000a910:	40020458 	.word	0x40020458
9000a914:	40020470 	.word	0x40020470
9000a918:	40020488 	.word	0x40020488
9000a91c:	400204a0 	.word	0x400204a0
9000a920:	400204b8 	.word	0x400204b8
9000a924:	58025408 	.word	0x58025408
9000a928:	5802541c 	.word	0x5802541c
9000a92c:	58025430 	.word	0x58025430
9000a930:	58025444 	.word	0x58025444
9000a934:	58025458 	.word	0x58025458
9000a938:	5802546c 	.word	0x5802546c
9000a93c:	58025480 	.word	0x58025480
9000a940:	58025494 	.word	0x58025494
9000a944:	2300      	movs	r3, #0
9000a946:	2b00      	cmp	r3, #0
9000a948:	d007      	beq.n	9000a95a <HAL_DMA_Abort+0x28a>
    {
      /* disable the DMAMUX sync overrun IT */
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
9000a94a:	687b      	ldr	r3, [r7, #4]
9000a94c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000a94e:	681a      	ldr	r2, [r3, #0]
9000a950:	687b      	ldr	r3, [r7, #4]
9000a952:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000a954:	f422 7280 	bic.w	r2, r2, #256	; 0x100
9000a958:	601a      	str	r2, [r3, #0]
    }

    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
9000a95a:	687b      	ldr	r3, [r7, #4]
9000a95c:	681b      	ldr	r3, [r3, #0]
9000a95e:	4a6d      	ldr	r2, [pc, #436]	; (9000ab14 <HAL_DMA_Abort+0x444>)
9000a960:	4293      	cmp	r3, r2
9000a962:	d04a      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a964:	687b      	ldr	r3, [r7, #4]
9000a966:	681b      	ldr	r3, [r3, #0]
9000a968:	4a6b      	ldr	r2, [pc, #428]	; (9000ab18 <HAL_DMA_Abort+0x448>)
9000a96a:	4293      	cmp	r3, r2
9000a96c:	d045      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a96e:	687b      	ldr	r3, [r7, #4]
9000a970:	681b      	ldr	r3, [r3, #0]
9000a972:	4a6a      	ldr	r2, [pc, #424]	; (9000ab1c <HAL_DMA_Abort+0x44c>)
9000a974:	4293      	cmp	r3, r2
9000a976:	d040      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a978:	687b      	ldr	r3, [r7, #4]
9000a97a:	681b      	ldr	r3, [r3, #0]
9000a97c:	4a68      	ldr	r2, [pc, #416]	; (9000ab20 <HAL_DMA_Abort+0x450>)
9000a97e:	4293      	cmp	r3, r2
9000a980:	d03b      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a982:	687b      	ldr	r3, [r7, #4]
9000a984:	681b      	ldr	r3, [r3, #0]
9000a986:	4a67      	ldr	r2, [pc, #412]	; (9000ab24 <HAL_DMA_Abort+0x454>)
9000a988:	4293      	cmp	r3, r2
9000a98a:	d036      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a98c:	687b      	ldr	r3, [r7, #4]
9000a98e:	681b      	ldr	r3, [r3, #0]
9000a990:	4a65      	ldr	r2, [pc, #404]	; (9000ab28 <HAL_DMA_Abort+0x458>)
9000a992:	4293      	cmp	r3, r2
9000a994:	d031      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a996:	687b      	ldr	r3, [r7, #4]
9000a998:	681b      	ldr	r3, [r3, #0]
9000a99a:	4a64      	ldr	r2, [pc, #400]	; (9000ab2c <HAL_DMA_Abort+0x45c>)
9000a99c:	4293      	cmp	r3, r2
9000a99e:	d02c      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a9a0:	687b      	ldr	r3, [r7, #4]
9000a9a2:	681b      	ldr	r3, [r3, #0]
9000a9a4:	4a62      	ldr	r2, [pc, #392]	; (9000ab30 <HAL_DMA_Abort+0x460>)
9000a9a6:	4293      	cmp	r3, r2
9000a9a8:	d027      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a9aa:	687b      	ldr	r3, [r7, #4]
9000a9ac:	681b      	ldr	r3, [r3, #0]
9000a9ae:	4a61      	ldr	r2, [pc, #388]	; (9000ab34 <HAL_DMA_Abort+0x464>)
9000a9b0:	4293      	cmp	r3, r2
9000a9b2:	d022      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a9b4:	687b      	ldr	r3, [r7, #4]
9000a9b6:	681b      	ldr	r3, [r3, #0]
9000a9b8:	4a5f      	ldr	r2, [pc, #380]	; (9000ab38 <HAL_DMA_Abort+0x468>)
9000a9ba:	4293      	cmp	r3, r2
9000a9bc:	d01d      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a9be:	687b      	ldr	r3, [r7, #4]
9000a9c0:	681b      	ldr	r3, [r3, #0]
9000a9c2:	4a5e      	ldr	r2, [pc, #376]	; (9000ab3c <HAL_DMA_Abort+0x46c>)
9000a9c4:	4293      	cmp	r3, r2
9000a9c6:	d018      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a9c8:	687b      	ldr	r3, [r7, #4]
9000a9ca:	681b      	ldr	r3, [r3, #0]
9000a9cc:	4a5c      	ldr	r2, [pc, #368]	; (9000ab40 <HAL_DMA_Abort+0x470>)
9000a9ce:	4293      	cmp	r3, r2
9000a9d0:	d013      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a9d2:	687b      	ldr	r3, [r7, #4]
9000a9d4:	681b      	ldr	r3, [r3, #0]
9000a9d6:	4a5b      	ldr	r2, [pc, #364]	; (9000ab44 <HAL_DMA_Abort+0x474>)
9000a9d8:	4293      	cmp	r3, r2
9000a9da:	d00e      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a9dc:	687b      	ldr	r3, [r7, #4]
9000a9de:	681b      	ldr	r3, [r3, #0]
9000a9e0:	4a59      	ldr	r2, [pc, #356]	; (9000ab48 <HAL_DMA_Abort+0x478>)
9000a9e2:	4293      	cmp	r3, r2
9000a9e4:	d009      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a9e6:	687b      	ldr	r3, [r7, #4]
9000a9e8:	681b      	ldr	r3, [r3, #0]
9000a9ea:	4a58      	ldr	r2, [pc, #352]	; (9000ab4c <HAL_DMA_Abort+0x47c>)
9000a9ec:	4293      	cmp	r3, r2
9000a9ee:	d004      	beq.n	9000a9fa <HAL_DMA_Abort+0x32a>
9000a9f0:	687b      	ldr	r3, [r7, #4]
9000a9f2:	681b      	ldr	r3, [r3, #0]
9000a9f4:	4a56      	ldr	r2, [pc, #344]	; (9000ab50 <HAL_DMA_Abort+0x480>)
9000a9f6:	4293      	cmp	r3, r2
9000a9f8:	d108      	bne.n	9000aa0c <HAL_DMA_Abort+0x33c>
9000a9fa:	687b      	ldr	r3, [r7, #4]
9000a9fc:	681b      	ldr	r3, [r3, #0]
9000a9fe:	681a      	ldr	r2, [r3, #0]
9000aa00:	687b      	ldr	r3, [r7, #4]
9000aa02:	681b      	ldr	r3, [r3, #0]
9000aa04:	f022 0201 	bic.w	r2, r2, #1
9000aa08:	601a      	str	r2, [r3, #0]
9000aa0a:	e007      	b.n	9000aa1c <HAL_DMA_Abort+0x34c>
9000aa0c:	687b      	ldr	r3, [r7, #4]
9000aa0e:	681b      	ldr	r3, [r3, #0]
9000aa10:	681a      	ldr	r2, [r3, #0]
9000aa12:	687b      	ldr	r3, [r7, #4]
9000aa14:	681b      	ldr	r3, [r3, #0]
9000aa16:	f022 0201 	bic.w	r2, r2, #1
9000aa1a:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
9000aa1c:	e013      	b.n	9000aa46 <HAL_DMA_Abort+0x376>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
9000aa1e:	f7fe fcd1 	bl	900093c4 <HAL_GetTick>
9000aa22:	4602      	mov	r2, r0
9000aa24:	693b      	ldr	r3, [r7, #16]
9000aa26:	1ad3      	subs	r3, r2, r3
9000aa28:	2b05      	cmp	r3, #5
9000aa2a:	d90c      	bls.n	9000aa46 <HAL_DMA_Abort+0x376>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
9000aa2c:	687b      	ldr	r3, [r7, #4]
9000aa2e:	2220      	movs	r2, #32
9000aa30:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
9000aa32:	687b      	ldr	r3, [r7, #4]
9000aa34:	2203      	movs	r2, #3
9000aa36:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
9000aa3a:	687b      	ldr	r3, [r7, #4]
9000aa3c:	2200      	movs	r2, #0
9000aa3e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
9000aa42:	2301      	movs	r3, #1
9000aa44:	e12d      	b.n	9000aca2 <HAL_DMA_Abort+0x5d2>
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
9000aa46:	697b      	ldr	r3, [r7, #20]
9000aa48:	681b      	ldr	r3, [r3, #0]
9000aa4a:	f003 0301 	and.w	r3, r3, #1
9000aa4e:	2b00      	cmp	r3, #0
9000aa50:	d1e5      	bne.n	9000aa1e <HAL_DMA_Abort+0x34e>
      }
    }

    /* Clear all interrupt flags at correct offset within the register */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
9000aa52:	687b      	ldr	r3, [r7, #4]
9000aa54:	681b      	ldr	r3, [r3, #0]
9000aa56:	4a2f      	ldr	r2, [pc, #188]	; (9000ab14 <HAL_DMA_Abort+0x444>)
9000aa58:	4293      	cmp	r3, r2
9000aa5a:	d04a      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aa5c:	687b      	ldr	r3, [r7, #4]
9000aa5e:	681b      	ldr	r3, [r3, #0]
9000aa60:	4a2d      	ldr	r2, [pc, #180]	; (9000ab18 <HAL_DMA_Abort+0x448>)
9000aa62:	4293      	cmp	r3, r2
9000aa64:	d045      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aa66:	687b      	ldr	r3, [r7, #4]
9000aa68:	681b      	ldr	r3, [r3, #0]
9000aa6a:	4a2c      	ldr	r2, [pc, #176]	; (9000ab1c <HAL_DMA_Abort+0x44c>)
9000aa6c:	4293      	cmp	r3, r2
9000aa6e:	d040      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aa70:	687b      	ldr	r3, [r7, #4]
9000aa72:	681b      	ldr	r3, [r3, #0]
9000aa74:	4a2a      	ldr	r2, [pc, #168]	; (9000ab20 <HAL_DMA_Abort+0x450>)
9000aa76:	4293      	cmp	r3, r2
9000aa78:	d03b      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aa7a:	687b      	ldr	r3, [r7, #4]
9000aa7c:	681b      	ldr	r3, [r3, #0]
9000aa7e:	4a29      	ldr	r2, [pc, #164]	; (9000ab24 <HAL_DMA_Abort+0x454>)
9000aa80:	4293      	cmp	r3, r2
9000aa82:	d036      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aa84:	687b      	ldr	r3, [r7, #4]
9000aa86:	681b      	ldr	r3, [r3, #0]
9000aa88:	4a27      	ldr	r2, [pc, #156]	; (9000ab28 <HAL_DMA_Abort+0x458>)
9000aa8a:	4293      	cmp	r3, r2
9000aa8c:	d031      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aa8e:	687b      	ldr	r3, [r7, #4]
9000aa90:	681b      	ldr	r3, [r3, #0]
9000aa92:	4a26      	ldr	r2, [pc, #152]	; (9000ab2c <HAL_DMA_Abort+0x45c>)
9000aa94:	4293      	cmp	r3, r2
9000aa96:	d02c      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aa98:	687b      	ldr	r3, [r7, #4]
9000aa9a:	681b      	ldr	r3, [r3, #0]
9000aa9c:	4a24      	ldr	r2, [pc, #144]	; (9000ab30 <HAL_DMA_Abort+0x460>)
9000aa9e:	4293      	cmp	r3, r2
9000aaa0:	d027      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aaa2:	687b      	ldr	r3, [r7, #4]
9000aaa4:	681b      	ldr	r3, [r3, #0]
9000aaa6:	4a23      	ldr	r2, [pc, #140]	; (9000ab34 <HAL_DMA_Abort+0x464>)
9000aaa8:	4293      	cmp	r3, r2
9000aaaa:	d022      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aaac:	687b      	ldr	r3, [r7, #4]
9000aaae:	681b      	ldr	r3, [r3, #0]
9000aab0:	4a21      	ldr	r2, [pc, #132]	; (9000ab38 <HAL_DMA_Abort+0x468>)
9000aab2:	4293      	cmp	r3, r2
9000aab4:	d01d      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aab6:	687b      	ldr	r3, [r7, #4]
9000aab8:	681b      	ldr	r3, [r3, #0]
9000aaba:	4a20      	ldr	r2, [pc, #128]	; (9000ab3c <HAL_DMA_Abort+0x46c>)
9000aabc:	4293      	cmp	r3, r2
9000aabe:	d018      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aac0:	687b      	ldr	r3, [r7, #4]
9000aac2:	681b      	ldr	r3, [r3, #0]
9000aac4:	4a1e      	ldr	r2, [pc, #120]	; (9000ab40 <HAL_DMA_Abort+0x470>)
9000aac6:	4293      	cmp	r3, r2
9000aac8:	d013      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aaca:	687b      	ldr	r3, [r7, #4]
9000aacc:	681b      	ldr	r3, [r3, #0]
9000aace:	4a1d      	ldr	r2, [pc, #116]	; (9000ab44 <HAL_DMA_Abort+0x474>)
9000aad0:	4293      	cmp	r3, r2
9000aad2:	d00e      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aad4:	687b      	ldr	r3, [r7, #4]
9000aad6:	681b      	ldr	r3, [r3, #0]
9000aad8:	4a1b      	ldr	r2, [pc, #108]	; (9000ab48 <HAL_DMA_Abort+0x478>)
9000aada:	4293      	cmp	r3, r2
9000aadc:	d009      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aade:	687b      	ldr	r3, [r7, #4]
9000aae0:	681b      	ldr	r3, [r3, #0]
9000aae2:	4a1a      	ldr	r2, [pc, #104]	; (9000ab4c <HAL_DMA_Abort+0x47c>)
9000aae4:	4293      	cmp	r3, r2
9000aae6:	d004      	beq.n	9000aaf2 <HAL_DMA_Abort+0x422>
9000aae8:	687b      	ldr	r3, [r7, #4]
9000aaea:	681b      	ldr	r3, [r3, #0]
9000aaec:	4a18      	ldr	r2, [pc, #96]	; (9000ab50 <HAL_DMA_Abort+0x480>)
9000aaee:	4293      	cmp	r3, r2
9000aaf0:	d101      	bne.n	9000aaf6 <HAL_DMA_Abort+0x426>
9000aaf2:	2301      	movs	r3, #1
9000aaf4:	e000      	b.n	9000aaf8 <HAL_DMA_Abort+0x428>
9000aaf6:	2300      	movs	r3, #0
9000aaf8:	2b00      	cmp	r3, #0
9000aafa:	d02b      	beq.n	9000ab54 <HAL_DMA_Abort+0x484>
    {
      regs_dma = (DMA_Base_Registers *)hdma->StreamBaseAddress;
9000aafc:	687b      	ldr	r3, [r7, #4]
9000aafe:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000ab00:	60bb      	str	r3, [r7, #8]
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
9000ab02:	687b      	ldr	r3, [r7, #4]
9000ab04:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000ab06:	f003 031f 	and.w	r3, r3, #31
9000ab0a:	223f      	movs	r2, #63	; 0x3f
9000ab0c:	409a      	lsls	r2, r3
9000ab0e:	68bb      	ldr	r3, [r7, #8]
9000ab10:	609a      	str	r2, [r3, #8]
9000ab12:	e02a      	b.n	9000ab6a <HAL_DMA_Abort+0x49a>
9000ab14:	40020010 	.word	0x40020010
9000ab18:	40020028 	.word	0x40020028
9000ab1c:	40020040 	.word	0x40020040
9000ab20:	40020058 	.word	0x40020058
9000ab24:	40020070 	.word	0x40020070
9000ab28:	40020088 	.word	0x40020088
9000ab2c:	400200a0 	.word	0x400200a0
9000ab30:	400200b8 	.word	0x400200b8
9000ab34:	40020410 	.word	0x40020410
9000ab38:	40020428 	.word	0x40020428
9000ab3c:	40020440 	.word	0x40020440
9000ab40:	40020458 	.word	0x40020458
9000ab44:	40020470 	.word	0x40020470
9000ab48:	40020488 	.word	0x40020488
9000ab4c:	400204a0 	.word	0x400204a0
9000ab50:	400204b8 	.word	0x400204b8
    }
    else /* BDMA channel */
    {
      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
9000ab54:	687b      	ldr	r3, [r7, #4]
9000ab56:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000ab58:	60fb      	str	r3, [r7, #12]
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
9000ab5a:	687b      	ldr	r3, [r7, #4]
9000ab5c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000ab5e:	f003 031f 	and.w	r3, r3, #31
9000ab62:	2201      	movs	r2, #1
9000ab64:	409a      	lsls	r2, r3
9000ab66:	68fb      	ldr	r3, [r7, #12]
9000ab68:	605a      	str	r2, [r3, #4]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
9000ab6a:	687b      	ldr	r3, [r7, #4]
9000ab6c:	681b      	ldr	r3, [r3, #0]
9000ab6e:	4a4f      	ldr	r2, [pc, #316]	; (9000acac <HAL_DMA_Abort+0x5dc>)
9000ab70:	4293      	cmp	r3, r2
9000ab72:	d072      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ab74:	687b      	ldr	r3, [r7, #4]
9000ab76:	681b      	ldr	r3, [r3, #0]
9000ab78:	4a4d      	ldr	r2, [pc, #308]	; (9000acb0 <HAL_DMA_Abort+0x5e0>)
9000ab7a:	4293      	cmp	r3, r2
9000ab7c:	d06d      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ab7e:	687b      	ldr	r3, [r7, #4]
9000ab80:	681b      	ldr	r3, [r3, #0]
9000ab82:	4a4c      	ldr	r2, [pc, #304]	; (9000acb4 <HAL_DMA_Abort+0x5e4>)
9000ab84:	4293      	cmp	r3, r2
9000ab86:	d068      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ab88:	687b      	ldr	r3, [r7, #4]
9000ab8a:	681b      	ldr	r3, [r3, #0]
9000ab8c:	4a4a      	ldr	r2, [pc, #296]	; (9000acb8 <HAL_DMA_Abort+0x5e8>)
9000ab8e:	4293      	cmp	r3, r2
9000ab90:	d063      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ab92:	687b      	ldr	r3, [r7, #4]
9000ab94:	681b      	ldr	r3, [r3, #0]
9000ab96:	4a49      	ldr	r2, [pc, #292]	; (9000acbc <HAL_DMA_Abort+0x5ec>)
9000ab98:	4293      	cmp	r3, r2
9000ab9a:	d05e      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ab9c:	687b      	ldr	r3, [r7, #4]
9000ab9e:	681b      	ldr	r3, [r3, #0]
9000aba0:	4a47      	ldr	r2, [pc, #284]	; (9000acc0 <HAL_DMA_Abort+0x5f0>)
9000aba2:	4293      	cmp	r3, r2
9000aba4:	d059      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000aba6:	687b      	ldr	r3, [r7, #4]
9000aba8:	681b      	ldr	r3, [r3, #0]
9000abaa:	4a46      	ldr	r2, [pc, #280]	; (9000acc4 <HAL_DMA_Abort+0x5f4>)
9000abac:	4293      	cmp	r3, r2
9000abae:	d054      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000abb0:	687b      	ldr	r3, [r7, #4]
9000abb2:	681b      	ldr	r3, [r3, #0]
9000abb4:	4a44      	ldr	r2, [pc, #272]	; (9000acc8 <HAL_DMA_Abort+0x5f8>)
9000abb6:	4293      	cmp	r3, r2
9000abb8:	d04f      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000abba:	687b      	ldr	r3, [r7, #4]
9000abbc:	681b      	ldr	r3, [r3, #0]
9000abbe:	4a43      	ldr	r2, [pc, #268]	; (9000accc <HAL_DMA_Abort+0x5fc>)
9000abc0:	4293      	cmp	r3, r2
9000abc2:	d04a      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000abc4:	687b      	ldr	r3, [r7, #4]
9000abc6:	681b      	ldr	r3, [r3, #0]
9000abc8:	4a41      	ldr	r2, [pc, #260]	; (9000acd0 <HAL_DMA_Abort+0x600>)
9000abca:	4293      	cmp	r3, r2
9000abcc:	d045      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000abce:	687b      	ldr	r3, [r7, #4]
9000abd0:	681b      	ldr	r3, [r3, #0]
9000abd2:	4a40      	ldr	r2, [pc, #256]	; (9000acd4 <HAL_DMA_Abort+0x604>)
9000abd4:	4293      	cmp	r3, r2
9000abd6:	d040      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000abd8:	687b      	ldr	r3, [r7, #4]
9000abda:	681b      	ldr	r3, [r3, #0]
9000abdc:	4a3e      	ldr	r2, [pc, #248]	; (9000acd8 <HAL_DMA_Abort+0x608>)
9000abde:	4293      	cmp	r3, r2
9000abe0:	d03b      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000abe2:	687b      	ldr	r3, [r7, #4]
9000abe4:	681b      	ldr	r3, [r3, #0]
9000abe6:	4a3d      	ldr	r2, [pc, #244]	; (9000acdc <HAL_DMA_Abort+0x60c>)
9000abe8:	4293      	cmp	r3, r2
9000abea:	d036      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000abec:	687b      	ldr	r3, [r7, #4]
9000abee:	681b      	ldr	r3, [r3, #0]
9000abf0:	4a3b      	ldr	r2, [pc, #236]	; (9000ace0 <HAL_DMA_Abort+0x610>)
9000abf2:	4293      	cmp	r3, r2
9000abf4:	d031      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000abf6:	687b      	ldr	r3, [r7, #4]
9000abf8:	681b      	ldr	r3, [r3, #0]
9000abfa:	4a3a      	ldr	r2, [pc, #232]	; (9000ace4 <HAL_DMA_Abort+0x614>)
9000abfc:	4293      	cmp	r3, r2
9000abfe:	d02c      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ac00:	687b      	ldr	r3, [r7, #4]
9000ac02:	681b      	ldr	r3, [r3, #0]
9000ac04:	4a38      	ldr	r2, [pc, #224]	; (9000ace8 <HAL_DMA_Abort+0x618>)
9000ac06:	4293      	cmp	r3, r2
9000ac08:	d027      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ac0a:	687b      	ldr	r3, [r7, #4]
9000ac0c:	681b      	ldr	r3, [r3, #0]
9000ac0e:	4a37      	ldr	r2, [pc, #220]	; (9000acec <HAL_DMA_Abort+0x61c>)
9000ac10:	4293      	cmp	r3, r2
9000ac12:	d022      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ac14:	687b      	ldr	r3, [r7, #4]
9000ac16:	681b      	ldr	r3, [r3, #0]
9000ac18:	4a35      	ldr	r2, [pc, #212]	; (9000acf0 <HAL_DMA_Abort+0x620>)
9000ac1a:	4293      	cmp	r3, r2
9000ac1c:	d01d      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ac1e:	687b      	ldr	r3, [r7, #4]
9000ac20:	681b      	ldr	r3, [r3, #0]
9000ac22:	4a34      	ldr	r2, [pc, #208]	; (9000acf4 <HAL_DMA_Abort+0x624>)
9000ac24:	4293      	cmp	r3, r2
9000ac26:	d018      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ac28:	687b      	ldr	r3, [r7, #4]
9000ac2a:	681b      	ldr	r3, [r3, #0]
9000ac2c:	4a32      	ldr	r2, [pc, #200]	; (9000acf8 <HAL_DMA_Abort+0x628>)
9000ac2e:	4293      	cmp	r3, r2
9000ac30:	d013      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ac32:	687b      	ldr	r3, [r7, #4]
9000ac34:	681b      	ldr	r3, [r3, #0]
9000ac36:	4a31      	ldr	r2, [pc, #196]	; (9000acfc <HAL_DMA_Abort+0x62c>)
9000ac38:	4293      	cmp	r3, r2
9000ac3a:	d00e      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ac3c:	687b      	ldr	r3, [r7, #4]
9000ac3e:	681b      	ldr	r3, [r3, #0]
9000ac40:	4a2f      	ldr	r2, [pc, #188]	; (9000ad00 <HAL_DMA_Abort+0x630>)
9000ac42:	4293      	cmp	r3, r2
9000ac44:	d009      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ac46:	687b      	ldr	r3, [r7, #4]
9000ac48:	681b      	ldr	r3, [r3, #0]
9000ac4a:	4a2e      	ldr	r2, [pc, #184]	; (9000ad04 <HAL_DMA_Abort+0x634>)
9000ac4c:	4293      	cmp	r3, r2
9000ac4e:	d004      	beq.n	9000ac5a <HAL_DMA_Abort+0x58a>
9000ac50:	687b      	ldr	r3, [r7, #4]
9000ac52:	681b      	ldr	r3, [r3, #0]
9000ac54:	4a2c      	ldr	r2, [pc, #176]	; (9000ad08 <HAL_DMA_Abort+0x638>)
9000ac56:	4293      	cmp	r3, r2
9000ac58:	d101      	bne.n	9000ac5e <HAL_DMA_Abort+0x58e>
9000ac5a:	2301      	movs	r3, #1
9000ac5c:	e000      	b.n	9000ac60 <HAL_DMA_Abort+0x590>
9000ac5e:	2300      	movs	r3, #0
9000ac60:	2b00      	cmp	r3, #0
9000ac62:	d015      	beq.n	9000ac90 <HAL_DMA_Abort+0x5c0>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
9000ac64:	687b      	ldr	r3, [r7, #4]
9000ac66:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000ac68:	687a      	ldr	r2, [r7, #4]
9000ac6a:	6e92      	ldr	r2, [r2, #104]	; 0x68
9000ac6c:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
9000ac6e:	687b      	ldr	r3, [r7, #4]
9000ac70:	6edb      	ldr	r3, [r3, #108]	; 0x6c
9000ac72:	2b00      	cmp	r3, #0
9000ac74:	d00c      	beq.n	9000ac90 <HAL_DMA_Abort+0x5c0>
      {
        /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT */
        /* disable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
9000ac76:	687b      	ldr	r3, [r7, #4]
9000ac78:	6edb      	ldr	r3, [r3, #108]	; 0x6c
9000ac7a:	681a      	ldr	r2, [r3, #0]
9000ac7c:	687b      	ldr	r3, [r7, #4]
9000ac7e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
9000ac80:	f422 7280 	bic.w	r2, r2, #256	; 0x100
9000ac84:	601a      	str	r2, [r3, #0]

        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
9000ac86:	687b      	ldr	r3, [r7, #4]
9000ac88:	6f1b      	ldr	r3, [r3, #112]	; 0x70
9000ac8a:	687a      	ldr	r2, [r7, #4]
9000ac8c:	6f52      	ldr	r2, [r2, #116]	; 0x74
9000ac8e:	605a      	str	r2, [r3, #4]
      }
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
9000ac90:	687b      	ldr	r3, [r7, #4]
9000ac92:	2201      	movs	r2, #1
9000ac94:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
9000ac98:	687b      	ldr	r3, [r7, #4]
9000ac9a:	2200      	movs	r2, #0
9000ac9c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  }

  return HAL_OK;
9000aca0:	2300      	movs	r3, #0
}
9000aca2:	4618      	mov	r0, r3
9000aca4:	3718      	adds	r7, #24
9000aca6:	46bd      	mov	sp, r7
9000aca8:	bd80      	pop	{r7, pc}
9000acaa:	bf00      	nop
9000acac:	40020010 	.word	0x40020010
9000acb0:	40020028 	.word	0x40020028
9000acb4:	40020040 	.word	0x40020040
9000acb8:	40020058 	.word	0x40020058
9000acbc:	40020070 	.word	0x40020070
9000acc0:	40020088 	.word	0x40020088
9000acc4:	400200a0 	.word	0x400200a0
9000acc8:	400200b8 	.word	0x400200b8
9000accc:	40020410 	.word	0x40020410
9000acd0:	40020428 	.word	0x40020428
9000acd4:	40020440 	.word	0x40020440
9000acd8:	40020458 	.word	0x40020458
9000acdc:	40020470 	.word	0x40020470
9000ace0:	40020488 	.word	0x40020488
9000ace4:	400204a0 	.word	0x400204a0
9000ace8:	400204b8 	.word	0x400204b8
9000acec:	58025408 	.word	0x58025408
9000acf0:	5802541c 	.word	0x5802541c
9000acf4:	58025430 	.word	0x58025430
9000acf8:	58025444 	.word	0x58025444
9000acfc:	58025458 	.word	0x58025458
9000ad00:	5802546c 	.word	0x5802546c
9000ad04:	58025480 	.word	0x58025480
9000ad08:	58025494 	.word	0x58025494

9000ad0c <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
9000ad0c:	b580      	push	{r7, lr}
9000ad0e:	b08a      	sub	sp, #40	; 0x28
9000ad10:	af00      	add	r7, sp, #0
9000ad12:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr_dma, tmpisr_bdma;
  uint32_t ccr_reg;
  __IO uint32_t count = 0U;
9000ad14:	2300      	movs	r3, #0
9000ad16:	60fb      	str	r3, [r7, #12]
  uint32_t timeout = SystemCoreClock / 9600U;
9000ad18:	4b67      	ldr	r3, [pc, #412]	; (9000aeb8 <HAL_DMA_IRQHandler+0x1ac>)
9000ad1a:	681b      	ldr	r3, [r3, #0]
9000ad1c:	4a67      	ldr	r2, [pc, #412]	; (9000aebc <HAL_DMA_IRQHandler+0x1b0>)
9000ad1e:	fba2 2303 	umull	r2, r3, r2, r3
9000ad22:	0a9b      	lsrs	r3, r3, #10
9000ad24:	627b      	str	r3, [r7, #36]	; 0x24

  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
9000ad26:	687b      	ldr	r3, [r7, #4]
9000ad28:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000ad2a:	623b      	str	r3, [r7, #32]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
9000ad2c:	687b      	ldr	r3, [r7, #4]
9000ad2e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000ad30:	61fb      	str	r3, [r7, #28]

  tmpisr_dma  = regs_dma->ISR;
9000ad32:	6a3b      	ldr	r3, [r7, #32]
9000ad34:	681b      	ldr	r3, [r3, #0]
9000ad36:	61bb      	str	r3, [r7, #24]
  tmpisr_bdma = regs_bdma->ISR;
9000ad38:	69fb      	ldr	r3, [r7, #28]
9000ad3a:	681b      	ldr	r3, [r3, #0]
9000ad3c:	617b      	str	r3, [r7, #20]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
9000ad3e:	687b      	ldr	r3, [r7, #4]
9000ad40:	681b      	ldr	r3, [r3, #0]
9000ad42:	4a5f      	ldr	r2, [pc, #380]	; (9000aec0 <HAL_DMA_IRQHandler+0x1b4>)
9000ad44:	4293      	cmp	r3, r2
9000ad46:	d04a      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000ad48:	687b      	ldr	r3, [r7, #4]
9000ad4a:	681b      	ldr	r3, [r3, #0]
9000ad4c:	4a5d      	ldr	r2, [pc, #372]	; (9000aec4 <HAL_DMA_IRQHandler+0x1b8>)
9000ad4e:	4293      	cmp	r3, r2
9000ad50:	d045      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000ad52:	687b      	ldr	r3, [r7, #4]
9000ad54:	681b      	ldr	r3, [r3, #0]
9000ad56:	4a5c      	ldr	r2, [pc, #368]	; (9000aec8 <HAL_DMA_IRQHandler+0x1bc>)
9000ad58:	4293      	cmp	r3, r2
9000ad5a:	d040      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000ad5c:	687b      	ldr	r3, [r7, #4]
9000ad5e:	681b      	ldr	r3, [r3, #0]
9000ad60:	4a5a      	ldr	r2, [pc, #360]	; (9000aecc <HAL_DMA_IRQHandler+0x1c0>)
9000ad62:	4293      	cmp	r3, r2
9000ad64:	d03b      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000ad66:	687b      	ldr	r3, [r7, #4]
9000ad68:	681b      	ldr	r3, [r3, #0]
9000ad6a:	4a59      	ldr	r2, [pc, #356]	; (9000aed0 <HAL_DMA_IRQHandler+0x1c4>)
9000ad6c:	4293      	cmp	r3, r2
9000ad6e:	d036      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000ad70:	687b      	ldr	r3, [r7, #4]
9000ad72:	681b      	ldr	r3, [r3, #0]
9000ad74:	4a57      	ldr	r2, [pc, #348]	; (9000aed4 <HAL_DMA_IRQHandler+0x1c8>)
9000ad76:	4293      	cmp	r3, r2
9000ad78:	d031      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000ad7a:	687b      	ldr	r3, [r7, #4]
9000ad7c:	681b      	ldr	r3, [r3, #0]
9000ad7e:	4a56      	ldr	r2, [pc, #344]	; (9000aed8 <HAL_DMA_IRQHandler+0x1cc>)
9000ad80:	4293      	cmp	r3, r2
9000ad82:	d02c      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000ad84:	687b      	ldr	r3, [r7, #4]
9000ad86:	681b      	ldr	r3, [r3, #0]
9000ad88:	4a54      	ldr	r2, [pc, #336]	; (9000aedc <HAL_DMA_IRQHandler+0x1d0>)
9000ad8a:	4293      	cmp	r3, r2
9000ad8c:	d027      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000ad8e:	687b      	ldr	r3, [r7, #4]
9000ad90:	681b      	ldr	r3, [r3, #0]
9000ad92:	4a53      	ldr	r2, [pc, #332]	; (9000aee0 <HAL_DMA_IRQHandler+0x1d4>)
9000ad94:	4293      	cmp	r3, r2
9000ad96:	d022      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000ad98:	687b      	ldr	r3, [r7, #4]
9000ad9a:	681b      	ldr	r3, [r3, #0]
9000ad9c:	4a51      	ldr	r2, [pc, #324]	; (9000aee4 <HAL_DMA_IRQHandler+0x1d8>)
9000ad9e:	4293      	cmp	r3, r2
9000ada0:	d01d      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000ada2:	687b      	ldr	r3, [r7, #4]
9000ada4:	681b      	ldr	r3, [r3, #0]
9000ada6:	4a50      	ldr	r2, [pc, #320]	; (9000aee8 <HAL_DMA_IRQHandler+0x1dc>)
9000ada8:	4293      	cmp	r3, r2
9000adaa:	d018      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000adac:	687b      	ldr	r3, [r7, #4]
9000adae:	681b      	ldr	r3, [r3, #0]
9000adb0:	4a4e      	ldr	r2, [pc, #312]	; (9000aeec <HAL_DMA_IRQHandler+0x1e0>)
9000adb2:	4293      	cmp	r3, r2
9000adb4:	d013      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000adb6:	687b      	ldr	r3, [r7, #4]
9000adb8:	681b      	ldr	r3, [r3, #0]
9000adba:	4a4d      	ldr	r2, [pc, #308]	; (9000aef0 <HAL_DMA_IRQHandler+0x1e4>)
9000adbc:	4293      	cmp	r3, r2
9000adbe:	d00e      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000adc0:	687b      	ldr	r3, [r7, #4]
9000adc2:	681b      	ldr	r3, [r3, #0]
9000adc4:	4a4b      	ldr	r2, [pc, #300]	; (9000aef4 <HAL_DMA_IRQHandler+0x1e8>)
9000adc6:	4293      	cmp	r3, r2
9000adc8:	d009      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000adca:	687b      	ldr	r3, [r7, #4]
9000adcc:	681b      	ldr	r3, [r3, #0]
9000adce:	4a4a      	ldr	r2, [pc, #296]	; (9000aef8 <HAL_DMA_IRQHandler+0x1ec>)
9000add0:	4293      	cmp	r3, r2
9000add2:	d004      	beq.n	9000adde <HAL_DMA_IRQHandler+0xd2>
9000add4:	687b      	ldr	r3, [r7, #4]
9000add6:	681b      	ldr	r3, [r3, #0]
9000add8:	4a48      	ldr	r2, [pc, #288]	; (9000aefc <HAL_DMA_IRQHandler+0x1f0>)
9000adda:	4293      	cmp	r3, r2
9000addc:	d101      	bne.n	9000ade2 <HAL_DMA_IRQHandler+0xd6>
9000adde:	2301      	movs	r3, #1
9000ade0:	e000      	b.n	9000ade4 <HAL_DMA_IRQHandler+0xd8>
9000ade2:	2300      	movs	r3, #0
9000ade4:	2b00      	cmp	r3, #0
9000ade6:	f000 842b 	beq.w	9000b640 <HAL_DMA_IRQHandler+0x934>
  {
    /* Transfer Error Interrupt management ***************************************/
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
9000adea:	687b      	ldr	r3, [r7, #4]
9000adec:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000adee:	f003 031f 	and.w	r3, r3, #31
9000adf2:	2208      	movs	r2, #8
9000adf4:	409a      	lsls	r2, r3
9000adf6:	69bb      	ldr	r3, [r7, #24]
9000adf8:	4013      	ands	r3, r2
9000adfa:	2b00      	cmp	r3, #0
9000adfc:	f000 80a2 	beq.w	9000af44 <HAL_DMA_IRQHandler+0x238>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
9000ae00:	687b      	ldr	r3, [r7, #4]
9000ae02:	681b      	ldr	r3, [r3, #0]
9000ae04:	4a2e      	ldr	r2, [pc, #184]	; (9000aec0 <HAL_DMA_IRQHandler+0x1b4>)
9000ae06:	4293      	cmp	r3, r2
9000ae08:	d04a      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae0a:	687b      	ldr	r3, [r7, #4]
9000ae0c:	681b      	ldr	r3, [r3, #0]
9000ae0e:	4a2d      	ldr	r2, [pc, #180]	; (9000aec4 <HAL_DMA_IRQHandler+0x1b8>)
9000ae10:	4293      	cmp	r3, r2
9000ae12:	d045      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae14:	687b      	ldr	r3, [r7, #4]
9000ae16:	681b      	ldr	r3, [r3, #0]
9000ae18:	4a2b      	ldr	r2, [pc, #172]	; (9000aec8 <HAL_DMA_IRQHandler+0x1bc>)
9000ae1a:	4293      	cmp	r3, r2
9000ae1c:	d040      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae1e:	687b      	ldr	r3, [r7, #4]
9000ae20:	681b      	ldr	r3, [r3, #0]
9000ae22:	4a2a      	ldr	r2, [pc, #168]	; (9000aecc <HAL_DMA_IRQHandler+0x1c0>)
9000ae24:	4293      	cmp	r3, r2
9000ae26:	d03b      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae28:	687b      	ldr	r3, [r7, #4]
9000ae2a:	681b      	ldr	r3, [r3, #0]
9000ae2c:	4a28      	ldr	r2, [pc, #160]	; (9000aed0 <HAL_DMA_IRQHandler+0x1c4>)
9000ae2e:	4293      	cmp	r3, r2
9000ae30:	d036      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae32:	687b      	ldr	r3, [r7, #4]
9000ae34:	681b      	ldr	r3, [r3, #0]
9000ae36:	4a27      	ldr	r2, [pc, #156]	; (9000aed4 <HAL_DMA_IRQHandler+0x1c8>)
9000ae38:	4293      	cmp	r3, r2
9000ae3a:	d031      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae3c:	687b      	ldr	r3, [r7, #4]
9000ae3e:	681b      	ldr	r3, [r3, #0]
9000ae40:	4a25      	ldr	r2, [pc, #148]	; (9000aed8 <HAL_DMA_IRQHandler+0x1cc>)
9000ae42:	4293      	cmp	r3, r2
9000ae44:	d02c      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae46:	687b      	ldr	r3, [r7, #4]
9000ae48:	681b      	ldr	r3, [r3, #0]
9000ae4a:	4a24      	ldr	r2, [pc, #144]	; (9000aedc <HAL_DMA_IRQHandler+0x1d0>)
9000ae4c:	4293      	cmp	r3, r2
9000ae4e:	d027      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae50:	687b      	ldr	r3, [r7, #4]
9000ae52:	681b      	ldr	r3, [r3, #0]
9000ae54:	4a22      	ldr	r2, [pc, #136]	; (9000aee0 <HAL_DMA_IRQHandler+0x1d4>)
9000ae56:	4293      	cmp	r3, r2
9000ae58:	d022      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae5a:	687b      	ldr	r3, [r7, #4]
9000ae5c:	681b      	ldr	r3, [r3, #0]
9000ae5e:	4a21      	ldr	r2, [pc, #132]	; (9000aee4 <HAL_DMA_IRQHandler+0x1d8>)
9000ae60:	4293      	cmp	r3, r2
9000ae62:	d01d      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae64:	687b      	ldr	r3, [r7, #4]
9000ae66:	681b      	ldr	r3, [r3, #0]
9000ae68:	4a1f      	ldr	r2, [pc, #124]	; (9000aee8 <HAL_DMA_IRQHandler+0x1dc>)
9000ae6a:	4293      	cmp	r3, r2
9000ae6c:	d018      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae6e:	687b      	ldr	r3, [r7, #4]
9000ae70:	681b      	ldr	r3, [r3, #0]
9000ae72:	4a1e      	ldr	r2, [pc, #120]	; (9000aeec <HAL_DMA_IRQHandler+0x1e0>)
9000ae74:	4293      	cmp	r3, r2
9000ae76:	d013      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae78:	687b      	ldr	r3, [r7, #4]
9000ae7a:	681b      	ldr	r3, [r3, #0]
9000ae7c:	4a1c      	ldr	r2, [pc, #112]	; (9000aef0 <HAL_DMA_IRQHandler+0x1e4>)
9000ae7e:	4293      	cmp	r3, r2
9000ae80:	d00e      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae82:	687b      	ldr	r3, [r7, #4]
9000ae84:	681b      	ldr	r3, [r3, #0]
9000ae86:	4a1b      	ldr	r2, [pc, #108]	; (9000aef4 <HAL_DMA_IRQHandler+0x1e8>)
9000ae88:	4293      	cmp	r3, r2
9000ae8a:	d009      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae8c:	687b      	ldr	r3, [r7, #4]
9000ae8e:	681b      	ldr	r3, [r3, #0]
9000ae90:	4a19      	ldr	r2, [pc, #100]	; (9000aef8 <HAL_DMA_IRQHandler+0x1ec>)
9000ae92:	4293      	cmp	r3, r2
9000ae94:	d004      	beq.n	9000aea0 <HAL_DMA_IRQHandler+0x194>
9000ae96:	687b      	ldr	r3, [r7, #4]
9000ae98:	681b      	ldr	r3, [r3, #0]
9000ae9a:	4a18      	ldr	r2, [pc, #96]	; (9000aefc <HAL_DMA_IRQHandler+0x1f0>)
9000ae9c:	4293      	cmp	r3, r2
9000ae9e:	d12f      	bne.n	9000af00 <HAL_DMA_IRQHandler+0x1f4>
9000aea0:	687b      	ldr	r3, [r7, #4]
9000aea2:	681b      	ldr	r3, [r3, #0]
9000aea4:	681b      	ldr	r3, [r3, #0]
9000aea6:	f003 0304 	and.w	r3, r3, #4
9000aeaa:	2b00      	cmp	r3, #0
9000aeac:	bf14      	ite	ne
9000aeae:	2301      	movne	r3, #1
9000aeb0:	2300      	moveq	r3, #0
9000aeb2:	b2db      	uxtb	r3, r3
9000aeb4:	e02e      	b.n	9000af14 <HAL_DMA_IRQHandler+0x208>
9000aeb6:	bf00      	nop
9000aeb8:	24000090 	.word	0x24000090
9000aebc:	1b4e81b5 	.word	0x1b4e81b5
9000aec0:	40020010 	.word	0x40020010
9000aec4:	40020028 	.word	0x40020028
9000aec8:	40020040 	.word	0x40020040
9000aecc:	40020058 	.word	0x40020058
9000aed0:	40020070 	.word	0x40020070
9000aed4:	40020088 	.word	0x40020088
9000aed8:	400200a0 	.word	0x400200a0
9000aedc:	400200b8 	.word	0x400200b8
9000aee0:	40020410 	.word	0x40020410
9000aee4:	40020428 	.word	0x40020428
9000aee8:	40020440 	.word	0x40020440
9000aeec:	40020458 	.word	0x40020458
9000aef0:	40020470 	.word	0x40020470
9000aef4:	40020488 	.word	0x40020488
9000aef8:	400204a0 	.word	0x400204a0
9000aefc:	400204b8 	.word	0x400204b8
9000af00:	687b      	ldr	r3, [r7, #4]
9000af02:	681b      	ldr	r3, [r3, #0]
9000af04:	681b      	ldr	r3, [r3, #0]
9000af06:	f003 0308 	and.w	r3, r3, #8
9000af0a:	2b00      	cmp	r3, #0
9000af0c:	bf14      	ite	ne
9000af0e:	2301      	movne	r3, #1
9000af10:	2300      	moveq	r3, #0
9000af12:	b2db      	uxtb	r3, r3
9000af14:	2b00      	cmp	r3, #0
9000af16:	d015      	beq.n	9000af44 <HAL_DMA_IRQHandler+0x238>
      {
        /* Disable the transfer error interrupt */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
9000af18:	687b      	ldr	r3, [r7, #4]
9000af1a:	681b      	ldr	r3, [r3, #0]
9000af1c:	681a      	ldr	r2, [r3, #0]
9000af1e:	687b      	ldr	r3, [r7, #4]
9000af20:	681b      	ldr	r3, [r3, #0]
9000af22:	f022 0204 	bic.w	r2, r2, #4
9000af26:	601a      	str	r2, [r3, #0]

        /* Clear the transfer error flag */
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
9000af28:	687b      	ldr	r3, [r7, #4]
9000af2a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000af2c:	f003 031f 	and.w	r3, r3, #31
9000af30:	2208      	movs	r2, #8
9000af32:	409a      	lsls	r2, r3
9000af34:	6a3b      	ldr	r3, [r7, #32]
9000af36:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
9000af38:	687b      	ldr	r3, [r7, #4]
9000af3a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000af3c:	f043 0201 	orr.w	r2, r3, #1
9000af40:	687b      	ldr	r3, [r7, #4]
9000af42:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* FIFO Error Interrupt management ******************************************/
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
9000af44:	687b      	ldr	r3, [r7, #4]
9000af46:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000af48:	f003 031f 	and.w	r3, r3, #31
9000af4c:	69ba      	ldr	r2, [r7, #24]
9000af4e:	fa22 f303 	lsr.w	r3, r2, r3
9000af52:	f003 0301 	and.w	r3, r3, #1
9000af56:	2b00      	cmp	r3, #0
9000af58:	d06e      	beq.n	9000b038 <HAL_DMA_IRQHandler+0x32c>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
9000af5a:	687b      	ldr	r3, [r7, #4]
9000af5c:	681b      	ldr	r3, [r3, #0]
9000af5e:	4a69      	ldr	r2, [pc, #420]	; (9000b104 <HAL_DMA_IRQHandler+0x3f8>)
9000af60:	4293      	cmp	r3, r2
9000af62:	d04a      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000af64:	687b      	ldr	r3, [r7, #4]
9000af66:	681b      	ldr	r3, [r3, #0]
9000af68:	4a67      	ldr	r2, [pc, #412]	; (9000b108 <HAL_DMA_IRQHandler+0x3fc>)
9000af6a:	4293      	cmp	r3, r2
9000af6c:	d045      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000af6e:	687b      	ldr	r3, [r7, #4]
9000af70:	681b      	ldr	r3, [r3, #0]
9000af72:	4a66      	ldr	r2, [pc, #408]	; (9000b10c <HAL_DMA_IRQHandler+0x400>)
9000af74:	4293      	cmp	r3, r2
9000af76:	d040      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000af78:	687b      	ldr	r3, [r7, #4]
9000af7a:	681b      	ldr	r3, [r3, #0]
9000af7c:	4a64      	ldr	r2, [pc, #400]	; (9000b110 <HAL_DMA_IRQHandler+0x404>)
9000af7e:	4293      	cmp	r3, r2
9000af80:	d03b      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000af82:	687b      	ldr	r3, [r7, #4]
9000af84:	681b      	ldr	r3, [r3, #0]
9000af86:	4a63      	ldr	r2, [pc, #396]	; (9000b114 <HAL_DMA_IRQHandler+0x408>)
9000af88:	4293      	cmp	r3, r2
9000af8a:	d036      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000af8c:	687b      	ldr	r3, [r7, #4]
9000af8e:	681b      	ldr	r3, [r3, #0]
9000af90:	4a61      	ldr	r2, [pc, #388]	; (9000b118 <HAL_DMA_IRQHandler+0x40c>)
9000af92:	4293      	cmp	r3, r2
9000af94:	d031      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000af96:	687b      	ldr	r3, [r7, #4]
9000af98:	681b      	ldr	r3, [r3, #0]
9000af9a:	4a60      	ldr	r2, [pc, #384]	; (9000b11c <HAL_DMA_IRQHandler+0x410>)
9000af9c:	4293      	cmp	r3, r2
9000af9e:	d02c      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000afa0:	687b      	ldr	r3, [r7, #4]
9000afa2:	681b      	ldr	r3, [r3, #0]
9000afa4:	4a5e      	ldr	r2, [pc, #376]	; (9000b120 <HAL_DMA_IRQHandler+0x414>)
9000afa6:	4293      	cmp	r3, r2
9000afa8:	d027      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000afaa:	687b      	ldr	r3, [r7, #4]
9000afac:	681b      	ldr	r3, [r3, #0]
9000afae:	4a5d      	ldr	r2, [pc, #372]	; (9000b124 <HAL_DMA_IRQHandler+0x418>)
9000afb0:	4293      	cmp	r3, r2
9000afb2:	d022      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000afb4:	687b      	ldr	r3, [r7, #4]
9000afb6:	681b      	ldr	r3, [r3, #0]
9000afb8:	4a5b      	ldr	r2, [pc, #364]	; (9000b128 <HAL_DMA_IRQHandler+0x41c>)
9000afba:	4293      	cmp	r3, r2
9000afbc:	d01d      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000afbe:	687b      	ldr	r3, [r7, #4]
9000afc0:	681b      	ldr	r3, [r3, #0]
9000afc2:	4a5a      	ldr	r2, [pc, #360]	; (9000b12c <HAL_DMA_IRQHandler+0x420>)
9000afc4:	4293      	cmp	r3, r2
9000afc6:	d018      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000afc8:	687b      	ldr	r3, [r7, #4]
9000afca:	681b      	ldr	r3, [r3, #0]
9000afcc:	4a58      	ldr	r2, [pc, #352]	; (9000b130 <HAL_DMA_IRQHandler+0x424>)
9000afce:	4293      	cmp	r3, r2
9000afd0:	d013      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000afd2:	687b      	ldr	r3, [r7, #4]
9000afd4:	681b      	ldr	r3, [r3, #0]
9000afd6:	4a57      	ldr	r2, [pc, #348]	; (9000b134 <HAL_DMA_IRQHandler+0x428>)
9000afd8:	4293      	cmp	r3, r2
9000afda:	d00e      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000afdc:	687b      	ldr	r3, [r7, #4]
9000afde:	681b      	ldr	r3, [r3, #0]
9000afe0:	4a55      	ldr	r2, [pc, #340]	; (9000b138 <HAL_DMA_IRQHandler+0x42c>)
9000afe2:	4293      	cmp	r3, r2
9000afe4:	d009      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000afe6:	687b      	ldr	r3, [r7, #4]
9000afe8:	681b      	ldr	r3, [r3, #0]
9000afea:	4a54      	ldr	r2, [pc, #336]	; (9000b13c <HAL_DMA_IRQHandler+0x430>)
9000afec:	4293      	cmp	r3, r2
9000afee:	d004      	beq.n	9000affa <HAL_DMA_IRQHandler+0x2ee>
9000aff0:	687b      	ldr	r3, [r7, #4]
9000aff2:	681b      	ldr	r3, [r3, #0]
9000aff4:	4a52      	ldr	r2, [pc, #328]	; (9000b140 <HAL_DMA_IRQHandler+0x434>)
9000aff6:	4293      	cmp	r3, r2
9000aff8:	d10a      	bne.n	9000b010 <HAL_DMA_IRQHandler+0x304>
9000affa:	687b      	ldr	r3, [r7, #4]
9000affc:	681b      	ldr	r3, [r3, #0]
9000affe:	695b      	ldr	r3, [r3, #20]
9000b000:	f003 0380 	and.w	r3, r3, #128	; 0x80
9000b004:	2b00      	cmp	r3, #0
9000b006:	bf14      	ite	ne
9000b008:	2301      	movne	r3, #1
9000b00a:	2300      	moveq	r3, #0
9000b00c:	b2db      	uxtb	r3, r3
9000b00e:	e003      	b.n	9000b018 <HAL_DMA_IRQHandler+0x30c>
9000b010:	687b      	ldr	r3, [r7, #4]
9000b012:	681b      	ldr	r3, [r3, #0]
9000b014:	681b      	ldr	r3, [r3, #0]
9000b016:	2300      	movs	r3, #0
9000b018:	2b00      	cmp	r3, #0
9000b01a:	d00d      	beq.n	9000b038 <HAL_DMA_IRQHandler+0x32c>
      {
        /* Clear the FIFO error flag */
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
9000b01c:	687b      	ldr	r3, [r7, #4]
9000b01e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b020:	f003 031f 	and.w	r3, r3, #31
9000b024:	2201      	movs	r2, #1
9000b026:	409a      	lsls	r2, r3
9000b028:	6a3b      	ldr	r3, [r7, #32]
9000b02a:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
9000b02c:	687b      	ldr	r3, [r7, #4]
9000b02e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000b030:	f043 0202 	orr.w	r2, r3, #2
9000b034:	687b      	ldr	r3, [r7, #4]
9000b036:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Direct Mode Error Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
9000b038:	687b      	ldr	r3, [r7, #4]
9000b03a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b03c:	f003 031f 	and.w	r3, r3, #31
9000b040:	2204      	movs	r2, #4
9000b042:	409a      	lsls	r2, r3
9000b044:	69bb      	ldr	r3, [r7, #24]
9000b046:	4013      	ands	r3, r2
9000b048:	2b00      	cmp	r3, #0
9000b04a:	f000 808f 	beq.w	9000b16c <HAL_DMA_IRQHandler+0x460>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
9000b04e:	687b      	ldr	r3, [r7, #4]
9000b050:	681b      	ldr	r3, [r3, #0]
9000b052:	4a2c      	ldr	r2, [pc, #176]	; (9000b104 <HAL_DMA_IRQHandler+0x3f8>)
9000b054:	4293      	cmp	r3, r2
9000b056:	d04a      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b058:	687b      	ldr	r3, [r7, #4]
9000b05a:	681b      	ldr	r3, [r3, #0]
9000b05c:	4a2a      	ldr	r2, [pc, #168]	; (9000b108 <HAL_DMA_IRQHandler+0x3fc>)
9000b05e:	4293      	cmp	r3, r2
9000b060:	d045      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b062:	687b      	ldr	r3, [r7, #4]
9000b064:	681b      	ldr	r3, [r3, #0]
9000b066:	4a29      	ldr	r2, [pc, #164]	; (9000b10c <HAL_DMA_IRQHandler+0x400>)
9000b068:	4293      	cmp	r3, r2
9000b06a:	d040      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b06c:	687b      	ldr	r3, [r7, #4]
9000b06e:	681b      	ldr	r3, [r3, #0]
9000b070:	4a27      	ldr	r2, [pc, #156]	; (9000b110 <HAL_DMA_IRQHandler+0x404>)
9000b072:	4293      	cmp	r3, r2
9000b074:	d03b      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b076:	687b      	ldr	r3, [r7, #4]
9000b078:	681b      	ldr	r3, [r3, #0]
9000b07a:	4a26      	ldr	r2, [pc, #152]	; (9000b114 <HAL_DMA_IRQHandler+0x408>)
9000b07c:	4293      	cmp	r3, r2
9000b07e:	d036      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b080:	687b      	ldr	r3, [r7, #4]
9000b082:	681b      	ldr	r3, [r3, #0]
9000b084:	4a24      	ldr	r2, [pc, #144]	; (9000b118 <HAL_DMA_IRQHandler+0x40c>)
9000b086:	4293      	cmp	r3, r2
9000b088:	d031      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b08a:	687b      	ldr	r3, [r7, #4]
9000b08c:	681b      	ldr	r3, [r3, #0]
9000b08e:	4a23      	ldr	r2, [pc, #140]	; (9000b11c <HAL_DMA_IRQHandler+0x410>)
9000b090:	4293      	cmp	r3, r2
9000b092:	d02c      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b094:	687b      	ldr	r3, [r7, #4]
9000b096:	681b      	ldr	r3, [r3, #0]
9000b098:	4a21      	ldr	r2, [pc, #132]	; (9000b120 <HAL_DMA_IRQHandler+0x414>)
9000b09a:	4293      	cmp	r3, r2
9000b09c:	d027      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b09e:	687b      	ldr	r3, [r7, #4]
9000b0a0:	681b      	ldr	r3, [r3, #0]
9000b0a2:	4a20      	ldr	r2, [pc, #128]	; (9000b124 <HAL_DMA_IRQHandler+0x418>)
9000b0a4:	4293      	cmp	r3, r2
9000b0a6:	d022      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b0a8:	687b      	ldr	r3, [r7, #4]
9000b0aa:	681b      	ldr	r3, [r3, #0]
9000b0ac:	4a1e      	ldr	r2, [pc, #120]	; (9000b128 <HAL_DMA_IRQHandler+0x41c>)
9000b0ae:	4293      	cmp	r3, r2
9000b0b0:	d01d      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b0b2:	687b      	ldr	r3, [r7, #4]
9000b0b4:	681b      	ldr	r3, [r3, #0]
9000b0b6:	4a1d      	ldr	r2, [pc, #116]	; (9000b12c <HAL_DMA_IRQHandler+0x420>)
9000b0b8:	4293      	cmp	r3, r2
9000b0ba:	d018      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b0bc:	687b      	ldr	r3, [r7, #4]
9000b0be:	681b      	ldr	r3, [r3, #0]
9000b0c0:	4a1b      	ldr	r2, [pc, #108]	; (9000b130 <HAL_DMA_IRQHandler+0x424>)
9000b0c2:	4293      	cmp	r3, r2
9000b0c4:	d013      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b0c6:	687b      	ldr	r3, [r7, #4]
9000b0c8:	681b      	ldr	r3, [r3, #0]
9000b0ca:	4a1a      	ldr	r2, [pc, #104]	; (9000b134 <HAL_DMA_IRQHandler+0x428>)
9000b0cc:	4293      	cmp	r3, r2
9000b0ce:	d00e      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b0d0:	687b      	ldr	r3, [r7, #4]
9000b0d2:	681b      	ldr	r3, [r3, #0]
9000b0d4:	4a18      	ldr	r2, [pc, #96]	; (9000b138 <HAL_DMA_IRQHandler+0x42c>)
9000b0d6:	4293      	cmp	r3, r2
9000b0d8:	d009      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b0da:	687b      	ldr	r3, [r7, #4]
9000b0dc:	681b      	ldr	r3, [r3, #0]
9000b0de:	4a17      	ldr	r2, [pc, #92]	; (9000b13c <HAL_DMA_IRQHandler+0x430>)
9000b0e0:	4293      	cmp	r3, r2
9000b0e2:	d004      	beq.n	9000b0ee <HAL_DMA_IRQHandler+0x3e2>
9000b0e4:	687b      	ldr	r3, [r7, #4]
9000b0e6:	681b      	ldr	r3, [r3, #0]
9000b0e8:	4a15      	ldr	r2, [pc, #84]	; (9000b140 <HAL_DMA_IRQHandler+0x434>)
9000b0ea:	4293      	cmp	r3, r2
9000b0ec:	d12a      	bne.n	9000b144 <HAL_DMA_IRQHandler+0x438>
9000b0ee:	687b      	ldr	r3, [r7, #4]
9000b0f0:	681b      	ldr	r3, [r3, #0]
9000b0f2:	681b      	ldr	r3, [r3, #0]
9000b0f4:	f003 0302 	and.w	r3, r3, #2
9000b0f8:	2b00      	cmp	r3, #0
9000b0fa:	bf14      	ite	ne
9000b0fc:	2301      	movne	r3, #1
9000b0fe:	2300      	moveq	r3, #0
9000b100:	b2db      	uxtb	r3, r3
9000b102:	e023      	b.n	9000b14c <HAL_DMA_IRQHandler+0x440>
9000b104:	40020010 	.word	0x40020010
9000b108:	40020028 	.word	0x40020028
9000b10c:	40020040 	.word	0x40020040
9000b110:	40020058 	.word	0x40020058
9000b114:	40020070 	.word	0x40020070
9000b118:	40020088 	.word	0x40020088
9000b11c:	400200a0 	.word	0x400200a0
9000b120:	400200b8 	.word	0x400200b8
9000b124:	40020410 	.word	0x40020410
9000b128:	40020428 	.word	0x40020428
9000b12c:	40020440 	.word	0x40020440
9000b130:	40020458 	.word	0x40020458
9000b134:	40020470 	.word	0x40020470
9000b138:	40020488 	.word	0x40020488
9000b13c:	400204a0 	.word	0x400204a0
9000b140:	400204b8 	.word	0x400204b8
9000b144:	687b      	ldr	r3, [r7, #4]
9000b146:	681b      	ldr	r3, [r3, #0]
9000b148:	681b      	ldr	r3, [r3, #0]
9000b14a:	2300      	movs	r3, #0
9000b14c:	2b00      	cmp	r3, #0
9000b14e:	d00d      	beq.n	9000b16c <HAL_DMA_IRQHandler+0x460>
      {
        /* Clear the direct mode error flag */
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
9000b150:	687b      	ldr	r3, [r7, #4]
9000b152:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b154:	f003 031f 	and.w	r3, r3, #31
9000b158:	2204      	movs	r2, #4
9000b15a:	409a      	lsls	r2, r3
9000b15c:	6a3b      	ldr	r3, [r7, #32]
9000b15e:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
9000b160:	687b      	ldr	r3, [r7, #4]
9000b162:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000b164:	f043 0204 	orr.w	r2, r3, #4
9000b168:	687b      	ldr	r3, [r7, #4]
9000b16a:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Half Transfer Complete Interrupt management ******************************/
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
9000b16c:	687b      	ldr	r3, [r7, #4]
9000b16e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b170:	f003 031f 	and.w	r3, r3, #31
9000b174:	2210      	movs	r2, #16
9000b176:	409a      	lsls	r2, r3
9000b178:	69bb      	ldr	r3, [r7, #24]
9000b17a:	4013      	ands	r3, r2
9000b17c:	2b00      	cmp	r3, #0
9000b17e:	f000 80a6 	beq.w	9000b2ce <HAL_DMA_IRQHandler+0x5c2>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
9000b182:	687b      	ldr	r3, [r7, #4]
9000b184:	681b      	ldr	r3, [r3, #0]
9000b186:	4a85      	ldr	r2, [pc, #532]	; (9000b39c <HAL_DMA_IRQHandler+0x690>)
9000b188:	4293      	cmp	r3, r2
9000b18a:	d04a      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b18c:	687b      	ldr	r3, [r7, #4]
9000b18e:	681b      	ldr	r3, [r3, #0]
9000b190:	4a83      	ldr	r2, [pc, #524]	; (9000b3a0 <HAL_DMA_IRQHandler+0x694>)
9000b192:	4293      	cmp	r3, r2
9000b194:	d045      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b196:	687b      	ldr	r3, [r7, #4]
9000b198:	681b      	ldr	r3, [r3, #0]
9000b19a:	4a82      	ldr	r2, [pc, #520]	; (9000b3a4 <HAL_DMA_IRQHandler+0x698>)
9000b19c:	4293      	cmp	r3, r2
9000b19e:	d040      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b1a0:	687b      	ldr	r3, [r7, #4]
9000b1a2:	681b      	ldr	r3, [r3, #0]
9000b1a4:	4a80      	ldr	r2, [pc, #512]	; (9000b3a8 <HAL_DMA_IRQHandler+0x69c>)
9000b1a6:	4293      	cmp	r3, r2
9000b1a8:	d03b      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b1aa:	687b      	ldr	r3, [r7, #4]
9000b1ac:	681b      	ldr	r3, [r3, #0]
9000b1ae:	4a7f      	ldr	r2, [pc, #508]	; (9000b3ac <HAL_DMA_IRQHandler+0x6a0>)
9000b1b0:	4293      	cmp	r3, r2
9000b1b2:	d036      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b1b4:	687b      	ldr	r3, [r7, #4]
9000b1b6:	681b      	ldr	r3, [r3, #0]
9000b1b8:	4a7d      	ldr	r2, [pc, #500]	; (9000b3b0 <HAL_DMA_IRQHandler+0x6a4>)
9000b1ba:	4293      	cmp	r3, r2
9000b1bc:	d031      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b1be:	687b      	ldr	r3, [r7, #4]
9000b1c0:	681b      	ldr	r3, [r3, #0]
9000b1c2:	4a7c      	ldr	r2, [pc, #496]	; (9000b3b4 <HAL_DMA_IRQHandler+0x6a8>)
9000b1c4:	4293      	cmp	r3, r2
9000b1c6:	d02c      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b1c8:	687b      	ldr	r3, [r7, #4]
9000b1ca:	681b      	ldr	r3, [r3, #0]
9000b1cc:	4a7a      	ldr	r2, [pc, #488]	; (9000b3b8 <HAL_DMA_IRQHandler+0x6ac>)
9000b1ce:	4293      	cmp	r3, r2
9000b1d0:	d027      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b1d2:	687b      	ldr	r3, [r7, #4]
9000b1d4:	681b      	ldr	r3, [r3, #0]
9000b1d6:	4a79      	ldr	r2, [pc, #484]	; (9000b3bc <HAL_DMA_IRQHandler+0x6b0>)
9000b1d8:	4293      	cmp	r3, r2
9000b1da:	d022      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b1dc:	687b      	ldr	r3, [r7, #4]
9000b1de:	681b      	ldr	r3, [r3, #0]
9000b1e0:	4a77      	ldr	r2, [pc, #476]	; (9000b3c0 <HAL_DMA_IRQHandler+0x6b4>)
9000b1e2:	4293      	cmp	r3, r2
9000b1e4:	d01d      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b1e6:	687b      	ldr	r3, [r7, #4]
9000b1e8:	681b      	ldr	r3, [r3, #0]
9000b1ea:	4a76      	ldr	r2, [pc, #472]	; (9000b3c4 <HAL_DMA_IRQHandler+0x6b8>)
9000b1ec:	4293      	cmp	r3, r2
9000b1ee:	d018      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b1f0:	687b      	ldr	r3, [r7, #4]
9000b1f2:	681b      	ldr	r3, [r3, #0]
9000b1f4:	4a74      	ldr	r2, [pc, #464]	; (9000b3c8 <HAL_DMA_IRQHandler+0x6bc>)
9000b1f6:	4293      	cmp	r3, r2
9000b1f8:	d013      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b1fa:	687b      	ldr	r3, [r7, #4]
9000b1fc:	681b      	ldr	r3, [r3, #0]
9000b1fe:	4a73      	ldr	r2, [pc, #460]	; (9000b3cc <HAL_DMA_IRQHandler+0x6c0>)
9000b200:	4293      	cmp	r3, r2
9000b202:	d00e      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b204:	687b      	ldr	r3, [r7, #4]
9000b206:	681b      	ldr	r3, [r3, #0]
9000b208:	4a71      	ldr	r2, [pc, #452]	; (9000b3d0 <HAL_DMA_IRQHandler+0x6c4>)
9000b20a:	4293      	cmp	r3, r2
9000b20c:	d009      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b20e:	687b      	ldr	r3, [r7, #4]
9000b210:	681b      	ldr	r3, [r3, #0]
9000b212:	4a70      	ldr	r2, [pc, #448]	; (9000b3d4 <HAL_DMA_IRQHandler+0x6c8>)
9000b214:	4293      	cmp	r3, r2
9000b216:	d004      	beq.n	9000b222 <HAL_DMA_IRQHandler+0x516>
9000b218:	687b      	ldr	r3, [r7, #4]
9000b21a:	681b      	ldr	r3, [r3, #0]
9000b21c:	4a6e      	ldr	r2, [pc, #440]	; (9000b3d8 <HAL_DMA_IRQHandler+0x6cc>)
9000b21e:	4293      	cmp	r3, r2
9000b220:	d10a      	bne.n	9000b238 <HAL_DMA_IRQHandler+0x52c>
9000b222:	687b      	ldr	r3, [r7, #4]
9000b224:	681b      	ldr	r3, [r3, #0]
9000b226:	681b      	ldr	r3, [r3, #0]
9000b228:	f003 0308 	and.w	r3, r3, #8
9000b22c:	2b00      	cmp	r3, #0
9000b22e:	bf14      	ite	ne
9000b230:	2301      	movne	r3, #1
9000b232:	2300      	moveq	r3, #0
9000b234:	b2db      	uxtb	r3, r3
9000b236:	e009      	b.n	9000b24c <HAL_DMA_IRQHandler+0x540>
9000b238:	687b      	ldr	r3, [r7, #4]
9000b23a:	681b      	ldr	r3, [r3, #0]
9000b23c:	681b      	ldr	r3, [r3, #0]
9000b23e:	f003 0304 	and.w	r3, r3, #4
9000b242:	2b00      	cmp	r3, #0
9000b244:	bf14      	ite	ne
9000b246:	2301      	movne	r3, #1
9000b248:	2300      	moveq	r3, #0
9000b24a:	b2db      	uxtb	r3, r3
9000b24c:	2b00      	cmp	r3, #0
9000b24e:	d03e      	beq.n	9000b2ce <HAL_DMA_IRQHandler+0x5c2>
      {
        /* Clear the half transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
9000b250:	687b      	ldr	r3, [r7, #4]
9000b252:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b254:	f003 031f 	and.w	r3, r3, #31
9000b258:	2210      	movs	r2, #16
9000b25a:	409a      	lsls	r2, r3
9000b25c:	6a3b      	ldr	r3, [r7, #32]
9000b25e:	609a      	str	r2, [r3, #8]

        /* Multi_Buffering mode enabled */
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
9000b260:	687b      	ldr	r3, [r7, #4]
9000b262:	681b      	ldr	r3, [r3, #0]
9000b264:	681b      	ldr	r3, [r3, #0]
9000b266:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
9000b26a:	2b00      	cmp	r3, #0
9000b26c:	d018      	beq.n	9000b2a0 <HAL_DMA_IRQHandler+0x594>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
9000b26e:	687b      	ldr	r3, [r7, #4]
9000b270:	681b      	ldr	r3, [r3, #0]
9000b272:	681b      	ldr	r3, [r3, #0]
9000b274:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
9000b278:	2b00      	cmp	r3, #0
9000b27a:	d108      	bne.n	9000b28e <HAL_DMA_IRQHandler+0x582>
          {
            if(hdma->XferHalfCpltCallback != NULL)
9000b27c:	687b      	ldr	r3, [r7, #4]
9000b27e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000b280:	2b00      	cmp	r3, #0
9000b282:	d024      	beq.n	9000b2ce <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferHalfCpltCallback(hdma);
9000b284:	687b      	ldr	r3, [r7, #4]
9000b286:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000b288:	6878      	ldr	r0, [r7, #4]
9000b28a:	4798      	blx	r3
9000b28c:	e01f      	b.n	9000b2ce <HAL_DMA_IRQHandler+0x5c2>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferM1HalfCpltCallback != NULL)
9000b28e:	687b      	ldr	r3, [r7, #4]
9000b290:	6c9b      	ldr	r3, [r3, #72]	; 0x48
9000b292:	2b00      	cmp	r3, #0
9000b294:	d01b      	beq.n	9000b2ce <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferM1HalfCpltCallback(hdma);
9000b296:	687b      	ldr	r3, [r7, #4]
9000b298:	6c9b      	ldr	r3, [r3, #72]	; 0x48
9000b29a:	6878      	ldr	r0, [r7, #4]
9000b29c:	4798      	blx	r3
9000b29e:	e016      	b.n	9000b2ce <HAL_DMA_IRQHandler+0x5c2>
          }
        }
        else
        {
          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
9000b2a0:	687b      	ldr	r3, [r7, #4]
9000b2a2:	681b      	ldr	r3, [r3, #0]
9000b2a4:	681b      	ldr	r3, [r3, #0]
9000b2a6:	f403 7380 	and.w	r3, r3, #256	; 0x100
9000b2aa:	2b00      	cmp	r3, #0
9000b2ac:	d107      	bne.n	9000b2be <HAL_DMA_IRQHandler+0x5b2>
          {
            /* Disable the half transfer interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
9000b2ae:	687b      	ldr	r3, [r7, #4]
9000b2b0:	681b      	ldr	r3, [r3, #0]
9000b2b2:	681a      	ldr	r2, [r3, #0]
9000b2b4:	687b      	ldr	r3, [r7, #4]
9000b2b6:	681b      	ldr	r3, [r3, #0]
9000b2b8:	f022 0208 	bic.w	r2, r2, #8
9000b2bc:	601a      	str	r2, [r3, #0]
          }

          if(hdma->XferHalfCpltCallback != NULL)
9000b2be:	687b      	ldr	r3, [r7, #4]
9000b2c0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000b2c2:	2b00      	cmp	r3, #0
9000b2c4:	d003      	beq.n	9000b2ce <HAL_DMA_IRQHandler+0x5c2>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
9000b2c6:	687b      	ldr	r3, [r7, #4]
9000b2c8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000b2ca:	6878      	ldr	r0, [r7, #4]
9000b2cc:	4798      	blx	r3
          }
        }
      }
    }
    /* Transfer Complete Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
9000b2ce:	687b      	ldr	r3, [r7, #4]
9000b2d0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b2d2:	f003 031f 	and.w	r3, r3, #31
9000b2d6:	2220      	movs	r2, #32
9000b2d8:	409a      	lsls	r2, r3
9000b2da:	69bb      	ldr	r3, [r7, #24]
9000b2dc:	4013      	ands	r3, r2
9000b2de:	2b00      	cmp	r3, #0
9000b2e0:	f000 8110 	beq.w	9000b504 <HAL_DMA_IRQHandler+0x7f8>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
9000b2e4:	687b      	ldr	r3, [r7, #4]
9000b2e6:	681b      	ldr	r3, [r3, #0]
9000b2e8:	4a2c      	ldr	r2, [pc, #176]	; (9000b39c <HAL_DMA_IRQHandler+0x690>)
9000b2ea:	4293      	cmp	r3, r2
9000b2ec:	d04a      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b2ee:	687b      	ldr	r3, [r7, #4]
9000b2f0:	681b      	ldr	r3, [r3, #0]
9000b2f2:	4a2b      	ldr	r2, [pc, #172]	; (9000b3a0 <HAL_DMA_IRQHandler+0x694>)
9000b2f4:	4293      	cmp	r3, r2
9000b2f6:	d045      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b2f8:	687b      	ldr	r3, [r7, #4]
9000b2fa:	681b      	ldr	r3, [r3, #0]
9000b2fc:	4a29      	ldr	r2, [pc, #164]	; (9000b3a4 <HAL_DMA_IRQHandler+0x698>)
9000b2fe:	4293      	cmp	r3, r2
9000b300:	d040      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b302:	687b      	ldr	r3, [r7, #4]
9000b304:	681b      	ldr	r3, [r3, #0]
9000b306:	4a28      	ldr	r2, [pc, #160]	; (9000b3a8 <HAL_DMA_IRQHandler+0x69c>)
9000b308:	4293      	cmp	r3, r2
9000b30a:	d03b      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b30c:	687b      	ldr	r3, [r7, #4]
9000b30e:	681b      	ldr	r3, [r3, #0]
9000b310:	4a26      	ldr	r2, [pc, #152]	; (9000b3ac <HAL_DMA_IRQHandler+0x6a0>)
9000b312:	4293      	cmp	r3, r2
9000b314:	d036      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b316:	687b      	ldr	r3, [r7, #4]
9000b318:	681b      	ldr	r3, [r3, #0]
9000b31a:	4a25      	ldr	r2, [pc, #148]	; (9000b3b0 <HAL_DMA_IRQHandler+0x6a4>)
9000b31c:	4293      	cmp	r3, r2
9000b31e:	d031      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b320:	687b      	ldr	r3, [r7, #4]
9000b322:	681b      	ldr	r3, [r3, #0]
9000b324:	4a23      	ldr	r2, [pc, #140]	; (9000b3b4 <HAL_DMA_IRQHandler+0x6a8>)
9000b326:	4293      	cmp	r3, r2
9000b328:	d02c      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b32a:	687b      	ldr	r3, [r7, #4]
9000b32c:	681b      	ldr	r3, [r3, #0]
9000b32e:	4a22      	ldr	r2, [pc, #136]	; (9000b3b8 <HAL_DMA_IRQHandler+0x6ac>)
9000b330:	4293      	cmp	r3, r2
9000b332:	d027      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b334:	687b      	ldr	r3, [r7, #4]
9000b336:	681b      	ldr	r3, [r3, #0]
9000b338:	4a20      	ldr	r2, [pc, #128]	; (9000b3bc <HAL_DMA_IRQHandler+0x6b0>)
9000b33a:	4293      	cmp	r3, r2
9000b33c:	d022      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b33e:	687b      	ldr	r3, [r7, #4]
9000b340:	681b      	ldr	r3, [r3, #0]
9000b342:	4a1f      	ldr	r2, [pc, #124]	; (9000b3c0 <HAL_DMA_IRQHandler+0x6b4>)
9000b344:	4293      	cmp	r3, r2
9000b346:	d01d      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b348:	687b      	ldr	r3, [r7, #4]
9000b34a:	681b      	ldr	r3, [r3, #0]
9000b34c:	4a1d      	ldr	r2, [pc, #116]	; (9000b3c4 <HAL_DMA_IRQHandler+0x6b8>)
9000b34e:	4293      	cmp	r3, r2
9000b350:	d018      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b352:	687b      	ldr	r3, [r7, #4]
9000b354:	681b      	ldr	r3, [r3, #0]
9000b356:	4a1c      	ldr	r2, [pc, #112]	; (9000b3c8 <HAL_DMA_IRQHandler+0x6bc>)
9000b358:	4293      	cmp	r3, r2
9000b35a:	d013      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b35c:	687b      	ldr	r3, [r7, #4]
9000b35e:	681b      	ldr	r3, [r3, #0]
9000b360:	4a1a      	ldr	r2, [pc, #104]	; (9000b3cc <HAL_DMA_IRQHandler+0x6c0>)
9000b362:	4293      	cmp	r3, r2
9000b364:	d00e      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b366:	687b      	ldr	r3, [r7, #4]
9000b368:	681b      	ldr	r3, [r3, #0]
9000b36a:	4a19      	ldr	r2, [pc, #100]	; (9000b3d0 <HAL_DMA_IRQHandler+0x6c4>)
9000b36c:	4293      	cmp	r3, r2
9000b36e:	d009      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b370:	687b      	ldr	r3, [r7, #4]
9000b372:	681b      	ldr	r3, [r3, #0]
9000b374:	4a17      	ldr	r2, [pc, #92]	; (9000b3d4 <HAL_DMA_IRQHandler+0x6c8>)
9000b376:	4293      	cmp	r3, r2
9000b378:	d004      	beq.n	9000b384 <HAL_DMA_IRQHandler+0x678>
9000b37a:	687b      	ldr	r3, [r7, #4]
9000b37c:	681b      	ldr	r3, [r3, #0]
9000b37e:	4a16      	ldr	r2, [pc, #88]	; (9000b3d8 <HAL_DMA_IRQHandler+0x6cc>)
9000b380:	4293      	cmp	r3, r2
9000b382:	d12b      	bne.n	9000b3dc <HAL_DMA_IRQHandler+0x6d0>
9000b384:	687b      	ldr	r3, [r7, #4]
9000b386:	681b      	ldr	r3, [r3, #0]
9000b388:	681b      	ldr	r3, [r3, #0]
9000b38a:	f003 0310 	and.w	r3, r3, #16
9000b38e:	2b00      	cmp	r3, #0
9000b390:	bf14      	ite	ne
9000b392:	2301      	movne	r3, #1
9000b394:	2300      	moveq	r3, #0
9000b396:	b2db      	uxtb	r3, r3
9000b398:	e02a      	b.n	9000b3f0 <HAL_DMA_IRQHandler+0x6e4>
9000b39a:	bf00      	nop
9000b39c:	40020010 	.word	0x40020010
9000b3a0:	40020028 	.word	0x40020028
9000b3a4:	40020040 	.word	0x40020040
9000b3a8:	40020058 	.word	0x40020058
9000b3ac:	40020070 	.word	0x40020070
9000b3b0:	40020088 	.word	0x40020088
9000b3b4:	400200a0 	.word	0x400200a0
9000b3b8:	400200b8 	.word	0x400200b8
9000b3bc:	40020410 	.word	0x40020410
9000b3c0:	40020428 	.word	0x40020428
9000b3c4:	40020440 	.word	0x40020440
9000b3c8:	40020458 	.word	0x40020458
9000b3cc:	40020470 	.word	0x40020470
9000b3d0:	40020488 	.word	0x40020488
9000b3d4:	400204a0 	.word	0x400204a0
9000b3d8:	400204b8 	.word	0x400204b8
9000b3dc:	687b      	ldr	r3, [r7, #4]
9000b3de:	681b      	ldr	r3, [r3, #0]
9000b3e0:	681b      	ldr	r3, [r3, #0]
9000b3e2:	f003 0302 	and.w	r3, r3, #2
9000b3e6:	2b00      	cmp	r3, #0
9000b3e8:	bf14      	ite	ne
9000b3ea:	2301      	movne	r3, #1
9000b3ec:	2300      	moveq	r3, #0
9000b3ee:	b2db      	uxtb	r3, r3
9000b3f0:	2b00      	cmp	r3, #0
9000b3f2:	f000 8087 	beq.w	9000b504 <HAL_DMA_IRQHandler+0x7f8>
      {
        /* Clear the transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
9000b3f6:	687b      	ldr	r3, [r7, #4]
9000b3f8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b3fa:	f003 031f 	and.w	r3, r3, #31
9000b3fe:	2220      	movs	r2, #32
9000b400:	409a      	lsls	r2, r3
9000b402:	6a3b      	ldr	r3, [r7, #32]
9000b404:	609a      	str	r2, [r3, #8]

        if(HAL_DMA_STATE_ABORT == hdma->State)
9000b406:	687b      	ldr	r3, [r7, #4]
9000b408:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
9000b40c:	b2db      	uxtb	r3, r3
9000b40e:	2b04      	cmp	r3, #4
9000b410:	d139      	bne.n	9000b486 <HAL_DMA_IRQHandler+0x77a>
        {
          /* Disable all the transfer interrupts */
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
9000b412:	687b      	ldr	r3, [r7, #4]
9000b414:	681b      	ldr	r3, [r3, #0]
9000b416:	681a      	ldr	r2, [r3, #0]
9000b418:	687b      	ldr	r3, [r7, #4]
9000b41a:	681b      	ldr	r3, [r3, #0]
9000b41c:	f022 0216 	bic.w	r2, r2, #22
9000b420:	601a      	str	r2, [r3, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
9000b422:	687b      	ldr	r3, [r7, #4]
9000b424:	681b      	ldr	r3, [r3, #0]
9000b426:	695a      	ldr	r2, [r3, #20]
9000b428:	687b      	ldr	r3, [r7, #4]
9000b42a:	681b      	ldr	r3, [r3, #0]
9000b42c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
9000b430:	615a      	str	r2, [r3, #20]

          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
9000b432:	687b      	ldr	r3, [r7, #4]
9000b434:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000b436:	2b00      	cmp	r3, #0
9000b438:	d103      	bne.n	9000b442 <HAL_DMA_IRQHandler+0x736>
9000b43a:	687b      	ldr	r3, [r7, #4]
9000b43c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
9000b43e:	2b00      	cmp	r3, #0
9000b440:	d007      	beq.n	9000b452 <HAL_DMA_IRQHandler+0x746>
          {
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
9000b442:	687b      	ldr	r3, [r7, #4]
9000b444:	681b      	ldr	r3, [r3, #0]
9000b446:	681a      	ldr	r2, [r3, #0]
9000b448:	687b      	ldr	r3, [r7, #4]
9000b44a:	681b      	ldr	r3, [r3, #0]
9000b44c:	f022 0208 	bic.w	r2, r2, #8
9000b450:	601a      	str	r2, [r3, #0]
          }

          /* Clear all interrupt flags at correct offset within the register */
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
9000b452:	687b      	ldr	r3, [r7, #4]
9000b454:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b456:	f003 031f 	and.w	r3, r3, #31
9000b45a:	223f      	movs	r2, #63	; 0x3f
9000b45c:	409a      	lsls	r2, r3
9000b45e:	6a3b      	ldr	r3, [r7, #32]
9000b460:	609a      	str	r2, [r3, #8]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
9000b462:	687b      	ldr	r3, [r7, #4]
9000b464:	2201      	movs	r2, #1
9000b466:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
9000b46a:	687b      	ldr	r3, [r7, #4]
9000b46c:	2200      	movs	r2, #0
9000b46e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          if(hdma->XferAbortCallback != NULL)
9000b472:	687b      	ldr	r3, [r7, #4]
9000b474:	6d1b      	ldr	r3, [r3, #80]	; 0x50
9000b476:	2b00      	cmp	r3, #0
9000b478:	f000 834a 	beq.w	9000bb10 <HAL_DMA_IRQHandler+0xe04>
          {
            hdma->XferAbortCallback(hdma);
9000b47c:	687b      	ldr	r3, [r7, #4]
9000b47e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
9000b480:	6878      	ldr	r0, [r7, #4]
9000b482:	4798      	blx	r3
          }
          return;
9000b484:	e344      	b.n	9000bb10 <HAL_DMA_IRQHandler+0xe04>
        }

        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
9000b486:	687b      	ldr	r3, [r7, #4]
9000b488:	681b      	ldr	r3, [r3, #0]
9000b48a:	681b      	ldr	r3, [r3, #0]
9000b48c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
9000b490:	2b00      	cmp	r3, #0
9000b492:	d018      	beq.n	9000b4c6 <HAL_DMA_IRQHandler+0x7ba>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
9000b494:	687b      	ldr	r3, [r7, #4]
9000b496:	681b      	ldr	r3, [r3, #0]
9000b498:	681b      	ldr	r3, [r3, #0]
9000b49a:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
9000b49e:	2b00      	cmp	r3, #0
9000b4a0:	d108      	bne.n	9000b4b4 <HAL_DMA_IRQHandler+0x7a8>
          {
            if(hdma->XferM1CpltCallback != NULL)
9000b4a2:	687b      	ldr	r3, [r7, #4]
9000b4a4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000b4a6:	2b00      	cmp	r3, #0
9000b4a8:	d02c      	beq.n	9000b504 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory1 */
              hdma->XferM1CpltCallback(hdma);
9000b4aa:	687b      	ldr	r3, [r7, #4]
9000b4ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000b4ae:	6878      	ldr	r0, [r7, #4]
9000b4b0:	4798      	blx	r3
9000b4b2:	e027      	b.n	9000b504 <HAL_DMA_IRQHandler+0x7f8>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferCpltCallback != NULL)
9000b4b4:	687b      	ldr	r3, [r7, #4]
9000b4b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
9000b4b8:	2b00      	cmp	r3, #0
9000b4ba:	d023      	beq.n	9000b504 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory0 */
              hdma->XferCpltCallback(hdma);
9000b4bc:	687b      	ldr	r3, [r7, #4]
9000b4be:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
9000b4c0:	6878      	ldr	r0, [r7, #4]
9000b4c2:	4798      	blx	r3
9000b4c4:	e01e      	b.n	9000b504 <HAL_DMA_IRQHandler+0x7f8>
          }
        }
        /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
        else
        {
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
9000b4c6:	687b      	ldr	r3, [r7, #4]
9000b4c8:	681b      	ldr	r3, [r3, #0]
9000b4ca:	681b      	ldr	r3, [r3, #0]
9000b4cc:	f403 7380 	and.w	r3, r3, #256	; 0x100
9000b4d0:	2b00      	cmp	r3, #0
9000b4d2:	d10f      	bne.n	9000b4f4 <HAL_DMA_IRQHandler+0x7e8>
          {
            /* Disable the transfer complete interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
9000b4d4:	687b      	ldr	r3, [r7, #4]
9000b4d6:	681b      	ldr	r3, [r3, #0]
9000b4d8:	681a      	ldr	r2, [r3, #0]
9000b4da:	687b      	ldr	r3, [r7, #4]
9000b4dc:	681b      	ldr	r3, [r3, #0]
9000b4de:	f022 0210 	bic.w	r2, r2, #16
9000b4e2:	601a      	str	r2, [r3, #0]

            /* Change the DMA state */
            hdma->State = HAL_DMA_STATE_READY;
9000b4e4:	687b      	ldr	r3, [r7, #4]
9000b4e6:	2201      	movs	r2, #1
9000b4e8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

            /* Process Unlocked */
            __HAL_UNLOCK(hdma);
9000b4ec:	687b      	ldr	r3, [r7, #4]
9000b4ee:	2200      	movs	r2, #0
9000b4f0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
          }

          if(hdma->XferCpltCallback != NULL)
9000b4f4:	687b      	ldr	r3, [r7, #4]
9000b4f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
9000b4f8:	2b00      	cmp	r3, #0
9000b4fa:	d003      	beq.n	9000b504 <HAL_DMA_IRQHandler+0x7f8>
          {
            /* Transfer complete callback */
            hdma->XferCpltCallback(hdma);
9000b4fc:	687b      	ldr	r3, [r7, #4]
9000b4fe:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
9000b500:	6878      	ldr	r0, [r7, #4]
9000b502:	4798      	blx	r3
        }
      }
    }

    /* manage error case */
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
9000b504:	687b      	ldr	r3, [r7, #4]
9000b506:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000b508:	2b00      	cmp	r3, #0
9000b50a:	f000 8306 	beq.w	9000bb1a <HAL_DMA_IRQHandler+0xe0e>
    {
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
9000b50e:	687b      	ldr	r3, [r7, #4]
9000b510:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000b512:	f003 0301 	and.w	r3, r3, #1
9000b516:	2b00      	cmp	r3, #0
9000b518:	f000 8088 	beq.w	9000b62c <HAL_DMA_IRQHandler+0x920>
      {
        hdma->State = HAL_DMA_STATE_ABORT;
9000b51c:	687b      	ldr	r3, [r7, #4]
9000b51e:	2204      	movs	r2, #4
9000b520:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Disable the stream */
        __HAL_DMA_DISABLE(hdma);
9000b524:	687b      	ldr	r3, [r7, #4]
9000b526:	681b      	ldr	r3, [r3, #0]
9000b528:	4a7a      	ldr	r2, [pc, #488]	; (9000b714 <HAL_DMA_IRQHandler+0xa08>)
9000b52a:	4293      	cmp	r3, r2
9000b52c:	d04a      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b52e:	687b      	ldr	r3, [r7, #4]
9000b530:	681b      	ldr	r3, [r3, #0]
9000b532:	4a79      	ldr	r2, [pc, #484]	; (9000b718 <HAL_DMA_IRQHandler+0xa0c>)
9000b534:	4293      	cmp	r3, r2
9000b536:	d045      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b538:	687b      	ldr	r3, [r7, #4]
9000b53a:	681b      	ldr	r3, [r3, #0]
9000b53c:	4a77      	ldr	r2, [pc, #476]	; (9000b71c <HAL_DMA_IRQHandler+0xa10>)
9000b53e:	4293      	cmp	r3, r2
9000b540:	d040      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b542:	687b      	ldr	r3, [r7, #4]
9000b544:	681b      	ldr	r3, [r3, #0]
9000b546:	4a76      	ldr	r2, [pc, #472]	; (9000b720 <HAL_DMA_IRQHandler+0xa14>)
9000b548:	4293      	cmp	r3, r2
9000b54a:	d03b      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b54c:	687b      	ldr	r3, [r7, #4]
9000b54e:	681b      	ldr	r3, [r3, #0]
9000b550:	4a74      	ldr	r2, [pc, #464]	; (9000b724 <HAL_DMA_IRQHandler+0xa18>)
9000b552:	4293      	cmp	r3, r2
9000b554:	d036      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b556:	687b      	ldr	r3, [r7, #4]
9000b558:	681b      	ldr	r3, [r3, #0]
9000b55a:	4a73      	ldr	r2, [pc, #460]	; (9000b728 <HAL_DMA_IRQHandler+0xa1c>)
9000b55c:	4293      	cmp	r3, r2
9000b55e:	d031      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b560:	687b      	ldr	r3, [r7, #4]
9000b562:	681b      	ldr	r3, [r3, #0]
9000b564:	4a71      	ldr	r2, [pc, #452]	; (9000b72c <HAL_DMA_IRQHandler+0xa20>)
9000b566:	4293      	cmp	r3, r2
9000b568:	d02c      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b56a:	687b      	ldr	r3, [r7, #4]
9000b56c:	681b      	ldr	r3, [r3, #0]
9000b56e:	4a70      	ldr	r2, [pc, #448]	; (9000b730 <HAL_DMA_IRQHandler+0xa24>)
9000b570:	4293      	cmp	r3, r2
9000b572:	d027      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b574:	687b      	ldr	r3, [r7, #4]
9000b576:	681b      	ldr	r3, [r3, #0]
9000b578:	4a6e      	ldr	r2, [pc, #440]	; (9000b734 <HAL_DMA_IRQHandler+0xa28>)
9000b57a:	4293      	cmp	r3, r2
9000b57c:	d022      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b57e:	687b      	ldr	r3, [r7, #4]
9000b580:	681b      	ldr	r3, [r3, #0]
9000b582:	4a6d      	ldr	r2, [pc, #436]	; (9000b738 <HAL_DMA_IRQHandler+0xa2c>)
9000b584:	4293      	cmp	r3, r2
9000b586:	d01d      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b588:	687b      	ldr	r3, [r7, #4]
9000b58a:	681b      	ldr	r3, [r3, #0]
9000b58c:	4a6b      	ldr	r2, [pc, #428]	; (9000b73c <HAL_DMA_IRQHandler+0xa30>)
9000b58e:	4293      	cmp	r3, r2
9000b590:	d018      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b592:	687b      	ldr	r3, [r7, #4]
9000b594:	681b      	ldr	r3, [r3, #0]
9000b596:	4a6a      	ldr	r2, [pc, #424]	; (9000b740 <HAL_DMA_IRQHandler+0xa34>)
9000b598:	4293      	cmp	r3, r2
9000b59a:	d013      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b59c:	687b      	ldr	r3, [r7, #4]
9000b59e:	681b      	ldr	r3, [r3, #0]
9000b5a0:	4a68      	ldr	r2, [pc, #416]	; (9000b744 <HAL_DMA_IRQHandler+0xa38>)
9000b5a2:	4293      	cmp	r3, r2
9000b5a4:	d00e      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b5a6:	687b      	ldr	r3, [r7, #4]
9000b5a8:	681b      	ldr	r3, [r3, #0]
9000b5aa:	4a67      	ldr	r2, [pc, #412]	; (9000b748 <HAL_DMA_IRQHandler+0xa3c>)
9000b5ac:	4293      	cmp	r3, r2
9000b5ae:	d009      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b5b0:	687b      	ldr	r3, [r7, #4]
9000b5b2:	681b      	ldr	r3, [r3, #0]
9000b5b4:	4a65      	ldr	r2, [pc, #404]	; (9000b74c <HAL_DMA_IRQHandler+0xa40>)
9000b5b6:	4293      	cmp	r3, r2
9000b5b8:	d004      	beq.n	9000b5c4 <HAL_DMA_IRQHandler+0x8b8>
9000b5ba:	687b      	ldr	r3, [r7, #4]
9000b5bc:	681b      	ldr	r3, [r3, #0]
9000b5be:	4a64      	ldr	r2, [pc, #400]	; (9000b750 <HAL_DMA_IRQHandler+0xa44>)
9000b5c0:	4293      	cmp	r3, r2
9000b5c2:	d108      	bne.n	9000b5d6 <HAL_DMA_IRQHandler+0x8ca>
9000b5c4:	687b      	ldr	r3, [r7, #4]
9000b5c6:	681b      	ldr	r3, [r3, #0]
9000b5c8:	681a      	ldr	r2, [r3, #0]
9000b5ca:	687b      	ldr	r3, [r7, #4]
9000b5cc:	681b      	ldr	r3, [r3, #0]
9000b5ce:	f022 0201 	bic.w	r2, r2, #1
9000b5d2:	601a      	str	r2, [r3, #0]
9000b5d4:	e007      	b.n	9000b5e6 <HAL_DMA_IRQHandler+0x8da>
9000b5d6:	687b      	ldr	r3, [r7, #4]
9000b5d8:	681b      	ldr	r3, [r3, #0]
9000b5da:	681a      	ldr	r2, [r3, #0]
9000b5dc:	687b      	ldr	r3, [r7, #4]
9000b5de:	681b      	ldr	r3, [r3, #0]
9000b5e0:	f022 0201 	bic.w	r2, r2, #1
9000b5e4:	601a      	str	r2, [r3, #0]

        do
        {
          if (++count > timeout)
9000b5e6:	68fb      	ldr	r3, [r7, #12]
9000b5e8:	3301      	adds	r3, #1
9000b5ea:	60fb      	str	r3, [r7, #12]
9000b5ec:	6a7a      	ldr	r2, [r7, #36]	; 0x24
9000b5ee:	429a      	cmp	r2, r3
9000b5f0:	d307      	bcc.n	9000b602 <HAL_DMA_IRQHandler+0x8f6>
          {
            break;
          }
        }
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
9000b5f2:	687b      	ldr	r3, [r7, #4]
9000b5f4:	681b      	ldr	r3, [r3, #0]
9000b5f6:	681b      	ldr	r3, [r3, #0]
9000b5f8:	f003 0301 	and.w	r3, r3, #1
9000b5fc:	2b00      	cmp	r3, #0
9000b5fe:	d1f2      	bne.n	9000b5e6 <HAL_DMA_IRQHandler+0x8da>
9000b600:	e000      	b.n	9000b604 <HAL_DMA_IRQHandler+0x8f8>
            break;
9000b602:	bf00      	nop

        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
9000b604:	687b      	ldr	r3, [r7, #4]
9000b606:	681b      	ldr	r3, [r3, #0]
9000b608:	681b      	ldr	r3, [r3, #0]
9000b60a:	f003 0301 	and.w	r3, r3, #1
9000b60e:	2b00      	cmp	r3, #0
9000b610:	d004      	beq.n	9000b61c <HAL_DMA_IRQHandler+0x910>
        {
          /* Change the DMA state to error if DMA disable fails */
          hdma->State = HAL_DMA_STATE_ERROR;
9000b612:	687b      	ldr	r3, [r7, #4]
9000b614:	2203      	movs	r2, #3
9000b616:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
9000b61a:	e003      	b.n	9000b624 <HAL_DMA_IRQHandler+0x918>
        }
        else
        {
          /* Change the DMA state to Ready if DMA disable success */
          hdma->State = HAL_DMA_STATE_READY;
9000b61c:	687b      	ldr	r3, [r7, #4]
9000b61e:	2201      	movs	r2, #1
9000b620:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
9000b624:	687b      	ldr	r3, [r7, #4]
9000b626:	2200      	movs	r2, #0
9000b628:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      }

      if(hdma->XferErrorCallback != NULL)
9000b62c:	687b      	ldr	r3, [r7, #4]
9000b62e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000b630:	2b00      	cmp	r3, #0
9000b632:	f000 8272 	beq.w	9000bb1a <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
9000b636:	687b      	ldr	r3, [r7, #4]
9000b638:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000b63a:	6878      	ldr	r0, [r7, #4]
9000b63c:	4798      	blx	r3
9000b63e:	e26c      	b.n	9000bb1a <HAL_DMA_IRQHandler+0xe0e>
      }
    }
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
9000b640:	687b      	ldr	r3, [r7, #4]
9000b642:	681b      	ldr	r3, [r3, #0]
9000b644:	4a43      	ldr	r2, [pc, #268]	; (9000b754 <HAL_DMA_IRQHandler+0xa48>)
9000b646:	4293      	cmp	r3, r2
9000b648:	d022      	beq.n	9000b690 <HAL_DMA_IRQHandler+0x984>
9000b64a:	687b      	ldr	r3, [r7, #4]
9000b64c:	681b      	ldr	r3, [r3, #0]
9000b64e:	4a42      	ldr	r2, [pc, #264]	; (9000b758 <HAL_DMA_IRQHandler+0xa4c>)
9000b650:	4293      	cmp	r3, r2
9000b652:	d01d      	beq.n	9000b690 <HAL_DMA_IRQHandler+0x984>
9000b654:	687b      	ldr	r3, [r7, #4]
9000b656:	681b      	ldr	r3, [r3, #0]
9000b658:	4a40      	ldr	r2, [pc, #256]	; (9000b75c <HAL_DMA_IRQHandler+0xa50>)
9000b65a:	4293      	cmp	r3, r2
9000b65c:	d018      	beq.n	9000b690 <HAL_DMA_IRQHandler+0x984>
9000b65e:	687b      	ldr	r3, [r7, #4]
9000b660:	681b      	ldr	r3, [r3, #0]
9000b662:	4a3f      	ldr	r2, [pc, #252]	; (9000b760 <HAL_DMA_IRQHandler+0xa54>)
9000b664:	4293      	cmp	r3, r2
9000b666:	d013      	beq.n	9000b690 <HAL_DMA_IRQHandler+0x984>
9000b668:	687b      	ldr	r3, [r7, #4]
9000b66a:	681b      	ldr	r3, [r3, #0]
9000b66c:	4a3d      	ldr	r2, [pc, #244]	; (9000b764 <HAL_DMA_IRQHandler+0xa58>)
9000b66e:	4293      	cmp	r3, r2
9000b670:	d00e      	beq.n	9000b690 <HAL_DMA_IRQHandler+0x984>
9000b672:	687b      	ldr	r3, [r7, #4]
9000b674:	681b      	ldr	r3, [r3, #0]
9000b676:	4a3c      	ldr	r2, [pc, #240]	; (9000b768 <HAL_DMA_IRQHandler+0xa5c>)
9000b678:	4293      	cmp	r3, r2
9000b67a:	d009      	beq.n	9000b690 <HAL_DMA_IRQHandler+0x984>
9000b67c:	687b      	ldr	r3, [r7, #4]
9000b67e:	681b      	ldr	r3, [r3, #0]
9000b680:	4a3a      	ldr	r2, [pc, #232]	; (9000b76c <HAL_DMA_IRQHandler+0xa60>)
9000b682:	4293      	cmp	r3, r2
9000b684:	d004      	beq.n	9000b690 <HAL_DMA_IRQHandler+0x984>
9000b686:	687b      	ldr	r3, [r7, #4]
9000b688:	681b      	ldr	r3, [r3, #0]
9000b68a:	4a39      	ldr	r2, [pc, #228]	; (9000b770 <HAL_DMA_IRQHandler+0xa64>)
9000b68c:	4293      	cmp	r3, r2
9000b68e:	d101      	bne.n	9000b694 <HAL_DMA_IRQHandler+0x988>
9000b690:	2301      	movs	r3, #1
9000b692:	e000      	b.n	9000b696 <HAL_DMA_IRQHandler+0x98a>
9000b694:	2300      	movs	r3, #0
9000b696:	2b00      	cmp	r3, #0
9000b698:	f000 823f 	beq.w	9000bb1a <HAL_DMA_IRQHandler+0xe0e>
  {
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
9000b69c:	687b      	ldr	r3, [r7, #4]
9000b69e:	681b      	ldr	r3, [r3, #0]
9000b6a0:	681b      	ldr	r3, [r3, #0]
9000b6a2:	613b      	str	r3, [r7, #16]

    /* Half Transfer Complete Interrupt management ******************************/
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
9000b6a4:	687b      	ldr	r3, [r7, #4]
9000b6a6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b6a8:	f003 031f 	and.w	r3, r3, #31
9000b6ac:	2204      	movs	r2, #4
9000b6ae:	409a      	lsls	r2, r3
9000b6b0:	697b      	ldr	r3, [r7, #20]
9000b6b2:	4013      	ands	r3, r2
9000b6b4:	2b00      	cmp	r3, #0
9000b6b6:	f000 80cd 	beq.w	9000b854 <HAL_DMA_IRQHandler+0xb48>
9000b6ba:	693b      	ldr	r3, [r7, #16]
9000b6bc:	f003 0304 	and.w	r3, r3, #4
9000b6c0:	2b00      	cmp	r3, #0
9000b6c2:	f000 80c7 	beq.w	9000b854 <HAL_DMA_IRQHandler+0xb48>
    {
      /* Clear the half transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
9000b6c6:	687b      	ldr	r3, [r7, #4]
9000b6c8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b6ca:	f003 031f 	and.w	r3, r3, #31
9000b6ce:	2204      	movs	r2, #4
9000b6d0:	409a      	lsls	r2, r3
9000b6d2:	69fb      	ldr	r3, [r7, #28]
9000b6d4:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
9000b6d6:	693b      	ldr	r3, [r7, #16]
9000b6d8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
9000b6dc:	2b00      	cmp	r3, #0
9000b6de:	d049      	beq.n	9000b774 <HAL_DMA_IRQHandler+0xa68>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
9000b6e0:	693b      	ldr	r3, [r7, #16]
9000b6e2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
9000b6e6:	2b00      	cmp	r3, #0
9000b6e8:	d109      	bne.n	9000b6fe <HAL_DMA_IRQHandler+0x9f2>
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
9000b6ea:	687b      	ldr	r3, [r7, #4]
9000b6ec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
9000b6ee:	2b00      	cmp	r3, #0
9000b6f0:	f000 8210 	beq.w	9000bb14 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 1 */
            hdma->XferM1HalfCpltCallback(hdma);
9000b6f4:	687b      	ldr	r3, [r7, #4]
9000b6f6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
9000b6f8:	6878      	ldr	r0, [r7, #4]
9000b6fa:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
9000b6fc:	e20a      	b.n	9000bb14 <HAL_DMA_IRQHandler+0xe08>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferHalfCpltCallback != NULL)
9000b6fe:	687b      	ldr	r3, [r7, #4]
9000b700:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000b702:	2b00      	cmp	r3, #0
9000b704:	f000 8206 	beq.w	9000bb14 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 0 */
            hdma->XferHalfCpltCallback(hdma);
9000b708:	687b      	ldr	r3, [r7, #4]
9000b70a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000b70c:	6878      	ldr	r0, [r7, #4]
9000b70e:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
9000b710:	e200      	b.n	9000bb14 <HAL_DMA_IRQHandler+0xe08>
9000b712:	bf00      	nop
9000b714:	40020010 	.word	0x40020010
9000b718:	40020028 	.word	0x40020028
9000b71c:	40020040 	.word	0x40020040
9000b720:	40020058 	.word	0x40020058
9000b724:	40020070 	.word	0x40020070
9000b728:	40020088 	.word	0x40020088
9000b72c:	400200a0 	.word	0x400200a0
9000b730:	400200b8 	.word	0x400200b8
9000b734:	40020410 	.word	0x40020410
9000b738:	40020428 	.word	0x40020428
9000b73c:	40020440 	.word	0x40020440
9000b740:	40020458 	.word	0x40020458
9000b744:	40020470 	.word	0x40020470
9000b748:	40020488 	.word	0x40020488
9000b74c:	400204a0 	.word	0x400204a0
9000b750:	400204b8 	.word	0x400204b8
9000b754:	58025408 	.word	0x58025408
9000b758:	5802541c 	.word	0x5802541c
9000b75c:	58025430 	.word	0x58025430
9000b760:	58025444 	.word	0x58025444
9000b764:	58025458 	.word	0x58025458
9000b768:	5802546c 	.word	0x5802546c
9000b76c:	58025480 	.word	0x58025480
9000b770:	58025494 	.word	0x58025494
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
9000b774:	693b      	ldr	r3, [r7, #16]
9000b776:	f003 0320 	and.w	r3, r3, #32
9000b77a:	2b00      	cmp	r3, #0
9000b77c:	d160      	bne.n	9000b840 <HAL_DMA_IRQHandler+0xb34>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
9000b77e:	687b      	ldr	r3, [r7, #4]
9000b780:	681b      	ldr	r3, [r3, #0]
9000b782:	4a8c      	ldr	r2, [pc, #560]	; (9000b9b4 <HAL_DMA_IRQHandler+0xca8>)
9000b784:	4293      	cmp	r3, r2
9000b786:	d04a      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b788:	687b      	ldr	r3, [r7, #4]
9000b78a:	681b      	ldr	r3, [r3, #0]
9000b78c:	4a8a      	ldr	r2, [pc, #552]	; (9000b9b8 <HAL_DMA_IRQHandler+0xcac>)
9000b78e:	4293      	cmp	r3, r2
9000b790:	d045      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b792:	687b      	ldr	r3, [r7, #4]
9000b794:	681b      	ldr	r3, [r3, #0]
9000b796:	4a89      	ldr	r2, [pc, #548]	; (9000b9bc <HAL_DMA_IRQHandler+0xcb0>)
9000b798:	4293      	cmp	r3, r2
9000b79a:	d040      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b79c:	687b      	ldr	r3, [r7, #4]
9000b79e:	681b      	ldr	r3, [r3, #0]
9000b7a0:	4a87      	ldr	r2, [pc, #540]	; (9000b9c0 <HAL_DMA_IRQHandler+0xcb4>)
9000b7a2:	4293      	cmp	r3, r2
9000b7a4:	d03b      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b7a6:	687b      	ldr	r3, [r7, #4]
9000b7a8:	681b      	ldr	r3, [r3, #0]
9000b7aa:	4a86      	ldr	r2, [pc, #536]	; (9000b9c4 <HAL_DMA_IRQHandler+0xcb8>)
9000b7ac:	4293      	cmp	r3, r2
9000b7ae:	d036      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b7b0:	687b      	ldr	r3, [r7, #4]
9000b7b2:	681b      	ldr	r3, [r3, #0]
9000b7b4:	4a84      	ldr	r2, [pc, #528]	; (9000b9c8 <HAL_DMA_IRQHandler+0xcbc>)
9000b7b6:	4293      	cmp	r3, r2
9000b7b8:	d031      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b7ba:	687b      	ldr	r3, [r7, #4]
9000b7bc:	681b      	ldr	r3, [r3, #0]
9000b7be:	4a83      	ldr	r2, [pc, #524]	; (9000b9cc <HAL_DMA_IRQHandler+0xcc0>)
9000b7c0:	4293      	cmp	r3, r2
9000b7c2:	d02c      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b7c4:	687b      	ldr	r3, [r7, #4]
9000b7c6:	681b      	ldr	r3, [r3, #0]
9000b7c8:	4a81      	ldr	r2, [pc, #516]	; (9000b9d0 <HAL_DMA_IRQHandler+0xcc4>)
9000b7ca:	4293      	cmp	r3, r2
9000b7cc:	d027      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b7ce:	687b      	ldr	r3, [r7, #4]
9000b7d0:	681b      	ldr	r3, [r3, #0]
9000b7d2:	4a80      	ldr	r2, [pc, #512]	; (9000b9d4 <HAL_DMA_IRQHandler+0xcc8>)
9000b7d4:	4293      	cmp	r3, r2
9000b7d6:	d022      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b7d8:	687b      	ldr	r3, [r7, #4]
9000b7da:	681b      	ldr	r3, [r3, #0]
9000b7dc:	4a7e      	ldr	r2, [pc, #504]	; (9000b9d8 <HAL_DMA_IRQHandler+0xccc>)
9000b7de:	4293      	cmp	r3, r2
9000b7e0:	d01d      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b7e2:	687b      	ldr	r3, [r7, #4]
9000b7e4:	681b      	ldr	r3, [r3, #0]
9000b7e6:	4a7d      	ldr	r2, [pc, #500]	; (9000b9dc <HAL_DMA_IRQHandler+0xcd0>)
9000b7e8:	4293      	cmp	r3, r2
9000b7ea:	d018      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b7ec:	687b      	ldr	r3, [r7, #4]
9000b7ee:	681b      	ldr	r3, [r3, #0]
9000b7f0:	4a7b      	ldr	r2, [pc, #492]	; (9000b9e0 <HAL_DMA_IRQHandler+0xcd4>)
9000b7f2:	4293      	cmp	r3, r2
9000b7f4:	d013      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b7f6:	687b      	ldr	r3, [r7, #4]
9000b7f8:	681b      	ldr	r3, [r3, #0]
9000b7fa:	4a7a      	ldr	r2, [pc, #488]	; (9000b9e4 <HAL_DMA_IRQHandler+0xcd8>)
9000b7fc:	4293      	cmp	r3, r2
9000b7fe:	d00e      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b800:	687b      	ldr	r3, [r7, #4]
9000b802:	681b      	ldr	r3, [r3, #0]
9000b804:	4a78      	ldr	r2, [pc, #480]	; (9000b9e8 <HAL_DMA_IRQHandler+0xcdc>)
9000b806:	4293      	cmp	r3, r2
9000b808:	d009      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b80a:	687b      	ldr	r3, [r7, #4]
9000b80c:	681b      	ldr	r3, [r3, #0]
9000b80e:	4a77      	ldr	r2, [pc, #476]	; (9000b9ec <HAL_DMA_IRQHandler+0xce0>)
9000b810:	4293      	cmp	r3, r2
9000b812:	d004      	beq.n	9000b81e <HAL_DMA_IRQHandler+0xb12>
9000b814:	687b      	ldr	r3, [r7, #4]
9000b816:	681b      	ldr	r3, [r3, #0]
9000b818:	4a75      	ldr	r2, [pc, #468]	; (9000b9f0 <HAL_DMA_IRQHandler+0xce4>)
9000b81a:	4293      	cmp	r3, r2
9000b81c:	d108      	bne.n	9000b830 <HAL_DMA_IRQHandler+0xb24>
9000b81e:	687b      	ldr	r3, [r7, #4]
9000b820:	681b      	ldr	r3, [r3, #0]
9000b822:	681a      	ldr	r2, [r3, #0]
9000b824:	687b      	ldr	r3, [r7, #4]
9000b826:	681b      	ldr	r3, [r3, #0]
9000b828:	f022 0208 	bic.w	r2, r2, #8
9000b82c:	601a      	str	r2, [r3, #0]
9000b82e:	e007      	b.n	9000b840 <HAL_DMA_IRQHandler+0xb34>
9000b830:	687b      	ldr	r3, [r7, #4]
9000b832:	681b      	ldr	r3, [r3, #0]
9000b834:	681a      	ldr	r2, [r3, #0]
9000b836:	687b      	ldr	r3, [r7, #4]
9000b838:	681b      	ldr	r3, [r3, #0]
9000b83a:	f022 0204 	bic.w	r2, r2, #4
9000b83e:	601a      	str	r2, [r3, #0]
        }

        /* DMA peripheral state is not updated in Half Transfer */
        /* but in Transfer Complete case */

       if(hdma->XferHalfCpltCallback != NULL)
9000b840:	687b      	ldr	r3, [r7, #4]
9000b842:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000b844:	2b00      	cmp	r3, #0
9000b846:	f000 8165 	beq.w	9000bb14 <HAL_DMA_IRQHandler+0xe08>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
9000b84a:	687b      	ldr	r3, [r7, #4]
9000b84c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000b84e:	6878      	ldr	r0, [r7, #4]
9000b850:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
9000b852:	e15f      	b.n	9000bb14 <HAL_DMA_IRQHandler+0xe08>
        }
      }
    }

    /* Transfer Complete Interrupt management ***********************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
9000b854:	687b      	ldr	r3, [r7, #4]
9000b856:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b858:	f003 031f 	and.w	r3, r3, #31
9000b85c:	2202      	movs	r2, #2
9000b85e:	409a      	lsls	r2, r3
9000b860:	697b      	ldr	r3, [r7, #20]
9000b862:	4013      	ands	r3, r2
9000b864:	2b00      	cmp	r3, #0
9000b866:	f000 80c5 	beq.w	9000b9f4 <HAL_DMA_IRQHandler+0xce8>
9000b86a:	693b      	ldr	r3, [r7, #16]
9000b86c:	f003 0302 	and.w	r3, r3, #2
9000b870:	2b00      	cmp	r3, #0
9000b872:	f000 80bf 	beq.w	9000b9f4 <HAL_DMA_IRQHandler+0xce8>
    {
      /* Clear the transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
9000b876:	687b      	ldr	r3, [r7, #4]
9000b878:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b87a:	f003 031f 	and.w	r3, r3, #31
9000b87e:	2202      	movs	r2, #2
9000b880:	409a      	lsls	r2, r3
9000b882:	69fb      	ldr	r3, [r7, #28]
9000b884:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
9000b886:	693b      	ldr	r3, [r7, #16]
9000b888:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
9000b88c:	2b00      	cmp	r3, #0
9000b88e:	d018      	beq.n	9000b8c2 <HAL_DMA_IRQHandler+0xbb6>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
9000b890:	693b      	ldr	r3, [r7, #16]
9000b892:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
9000b896:	2b00      	cmp	r3, #0
9000b898:	d109      	bne.n	9000b8ae <HAL_DMA_IRQHandler+0xba2>
        {
          if(hdma->XferM1CpltCallback != NULL)
9000b89a:	687b      	ldr	r3, [r7, #4]
9000b89c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000b89e:	2b00      	cmp	r3, #0
9000b8a0:	f000 813a 	beq.w	9000bb18 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 1 */
            hdma->XferM1CpltCallback(hdma);
9000b8a4:	687b      	ldr	r3, [r7, #4]
9000b8a6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000b8a8:	6878      	ldr	r0, [r7, #4]
9000b8aa:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
9000b8ac:	e134      	b.n	9000bb18 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
9000b8ae:	687b      	ldr	r3, [r7, #4]
9000b8b0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
9000b8b2:	2b00      	cmp	r3, #0
9000b8b4:	f000 8130 	beq.w	9000bb18 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 0 */
            hdma->XferCpltCallback(hdma);
9000b8b8:	687b      	ldr	r3, [r7, #4]
9000b8ba:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
9000b8bc:	6878      	ldr	r0, [r7, #4]
9000b8be:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
9000b8c0:	e12a      	b.n	9000bb18 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
9000b8c2:	693b      	ldr	r3, [r7, #16]
9000b8c4:	f003 0320 	and.w	r3, r3, #32
9000b8c8:	2b00      	cmp	r3, #0
9000b8ca:	d168      	bne.n	9000b99e <HAL_DMA_IRQHandler+0xc92>
        {
          /* Disable the transfer complete and error interrupt, if the DMA mode is not CIRCULAR */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
9000b8cc:	687b      	ldr	r3, [r7, #4]
9000b8ce:	681b      	ldr	r3, [r3, #0]
9000b8d0:	4a38      	ldr	r2, [pc, #224]	; (9000b9b4 <HAL_DMA_IRQHandler+0xca8>)
9000b8d2:	4293      	cmp	r3, r2
9000b8d4:	d04a      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b8d6:	687b      	ldr	r3, [r7, #4]
9000b8d8:	681b      	ldr	r3, [r3, #0]
9000b8da:	4a37      	ldr	r2, [pc, #220]	; (9000b9b8 <HAL_DMA_IRQHandler+0xcac>)
9000b8dc:	4293      	cmp	r3, r2
9000b8de:	d045      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b8e0:	687b      	ldr	r3, [r7, #4]
9000b8e2:	681b      	ldr	r3, [r3, #0]
9000b8e4:	4a35      	ldr	r2, [pc, #212]	; (9000b9bc <HAL_DMA_IRQHandler+0xcb0>)
9000b8e6:	4293      	cmp	r3, r2
9000b8e8:	d040      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b8ea:	687b      	ldr	r3, [r7, #4]
9000b8ec:	681b      	ldr	r3, [r3, #0]
9000b8ee:	4a34      	ldr	r2, [pc, #208]	; (9000b9c0 <HAL_DMA_IRQHandler+0xcb4>)
9000b8f0:	4293      	cmp	r3, r2
9000b8f2:	d03b      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b8f4:	687b      	ldr	r3, [r7, #4]
9000b8f6:	681b      	ldr	r3, [r3, #0]
9000b8f8:	4a32      	ldr	r2, [pc, #200]	; (9000b9c4 <HAL_DMA_IRQHandler+0xcb8>)
9000b8fa:	4293      	cmp	r3, r2
9000b8fc:	d036      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b8fe:	687b      	ldr	r3, [r7, #4]
9000b900:	681b      	ldr	r3, [r3, #0]
9000b902:	4a31      	ldr	r2, [pc, #196]	; (9000b9c8 <HAL_DMA_IRQHandler+0xcbc>)
9000b904:	4293      	cmp	r3, r2
9000b906:	d031      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b908:	687b      	ldr	r3, [r7, #4]
9000b90a:	681b      	ldr	r3, [r3, #0]
9000b90c:	4a2f      	ldr	r2, [pc, #188]	; (9000b9cc <HAL_DMA_IRQHandler+0xcc0>)
9000b90e:	4293      	cmp	r3, r2
9000b910:	d02c      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b912:	687b      	ldr	r3, [r7, #4]
9000b914:	681b      	ldr	r3, [r3, #0]
9000b916:	4a2e      	ldr	r2, [pc, #184]	; (9000b9d0 <HAL_DMA_IRQHandler+0xcc4>)
9000b918:	4293      	cmp	r3, r2
9000b91a:	d027      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b91c:	687b      	ldr	r3, [r7, #4]
9000b91e:	681b      	ldr	r3, [r3, #0]
9000b920:	4a2c      	ldr	r2, [pc, #176]	; (9000b9d4 <HAL_DMA_IRQHandler+0xcc8>)
9000b922:	4293      	cmp	r3, r2
9000b924:	d022      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b926:	687b      	ldr	r3, [r7, #4]
9000b928:	681b      	ldr	r3, [r3, #0]
9000b92a:	4a2b      	ldr	r2, [pc, #172]	; (9000b9d8 <HAL_DMA_IRQHandler+0xccc>)
9000b92c:	4293      	cmp	r3, r2
9000b92e:	d01d      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b930:	687b      	ldr	r3, [r7, #4]
9000b932:	681b      	ldr	r3, [r3, #0]
9000b934:	4a29      	ldr	r2, [pc, #164]	; (9000b9dc <HAL_DMA_IRQHandler+0xcd0>)
9000b936:	4293      	cmp	r3, r2
9000b938:	d018      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b93a:	687b      	ldr	r3, [r7, #4]
9000b93c:	681b      	ldr	r3, [r3, #0]
9000b93e:	4a28      	ldr	r2, [pc, #160]	; (9000b9e0 <HAL_DMA_IRQHandler+0xcd4>)
9000b940:	4293      	cmp	r3, r2
9000b942:	d013      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b944:	687b      	ldr	r3, [r7, #4]
9000b946:	681b      	ldr	r3, [r3, #0]
9000b948:	4a26      	ldr	r2, [pc, #152]	; (9000b9e4 <HAL_DMA_IRQHandler+0xcd8>)
9000b94a:	4293      	cmp	r3, r2
9000b94c:	d00e      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b94e:	687b      	ldr	r3, [r7, #4]
9000b950:	681b      	ldr	r3, [r3, #0]
9000b952:	4a25      	ldr	r2, [pc, #148]	; (9000b9e8 <HAL_DMA_IRQHandler+0xcdc>)
9000b954:	4293      	cmp	r3, r2
9000b956:	d009      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b958:	687b      	ldr	r3, [r7, #4]
9000b95a:	681b      	ldr	r3, [r3, #0]
9000b95c:	4a23      	ldr	r2, [pc, #140]	; (9000b9ec <HAL_DMA_IRQHandler+0xce0>)
9000b95e:	4293      	cmp	r3, r2
9000b960:	d004      	beq.n	9000b96c <HAL_DMA_IRQHandler+0xc60>
9000b962:	687b      	ldr	r3, [r7, #4]
9000b964:	681b      	ldr	r3, [r3, #0]
9000b966:	4a22      	ldr	r2, [pc, #136]	; (9000b9f0 <HAL_DMA_IRQHandler+0xce4>)
9000b968:	4293      	cmp	r3, r2
9000b96a:	d108      	bne.n	9000b97e <HAL_DMA_IRQHandler+0xc72>
9000b96c:	687b      	ldr	r3, [r7, #4]
9000b96e:	681b      	ldr	r3, [r3, #0]
9000b970:	681a      	ldr	r2, [r3, #0]
9000b972:	687b      	ldr	r3, [r7, #4]
9000b974:	681b      	ldr	r3, [r3, #0]
9000b976:	f022 0214 	bic.w	r2, r2, #20
9000b97a:	601a      	str	r2, [r3, #0]
9000b97c:	e007      	b.n	9000b98e <HAL_DMA_IRQHandler+0xc82>
9000b97e:	687b      	ldr	r3, [r7, #4]
9000b980:	681b      	ldr	r3, [r3, #0]
9000b982:	681a      	ldr	r2, [r3, #0]
9000b984:	687b      	ldr	r3, [r7, #4]
9000b986:	681b      	ldr	r3, [r3, #0]
9000b988:	f022 020a 	bic.w	r2, r2, #10
9000b98c:	601a      	str	r2, [r3, #0]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
9000b98e:	687b      	ldr	r3, [r7, #4]
9000b990:	2201      	movs	r2, #1
9000b992:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
9000b996:	687b      	ldr	r3, [r7, #4]
9000b998:	2200      	movs	r2, #0
9000b99a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        }

        if(hdma->XferCpltCallback != NULL)
9000b99e:	687b      	ldr	r3, [r7, #4]
9000b9a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
9000b9a2:	2b00      	cmp	r3, #0
9000b9a4:	f000 80b8 	beq.w	9000bb18 <HAL_DMA_IRQHandler+0xe0c>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
9000b9a8:	687b      	ldr	r3, [r7, #4]
9000b9aa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
9000b9ac:	6878      	ldr	r0, [r7, #4]
9000b9ae:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
9000b9b0:	e0b2      	b.n	9000bb18 <HAL_DMA_IRQHandler+0xe0c>
9000b9b2:	bf00      	nop
9000b9b4:	40020010 	.word	0x40020010
9000b9b8:	40020028 	.word	0x40020028
9000b9bc:	40020040 	.word	0x40020040
9000b9c0:	40020058 	.word	0x40020058
9000b9c4:	40020070 	.word	0x40020070
9000b9c8:	40020088 	.word	0x40020088
9000b9cc:	400200a0 	.word	0x400200a0
9000b9d0:	400200b8 	.word	0x400200b8
9000b9d4:	40020410 	.word	0x40020410
9000b9d8:	40020428 	.word	0x40020428
9000b9dc:	40020440 	.word	0x40020440
9000b9e0:	40020458 	.word	0x40020458
9000b9e4:	40020470 	.word	0x40020470
9000b9e8:	40020488 	.word	0x40020488
9000b9ec:	400204a0 	.word	0x400204a0
9000b9f0:	400204b8 	.word	0x400204b8
        }
      }
    }
    /* Transfer Error Interrupt management **************************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
9000b9f4:	687b      	ldr	r3, [r7, #4]
9000b9f6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000b9f8:	f003 031f 	and.w	r3, r3, #31
9000b9fc:	2208      	movs	r2, #8
9000b9fe:	409a      	lsls	r2, r3
9000ba00:	697b      	ldr	r3, [r7, #20]
9000ba02:	4013      	ands	r3, r2
9000ba04:	2b00      	cmp	r3, #0
9000ba06:	f000 8088 	beq.w	9000bb1a <HAL_DMA_IRQHandler+0xe0e>
9000ba0a:	693b      	ldr	r3, [r7, #16]
9000ba0c:	f003 0308 	and.w	r3, r3, #8
9000ba10:	2b00      	cmp	r3, #0
9000ba12:	f000 8082 	beq.w	9000bb1a <HAL_DMA_IRQHandler+0xe0e>
    {
      /* When a DMA transfer error occurs */
      /* A hardware clear of its EN bits is performed */
      /* Disable ALL DMA IT */
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
9000ba16:	687b      	ldr	r3, [r7, #4]
9000ba18:	681b      	ldr	r3, [r3, #0]
9000ba1a:	4a41      	ldr	r2, [pc, #260]	; (9000bb20 <HAL_DMA_IRQHandler+0xe14>)
9000ba1c:	4293      	cmp	r3, r2
9000ba1e:	d04a      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba20:	687b      	ldr	r3, [r7, #4]
9000ba22:	681b      	ldr	r3, [r3, #0]
9000ba24:	4a3f      	ldr	r2, [pc, #252]	; (9000bb24 <HAL_DMA_IRQHandler+0xe18>)
9000ba26:	4293      	cmp	r3, r2
9000ba28:	d045      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba2a:	687b      	ldr	r3, [r7, #4]
9000ba2c:	681b      	ldr	r3, [r3, #0]
9000ba2e:	4a3e      	ldr	r2, [pc, #248]	; (9000bb28 <HAL_DMA_IRQHandler+0xe1c>)
9000ba30:	4293      	cmp	r3, r2
9000ba32:	d040      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba34:	687b      	ldr	r3, [r7, #4]
9000ba36:	681b      	ldr	r3, [r3, #0]
9000ba38:	4a3c      	ldr	r2, [pc, #240]	; (9000bb2c <HAL_DMA_IRQHandler+0xe20>)
9000ba3a:	4293      	cmp	r3, r2
9000ba3c:	d03b      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba3e:	687b      	ldr	r3, [r7, #4]
9000ba40:	681b      	ldr	r3, [r3, #0]
9000ba42:	4a3b      	ldr	r2, [pc, #236]	; (9000bb30 <HAL_DMA_IRQHandler+0xe24>)
9000ba44:	4293      	cmp	r3, r2
9000ba46:	d036      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba48:	687b      	ldr	r3, [r7, #4]
9000ba4a:	681b      	ldr	r3, [r3, #0]
9000ba4c:	4a39      	ldr	r2, [pc, #228]	; (9000bb34 <HAL_DMA_IRQHandler+0xe28>)
9000ba4e:	4293      	cmp	r3, r2
9000ba50:	d031      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba52:	687b      	ldr	r3, [r7, #4]
9000ba54:	681b      	ldr	r3, [r3, #0]
9000ba56:	4a38      	ldr	r2, [pc, #224]	; (9000bb38 <HAL_DMA_IRQHandler+0xe2c>)
9000ba58:	4293      	cmp	r3, r2
9000ba5a:	d02c      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba5c:	687b      	ldr	r3, [r7, #4]
9000ba5e:	681b      	ldr	r3, [r3, #0]
9000ba60:	4a36      	ldr	r2, [pc, #216]	; (9000bb3c <HAL_DMA_IRQHandler+0xe30>)
9000ba62:	4293      	cmp	r3, r2
9000ba64:	d027      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba66:	687b      	ldr	r3, [r7, #4]
9000ba68:	681b      	ldr	r3, [r3, #0]
9000ba6a:	4a35      	ldr	r2, [pc, #212]	; (9000bb40 <HAL_DMA_IRQHandler+0xe34>)
9000ba6c:	4293      	cmp	r3, r2
9000ba6e:	d022      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba70:	687b      	ldr	r3, [r7, #4]
9000ba72:	681b      	ldr	r3, [r3, #0]
9000ba74:	4a33      	ldr	r2, [pc, #204]	; (9000bb44 <HAL_DMA_IRQHandler+0xe38>)
9000ba76:	4293      	cmp	r3, r2
9000ba78:	d01d      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba7a:	687b      	ldr	r3, [r7, #4]
9000ba7c:	681b      	ldr	r3, [r3, #0]
9000ba7e:	4a32      	ldr	r2, [pc, #200]	; (9000bb48 <HAL_DMA_IRQHandler+0xe3c>)
9000ba80:	4293      	cmp	r3, r2
9000ba82:	d018      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba84:	687b      	ldr	r3, [r7, #4]
9000ba86:	681b      	ldr	r3, [r3, #0]
9000ba88:	4a30      	ldr	r2, [pc, #192]	; (9000bb4c <HAL_DMA_IRQHandler+0xe40>)
9000ba8a:	4293      	cmp	r3, r2
9000ba8c:	d013      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba8e:	687b      	ldr	r3, [r7, #4]
9000ba90:	681b      	ldr	r3, [r3, #0]
9000ba92:	4a2f      	ldr	r2, [pc, #188]	; (9000bb50 <HAL_DMA_IRQHandler+0xe44>)
9000ba94:	4293      	cmp	r3, r2
9000ba96:	d00e      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000ba98:	687b      	ldr	r3, [r7, #4]
9000ba9a:	681b      	ldr	r3, [r3, #0]
9000ba9c:	4a2d      	ldr	r2, [pc, #180]	; (9000bb54 <HAL_DMA_IRQHandler+0xe48>)
9000ba9e:	4293      	cmp	r3, r2
9000baa0:	d009      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000baa2:	687b      	ldr	r3, [r7, #4]
9000baa4:	681b      	ldr	r3, [r3, #0]
9000baa6:	4a2c      	ldr	r2, [pc, #176]	; (9000bb58 <HAL_DMA_IRQHandler+0xe4c>)
9000baa8:	4293      	cmp	r3, r2
9000baaa:	d004      	beq.n	9000bab6 <HAL_DMA_IRQHandler+0xdaa>
9000baac:	687b      	ldr	r3, [r7, #4]
9000baae:	681b      	ldr	r3, [r3, #0]
9000bab0:	4a2a      	ldr	r2, [pc, #168]	; (9000bb5c <HAL_DMA_IRQHandler+0xe50>)
9000bab2:	4293      	cmp	r3, r2
9000bab4:	d108      	bne.n	9000bac8 <HAL_DMA_IRQHandler+0xdbc>
9000bab6:	687b      	ldr	r3, [r7, #4]
9000bab8:	681b      	ldr	r3, [r3, #0]
9000baba:	681a      	ldr	r2, [r3, #0]
9000babc:	687b      	ldr	r3, [r7, #4]
9000babe:	681b      	ldr	r3, [r3, #0]
9000bac0:	f022 021c 	bic.w	r2, r2, #28
9000bac4:	601a      	str	r2, [r3, #0]
9000bac6:	e007      	b.n	9000bad8 <HAL_DMA_IRQHandler+0xdcc>
9000bac8:	687b      	ldr	r3, [r7, #4]
9000baca:	681b      	ldr	r3, [r3, #0]
9000bacc:	681a      	ldr	r2, [r3, #0]
9000bace:	687b      	ldr	r3, [r7, #4]
9000bad0:	681b      	ldr	r3, [r3, #0]
9000bad2:	f022 020e 	bic.w	r2, r2, #14
9000bad6:	601a      	str	r2, [r3, #0]

      /* Clear all flags */
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
9000bad8:	687b      	ldr	r3, [r7, #4]
9000bada:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000badc:	f003 031f 	and.w	r3, r3, #31
9000bae0:	2201      	movs	r2, #1
9000bae2:	409a      	lsls	r2, r3
9000bae4:	69fb      	ldr	r3, [r7, #28]
9000bae6:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
9000bae8:	687b      	ldr	r3, [r7, #4]
9000baea:	2201      	movs	r2, #1
9000baec:	655a      	str	r2, [r3, #84]	; 0x54

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
9000baee:	687b      	ldr	r3, [r7, #4]
9000baf0:	2201      	movs	r2, #1
9000baf2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
9000baf6:	687b      	ldr	r3, [r7, #4]
9000baf8:	2200      	movs	r2, #0
9000bafa:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if (hdma->XferErrorCallback != NULL)
9000bafe:	687b      	ldr	r3, [r7, #4]
9000bb00:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000bb02:	2b00      	cmp	r3, #0
9000bb04:	d009      	beq.n	9000bb1a <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
9000bb06:	687b      	ldr	r3, [r7, #4]
9000bb08:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000bb0a:	6878      	ldr	r0, [r7, #4]
9000bb0c:	4798      	blx	r3
9000bb0e:	e004      	b.n	9000bb1a <HAL_DMA_IRQHandler+0xe0e>
          return;
9000bb10:	bf00      	nop
9000bb12:	e002      	b.n	9000bb1a <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
9000bb14:	bf00      	nop
9000bb16:	e000      	b.n	9000bb1a <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
9000bb18:	bf00      	nop
  }
  else
  {
    /* Nothing To Do */
  }
}
9000bb1a:	3728      	adds	r7, #40	; 0x28
9000bb1c:	46bd      	mov	sp, r7
9000bb1e:	bd80      	pop	{r7, pc}
9000bb20:	40020010 	.word	0x40020010
9000bb24:	40020028 	.word	0x40020028
9000bb28:	40020040 	.word	0x40020040
9000bb2c:	40020058 	.word	0x40020058
9000bb30:	40020070 	.word	0x40020070
9000bb34:	40020088 	.word	0x40020088
9000bb38:	400200a0 	.word	0x400200a0
9000bb3c:	400200b8 	.word	0x400200b8
9000bb40:	40020410 	.word	0x40020410
9000bb44:	40020428 	.word	0x40020428
9000bb48:	40020440 	.word	0x40020440
9000bb4c:	40020458 	.word	0x40020458
9000bb50:	40020470 	.word	0x40020470
9000bb54:	40020488 	.word	0x40020488
9000bb58:	400204a0 	.word	0x400204a0
9000bb5c:	400204b8 	.word	0x400204b8

9000bb60 <HAL_DMA_GetError>:
  * @param  hdma : pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
9000bb60:	b480      	push	{r7}
9000bb62:	b083      	sub	sp, #12
9000bb64:	af00      	add	r7, sp, #0
9000bb66:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
9000bb68:	687b      	ldr	r3, [r7, #4]
9000bb6a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
}
9000bb6c:	4618      	mov	r0, r3
9000bb6e:	370c      	adds	r7, #12
9000bb70:	46bd      	mov	sp, r7
9000bb72:	f85d 7b04 	ldr.w	r7, [sp], #4
9000bb76:	4770      	bx	lr

9000bb78 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval None
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
9000bb78:	b480      	push	{r7}
9000bb7a:	b087      	sub	sp, #28
9000bb7c:	af00      	add	r7, sp, #0
9000bb7e:	60f8      	str	r0, [r7, #12]
9000bb80:	60b9      	str	r1, [r7, #8]
9000bb82:	607a      	str	r2, [r7, #4]
9000bb84:	603b      	str	r3, [r7, #0]
  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
9000bb86:	68fb      	ldr	r3, [r7, #12]
9000bb88:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000bb8a:	617b      	str	r3, [r7, #20]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
9000bb8c:	68fb      	ldr	r3, [r7, #12]
9000bb8e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000bb90:	613b      	str	r3, [r7, #16]

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
9000bb92:	68fb      	ldr	r3, [r7, #12]
9000bb94:	681b      	ldr	r3, [r3, #0]
9000bb96:	4a84      	ldr	r2, [pc, #528]	; (9000bda8 <DMA_SetConfig+0x230>)
9000bb98:	4293      	cmp	r3, r2
9000bb9a:	d072      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bb9c:	68fb      	ldr	r3, [r7, #12]
9000bb9e:	681b      	ldr	r3, [r3, #0]
9000bba0:	4a82      	ldr	r2, [pc, #520]	; (9000bdac <DMA_SetConfig+0x234>)
9000bba2:	4293      	cmp	r3, r2
9000bba4:	d06d      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bba6:	68fb      	ldr	r3, [r7, #12]
9000bba8:	681b      	ldr	r3, [r3, #0]
9000bbaa:	4a81      	ldr	r2, [pc, #516]	; (9000bdb0 <DMA_SetConfig+0x238>)
9000bbac:	4293      	cmp	r3, r2
9000bbae:	d068      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bbb0:	68fb      	ldr	r3, [r7, #12]
9000bbb2:	681b      	ldr	r3, [r3, #0]
9000bbb4:	4a7f      	ldr	r2, [pc, #508]	; (9000bdb4 <DMA_SetConfig+0x23c>)
9000bbb6:	4293      	cmp	r3, r2
9000bbb8:	d063      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bbba:	68fb      	ldr	r3, [r7, #12]
9000bbbc:	681b      	ldr	r3, [r3, #0]
9000bbbe:	4a7e      	ldr	r2, [pc, #504]	; (9000bdb8 <DMA_SetConfig+0x240>)
9000bbc0:	4293      	cmp	r3, r2
9000bbc2:	d05e      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bbc4:	68fb      	ldr	r3, [r7, #12]
9000bbc6:	681b      	ldr	r3, [r3, #0]
9000bbc8:	4a7c      	ldr	r2, [pc, #496]	; (9000bdbc <DMA_SetConfig+0x244>)
9000bbca:	4293      	cmp	r3, r2
9000bbcc:	d059      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bbce:	68fb      	ldr	r3, [r7, #12]
9000bbd0:	681b      	ldr	r3, [r3, #0]
9000bbd2:	4a7b      	ldr	r2, [pc, #492]	; (9000bdc0 <DMA_SetConfig+0x248>)
9000bbd4:	4293      	cmp	r3, r2
9000bbd6:	d054      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bbd8:	68fb      	ldr	r3, [r7, #12]
9000bbda:	681b      	ldr	r3, [r3, #0]
9000bbdc:	4a79      	ldr	r2, [pc, #484]	; (9000bdc4 <DMA_SetConfig+0x24c>)
9000bbde:	4293      	cmp	r3, r2
9000bbe0:	d04f      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bbe2:	68fb      	ldr	r3, [r7, #12]
9000bbe4:	681b      	ldr	r3, [r3, #0]
9000bbe6:	4a78      	ldr	r2, [pc, #480]	; (9000bdc8 <DMA_SetConfig+0x250>)
9000bbe8:	4293      	cmp	r3, r2
9000bbea:	d04a      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bbec:	68fb      	ldr	r3, [r7, #12]
9000bbee:	681b      	ldr	r3, [r3, #0]
9000bbf0:	4a76      	ldr	r2, [pc, #472]	; (9000bdcc <DMA_SetConfig+0x254>)
9000bbf2:	4293      	cmp	r3, r2
9000bbf4:	d045      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bbf6:	68fb      	ldr	r3, [r7, #12]
9000bbf8:	681b      	ldr	r3, [r3, #0]
9000bbfa:	4a75      	ldr	r2, [pc, #468]	; (9000bdd0 <DMA_SetConfig+0x258>)
9000bbfc:	4293      	cmp	r3, r2
9000bbfe:	d040      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc00:	68fb      	ldr	r3, [r7, #12]
9000bc02:	681b      	ldr	r3, [r3, #0]
9000bc04:	4a73      	ldr	r2, [pc, #460]	; (9000bdd4 <DMA_SetConfig+0x25c>)
9000bc06:	4293      	cmp	r3, r2
9000bc08:	d03b      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc0a:	68fb      	ldr	r3, [r7, #12]
9000bc0c:	681b      	ldr	r3, [r3, #0]
9000bc0e:	4a72      	ldr	r2, [pc, #456]	; (9000bdd8 <DMA_SetConfig+0x260>)
9000bc10:	4293      	cmp	r3, r2
9000bc12:	d036      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc14:	68fb      	ldr	r3, [r7, #12]
9000bc16:	681b      	ldr	r3, [r3, #0]
9000bc18:	4a70      	ldr	r2, [pc, #448]	; (9000bddc <DMA_SetConfig+0x264>)
9000bc1a:	4293      	cmp	r3, r2
9000bc1c:	d031      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc1e:	68fb      	ldr	r3, [r7, #12]
9000bc20:	681b      	ldr	r3, [r3, #0]
9000bc22:	4a6f      	ldr	r2, [pc, #444]	; (9000bde0 <DMA_SetConfig+0x268>)
9000bc24:	4293      	cmp	r3, r2
9000bc26:	d02c      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc28:	68fb      	ldr	r3, [r7, #12]
9000bc2a:	681b      	ldr	r3, [r3, #0]
9000bc2c:	4a6d      	ldr	r2, [pc, #436]	; (9000bde4 <DMA_SetConfig+0x26c>)
9000bc2e:	4293      	cmp	r3, r2
9000bc30:	d027      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc32:	68fb      	ldr	r3, [r7, #12]
9000bc34:	681b      	ldr	r3, [r3, #0]
9000bc36:	4a6c      	ldr	r2, [pc, #432]	; (9000bde8 <DMA_SetConfig+0x270>)
9000bc38:	4293      	cmp	r3, r2
9000bc3a:	d022      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc3c:	68fb      	ldr	r3, [r7, #12]
9000bc3e:	681b      	ldr	r3, [r3, #0]
9000bc40:	4a6a      	ldr	r2, [pc, #424]	; (9000bdec <DMA_SetConfig+0x274>)
9000bc42:	4293      	cmp	r3, r2
9000bc44:	d01d      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc46:	68fb      	ldr	r3, [r7, #12]
9000bc48:	681b      	ldr	r3, [r3, #0]
9000bc4a:	4a69      	ldr	r2, [pc, #420]	; (9000bdf0 <DMA_SetConfig+0x278>)
9000bc4c:	4293      	cmp	r3, r2
9000bc4e:	d018      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc50:	68fb      	ldr	r3, [r7, #12]
9000bc52:	681b      	ldr	r3, [r3, #0]
9000bc54:	4a67      	ldr	r2, [pc, #412]	; (9000bdf4 <DMA_SetConfig+0x27c>)
9000bc56:	4293      	cmp	r3, r2
9000bc58:	d013      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc5a:	68fb      	ldr	r3, [r7, #12]
9000bc5c:	681b      	ldr	r3, [r3, #0]
9000bc5e:	4a66      	ldr	r2, [pc, #408]	; (9000bdf8 <DMA_SetConfig+0x280>)
9000bc60:	4293      	cmp	r3, r2
9000bc62:	d00e      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc64:	68fb      	ldr	r3, [r7, #12]
9000bc66:	681b      	ldr	r3, [r3, #0]
9000bc68:	4a64      	ldr	r2, [pc, #400]	; (9000bdfc <DMA_SetConfig+0x284>)
9000bc6a:	4293      	cmp	r3, r2
9000bc6c:	d009      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc6e:	68fb      	ldr	r3, [r7, #12]
9000bc70:	681b      	ldr	r3, [r3, #0]
9000bc72:	4a63      	ldr	r2, [pc, #396]	; (9000be00 <DMA_SetConfig+0x288>)
9000bc74:	4293      	cmp	r3, r2
9000bc76:	d004      	beq.n	9000bc82 <DMA_SetConfig+0x10a>
9000bc78:	68fb      	ldr	r3, [r7, #12]
9000bc7a:	681b      	ldr	r3, [r3, #0]
9000bc7c:	4a61      	ldr	r2, [pc, #388]	; (9000be04 <DMA_SetConfig+0x28c>)
9000bc7e:	4293      	cmp	r3, r2
9000bc80:	d101      	bne.n	9000bc86 <DMA_SetConfig+0x10e>
9000bc82:	2301      	movs	r3, #1
9000bc84:	e000      	b.n	9000bc88 <DMA_SetConfig+0x110>
9000bc86:	2300      	movs	r3, #0
9000bc88:	2b00      	cmp	r3, #0
9000bc8a:	d00d      	beq.n	9000bca8 <DMA_SetConfig+0x130>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
9000bc8c:	68fb      	ldr	r3, [r7, #12]
9000bc8e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000bc90:	68fa      	ldr	r2, [r7, #12]
9000bc92:	6e92      	ldr	r2, [r2, #104]	; 0x68
9000bc94:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
9000bc96:	68fb      	ldr	r3, [r7, #12]
9000bc98:	6edb      	ldr	r3, [r3, #108]	; 0x6c
9000bc9a:	2b00      	cmp	r3, #0
9000bc9c:	d004      	beq.n	9000bca8 <DMA_SetConfig+0x130>
    {
      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
9000bc9e:	68fb      	ldr	r3, [r7, #12]
9000bca0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
9000bca2:	68fa      	ldr	r2, [r7, #12]
9000bca4:	6f52      	ldr	r2, [r2, #116]	; 0x74
9000bca6:	605a      	str	r2, [r3, #4]
    }
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
9000bca8:	68fb      	ldr	r3, [r7, #12]
9000bcaa:	681b      	ldr	r3, [r3, #0]
9000bcac:	4a3e      	ldr	r2, [pc, #248]	; (9000bda8 <DMA_SetConfig+0x230>)
9000bcae:	4293      	cmp	r3, r2
9000bcb0:	d04a      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bcb2:	68fb      	ldr	r3, [r7, #12]
9000bcb4:	681b      	ldr	r3, [r3, #0]
9000bcb6:	4a3d      	ldr	r2, [pc, #244]	; (9000bdac <DMA_SetConfig+0x234>)
9000bcb8:	4293      	cmp	r3, r2
9000bcba:	d045      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bcbc:	68fb      	ldr	r3, [r7, #12]
9000bcbe:	681b      	ldr	r3, [r3, #0]
9000bcc0:	4a3b      	ldr	r2, [pc, #236]	; (9000bdb0 <DMA_SetConfig+0x238>)
9000bcc2:	4293      	cmp	r3, r2
9000bcc4:	d040      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bcc6:	68fb      	ldr	r3, [r7, #12]
9000bcc8:	681b      	ldr	r3, [r3, #0]
9000bcca:	4a3a      	ldr	r2, [pc, #232]	; (9000bdb4 <DMA_SetConfig+0x23c>)
9000bccc:	4293      	cmp	r3, r2
9000bcce:	d03b      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bcd0:	68fb      	ldr	r3, [r7, #12]
9000bcd2:	681b      	ldr	r3, [r3, #0]
9000bcd4:	4a38      	ldr	r2, [pc, #224]	; (9000bdb8 <DMA_SetConfig+0x240>)
9000bcd6:	4293      	cmp	r3, r2
9000bcd8:	d036      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bcda:	68fb      	ldr	r3, [r7, #12]
9000bcdc:	681b      	ldr	r3, [r3, #0]
9000bcde:	4a37      	ldr	r2, [pc, #220]	; (9000bdbc <DMA_SetConfig+0x244>)
9000bce0:	4293      	cmp	r3, r2
9000bce2:	d031      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bce4:	68fb      	ldr	r3, [r7, #12]
9000bce6:	681b      	ldr	r3, [r3, #0]
9000bce8:	4a35      	ldr	r2, [pc, #212]	; (9000bdc0 <DMA_SetConfig+0x248>)
9000bcea:	4293      	cmp	r3, r2
9000bcec:	d02c      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bcee:	68fb      	ldr	r3, [r7, #12]
9000bcf0:	681b      	ldr	r3, [r3, #0]
9000bcf2:	4a34      	ldr	r2, [pc, #208]	; (9000bdc4 <DMA_SetConfig+0x24c>)
9000bcf4:	4293      	cmp	r3, r2
9000bcf6:	d027      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bcf8:	68fb      	ldr	r3, [r7, #12]
9000bcfa:	681b      	ldr	r3, [r3, #0]
9000bcfc:	4a32      	ldr	r2, [pc, #200]	; (9000bdc8 <DMA_SetConfig+0x250>)
9000bcfe:	4293      	cmp	r3, r2
9000bd00:	d022      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bd02:	68fb      	ldr	r3, [r7, #12]
9000bd04:	681b      	ldr	r3, [r3, #0]
9000bd06:	4a31      	ldr	r2, [pc, #196]	; (9000bdcc <DMA_SetConfig+0x254>)
9000bd08:	4293      	cmp	r3, r2
9000bd0a:	d01d      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bd0c:	68fb      	ldr	r3, [r7, #12]
9000bd0e:	681b      	ldr	r3, [r3, #0]
9000bd10:	4a2f      	ldr	r2, [pc, #188]	; (9000bdd0 <DMA_SetConfig+0x258>)
9000bd12:	4293      	cmp	r3, r2
9000bd14:	d018      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bd16:	68fb      	ldr	r3, [r7, #12]
9000bd18:	681b      	ldr	r3, [r3, #0]
9000bd1a:	4a2e      	ldr	r2, [pc, #184]	; (9000bdd4 <DMA_SetConfig+0x25c>)
9000bd1c:	4293      	cmp	r3, r2
9000bd1e:	d013      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bd20:	68fb      	ldr	r3, [r7, #12]
9000bd22:	681b      	ldr	r3, [r3, #0]
9000bd24:	4a2c      	ldr	r2, [pc, #176]	; (9000bdd8 <DMA_SetConfig+0x260>)
9000bd26:	4293      	cmp	r3, r2
9000bd28:	d00e      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bd2a:	68fb      	ldr	r3, [r7, #12]
9000bd2c:	681b      	ldr	r3, [r3, #0]
9000bd2e:	4a2b      	ldr	r2, [pc, #172]	; (9000bddc <DMA_SetConfig+0x264>)
9000bd30:	4293      	cmp	r3, r2
9000bd32:	d009      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bd34:	68fb      	ldr	r3, [r7, #12]
9000bd36:	681b      	ldr	r3, [r3, #0]
9000bd38:	4a29      	ldr	r2, [pc, #164]	; (9000bde0 <DMA_SetConfig+0x268>)
9000bd3a:	4293      	cmp	r3, r2
9000bd3c:	d004      	beq.n	9000bd48 <DMA_SetConfig+0x1d0>
9000bd3e:	68fb      	ldr	r3, [r7, #12]
9000bd40:	681b      	ldr	r3, [r3, #0]
9000bd42:	4a28      	ldr	r2, [pc, #160]	; (9000bde4 <DMA_SetConfig+0x26c>)
9000bd44:	4293      	cmp	r3, r2
9000bd46:	d101      	bne.n	9000bd4c <DMA_SetConfig+0x1d4>
9000bd48:	2301      	movs	r3, #1
9000bd4a:	e000      	b.n	9000bd4e <DMA_SetConfig+0x1d6>
9000bd4c:	2300      	movs	r3, #0
9000bd4e:	2b00      	cmp	r3, #0
9000bd50:	d05a      	beq.n	9000be08 <DMA_SetConfig+0x290>
  {
    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
9000bd52:	68fb      	ldr	r3, [r7, #12]
9000bd54:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000bd56:	f003 031f 	and.w	r3, r3, #31
9000bd5a:	223f      	movs	r2, #63	; 0x3f
9000bd5c:	409a      	lsls	r2, r3
9000bd5e:	697b      	ldr	r3, [r7, #20]
9000bd60:	609a      	str	r2, [r3, #8]

    /* Clear DBM bit */
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
9000bd62:	68fb      	ldr	r3, [r7, #12]
9000bd64:	681b      	ldr	r3, [r3, #0]
9000bd66:	681a      	ldr	r2, [r3, #0]
9000bd68:	68fb      	ldr	r3, [r7, #12]
9000bd6a:	681b      	ldr	r3, [r3, #0]
9000bd6c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
9000bd70:	601a      	str	r2, [r3, #0]

    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;
9000bd72:	68fb      	ldr	r3, [r7, #12]
9000bd74:	681b      	ldr	r3, [r3, #0]
9000bd76:	683a      	ldr	r2, [r7, #0]
9000bd78:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
9000bd7a:	68fb      	ldr	r3, [r7, #12]
9000bd7c:	689b      	ldr	r3, [r3, #8]
9000bd7e:	2b40      	cmp	r3, #64	; 0x40
9000bd80:	d108      	bne.n	9000bd94 <DMA_SetConfig+0x21c>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;
9000bd82:	68fb      	ldr	r3, [r7, #12]
9000bd84:	681b      	ldr	r3, [r3, #0]
9000bd86:	687a      	ldr	r2, [r7, #4]
9000bd88:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;
9000bd8a:	68fb      	ldr	r3, [r7, #12]
9000bd8c:	681b      	ldr	r3, [r3, #0]
9000bd8e:	68ba      	ldr	r2, [r7, #8]
9000bd90:	60da      	str	r2, [r3, #12]
  }
  else
  {
    /* Nothing To Do */
  }
}
9000bd92:	e087      	b.n	9000bea4 <DMA_SetConfig+0x32c>
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;
9000bd94:	68fb      	ldr	r3, [r7, #12]
9000bd96:	681b      	ldr	r3, [r3, #0]
9000bd98:	68ba      	ldr	r2, [r7, #8]
9000bd9a:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
9000bd9c:	68fb      	ldr	r3, [r7, #12]
9000bd9e:	681b      	ldr	r3, [r3, #0]
9000bda0:	687a      	ldr	r2, [r7, #4]
9000bda2:	60da      	str	r2, [r3, #12]
}
9000bda4:	e07e      	b.n	9000bea4 <DMA_SetConfig+0x32c>
9000bda6:	bf00      	nop
9000bda8:	40020010 	.word	0x40020010
9000bdac:	40020028 	.word	0x40020028
9000bdb0:	40020040 	.word	0x40020040
9000bdb4:	40020058 	.word	0x40020058
9000bdb8:	40020070 	.word	0x40020070
9000bdbc:	40020088 	.word	0x40020088
9000bdc0:	400200a0 	.word	0x400200a0
9000bdc4:	400200b8 	.word	0x400200b8
9000bdc8:	40020410 	.word	0x40020410
9000bdcc:	40020428 	.word	0x40020428
9000bdd0:	40020440 	.word	0x40020440
9000bdd4:	40020458 	.word	0x40020458
9000bdd8:	40020470 	.word	0x40020470
9000bddc:	40020488 	.word	0x40020488
9000bde0:	400204a0 	.word	0x400204a0
9000bde4:	400204b8 	.word	0x400204b8
9000bde8:	58025408 	.word	0x58025408
9000bdec:	5802541c 	.word	0x5802541c
9000bdf0:	58025430 	.word	0x58025430
9000bdf4:	58025444 	.word	0x58025444
9000bdf8:	58025458 	.word	0x58025458
9000bdfc:	5802546c 	.word	0x5802546c
9000be00:	58025480 	.word	0x58025480
9000be04:	58025494 	.word	0x58025494
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
9000be08:	68fb      	ldr	r3, [r7, #12]
9000be0a:	681b      	ldr	r3, [r3, #0]
9000be0c:	4a28      	ldr	r2, [pc, #160]	; (9000beb0 <DMA_SetConfig+0x338>)
9000be0e:	4293      	cmp	r3, r2
9000be10:	d022      	beq.n	9000be58 <DMA_SetConfig+0x2e0>
9000be12:	68fb      	ldr	r3, [r7, #12]
9000be14:	681b      	ldr	r3, [r3, #0]
9000be16:	4a27      	ldr	r2, [pc, #156]	; (9000beb4 <DMA_SetConfig+0x33c>)
9000be18:	4293      	cmp	r3, r2
9000be1a:	d01d      	beq.n	9000be58 <DMA_SetConfig+0x2e0>
9000be1c:	68fb      	ldr	r3, [r7, #12]
9000be1e:	681b      	ldr	r3, [r3, #0]
9000be20:	4a25      	ldr	r2, [pc, #148]	; (9000beb8 <DMA_SetConfig+0x340>)
9000be22:	4293      	cmp	r3, r2
9000be24:	d018      	beq.n	9000be58 <DMA_SetConfig+0x2e0>
9000be26:	68fb      	ldr	r3, [r7, #12]
9000be28:	681b      	ldr	r3, [r3, #0]
9000be2a:	4a24      	ldr	r2, [pc, #144]	; (9000bebc <DMA_SetConfig+0x344>)
9000be2c:	4293      	cmp	r3, r2
9000be2e:	d013      	beq.n	9000be58 <DMA_SetConfig+0x2e0>
9000be30:	68fb      	ldr	r3, [r7, #12]
9000be32:	681b      	ldr	r3, [r3, #0]
9000be34:	4a22      	ldr	r2, [pc, #136]	; (9000bec0 <DMA_SetConfig+0x348>)
9000be36:	4293      	cmp	r3, r2
9000be38:	d00e      	beq.n	9000be58 <DMA_SetConfig+0x2e0>
9000be3a:	68fb      	ldr	r3, [r7, #12]
9000be3c:	681b      	ldr	r3, [r3, #0]
9000be3e:	4a21      	ldr	r2, [pc, #132]	; (9000bec4 <DMA_SetConfig+0x34c>)
9000be40:	4293      	cmp	r3, r2
9000be42:	d009      	beq.n	9000be58 <DMA_SetConfig+0x2e0>
9000be44:	68fb      	ldr	r3, [r7, #12]
9000be46:	681b      	ldr	r3, [r3, #0]
9000be48:	4a1f      	ldr	r2, [pc, #124]	; (9000bec8 <DMA_SetConfig+0x350>)
9000be4a:	4293      	cmp	r3, r2
9000be4c:	d004      	beq.n	9000be58 <DMA_SetConfig+0x2e0>
9000be4e:	68fb      	ldr	r3, [r7, #12]
9000be50:	681b      	ldr	r3, [r3, #0]
9000be52:	4a1e      	ldr	r2, [pc, #120]	; (9000becc <DMA_SetConfig+0x354>)
9000be54:	4293      	cmp	r3, r2
9000be56:	d101      	bne.n	9000be5c <DMA_SetConfig+0x2e4>
9000be58:	2301      	movs	r3, #1
9000be5a:	e000      	b.n	9000be5e <DMA_SetConfig+0x2e6>
9000be5c:	2300      	movs	r3, #0
9000be5e:	2b00      	cmp	r3, #0
9000be60:	d020      	beq.n	9000bea4 <DMA_SetConfig+0x32c>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
9000be62:	68fb      	ldr	r3, [r7, #12]
9000be64:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000be66:	f003 031f 	and.w	r3, r3, #31
9000be6a:	2201      	movs	r2, #1
9000be6c:	409a      	lsls	r2, r3
9000be6e:	693b      	ldr	r3, [r7, #16]
9000be70:	605a      	str	r2, [r3, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
9000be72:	68fb      	ldr	r3, [r7, #12]
9000be74:	681b      	ldr	r3, [r3, #0]
9000be76:	683a      	ldr	r2, [r7, #0]
9000be78:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
9000be7a:	68fb      	ldr	r3, [r7, #12]
9000be7c:	689b      	ldr	r3, [r3, #8]
9000be7e:	2b40      	cmp	r3, #64	; 0x40
9000be80:	d108      	bne.n	9000be94 <DMA_SetConfig+0x31c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
9000be82:	68fb      	ldr	r3, [r7, #12]
9000be84:	681b      	ldr	r3, [r3, #0]
9000be86:	687a      	ldr	r2, [r7, #4]
9000be88:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
9000be8a:	68fb      	ldr	r3, [r7, #12]
9000be8c:	681b      	ldr	r3, [r3, #0]
9000be8e:	68ba      	ldr	r2, [r7, #8]
9000be90:	60da      	str	r2, [r3, #12]
}
9000be92:	e007      	b.n	9000bea4 <DMA_SetConfig+0x32c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
9000be94:	68fb      	ldr	r3, [r7, #12]
9000be96:	681b      	ldr	r3, [r3, #0]
9000be98:	68ba      	ldr	r2, [r7, #8]
9000be9a:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
9000be9c:	68fb      	ldr	r3, [r7, #12]
9000be9e:	681b      	ldr	r3, [r3, #0]
9000bea0:	687a      	ldr	r2, [r7, #4]
9000bea2:	60da      	str	r2, [r3, #12]
}
9000bea4:	bf00      	nop
9000bea6:	371c      	adds	r7, #28
9000bea8:	46bd      	mov	sp, r7
9000beaa:	f85d 7b04 	ldr.w	r7, [sp], #4
9000beae:	4770      	bx	lr
9000beb0:	58025408 	.word	0x58025408
9000beb4:	5802541c 	.word	0x5802541c
9000beb8:	58025430 	.word	0x58025430
9000bebc:	58025444 	.word	0x58025444
9000bec0:	58025458 	.word	0x58025458
9000bec4:	5802546c 	.word	0x5802546c
9000bec8:	58025480 	.word	0x58025480
9000becc:	58025494 	.word	0x58025494

9000bed0 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
9000bed0:	b480      	push	{r7}
9000bed2:	b085      	sub	sp, #20
9000bed4:	af00      	add	r7, sp, #0
9000bed6:	6078      	str	r0, [r7, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
9000bed8:	687b      	ldr	r3, [r7, #4]
9000beda:	681b      	ldr	r3, [r3, #0]
9000bedc:	4a42      	ldr	r2, [pc, #264]	; (9000bfe8 <DMA_CalcBaseAndBitshift+0x118>)
9000bede:	4293      	cmp	r3, r2
9000bee0:	d04a      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bee2:	687b      	ldr	r3, [r7, #4]
9000bee4:	681b      	ldr	r3, [r3, #0]
9000bee6:	4a41      	ldr	r2, [pc, #260]	; (9000bfec <DMA_CalcBaseAndBitshift+0x11c>)
9000bee8:	4293      	cmp	r3, r2
9000beea:	d045      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000beec:	687b      	ldr	r3, [r7, #4]
9000beee:	681b      	ldr	r3, [r3, #0]
9000bef0:	4a3f      	ldr	r2, [pc, #252]	; (9000bff0 <DMA_CalcBaseAndBitshift+0x120>)
9000bef2:	4293      	cmp	r3, r2
9000bef4:	d040      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bef6:	687b      	ldr	r3, [r7, #4]
9000bef8:	681b      	ldr	r3, [r3, #0]
9000befa:	4a3e      	ldr	r2, [pc, #248]	; (9000bff4 <DMA_CalcBaseAndBitshift+0x124>)
9000befc:	4293      	cmp	r3, r2
9000befe:	d03b      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf00:	687b      	ldr	r3, [r7, #4]
9000bf02:	681b      	ldr	r3, [r3, #0]
9000bf04:	4a3c      	ldr	r2, [pc, #240]	; (9000bff8 <DMA_CalcBaseAndBitshift+0x128>)
9000bf06:	4293      	cmp	r3, r2
9000bf08:	d036      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf0a:	687b      	ldr	r3, [r7, #4]
9000bf0c:	681b      	ldr	r3, [r3, #0]
9000bf0e:	4a3b      	ldr	r2, [pc, #236]	; (9000bffc <DMA_CalcBaseAndBitshift+0x12c>)
9000bf10:	4293      	cmp	r3, r2
9000bf12:	d031      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf14:	687b      	ldr	r3, [r7, #4]
9000bf16:	681b      	ldr	r3, [r3, #0]
9000bf18:	4a39      	ldr	r2, [pc, #228]	; (9000c000 <DMA_CalcBaseAndBitshift+0x130>)
9000bf1a:	4293      	cmp	r3, r2
9000bf1c:	d02c      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf1e:	687b      	ldr	r3, [r7, #4]
9000bf20:	681b      	ldr	r3, [r3, #0]
9000bf22:	4a38      	ldr	r2, [pc, #224]	; (9000c004 <DMA_CalcBaseAndBitshift+0x134>)
9000bf24:	4293      	cmp	r3, r2
9000bf26:	d027      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf28:	687b      	ldr	r3, [r7, #4]
9000bf2a:	681b      	ldr	r3, [r3, #0]
9000bf2c:	4a36      	ldr	r2, [pc, #216]	; (9000c008 <DMA_CalcBaseAndBitshift+0x138>)
9000bf2e:	4293      	cmp	r3, r2
9000bf30:	d022      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf32:	687b      	ldr	r3, [r7, #4]
9000bf34:	681b      	ldr	r3, [r3, #0]
9000bf36:	4a35      	ldr	r2, [pc, #212]	; (9000c00c <DMA_CalcBaseAndBitshift+0x13c>)
9000bf38:	4293      	cmp	r3, r2
9000bf3a:	d01d      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf3c:	687b      	ldr	r3, [r7, #4]
9000bf3e:	681b      	ldr	r3, [r3, #0]
9000bf40:	4a33      	ldr	r2, [pc, #204]	; (9000c010 <DMA_CalcBaseAndBitshift+0x140>)
9000bf42:	4293      	cmp	r3, r2
9000bf44:	d018      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf46:	687b      	ldr	r3, [r7, #4]
9000bf48:	681b      	ldr	r3, [r3, #0]
9000bf4a:	4a32      	ldr	r2, [pc, #200]	; (9000c014 <DMA_CalcBaseAndBitshift+0x144>)
9000bf4c:	4293      	cmp	r3, r2
9000bf4e:	d013      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf50:	687b      	ldr	r3, [r7, #4]
9000bf52:	681b      	ldr	r3, [r3, #0]
9000bf54:	4a30      	ldr	r2, [pc, #192]	; (9000c018 <DMA_CalcBaseAndBitshift+0x148>)
9000bf56:	4293      	cmp	r3, r2
9000bf58:	d00e      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf5a:	687b      	ldr	r3, [r7, #4]
9000bf5c:	681b      	ldr	r3, [r3, #0]
9000bf5e:	4a2f      	ldr	r2, [pc, #188]	; (9000c01c <DMA_CalcBaseAndBitshift+0x14c>)
9000bf60:	4293      	cmp	r3, r2
9000bf62:	d009      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf64:	687b      	ldr	r3, [r7, #4]
9000bf66:	681b      	ldr	r3, [r3, #0]
9000bf68:	4a2d      	ldr	r2, [pc, #180]	; (9000c020 <DMA_CalcBaseAndBitshift+0x150>)
9000bf6a:	4293      	cmp	r3, r2
9000bf6c:	d004      	beq.n	9000bf78 <DMA_CalcBaseAndBitshift+0xa8>
9000bf6e:	687b      	ldr	r3, [r7, #4]
9000bf70:	681b      	ldr	r3, [r3, #0]
9000bf72:	4a2c      	ldr	r2, [pc, #176]	; (9000c024 <DMA_CalcBaseAndBitshift+0x154>)
9000bf74:	4293      	cmp	r3, r2
9000bf76:	d101      	bne.n	9000bf7c <DMA_CalcBaseAndBitshift+0xac>
9000bf78:	2301      	movs	r3, #1
9000bf7a:	e000      	b.n	9000bf7e <DMA_CalcBaseAndBitshift+0xae>
9000bf7c:	2300      	movs	r3, #0
9000bf7e:	2b00      	cmp	r3, #0
9000bf80:	d024      	beq.n	9000bfcc <DMA_CalcBaseAndBitshift+0xfc>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
9000bf82:	687b      	ldr	r3, [r7, #4]
9000bf84:	681b      	ldr	r3, [r3, #0]
9000bf86:	b2db      	uxtb	r3, r3
9000bf88:	3b10      	subs	r3, #16
9000bf8a:	4a27      	ldr	r2, [pc, #156]	; (9000c028 <DMA_CalcBaseAndBitshift+0x158>)
9000bf8c:	fba2 2303 	umull	r2, r3, r2, r3
9000bf90:	091b      	lsrs	r3, r3, #4
9000bf92:	60fb      	str	r3, [r7, #12]

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
9000bf94:	68fb      	ldr	r3, [r7, #12]
9000bf96:	f003 0307 	and.w	r3, r3, #7
9000bf9a:	4a24      	ldr	r2, [pc, #144]	; (9000c02c <DMA_CalcBaseAndBitshift+0x15c>)
9000bf9c:	5cd3      	ldrb	r3, [r2, r3]
9000bf9e:	461a      	mov	r2, r3
9000bfa0:	687b      	ldr	r3, [r7, #4]
9000bfa2:	65da      	str	r2, [r3, #92]	; 0x5c

    if (stream_number > 3U)
9000bfa4:	68fb      	ldr	r3, [r7, #12]
9000bfa6:	2b03      	cmp	r3, #3
9000bfa8:	d908      	bls.n	9000bfbc <DMA_CalcBaseAndBitshift+0xec>
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
9000bfaa:	687b      	ldr	r3, [r7, #4]
9000bfac:	681b      	ldr	r3, [r3, #0]
9000bfae:	461a      	mov	r2, r3
9000bfb0:	4b1f      	ldr	r3, [pc, #124]	; (9000c030 <DMA_CalcBaseAndBitshift+0x160>)
9000bfb2:	4013      	ands	r3, r2
9000bfb4:	1d1a      	adds	r2, r3, #4
9000bfb6:	687b      	ldr	r3, [r7, #4]
9000bfb8:	659a      	str	r2, [r3, #88]	; 0x58
9000bfba:	e00d      	b.n	9000bfd8 <DMA_CalcBaseAndBitshift+0x108>
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
9000bfbc:	687b      	ldr	r3, [r7, #4]
9000bfbe:	681b      	ldr	r3, [r3, #0]
9000bfc0:	461a      	mov	r2, r3
9000bfc2:	4b1b      	ldr	r3, [pc, #108]	; (9000c030 <DMA_CalcBaseAndBitshift+0x160>)
9000bfc4:	4013      	ands	r3, r2
9000bfc6:	687a      	ldr	r2, [r7, #4]
9000bfc8:	6593      	str	r3, [r2, #88]	; 0x58
9000bfca:	e005      	b.n	9000bfd8 <DMA_CalcBaseAndBitshift+0x108>
    }
  }
  else /* BDMA instance(s) */
  {
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
9000bfcc:	687b      	ldr	r3, [r7, #4]
9000bfce:	681b      	ldr	r3, [r3, #0]
9000bfd0:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
9000bfd4:	687b      	ldr	r3, [r7, #4]
9000bfd6:	659a      	str	r2, [r3, #88]	; 0x58
  }

  return hdma->StreamBaseAddress;
9000bfd8:	687b      	ldr	r3, [r7, #4]
9000bfda:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
9000bfdc:	4618      	mov	r0, r3
9000bfde:	3714      	adds	r7, #20
9000bfe0:	46bd      	mov	sp, r7
9000bfe2:	f85d 7b04 	ldr.w	r7, [sp], #4
9000bfe6:	4770      	bx	lr
9000bfe8:	40020010 	.word	0x40020010
9000bfec:	40020028 	.word	0x40020028
9000bff0:	40020040 	.word	0x40020040
9000bff4:	40020058 	.word	0x40020058
9000bff8:	40020070 	.word	0x40020070
9000bffc:	40020088 	.word	0x40020088
9000c000:	400200a0 	.word	0x400200a0
9000c004:	400200b8 	.word	0x400200b8
9000c008:	40020410 	.word	0x40020410
9000c00c:	40020428 	.word	0x40020428
9000c010:	40020440 	.word	0x40020440
9000c014:	40020458 	.word	0x40020458
9000c018:	40020470 	.word	0x40020470
9000c01c:	40020488 	.word	0x40020488
9000c020:	400204a0 	.word	0x400204a0
9000c024:	400204b8 	.word	0x400204b8
9000c028:	aaaaaaab 	.word	0xaaaaaaab
9000c02c:	9001e8b8 	.word	0x9001e8b8
9000c030:	fffffc00 	.word	0xfffffc00

9000c034 <DMA_CheckFifoParam>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
9000c034:	b480      	push	{r7}
9000c036:	b085      	sub	sp, #20
9000c038:	af00      	add	r7, sp, #0
9000c03a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
9000c03c:	2300      	movs	r3, #0
9000c03e:	73fb      	strb	r3, [r7, #15]

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
9000c040:	687b      	ldr	r3, [r7, #4]
9000c042:	699b      	ldr	r3, [r3, #24]
9000c044:	2b00      	cmp	r3, #0
9000c046:	d120      	bne.n	9000c08a <DMA_CheckFifoParam+0x56>
  {
    switch (hdma->Init.FIFOThreshold)
9000c048:	687b      	ldr	r3, [r7, #4]
9000c04a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9000c04c:	2b03      	cmp	r3, #3
9000c04e:	d858      	bhi.n	9000c102 <DMA_CheckFifoParam+0xce>
9000c050:	a201      	add	r2, pc, #4	; (adr r2, 9000c058 <DMA_CheckFifoParam+0x24>)
9000c052:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000c056:	bf00      	nop
9000c058:	9000c069 	.word	0x9000c069
9000c05c:	9000c07b 	.word	0x9000c07b
9000c060:	9000c069 	.word	0x9000c069
9000c064:	9000c103 	.word	0x9000c103
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:

        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
9000c068:	687b      	ldr	r3, [r7, #4]
9000c06a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000c06c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
9000c070:	2b00      	cmp	r3, #0
9000c072:	d048      	beq.n	9000c106 <DMA_CheckFifoParam+0xd2>
        {
          status = HAL_ERROR;
9000c074:	2301      	movs	r3, #1
9000c076:	73fb      	strb	r3, [r7, #15]
        }
        break;
9000c078:	e045      	b.n	9000c106 <DMA_CheckFifoParam+0xd2>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
9000c07a:	687b      	ldr	r3, [r7, #4]
9000c07c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000c07e:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
9000c082:	d142      	bne.n	9000c10a <DMA_CheckFifoParam+0xd6>
        {
          status = HAL_ERROR;
9000c084:	2301      	movs	r3, #1
9000c086:	73fb      	strb	r3, [r7, #15]
        }
        break;
9000c088:	e03f      	b.n	9000c10a <DMA_CheckFifoParam+0xd6>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
9000c08a:	687b      	ldr	r3, [r7, #4]
9000c08c:	699b      	ldr	r3, [r3, #24]
9000c08e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
9000c092:	d123      	bne.n	9000c0dc <DMA_CheckFifoParam+0xa8>
  {
    switch (hdma->Init.FIFOThreshold)
9000c094:	687b      	ldr	r3, [r7, #4]
9000c096:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9000c098:	2b03      	cmp	r3, #3
9000c09a:	d838      	bhi.n	9000c10e <DMA_CheckFifoParam+0xda>
9000c09c:	a201      	add	r2, pc, #4	; (adr r2, 9000c0a4 <DMA_CheckFifoParam+0x70>)
9000c09e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9000c0a2:	bf00      	nop
9000c0a4:	9000c0b5 	.word	0x9000c0b5
9000c0a8:	9000c0bb 	.word	0x9000c0bb
9000c0ac:	9000c0b5 	.word	0x9000c0b5
9000c0b0:	9000c0cd 	.word	0x9000c0cd
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
9000c0b4:	2301      	movs	r3, #1
9000c0b6:	73fb      	strb	r3, [r7, #15]
        break;
9000c0b8:	e030      	b.n	9000c11c <DMA_CheckFifoParam+0xe8>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
9000c0ba:	687b      	ldr	r3, [r7, #4]
9000c0bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000c0be:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
9000c0c2:	2b00      	cmp	r3, #0
9000c0c4:	d025      	beq.n	9000c112 <DMA_CheckFifoParam+0xde>
        {
          status = HAL_ERROR;
9000c0c6:	2301      	movs	r3, #1
9000c0c8:	73fb      	strb	r3, [r7, #15]
        }
        break;
9000c0ca:	e022      	b.n	9000c112 <DMA_CheckFifoParam+0xde>

      case DMA_FIFO_THRESHOLD_FULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
9000c0cc:	687b      	ldr	r3, [r7, #4]
9000c0ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000c0d0:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
9000c0d4:	d11f      	bne.n	9000c116 <DMA_CheckFifoParam+0xe2>
        {
          status = HAL_ERROR;
9000c0d6:	2301      	movs	r3, #1
9000c0d8:	73fb      	strb	r3, [r7, #15]
        }
        break;
9000c0da:	e01c      	b.n	9000c116 <DMA_CheckFifoParam+0xe2>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
9000c0dc:	687b      	ldr	r3, [r7, #4]
9000c0de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9000c0e0:	2b02      	cmp	r3, #2
9000c0e2:	d902      	bls.n	9000c0ea <DMA_CheckFifoParam+0xb6>
9000c0e4:	2b03      	cmp	r3, #3
9000c0e6:	d003      	beq.n	9000c0f0 <DMA_CheckFifoParam+0xbc>
          status = HAL_ERROR;
        }
    break;

      default:
        break;
9000c0e8:	e018      	b.n	9000c11c <DMA_CheckFifoParam+0xe8>
        status = HAL_ERROR;
9000c0ea:	2301      	movs	r3, #1
9000c0ec:	73fb      	strb	r3, [r7, #15]
        break;
9000c0ee:	e015      	b.n	9000c11c <DMA_CheckFifoParam+0xe8>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
9000c0f0:	687b      	ldr	r3, [r7, #4]
9000c0f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000c0f4:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
9000c0f8:	2b00      	cmp	r3, #0
9000c0fa:	d00e      	beq.n	9000c11a <DMA_CheckFifoParam+0xe6>
          status = HAL_ERROR;
9000c0fc:	2301      	movs	r3, #1
9000c0fe:	73fb      	strb	r3, [r7, #15]
    break;
9000c100:	e00b      	b.n	9000c11a <DMA_CheckFifoParam+0xe6>
        break;
9000c102:	bf00      	nop
9000c104:	e00a      	b.n	9000c11c <DMA_CheckFifoParam+0xe8>
        break;
9000c106:	bf00      	nop
9000c108:	e008      	b.n	9000c11c <DMA_CheckFifoParam+0xe8>
        break;
9000c10a:	bf00      	nop
9000c10c:	e006      	b.n	9000c11c <DMA_CheckFifoParam+0xe8>
        break;
9000c10e:	bf00      	nop
9000c110:	e004      	b.n	9000c11c <DMA_CheckFifoParam+0xe8>
        break;
9000c112:	bf00      	nop
9000c114:	e002      	b.n	9000c11c <DMA_CheckFifoParam+0xe8>
        break;
9000c116:	bf00      	nop
9000c118:	e000      	b.n	9000c11c <DMA_CheckFifoParam+0xe8>
    break;
9000c11a:	bf00      	nop
    }
  }

  return status;
9000c11c:	7bfb      	ldrb	r3, [r7, #15]
}
9000c11e:	4618      	mov	r0, r3
9000c120:	3714      	adds	r7, #20
9000c122:	46bd      	mov	sp, r7
9000c124:	f85d 7b04 	ldr.w	r7, [sp], #4
9000c128:	4770      	bx	lr
9000c12a:	bf00      	nop

9000c12c <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
9000c12c:	b480      	push	{r7}
9000c12e:	b085      	sub	sp, #20
9000c130:	af00      	add	r7, sp, #0
9000c132:	6078      	str	r0, [r7, #4]
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
9000c134:	687b      	ldr	r3, [r7, #4]
9000c136:	681b      	ldr	r3, [r3, #0]
9000c138:	60bb      	str	r3, [r7, #8]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
9000c13a:	687b      	ldr	r3, [r7, #4]
9000c13c:	681b      	ldr	r3, [r3, #0]
9000c13e:	4a38      	ldr	r2, [pc, #224]	; (9000c220 <DMA_CalcDMAMUXChannelBaseAndMask+0xf4>)
9000c140:	4293      	cmp	r3, r2
9000c142:	d022      	beq.n	9000c18a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
9000c144:	687b      	ldr	r3, [r7, #4]
9000c146:	681b      	ldr	r3, [r3, #0]
9000c148:	4a36      	ldr	r2, [pc, #216]	; (9000c224 <DMA_CalcDMAMUXChannelBaseAndMask+0xf8>)
9000c14a:	4293      	cmp	r3, r2
9000c14c:	d01d      	beq.n	9000c18a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
9000c14e:	687b      	ldr	r3, [r7, #4]
9000c150:	681b      	ldr	r3, [r3, #0]
9000c152:	4a35      	ldr	r2, [pc, #212]	; (9000c228 <DMA_CalcDMAMUXChannelBaseAndMask+0xfc>)
9000c154:	4293      	cmp	r3, r2
9000c156:	d018      	beq.n	9000c18a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
9000c158:	687b      	ldr	r3, [r7, #4]
9000c15a:	681b      	ldr	r3, [r3, #0]
9000c15c:	4a33      	ldr	r2, [pc, #204]	; (9000c22c <DMA_CalcDMAMUXChannelBaseAndMask+0x100>)
9000c15e:	4293      	cmp	r3, r2
9000c160:	d013      	beq.n	9000c18a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
9000c162:	687b      	ldr	r3, [r7, #4]
9000c164:	681b      	ldr	r3, [r3, #0]
9000c166:	4a32      	ldr	r2, [pc, #200]	; (9000c230 <DMA_CalcDMAMUXChannelBaseAndMask+0x104>)
9000c168:	4293      	cmp	r3, r2
9000c16a:	d00e      	beq.n	9000c18a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
9000c16c:	687b      	ldr	r3, [r7, #4]
9000c16e:	681b      	ldr	r3, [r3, #0]
9000c170:	4a30      	ldr	r2, [pc, #192]	; (9000c234 <DMA_CalcDMAMUXChannelBaseAndMask+0x108>)
9000c172:	4293      	cmp	r3, r2
9000c174:	d009      	beq.n	9000c18a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
9000c176:	687b      	ldr	r3, [r7, #4]
9000c178:	681b      	ldr	r3, [r3, #0]
9000c17a:	4a2f      	ldr	r2, [pc, #188]	; (9000c238 <DMA_CalcDMAMUXChannelBaseAndMask+0x10c>)
9000c17c:	4293      	cmp	r3, r2
9000c17e:	d004      	beq.n	9000c18a <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
9000c180:	687b      	ldr	r3, [r7, #4]
9000c182:	681b      	ldr	r3, [r3, #0]
9000c184:	4a2d      	ldr	r2, [pc, #180]	; (9000c23c <DMA_CalcDMAMUXChannelBaseAndMask+0x110>)
9000c186:	4293      	cmp	r3, r2
9000c188:	d101      	bne.n	9000c18e <DMA_CalcDMAMUXChannelBaseAndMask+0x62>
9000c18a:	2301      	movs	r3, #1
9000c18c:	e000      	b.n	9000c190 <DMA_CalcDMAMUXChannelBaseAndMask+0x64>
9000c18e:	2300      	movs	r3, #0
9000c190:	2b00      	cmp	r3, #0
9000c192:	d01a      	beq.n	9000c1ca <DMA_CalcDMAMUXChannelBaseAndMask+0x9e>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
9000c194:	687b      	ldr	r3, [r7, #4]
9000c196:	681b      	ldr	r3, [r3, #0]
9000c198:	b2db      	uxtb	r3, r3
9000c19a:	3b08      	subs	r3, #8
9000c19c:	4a28      	ldr	r2, [pc, #160]	; (9000c240 <DMA_CalcDMAMUXChannelBaseAndMask+0x114>)
9000c19e:	fba2 2303 	umull	r2, r3, r2, r3
9000c1a2:	091b      	lsrs	r3, r3, #4
9000c1a4:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
9000c1a6:	68fa      	ldr	r2, [r7, #12]
9000c1a8:	4b26      	ldr	r3, [pc, #152]	; (9000c244 <DMA_CalcDMAMUXChannelBaseAndMask+0x118>)
9000c1aa:	4413      	add	r3, r2
9000c1ac:	009b      	lsls	r3, r3, #2
9000c1ae:	461a      	mov	r2, r3
9000c1b0:	687b      	ldr	r3, [r7, #4]
9000c1b2:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
9000c1b4:	687b      	ldr	r3, [r7, #4]
9000c1b6:	4a24      	ldr	r2, [pc, #144]	; (9000c248 <DMA_CalcDMAMUXChannelBaseAndMask+0x11c>)
9000c1b8:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
9000c1ba:	68fb      	ldr	r3, [r7, #12]
9000c1bc:	f003 031f 	and.w	r3, r3, #31
9000c1c0:	2201      	movs	r2, #1
9000c1c2:	409a      	lsls	r2, r3
9000c1c4:	687b      	ldr	r3, [r7, #4]
9000c1c6:	669a      	str	r2, [r3, #104]	; 0x68
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
}
9000c1c8:	e024      	b.n	9000c214 <DMA_CalcDMAMUXChannelBaseAndMask+0xe8>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
9000c1ca:	687b      	ldr	r3, [r7, #4]
9000c1cc:	681b      	ldr	r3, [r3, #0]
9000c1ce:	b2db      	uxtb	r3, r3
9000c1d0:	3b10      	subs	r3, #16
9000c1d2:	4a1e      	ldr	r2, [pc, #120]	; (9000c24c <DMA_CalcDMAMUXChannelBaseAndMask+0x120>)
9000c1d4:	fba2 2303 	umull	r2, r3, r2, r3
9000c1d8:	091b      	lsrs	r3, r3, #4
9000c1da:	60fb      	str	r3, [r7, #12]
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
9000c1dc:	68bb      	ldr	r3, [r7, #8]
9000c1de:	4a1c      	ldr	r2, [pc, #112]	; (9000c250 <DMA_CalcDMAMUXChannelBaseAndMask+0x124>)
9000c1e0:	4293      	cmp	r3, r2
9000c1e2:	d806      	bhi.n	9000c1f2 <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
9000c1e4:	68bb      	ldr	r3, [r7, #8]
9000c1e6:	4a1b      	ldr	r2, [pc, #108]	; (9000c254 <DMA_CalcDMAMUXChannelBaseAndMask+0x128>)
9000c1e8:	4293      	cmp	r3, r2
9000c1ea:	d902      	bls.n	9000c1f2 <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
      stream_number += 8U;
9000c1ec:	68fb      	ldr	r3, [r7, #12]
9000c1ee:	3308      	adds	r3, #8
9000c1f0:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
9000c1f2:	68fa      	ldr	r2, [r7, #12]
9000c1f4:	4b18      	ldr	r3, [pc, #96]	; (9000c258 <DMA_CalcDMAMUXChannelBaseAndMask+0x12c>)
9000c1f6:	4413      	add	r3, r2
9000c1f8:	009b      	lsls	r3, r3, #2
9000c1fa:	461a      	mov	r2, r3
9000c1fc:	687b      	ldr	r3, [r7, #4]
9000c1fe:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
9000c200:	687b      	ldr	r3, [r7, #4]
9000c202:	4a16      	ldr	r2, [pc, #88]	; (9000c25c <DMA_CalcDMAMUXChannelBaseAndMask+0x130>)
9000c204:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
9000c206:	68fb      	ldr	r3, [r7, #12]
9000c208:	f003 031f 	and.w	r3, r3, #31
9000c20c:	2201      	movs	r2, #1
9000c20e:	409a      	lsls	r2, r3
9000c210:	687b      	ldr	r3, [r7, #4]
9000c212:	669a      	str	r2, [r3, #104]	; 0x68
}
9000c214:	bf00      	nop
9000c216:	3714      	adds	r7, #20
9000c218:	46bd      	mov	sp, r7
9000c21a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000c21e:	4770      	bx	lr
9000c220:	58025408 	.word	0x58025408
9000c224:	5802541c 	.word	0x5802541c
9000c228:	58025430 	.word	0x58025430
9000c22c:	58025444 	.word	0x58025444
9000c230:	58025458 	.word	0x58025458
9000c234:	5802546c 	.word	0x5802546c
9000c238:	58025480 	.word	0x58025480
9000c23c:	58025494 	.word	0x58025494
9000c240:	cccccccd 	.word	0xcccccccd
9000c244:	16009600 	.word	0x16009600
9000c248:	58025880 	.word	0x58025880
9000c24c:	aaaaaaab 	.word	0xaaaaaaab
9000c250:	400204b8 	.word	0x400204b8
9000c254:	4002040f 	.word	0x4002040f
9000c258:	10008200 	.word	0x10008200
9000c25c:	40020880 	.word	0x40020880

9000c260 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
9000c260:	b480      	push	{r7}
9000c262:	b085      	sub	sp, #20
9000c264:	af00      	add	r7, sp, #0
9000c266:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
9000c268:	687b      	ldr	r3, [r7, #4]
9000c26a:	685b      	ldr	r3, [r3, #4]
9000c26c:	b2db      	uxtb	r3, r3
9000c26e:	60fb      	str	r3, [r7, #12]

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
9000c270:	68fb      	ldr	r3, [r7, #12]
9000c272:	2b00      	cmp	r3, #0
9000c274:	d04a      	beq.n	9000c30c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
9000c276:	68fb      	ldr	r3, [r7, #12]
9000c278:	2b08      	cmp	r3, #8
9000c27a:	d847      	bhi.n	9000c30c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
9000c27c:	687b      	ldr	r3, [r7, #4]
9000c27e:	681b      	ldr	r3, [r3, #0]
9000c280:	4a25      	ldr	r2, [pc, #148]	; (9000c318 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xb8>)
9000c282:	4293      	cmp	r3, r2
9000c284:	d022      	beq.n	9000c2cc <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
9000c286:	687b      	ldr	r3, [r7, #4]
9000c288:	681b      	ldr	r3, [r3, #0]
9000c28a:	4a24      	ldr	r2, [pc, #144]	; (9000c31c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xbc>)
9000c28c:	4293      	cmp	r3, r2
9000c28e:	d01d      	beq.n	9000c2cc <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
9000c290:	687b      	ldr	r3, [r7, #4]
9000c292:	681b      	ldr	r3, [r3, #0]
9000c294:	4a22      	ldr	r2, [pc, #136]	; (9000c320 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc0>)
9000c296:	4293      	cmp	r3, r2
9000c298:	d018      	beq.n	9000c2cc <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
9000c29a:	687b      	ldr	r3, [r7, #4]
9000c29c:	681b      	ldr	r3, [r3, #0]
9000c29e:	4a21      	ldr	r2, [pc, #132]	; (9000c324 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc4>)
9000c2a0:	4293      	cmp	r3, r2
9000c2a2:	d013      	beq.n	9000c2cc <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
9000c2a4:	687b      	ldr	r3, [r7, #4]
9000c2a6:	681b      	ldr	r3, [r3, #0]
9000c2a8:	4a1f      	ldr	r2, [pc, #124]	; (9000c328 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc8>)
9000c2aa:	4293      	cmp	r3, r2
9000c2ac:	d00e      	beq.n	9000c2cc <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
9000c2ae:	687b      	ldr	r3, [r7, #4]
9000c2b0:	681b      	ldr	r3, [r3, #0]
9000c2b2:	4a1e      	ldr	r2, [pc, #120]	; (9000c32c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xcc>)
9000c2b4:	4293      	cmp	r3, r2
9000c2b6:	d009      	beq.n	9000c2cc <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
9000c2b8:	687b      	ldr	r3, [r7, #4]
9000c2ba:	681b      	ldr	r3, [r3, #0]
9000c2bc:	4a1c      	ldr	r2, [pc, #112]	; (9000c330 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd0>)
9000c2be:	4293      	cmp	r3, r2
9000c2c0:	d004      	beq.n	9000c2cc <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
9000c2c2:	687b      	ldr	r3, [r7, #4]
9000c2c4:	681b      	ldr	r3, [r3, #0]
9000c2c6:	4a1b      	ldr	r2, [pc, #108]	; (9000c334 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd4>)
9000c2c8:	4293      	cmp	r3, r2
9000c2ca:	d101      	bne.n	9000c2d0 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x70>
9000c2cc:	2301      	movs	r3, #1
9000c2ce:	e000      	b.n	9000c2d2 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x72>
9000c2d0:	2300      	movs	r3, #0
9000c2d2:	2b00      	cmp	r3, #0
9000c2d4:	d00a      	beq.n	9000c2ec <DMA_CalcDMAMUXRequestGenBaseAndMask+0x8c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
9000c2d6:	68fa      	ldr	r2, [r7, #12]
9000c2d8:	4b17      	ldr	r3, [pc, #92]	; (9000c338 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd8>)
9000c2da:	4413      	add	r3, r2
9000c2dc:	009b      	lsls	r3, r3, #2
9000c2de:	461a      	mov	r2, r3
9000c2e0:	687b      	ldr	r3, [r7, #4]
9000c2e2:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
9000c2e4:	687b      	ldr	r3, [r7, #4]
9000c2e6:	4a15      	ldr	r2, [pc, #84]	; (9000c33c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xdc>)
9000c2e8:	671a      	str	r2, [r3, #112]	; 0x70
9000c2ea:	e009      	b.n	9000c300 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xa0>
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
9000c2ec:	68fa      	ldr	r2, [r7, #12]
9000c2ee:	4b14      	ldr	r3, [pc, #80]	; (9000c340 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe0>)
9000c2f0:	4413      	add	r3, r2
9000c2f2:	009b      	lsls	r3, r3, #2
9000c2f4:	461a      	mov	r2, r3
9000c2f6:	687b      	ldr	r3, [r7, #4]
9000c2f8:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
9000c2fa:	687b      	ldr	r3, [r7, #4]
9000c2fc:	4a11      	ldr	r2, [pc, #68]	; (9000c344 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe4>)
9000c2fe:	671a      	str	r2, [r3, #112]	; 0x70
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
9000c300:	68fb      	ldr	r3, [r7, #12]
9000c302:	3b01      	subs	r3, #1
9000c304:	2201      	movs	r2, #1
9000c306:	409a      	lsls	r2, r3
9000c308:	687b      	ldr	r3, [r7, #4]
9000c30a:	675a      	str	r2, [r3, #116]	; 0x74
  }
}
9000c30c:	bf00      	nop
9000c30e:	3714      	adds	r7, #20
9000c310:	46bd      	mov	sp, r7
9000c312:	f85d 7b04 	ldr.w	r7, [sp], #4
9000c316:	4770      	bx	lr
9000c318:	58025408 	.word	0x58025408
9000c31c:	5802541c 	.word	0x5802541c
9000c320:	58025430 	.word	0x58025430
9000c324:	58025444 	.word	0x58025444
9000c328:	58025458 	.word	0x58025458
9000c32c:	5802546c 	.word	0x5802546c
9000c330:	58025480 	.word	0x58025480
9000c334:	58025494 	.word	0x58025494
9000c338:	1600963f 	.word	0x1600963f
9000c33c:	58025940 	.word	0x58025940
9000c340:	1000823f 	.word	0x1000823f
9000c344:	40020940 	.word	0x40020940

9000c348 <HAL_DMA2D_Init>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
9000c348:	b580      	push	{r7, lr}
9000c34a:	b082      	sub	sp, #8
9000c34c:	af00      	add	r7, sp, #0
9000c34e:	6078      	str	r0, [r7, #4]
  /* Check the DMA2D peripheral state */
  if (hdma2d == NULL)
9000c350:	687b      	ldr	r3, [r7, #4]
9000c352:	2b00      	cmp	r3, #0
9000c354:	d101      	bne.n	9000c35a <HAL_DMA2D_Init+0x12>
  {
    return HAL_ERROR;
9000c356:	2301      	movs	r3, #1
9000c358:	e04f      	b.n	9000c3fa <HAL_DMA2D_Init+0xb2>

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
9000c35a:	687b      	ldr	r3, [r7, #4]
9000c35c:	f893 3061 	ldrb.w	r3, [r3, #97]	; 0x61
9000c360:	b2db      	uxtb	r3, r3
9000c362:	2b00      	cmp	r3, #0
9000c364:	d106      	bne.n	9000c374 <HAL_DMA2D_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
9000c366:	687b      	ldr	r3, [r7, #4]
9000c368:	2200      	movs	r2, #0
9000c36a:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
    /* Init the low level hardware */
    HAL_DMA2D_MspInit(hdma2d);
9000c36e:	6878      	ldr	r0, [r7, #4]
9000c370:	f000 f8be 	bl	9000c4f0 <HAL_DMA2D_MspInit>
  }
#endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
9000c374:	687b      	ldr	r3, [r7, #4]
9000c376:	2202      	movs	r2, #2
9000c378:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE | DMA2D_CR_LOM, hdma2d->Init.Mode | hdma2d->Init.LineOffsetMode);
9000c37c:	687b      	ldr	r3, [r7, #4]
9000c37e:	681b      	ldr	r3, [r3, #0]
9000c380:	681a      	ldr	r2, [r3, #0]
9000c382:	4b20      	ldr	r3, [pc, #128]	; (9000c404 <HAL_DMA2D_Init+0xbc>)
9000c384:	4013      	ands	r3, r2
9000c386:	687a      	ldr	r2, [r7, #4]
9000c388:	6851      	ldr	r1, [r2, #4]
9000c38a:	687a      	ldr	r2, [r7, #4]
9000c38c:	69d2      	ldr	r2, [r2, #28]
9000c38e:	4311      	orrs	r1, r2
9000c390:	687a      	ldr	r2, [r7, #4]
9000c392:	6812      	ldr	r2, [r2, #0]
9000c394:	430b      	orrs	r3, r1
9000c396:	6013      	str	r3, [r2, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM | DMA2D_OPFCCR_SB,
9000c398:	687b      	ldr	r3, [r7, #4]
9000c39a:	681b      	ldr	r3, [r3, #0]
9000c39c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000c39e:	4b1a      	ldr	r3, [pc, #104]	; (9000c408 <HAL_DMA2D_Init+0xc0>)
9000c3a0:	4013      	ands	r3, r2
9000c3a2:	687a      	ldr	r2, [r7, #4]
9000c3a4:	6891      	ldr	r1, [r2, #8]
9000c3a6:	687a      	ldr	r2, [r7, #4]
9000c3a8:	6992      	ldr	r2, [r2, #24]
9000c3aa:	4311      	orrs	r1, r2
9000c3ac:	687a      	ldr	r2, [r7, #4]
9000c3ae:	6812      	ldr	r2, [r2, #0]
9000c3b0:	430b      	orrs	r3, r1
9000c3b2:	6353      	str	r3, [r2, #52]	; 0x34
             hdma2d->Init.ColorMode | hdma2d->Init.BytesSwap);

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
9000c3b4:	687b      	ldr	r3, [r7, #4]
9000c3b6:	681b      	ldr	r3, [r3, #0]
9000c3b8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
9000c3ba:	4b14      	ldr	r3, [pc, #80]	; (9000c40c <HAL_DMA2D_Init+0xc4>)
9000c3bc:	4013      	ands	r3, r2
9000c3be:	687a      	ldr	r2, [r7, #4]
9000c3c0:	68d1      	ldr	r1, [r2, #12]
9000c3c2:	687a      	ldr	r2, [r7, #4]
9000c3c4:	6812      	ldr	r2, [r2, #0]
9000c3c6:	430b      	orrs	r3, r1
9000c3c8:	6413      	str	r3, [r2, #64]	; 0x40
  /* DMA2D OPFCCR AI and RBS fields setting (Output Alpha Inversion)*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
9000c3ca:	687b      	ldr	r3, [r7, #4]
9000c3cc:	681b      	ldr	r3, [r3, #0]
9000c3ce:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000c3d0:	f423 1140 	bic.w	r1, r3, #3145728	; 0x300000
9000c3d4:	687b      	ldr	r3, [r7, #4]
9000c3d6:	691b      	ldr	r3, [r3, #16]
9000c3d8:	051a      	lsls	r2, r3, #20
9000c3da:	687b      	ldr	r3, [r7, #4]
9000c3dc:	695b      	ldr	r3, [r3, #20]
9000c3de:	055b      	lsls	r3, r3, #21
9000c3e0:	431a      	orrs	r2, r3
9000c3e2:	687b      	ldr	r3, [r7, #4]
9000c3e4:	681b      	ldr	r3, [r3, #0]
9000c3e6:	430a      	orrs	r2, r1
9000c3e8:	635a      	str	r2, [r3, #52]	; 0x34
             ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | \
              (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
9000c3ea:	687b      	ldr	r3, [r7, #4]
9000c3ec:	2200      	movs	r2, #0
9000c3ee:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
9000c3f0:	687b      	ldr	r3, [r7, #4]
9000c3f2:	2201      	movs	r2, #1
9000c3f4:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

  return HAL_OK;
9000c3f8:	2300      	movs	r3, #0
}
9000c3fa:	4618      	mov	r0, r3
9000c3fc:	3708      	adds	r7, #8
9000c3fe:	46bd      	mov	sp, r7
9000c400:	bd80      	pop	{r7, pc}
9000c402:	bf00      	nop
9000c404:	fff8ffbf 	.word	0xfff8ffbf
9000c408:	fffffef8 	.word	0xfffffef8
9000c40c:	ffff0000 	.word	0xffff0000

9000c410 <HAL_DMA2D_DeInit>:
  *                 the configuration information for the DMA2D.
  * @retval None
  */

HAL_StatusTypeDef HAL_DMA2D_DeInit(DMA2D_HandleTypeDef *hdma2d)
{
9000c410:	b580      	push	{r7, lr}
9000c412:	b082      	sub	sp, #8
9000c414:	af00      	add	r7, sp, #0
9000c416:	6078      	str	r0, [r7, #4]

  /* Check the DMA2D peripheral state */
  if (hdma2d == NULL)
9000c418:	687b      	ldr	r3, [r7, #4]
9000c41a:	2b00      	cmp	r3, #0
9000c41c:	d101      	bne.n	9000c422 <HAL_DMA2D_DeInit+0x12>
  {
    return HAL_ERROR;
9000c41e:	2301      	movs	r3, #1
9000c420:	e060      	b.n	9000c4e4 <HAL_DMA2D_DeInit+0xd4>
  }

  /* Before aborting any DMA2D transfer or CLUT loading, check
     first whether or not DMA2D clock is enabled */
  if (__HAL_RCC_DMA2D_IS_CLK_ENABLED())
9000c422:	4b32      	ldr	r3, [pc, #200]	; (9000c4ec <HAL_DMA2D_DeInit+0xdc>)
9000c424:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
9000c428:	f003 0310 	and.w	r3, r3, #16
9000c42c:	2b00      	cmp	r3, #0
9000c42e:	d02e      	beq.n	9000c48e <HAL_DMA2D_DeInit+0x7e>
  {
    /* Abort DMA2D transfer if any */
    if ((hdma2d->Instance->CR & DMA2D_CR_START) == DMA2D_CR_START)
9000c430:	687b      	ldr	r3, [r7, #4]
9000c432:	681b      	ldr	r3, [r3, #0]
9000c434:	681b      	ldr	r3, [r3, #0]
9000c436:	f003 0301 	and.w	r3, r3, #1
9000c43a:	2b01      	cmp	r3, #1
9000c43c:	d107      	bne.n	9000c44e <HAL_DMA2D_DeInit+0x3e>
    {
      if (HAL_DMA2D_Abort(hdma2d) != HAL_OK)
9000c43e:	6878      	ldr	r0, [r7, #4]
9000c440:	f000 f895 	bl	9000c56e <HAL_DMA2D_Abort>
9000c444:	4603      	mov	r3, r0
9000c446:	2b00      	cmp	r3, #0
9000c448:	d021      	beq.n	9000c48e <HAL_DMA2D_DeInit+0x7e>
      {
        /* Issue when aborting DMA2D transfer */
        return HAL_ERROR;
9000c44a:	2301      	movs	r3, #1
9000c44c:	e04a      	b.n	9000c4e4 <HAL_DMA2D_DeInit+0xd4>
      }
    }
    else
    {
      /* Abort background CLUT loading if any */
      if ((hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START) == DMA2D_BGPFCCR_START)
9000c44e:	687b      	ldr	r3, [r7, #4]
9000c450:	681b      	ldr	r3, [r3, #0]
9000c452:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9000c454:	f003 0320 	and.w	r3, r3, #32
9000c458:	2b20      	cmp	r3, #32
9000c45a:	d108      	bne.n	9000c46e <HAL_DMA2D_DeInit+0x5e>
      {
        if (HAL_DMA2D_CLUTLoading_Abort(hdma2d, 0U) != HAL_OK)
9000c45c:	2100      	movs	r1, #0
9000c45e:	6878      	ldr	r0, [r7, #4]
9000c460:	f000 f8cb 	bl	9000c5fa <HAL_DMA2D_CLUTLoading_Abort>
9000c464:	4603      	mov	r3, r0
9000c466:	2b00      	cmp	r3, #0
9000c468:	d011      	beq.n	9000c48e <HAL_DMA2D_DeInit+0x7e>
        {
          /* Issue when aborting background CLUT loading */
          return HAL_ERROR;
9000c46a:	2301      	movs	r3, #1
9000c46c:	e03a      	b.n	9000c4e4 <HAL_DMA2D_DeInit+0xd4>
        }
      }
      else
      {
        /* Abort foreground CLUT loading if any */
        if ((hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START) == DMA2D_FGPFCCR_START)
9000c46e:	687b      	ldr	r3, [r7, #4]
9000c470:	681b      	ldr	r3, [r3, #0]
9000c472:	69db      	ldr	r3, [r3, #28]
9000c474:	f003 0320 	and.w	r3, r3, #32
9000c478:	2b20      	cmp	r3, #32
9000c47a:	d108      	bne.n	9000c48e <HAL_DMA2D_DeInit+0x7e>
        {
          if (HAL_DMA2D_CLUTLoading_Abort(hdma2d, 1U) != HAL_OK)
9000c47c:	2101      	movs	r1, #1
9000c47e:	6878      	ldr	r0, [r7, #4]
9000c480:	f000 f8bb 	bl	9000c5fa <HAL_DMA2D_CLUTLoading_Abort>
9000c484:	4603      	mov	r3, r0
9000c486:	2b00      	cmp	r3, #0
9000c488:	d001      	beq.n	9000c48e <HAL_DMA2D_DeInit+0x7e>
          {
            /* Issue when aborting foreground CLUT loading */
            return HAL_ERROR;
9000c48a:	2301      	movs	r3, #1
9000c48c:	e02a      	b.n	9000c4e4 <HAL_DMA2D_DeInit+0xd4>
      }
    }
  }

  /* Reset DMA2D control registers*/
  hdma2d->Instance->CR       =    0U;
9000c48e:	687b      	ldr	r3, [r7, #4]
9000c490:	681b      	ldr	r3, [r3, #0]
9000c492:	2200      	movs	r2, #0
9000c494:	601a      	str	r2, [r3, #0]
  hdma2d->Instance->IFCR     = 0x3FU;
9000c496:	687b      	ldr	r3, [r7, #4]
9000c498:	681b      	ldr	r3, [r3, #0]
9000c49a:	223f      	movs	r2, #63	; 0x3f
9000c49c:	609a      	str	r2, [r3, #8]
  hdma2d->Instance->FGOR     =    0U;
9000c49e:	687b      	ldr	r3, [r7, #4]
9000c4a0:	681b      	ldr	r3, [r3, #0]
9000c4a2:	2200      	movs	r2, #0
9000c4a4:	611a      	str	r2, [r3, #16]
  hdma2d->Instance->BGOR     =    0U;
9000c4a6:	687b      	ldr	r3, [r7, #4]
9000c4a8:	681b      	ldr	r3, [r3, #0]
9000c4aa:	2200      	movs	r2, #0
9000c4ac:	619a      	str	r2, [r3, #24]
  hdma2d->Instance->FGPFCCR  =    0U;
9000c4ae:	687b      	ldr	r3, [r7, #4]
9000c4b0:	681b      	ldr	r3, [r3, #0]
9000c4b2:	2200      	movs	r2, #0
9000c4b4:	61da      	str	r2, [r3, #28]
  hdma2d->Instance->BGPFCCR  =    0U;
9000c4b6:	687b      	ldr	r3, [r7, #4]
9000c4b8:	681b      	ldr	r3, [r3, #0]
9000c4ba:	2200      	movs	r2, #0
9000c4bc:	625a      	str	r2, [r3, #36]	; 0x24
  hdma2d->Instance->OPFCCR   =    0U;
9000c4be:	687b      	ldr	r3, [r7, #4]
9000c4c0:	681b      	ldr	r3, [r3, #0]
9000c4c2:	2200      	movs	r2, #0
9000c4c4:	635a      	str	r2, [r3, #52]	; 0x34
  /* DeInit the low level hardware */
  hdma2d->MspDeInitCallback(hdma2d);

#else
  /* Carry on with de-initialization of low level hardware */
  HAL_DMA2D_MspDeInit(hdma2d);
9000c4c6:	6878      	ldr	r0, [r7, #4]
9000c4c8:	f000 f81c 	bl	9000c504 <HAL_DMA2D_MspDeInit>
#endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */

  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
9000c4cc:	687b      	ldr	r3, [r7, #4]
9000c4ce:	2200      	movs	r2, #0
9000c4d0:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_RESET;
9000c4d2:	687b      	ldr	r3, [r7, #4]
9000c4d4:	2200      	movs	r2, #0
9000c4d6:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

  /* Release Lock */
  __HAL_UNLOCK(hdma2d);
9000c4da:	687b      	ldr	r3, [r7, #4]
9000c4dc:	2200      	movs	r2, #0
9000c4de:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

  return HAL_OK;
9000c4e2:	2300      	movs	r3, #0
}
9000c4e4:	4618      	mov	r0, r3
9000c4e6:	3708      	adds	r7, #8
9000c4e8:	46bd      	mov	sp, r7
9000c4ea:	bd80      	pop	{r7, pc}
9000c4ec:	58024400 	.word	0x58024400

9000c4f0 <HAL_DMA2D_MspInit>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
9000c4f0:	b480      	push	{r7}
9000c4f2:	b083      	sub	sp, #12
9000c4f4:	af00      	add	r7, sp, #0
9000c4f6:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_MspInit can be implemented in the user file.
   */
}
9000c4f8:	bf00      	nop
9000c4fa:	370c      	adds	r7, #12
9000c4fc:	46bd      	mov	sp, r7
9000c4fe:	f85d 7b04 	ldr.w	r7, [sp], #4
9000c502:	4770      	bx	lr

9000c504 <HAL_DMA2D_MspDeInit>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_MspDeInit(DMA2D_HandleTypeDef *hdma2d)
{
9000c504:	b480      	push	{r7}
9000c506:	b083      	sub	sp, #12
9000c508:	af00      	add	r7, sp, #0
9000c50a:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_MspDeInit can be implemented in the user file.
   */
}
9000c50c:	bf00      	nop
9000c50e:	370c      	adds	r7, #12
9000c510:	46bd      	mov	sp, r7
9000c512:	f85d 7b04 	ldr.w	r7, [sp], #4
9000c516:	4770      	bx	lr

9000c518 <HAL_DMA2D_Start>:
  * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Start(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                                  uint32_t Height)
{
9000c518:	b580      	push	{r7, lr}
9000c51a:	b086      	sub	sp, #24
9000c51c:	af02      	add	r7, sp, #8
9000c51e:	60f8      	str	r0, [r7, #12]
9000c520:	60b9      	str	r1, [r7, #8]
9000c522:	607a      	str	r2, [r7, #4]
9000c524:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA2D_LINE(Height));
  assert_param(IS_DMA2D_PIXEL(Width));

  /* Process locked */
  __HAL_LOCK(hdma2d);
9000c526:	68fb      	ldr	r3, [r7, #12]
9000c528:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
9000c52c:	2b01      	cmp	r3, #1
9000c52e:	d101      	bne.n	9000c534 <HAL_DMA2D_Start+0x1c>
9000c530:	2302      	movs	r3, #2
9000c532:	e018      	b.n	9000c566 <HAL_DMA2D_Start+0x4e>
9000c534:	68fb      	ldr	r3, [r7, #12]
9000c536:	2201      	movs	r2, #1
9000c538:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
9000c53c:	68fb      	ldr	r3, [r7, #12]
9000c53e:	2202      	movs	r2, #2
9000c540:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

  /* Configure the source, destination address and the data size */
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
9000c544:	69bb      	ldr	r3, [r7, #24]
9000c546:	9300      	str	r3, [sp, #0]
9000c548:	683b      	ldr	r3, [r7, #0]
9000c54a:	687a      	ldr	r2, [r7, #4]
9000c54c:	68b9      	ldr	r1, [r7, #8]
9000c54e:	68f8      	ldr	r0, [r7, #12]
9000c550:	f000 fa40 	bl	9000c9d4 <DMA2D_SetConfig>

  /* Enable the Peripheral */
  __HAL_DMA2D_ENABLE(hdma2d);
9000c554:	68fb      	ldr	r3, [r7, #12]
9000c556:	681b      	ldr	r3, [r3, #0]
9000c558:	681a      	ldr	r2, [r3, #0]
9000c55a:	68fb      	ldr	r3, [r7, #12]
9000c55c:	681b      	ldr	r3, [r3, #0]
9000c55e:	f042 0201 	orr.w	r2, r2, #1
9000c562:	601a      	str	r2, [r3, #0]

  return HAL_OK;
9000c564:	2300      	movs	r3, #0
}
9000c566:	4618      	mov	r0, r3
9000c568:	3710      	adds	r7, #16
9000c56a:	46bd      	mov	sp, r7
9000c56c:	bd80      	pop	{r7, pc}

9000c56e <HAL_DMA2D_Abort>:
  * @param  hdma2d  pointer to a DMA2D_HandleTypeDef structure that contains
  *                  the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Abort(DMA2D_HandleTypeDef *hdma2d)
{
9000c56e:	b580      	push	{r7, lr}
9000c570:	b084      	sub	sp, #16
9000c572:	af00      	add	r7, sp, #0
9000c574:	6078      	str	r0, [r7, #4]

  /* Abort the DMA2D transfer */
  /* START bit is reset to make sure not to set it again, in the event the HW clears it
     between the register read and the register write by the CPU (writing 0 has no
     effect on START bitvalue) */
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_ABORT | DMA2D_CR_START, DMA2D_CR_ABORT);
9000c576:	687b      	ldr	r3, [r7, #4]
9000c578:	681b      	ldr	r3, [r3, #0]
9000c57a:	681b      	ldr	r3, [r3, #0]
9000c57c:	f023 0205 	bic.w	r2, r3, #5
9000c580:	687b      	ldr	r3, [r7, #4]
9000c582:	681b      	ldr	r3, [r3, #0]
9000c584:	f042 0204 	orr.w	r2, r2, #4
9000c588:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
9000c58a:	f7fc ff1b 	bl	900093c4 <HAL_GetTick>
9000c58e:	60f8      	str	r0, [r7, #12]

  /* Check if the DMA2D is effectively disabled */
  while ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
9000c590:	e017      	b.n	9000c5c2 <HAL_DMA2D_Abort+0x54>
  {
    if ((HAL_GetTick() - tickstart) > DMA2D_TIMEOUT_ABORT)
9000c592:	f7fc ff17 	bl	900093c4 <HAL_GetTick>
9000c596:	4602      	mov	r2, r0
9000c598:	68fb      	ldr	r3, [r7, #12]
9000c59a:	1ad3      	subs	r3, r2, r3
9000c59c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
9000c5a0:	d90f      	bls.n	9000c5c2 <HAL_DMA2D_Abort+0x54>
    {
      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
9000c5a2:	687b      	ldr	r3, [r7, #4]
9000c5a4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000c5a6:	f043 0220 	orr.w	r2, r3, #32
9000c5aa:	687b      	ldr	r3, [r7, #4]
9000c5ac:	665a      	str	r2, [r3, #100]	; 0x64

      /* Change the DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
9000c5ae:	687b      	ldr	r3, [r7, #4]
9000c5b0:	2203      	movs	r2, #3
9000c5b2:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
9000c5b6:	687b      	ldr	r3, [r7, #4]
9000c5b8:	2200      	movs	r2, #0
9000c5ba:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

      return HAL_TIMEOUT;
9000c5be:	2303      	movs	r3, #3
9000c5c0:	e017      	b.n	9000c5f2 <HAL_DMA2D_Abort+0x84>
  while ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
9000c5c2:	687b      	ldr	r3, [r7, #4]
9000c5c4:	681b      	ldr	r3, [r3, #0]
9000c5c6:	681b      	ldr	r3, [r3, #0]
9000c5c8:	f003 0301 	and.w	r3, r3, #1
9000c5cc:	2b00      	cmp	r3, #0
9000c5ce:	d1e0      	bne.n	9000c592 <HAL_DMA2D_Abort+0x24>
    }
  }

  /* Disable the Transfer Complete, Transfer Error and Configuration Error interrupts */
  __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC | DMA2D_IT_TE | DMA2D_IT_CE);
9000c5d0:	687b      	ldr	r3, [r7, #4]
9000c5d2:	681b      	ldr	r3, [r3, #0]
9000c5d4:	681a      	ldr	r2, [r3, #0]
9000c5d6:	687b      	ldr	r3, [r7, #4]
9000c5d8:	681b      	ldr	r3, [r3, #0]
9000c5da:	f422 520c 	bic.w	r2, r2, #8960	; 0x2300
9000c5de:	601a      	str	r2, [r3, #0]

  /* Change the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
9000c5e0:	687b      	ldr	r3, [r7, #4]
9000c5e2:	2201      	movs	r2, #1
9000c5e4:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

  /* Process Unlocked */
  __HAL_UNLOCK(hdma2d);
9000c5e8:	687b      	ldr	r3, [r7, #4]
9000c5ea:	2200      	movs	r2, #0
9000c5ec:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

  return HAL_OK;
9000c5f0:	2300      	movs	r3, #0
}
9000c5f2:	4618      	mov	r0, r3
9000c5f4:	3710      	adds	r7, #16
9000c5f6:	46bd      	mov	sp, r7
9000c5f8:	bd80      	pop	{r7, pc}

9000c5fa <HAL_DMA2D_CLUTLoading_Abort>:
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_CLUTLoading_Abort(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
{
9000c5fa:	b580      	push	{r7, lr}
9000c5fc:	b084      	sub	sp, #16
9000c5fe:	af00      	add	r7, sp, #0
9000c600:	6078      	str	r0, [r7, #4]
9000c602:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  const __IO uint32_t *reg =  &(hdma2d->Instance->BGPFCCR);  /* by default, point at background register */
9000c604:	687b      	ldr	r3, [r7, #4]
9000c606:	681b      	ldr	r3, [r3, #0]
9000c608:	3324      	adds	r3, #36	; 0x24
9000c60a:	60fb      	str	r3, [r7, #12]

  /* Abort the CLUT loading */
  SET_BIT(hdma2d->Instance->CR, DMA2D_CR_ABORT);
9000c60c:	687b      	ldr	r3, [r7, #4]
9000c60e:	681b      	ldr	r3, [r3, #0]
9000c610:	681a      	ldr	r2, [r3, #0]
9000c612:	687b      	ldr	r3, [r7, #4]
9000c614:	681b      	ldr	r3, [r3, #0]
9000c616:	f042 0204 	orr.w	r2, r2, #4
9000c61a:	601a      	str	r2, [r3, #0]

  /* If foreground CLUT loading is considered, update local variables */
  if (LayerIdx == DMA2D_FOREGROUND_LAYER)
9000c61c:	683b      	ldr	r3, [r7, #0]
9000c61e:	2b01      	cmp	r3, #1
9000c620:	d103      	bne.n	9000c62a <HAL_DMA2D_CLUTLoading_Abort+0x30>
  {
    reg  = &(hdma2d->Instance->FGPFCCR);
9000c622:	687b      	ldr	r3, [r7, #4]
9000c624:	681b      	ldr	r3, [r3, #0]
9000c626:	331c      	adds	r3, #28
9000c628:	60fb      	str	r3, [r7, #12]
  }


  /* Get tick */
  tickstart = HAL_GetTick();
9000c62a:	f7fc fecb 	bl	900093c4 <HAL_GetTick>
9000c62e:	60b8      	str	r0, [r7, #8]

  /* Check if the CLUT loading is aborted */
  while ((*reg & DMA2D_BGPFCCR_START) != 0U)
9000c630:	e017      	b.n	9000c662 <HAL_DMA2D_CLUTLoading_Abort+0x68>
  {
    if ((HAL_GetTick() - tickstart) > DMA2D_TIMEOUT_ABORT)
9000c632:	f7fc fec7 	bl	900093c4 <HAL_GetTick>
9000c636:	4602      	mov	r2, r0
9000c638:	68bb      	ldr	r3, [r7, #8]
9000c63a:	1ad3      	subs	r3, r2, r3
9000c63c:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
9000c640:	d90f      	bls.n	9000c662 <HAL_DMA2D_CLUTLoading_Abort+0x68>
    {
      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
9000c642:	687b      	ldr	r3, [r7, #4]
9000c644:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000c646:	f043 0220 	orr.w	r2, r3, #32
9000c64a:	687b      	ldr	r3, [r7, #4]
9000c64c:	665a      	str	r2, [r3, #100]	; 0x64

      /* Change the DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
9000c64e:	687b      	ldr	r3, [r7, #4]
9000c650:	2203      	movs	r2, #3
9000c652:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
9000c656:	687b      	ldr	r3, [r7, #4]
9000c658:	2200      	movs	r2, #0
9000c65a:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

      return HAL_TIMEOUT;
9000c65e:	2303      	movs	r3, #3
9000c660:	e016      	b.n	9000c690 <HAL_DMA2D_CLUTLoading_Abort+0x96>
  while ((*reg & DMA2D_BGPFCCR_START) != 0U)
9000c662:	68fb      	ldr	r3, [r7, #12]
9000c664:	681b      	ldr	r3, [r3, #0]
9000c666:	f003 0320 	and.w	r3, r3, #32
9000c66a:	2b00      	cmp	r3, #0
9000c66c:	d1e1      	bne.n	9000c632 <HAL_DMA2D_CLUTLoading_Abort+0x38>
    }
  }

  /* Disable the CLUT Transfer Complete, Transfer Error, Configuration Error and CLUT Access Error interrupts */
  __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CTC | DMA2D_IT_TE | DMA2D_IT_CE | DMA2D_IT_CAE);
9000c66e:	687b      	ldr	r3, [r7, #4]
9000c670:	681b      	ldr	r3, [r3, #0]
9000c672:	681a      	ldr	r2, [r3, #0]
9000c674:	687b      	ldr	r3, [r7, #4]
9000c676:	681b      	ldr	r3, [r3, #0]
9000c678:	f422 5264 	bic.w	r2, r2, #14592	; 0x3900
9000c67c:	601a      	str	r2, [r3, #0]

  /* Change the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
9000c67e:	687b      	ldr	r3, [r7, #4]
9000c680:	2201      	movs	r2, #1
9000c682:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

  /* Process Unlocked */
  __HAL_UNLOCK(hdma2d);
9000c686:	687b      	ldr	r3, [r7, #4]
9000c688:	2200      	movs	r2, #0
9000c68a:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

  return HAL_OK;
9000c68e:	2300      	movs	r3, #0
}
9000c690:	4618      	mov	r0, r3
9000c692:	3710      	adds	r7, #16
9000c694:	46bd      	mov	sp, r7
9000c696:	bd80      	pop	{r7, pc}

9000c698 <HAL_DMA2D_PollForTransfer>:
  *                 the configuration information for the DMA2D.
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
{
9000c698:	b580      	push	{r7, lr}
9000c69a:	b086      	sub	sp, #24
9000c69c:	af00      	add	r7, sp, #0
9000c69e:	6078      	str	r0, [r7, #4]
9000c6a0:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t layer_start;
  __IO uint32_t isrflags = 0x0U;
9000c6a2:	2300      	movs	r3, #0
9000c6a4:	60fb      	str	r3, [r7, #12]

  /* Polling for DMA2D transfer */
  if ((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
9000c6a6:	687b      	ldr	r3, [r7, #4]
9000c6a8:	681b      	ldr	r3, [r3, #0]
9000c6aa:	681b      	ldr	r3, [r3, #0]
9000c6ac:	f003 0301 	and.w	r3, r3, #1
9000c6b0:	2b00      	cmp	r3, #0
9000c6b2:	d056      	beq.n	9000c762 <HAL_DMA2D_PollForTransfer+0xca>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
9000c6b4:	f7fc fe86 	bl	900093c4 <HAL_GetTick>
9000c6b8:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
9000c6ba:	e04b      	b.n	9000c754 <HAL_DMA2D_PollForTransfer+0xbc>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
9000c6bc:	687b      	ldr	r3, [r7, #4]
9000c6be:	681b      	ldr	r3, [r3, #0]
9000c6c0:	685b      	ldr	r3, [r3, #4]
9000c6c2:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
9000c6c4:	68fb      	ldr	r3, [r7, #12]
9000c6c6:	f003 0321 	and.w	r3, r3, #33	; 0x21
9000c6ca:	2b00      	cmp	r3, #0
9000c6cc:	d023      	beq.n	9000c716 <HAL_DMA2D_PollForTransfer+0x7e>
      {
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
9000c6ce:	68fb      	ldr	r3, [r7, #12]
9000c6d0:	f003 0320 	and.w	r3, r3, #32
9000c6d4:	2b00      	cmp	r3, #0
9000c6d6:	d005      	beq.n	9000c6e4 <HAL_DMA2D_PollForTransfer+0x4c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
9000c6d8:	687b      	ldr	r3, [r7, #4]
9000c6da:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000c6dc:	f043 0202 	orr.w	r2, r3, #2
9000c6e0:	687b      	ldr	r3, [r7, #4]
9000c6e2:	665a      	str	r2, [r3, #100]	; 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
9000c6e4:	68fb      	ldr	r3, [r7, #12]
9000c6e6:	f003 0301 	and.w	r3, r3, #1
9000c6ea:	2b00      	cmp	r3, #0
9000c6ec:	d005      	beq.n	9000c6fa <HAL_DMA2D_PollForTransfer+0x62>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
9000c6ee:	687b      	ldr	r3, [r7, #4]
9000c6f0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000c6f2:	f043 0201 	orr.w	r2, r3, #1
9000c6f6:	687b      	ldr	r3, [r7, #4]
9000c6f8:	665a      	str	r2, [r3, #100]	; 0x64
        }
        /* Clear the transfer and configuration error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
9000c6fa:	687b      	ldr	r3, [r7, #4]
9000c6fc:	681b      	ldr	r3, [r3, #0]
9000c6fe:	2221      	movs	r2, #33	; 0x21
9000c700:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
9000c702:	687b      	ldr	r3, [r7, #4]
9000c704:	2204      	movs	r2, #4
9000c706:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
9000c70a:	687b      	ldr	r3, [r7, #4]
9000c70c:	2200      	movs	r2, #0
9000c70e:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

        return HAL_ERROR;
9000c712:	2301      	movs	r3, #1
9000c714:	e0a5      	b.n	9000c862 <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
9000c716:	683b      	ldr	r3, [r7, #0]
9000c718:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
9000c71c:	d01a      	beq.n	9000c754 <HAL_DMA2D_PollForTransfer+0xbc>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
9000c71e:	f7fc fe51 	bl	900093c4 <HAL_GetTick>
9000c722:	4602      	mov	r2, r0
9000c724:	697b      	ldr	r3, [r7, #20]
9000c726:	1ad3      	subs	r3, r2, r3
9000c728:	683a      	ldr	r2, [r7, #0]
9000c72a:	429a      	cmp	r2, r3
9000c72c:	d302      	bcc.n	9000c734 <HAL_DMA2D_PollForTransfer+0x9c>
9000c72e:	683b      	ldr	r3, [r7, #0]
9000c730:	2b00      	cmp	r3, #0
9000c732:	d10f      	bne.n	9000c754 <HAL_DMA2D_PollForTransfer+0xbc>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
9000c734:	687b      	ldr	r3, [r7, #4]
9000c736:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000c738:	f043 0220 	orr.w	r2, r3, #32
9000c73c:	687b      	ldr	r3, [r7, #4]
9000c73e:	665a      	str	r2, [r3, #100]	; 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
9000c740:	687b      	ldr	r3, [r7, #4]
9000c742:	2203      	movs	r2, #3
9000c744:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
9000c748:	687b      	ldr	r3, [r7, #4]
9000c74a:	2200      	movs	r2, #0
9000c74c:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

          return HAL_TIMEOUT;
9000c750:	2303      	movs	r3, #3
9000c752:	e086      	b.n	9000c862 <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
9000c754:	687b      	ldr	r3, [r7, #4]
9000c756:	681b      	ldr	r3, [r3, #0]
9000c758:	685b      	ldr	r3, [r3, #4]
9000c75a:	f003 0302 	and.w	r3, r3, #2
9000c75e:	2b00      	cmp	r3, #0
9000c760:	d0ac      	beq.n	9000c6bc <HAL_DMA2D_PollForTransfer+0x24>
        }
      }
    }
  }
  /* Polling for CLUT loading (foreground or background) */
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
9000c762:	687b      	ldr	r3, [r7, #4]
9000c764:	681b      	ldr	r3, [r3, #0]
9000c766:	69db      	ldr	r3, [r3, #28]
9000c768:	f003 0320 	and.w	r3, r3, #32
9000c76c:	613b      	str	r3, [r7, #16]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
9000c76e:	687b      	ldr	r3, [r7, #4]
9000c770:	681b      	ldr	r3, [r3, #0]
9000c772:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9000c774:	f003 0320 	and.w	r3, r3, #32
9000c778:	693a      	ldr	r2, [r7, #16]
9000c77a:	4313      	orrs	r3, r2
9000c77c:	613b      	str	r3, [r7, #16]
  if (layer_start != 0U)
9000c77e:	693b      	ldr	r3, [r7, #16]
9000c780:	2b00      	cmp	r3, #0
9000c782:	d061      	beq.n	9000c848 <HAL_DMA2D_PollForTransfer+0x1b0>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
9000c784:	f7fc fe1e 	bl	900093c4 <HAL_GetTick>
9000c788:	6178      	str	r0, [r7, #20]

    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
9000c78a:	e056      	b.n	9000c83a <HAL_DMA2D_PollForTransfer+0x1a2>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
9000c78c:	687b      	ldr	r3, [r7, #4]
9000c78e:	681b      	ldr	r3, [r3, #0]
9000c790:	685b      	ldr	r3, [r3, #4]
9000c792:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE)) != 0U)
9000c794:	68fb      	ldr	r3, [r7, #12]
9000c796:	f003 0329 	and.w	r3, r3, #41	; 0x29
9000c79a:	2b00      	cmp	r3, #0
9000c79c:	d02e      	beq.n	9000c7fc <HAL_DMA2D_PollForTransfer+0x164>
      {
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
9000c79e:	68fb      	ldr	r3, [r7, #12]
9000c7a0:	f003 0308 	and.w	r3, r3, #8
9000c7a4:	2b00      	cmp	r3, #0
9000c7a6:	d005      	beq.n	9000c7b4 <HAL_DMA2D_PollForTransfer+0x11c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
9000c7a8:	687b      	ldr	r3, [r7, #4]
9000c7aa:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000c7ac:	f043 0204 	orr.w	r2, r3, #4
9000c7b0:	687b      	ldr	r3, [r7, #4]
9000c7b2:	665a      	str	r2, [r3, #100]	; 0x64
        }
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
9000c7b4:	68fb      	ldr	r3, [r7, #12]
9000c7b6:	f003 0320 	and.w	r3, r3, #32
9000c7ba:	2b00      	cmp	r3, #0
9000c7bc:	d005      	beq.n	9000c7ca <HAL_DMA2D_PollForTransfer+0x132>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
9000c7be:	687b      	ldr	r3, [r7, #4]
9000c7c0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000c7c2:	f043 0202 	orr.w	r2, r3, #2
9000c7c6:	687b      	ldr	r3, [r7, #4]
9000c7c8:	665a      	str	r2, [r3, #100]	; 0x64
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
9000c7ca:	68fb      	ldr	r3, [r7, #12]
9000c7cc:	f003 0301 	and.w	r3, r3, #1
9000c7d0:	2b00      	cmp	r3, #0
9000c7d2:	d005      	beq.n	9000c7e0 <HAL_DMA2D_PollForTransfer+0x148>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
9000c7d4:	687b      	ldr	r3, [r7, #4]
9000c7d6:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000c7d8:	f043 0201 	orr.w	r2, r3, #1
9000c7dc:	687b      	ldr	r3, [r7, #4]
9000c7de:	665a      	str	r2, [r3, #100]	; 0x64
        }
        /* Clear the CLUT Access Error, Configuration Error and Transfer Error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
9000c7e0:	687b      	ldr	r3, [r7, #4]
9000c7e2:	681b      	ldr	r3, [r3, #0]
9000c7e4:	2229      	movs	r2, #41	; 0x29
9000c7e6:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
9000c7e8:	687b      	ldr	r3, [r7, #4]
9000c7ea:	2204      	movs	r2, #4
9000c7ec:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
9000c7f0:	687b      	ldr	r3, [r7, #4]
9000c7f2:	2200      	movs	r2, #0
9000c7f4:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

        return HAL_ERROR;
9000c7f8:	2301      	movs	r3, #1
9000c7fa:	e032      	b.n	9000c862 <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
9000c7fc:	683b      	ldr	r3, [r7, #0]
9000c7fe:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
9000c802:	d01a      	beq.n	9000c83a <HAL_DMA2D_PollForTransfer+0x1a2>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
9000c804:	f7fc fdde 	bl	900093c4 <HAL_GetTick>
9000c808:	4602      	mov	r2, r0
9000c80a:	697b      	ldr	r3, [r7, #20]
9000c80c:	1ad3      	subs	r3, r2, r3
9000c80e:	683a      	ldr	r2, [r7, #0]
9000c810:	429a      	cmp	r2, r3
9000c812:	d302      	bcc.n	9000c81a <HAL_DMA2D_PollForTransfer+0x182>
9000c814:	683b      	ldr	r3, [r7, #0]
9000c816:	2b00      	cmp	r3, #0
9000c818:	d10f      	bne.n	9000c83a <HAL_DMA2D_PollForTransfer+0x1a2>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
9000c81a:	687b      	ldr	r3, [r7, #4]
9000c81c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
9000c81e:	f043 0220 	orr.w	r2, r3, #32
9000c822:	687b      	ldr	r3, [r7, #4]
9000c824:	665a      	str	r2, [r3, #100]	; 0x64

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
9000c826:	687b      	ldr	r3, [r7, #4]
9000c828:	2203      	movs	r2, #3
9000c82a:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
9000c82e:	687b      	ldr	r3, [r7, #4]
9000c830:	2200      	movs	r2, #0
9000c832:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

          return HAL_TIMEOUT;
9000c836:	2303      	movs	r3, #3
9000c838:	e013      	b.n	9000c862 <HAL_DMA2D_PollForTransfer+0x1ca>
    while (__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
9000c83a:	687b      	ldr	r3, [r7, #4]
9000c83c:	681b      	ldr	r3, [r3, #0]
9000c83e:	685b      	ldr	r3, [r3, #4]
9000c840:	f003 0310 	and.w	r3, r3, #16
9000c844:	2b00      	cmp	r3, #0
9000c846:	d0a1      	beq.n	9000c78c <HAL_DMA2D_PollForTransfer+0xf4>
      }
    }
  }

  /* Clear the transfer complete and CLUT loading flags */
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC | DMA2D_FLAG_CTC);
9000c848:	687b      	ldr	r3, [r7, #4]
9000c84a:	681b      	ldr	r3, [r3, #0]
9000c84c:	2212      	movs	r2, #18
9000c84e:	609a      	str	r2, [r3, #8]

  /* Change DMA2D state */
  hdma2d->State = HAL_DMA2D_STATE_READY;
9000c850:	687b      	ldr	r3, [r7, #4]
9000c852:	2201      	movs	r2, #1
9000c854:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
9000c858:	687b      	ldr	r3, [r7, #4]
9000c85a:	2200      	movs	r2, #0
9000c85c:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

  return HAL_OK;
9000c860:	2300      	movs	r3, #0
}
9000c862:	4618      	mov	r0, r3
9000c864:	3718      	adds	r7, #24
9000c866:	46bd      	mov	sp, r7
9000c868:	bd80      	pop	{r7, pc}
	...

9000c86c <HAL_DMA2D_ConfigLayer>:
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
{
9000c86c:	b480      	push	{r7}
9000c86e:	b087      	sub	sp, #28
9000c870:	af00      	add	r7, sp, #0
9000c872:	6078      	str	r0, [r7, #4]
9000c874:	6039      	str	r1, [r7, #0]
  uint32_t regValue;

  /* Check the parameters */
  assert_param(IS_DMA2D_LAYER(LayerIdx));
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
  if (hdma2d->Init.Mode != DMA2D_R2M)
9000c876:	687b      	ldr	r3, [r7, #4]
9000c878:	685b      	ldr	r3, [r3, #4]
9000c87a:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
    }
  }
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));

  if ((LayerIdx == DMA2D_FOREGROUND_LAYER) && (hdma2d->LayerCfg[LayerIdx].InputColorMode == DMA2D_INPUT_YCBCR))
9000c87e:	683b      	ldr	r3, [r7, #0]
9000c880:	2b01      	cmp	r3, #1
9000c882:	d104      	bne.n	9000c88e <HAL_DMA2D_ConfigLayer+0x22>
9000c884:	683a      	ldr	r2, [r7, #0]
9000c886:	4613      	mov	r3, r2
9000c888:	00db      	lsls	r3, r3, #3
9000c88a:	1a9b      	subs	r3, r3, r2
9000c88c:	009b      	lsls	r3, r3, #2
  {
    assert_param(IS_DMA2D_CHROMA_SUB_SAMPLING(hdma2d->LayerCfg[LayerIdx].ChromaSubSampling));
  }

  /* Process locked */
  __HAL_LOCK(hdma2d);
9000c88e:	687b      	ldr	r3, [r7, #4]
9000c890:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
9000c894:	2b01      	cmp	r3, #1
9000c896:	d101      	bne.n	9000c89c <HAL_DMA2D_ConfigLayer+0x30>
9000c898:	2302      	movs	r3, #2
9000c89a:	e092      	b.n	9000c9c2 <HAL_DMA2D_ConfigLayer+0x156>
9000c89c:	687b      	ldr	r3, [r7, #4]
9000c89e:	2201      	movs	r2, #1
9000c8a0:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
9000c8a4:	687b      	ldr	r3, [r7, #4]
9000c8a6:	2202      	movs	r2, #2
9000c8a8:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

  pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
9000c8ac:	683a      	ldr	r2, [r7, #0]
9000c8ae:	4613      	mov	r3, r2
9000c8b0:	00db      	lsls	r3, r3, #3
9000c8b2:	1a9b      	subs	r3, r3, r2
9000c8b4:	009b      	lsls	r3, r3, #2
9000c8b6:	3328      	adds	r3, #40	; 0x28
9000c8b8:	687a      	ldr	r2, [r7, #4]
9000c8ba:	4413      	add	r3, r2
9000c8bc:	60fb      	str	r3, [r7, #12]

  /* Prepare the value to be written to the BGPFCCR or FGPFCCR register */
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
9000c8be:	68fb      	ldr	r3, [r7, #12]
9000c8c0:	685a      	ldr	r2, [r3, #4]
9000c8c2:	68fb      	ldr	r3, [r7, #12]
9000c8c4:	689b      	ldr	r3, [r3, #8]
9000c8c6:	041b      	lsls	r3, r3, #16
9000c8c8:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
9000c8ca:	68fb      	ldr	r3, [r7, #12]
9000c8cc:	691b      	ldr	r3, [r3, #16]
9000c8ce:	051b      	lsls	r3, r3, #20
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
9000c8d0:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
9000c8d2:	68fb      	ldr	r3, [r7, #12]
9000c8d4:	695b      	ldr	r3, [r3, #20]
9000c8d6:	055b      	lsls	r3, r3, #21
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
9000c8d8:	4313      	orrs	r3, r2
9000c8da:	613b      	str	r3, [r7, #16]
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
9000c8dc:	4b3c      	ldr	r3, [pc, #240]	; (9000c9d0 <HAL_DMA2D_ConfigLayer+0x164>)
9000c8de:	617b      	str	r3, [r7, #20]


  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
9000c8e0:	68fb      	ldr	r3, [r7, #12]
9000c8e2:	685b      	ldr	r3, [r3, #4]
9000c8e4:	2b0a      	cmp	r3, #10
9000c8e6:	d003      	beq.n	9000c8f0 <HAL_DMA2D_ConfigLayer+0x84>
9000c8e8:	68fb      	ldr	r3, [r7, #12]
9000c8ea:	685b      	ldr	r3, [r3, #4]
9000c8ec:	2b09      	cmp	r3, #9
9000c8ee:	d107      	bne.n	9000c900 <HAL_DMA2D_ConfigLayer+0x94>
  {
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
9000c8f0:	68fb      	ldr	r3, [r7, #12]
9000c8f2:	68db      	ldr	r3, [r3, #12]
9000c8f4:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
9000c8f8:	693a      	ldr	r2, [r7, #16]
9000c8fa:	4313      	orrs	r3, r2
9000c8fc:	613b      	str	r3, [r7, #16]
9000c8fe:	e005      	b.n	9000c90c <HAL_DMA2D_ConfigLayer+0xa0>
  }
  else
  {
    regValue |= (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
9000c900:	68fb      	ldr	r3, [r7, #12]
9000c902:	68db      	ldr	r3, [r3, #12]
9000c904:	061b      	lsls	r3, r3, #24
9000c906:	693a      	ldr	r2, [r7, #16]
9000c908:	4313      	orrs	r3, r2
9000c90a:	613b      	str	r3, [r7, #16]
  }

  /* Configure the background DMA2D layer */
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
9000c90c:	683b      	ldr	r3, [r7, #0]
9000c90e:	2b00      	cmp	r3, #0
9000c910:	d120      	bne.n	9000c954 <HAL_DMA2D_ConfigLayer+0xe8>
  {
    /* Write DMA2D BGPFCCR register */
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
9000c912:	687b      	ldr	r3, [r7, #4]
9000c914:	681b      	ldr	r3, [r3, #0]
9000c916:	6a5a      	ldr	r2, [r3, #36]	; 0x24
9000c918:	697b      	ldr	r3, [r7, #20]
9000c91a:	43db      	mvns	r3, r3
9000c91c:	ea02 0103 	and.w	r1, r2, r3
9000c920:	687b      	ldr	r3, [r7, #4]
9000c922:	681b      	ldr	r3, [r3, #0]
9000c924:	693a      	ldr	r2, [r7, #16]
9000c926:	430a      	orrs	r2, r1
9000c928:	625a      	str	r2, [r3, #36]	; 0x24

    /* DMA2D BGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
9000c92a:	687b      	ldr	r3, [r7, #4]
9000c92c:	681b      	ldr	r3, [r3, #0]
9000c92e:	68fa      	ldr	r2, [r7, #12]
9000c930:	6812      	ldr	r2, [r2, #0]
9000c932:	619a      	str	r2, [r3, #24]

    /* DMA2D BGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
9000c934:	68fb      	ldr	r3, [r7, #12]
9000c936:	685b      	ldr	r3, [r3, #4]
9000c938:	2b0a      	cmp	r3, #10
9000c93a:	d003      	beq.n	9000c944 <HAL_DMA2D_ConfigLayer+0xd8>
9000c93c:	68fb      	ldr	r3, [r7, #12]
9000c93e:	685b      	ldr	r3, [r3, #4]
9000c940:	2b09      	cmp	r3, #9
9000c942:	d135      	bne.n	9000c9b0 <HAL_DMA2D_ConfigLayer+0x144>
    {
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
9000c944:	68fb      	ldr	r3, [r7, #12]
9000c946:	68da      	ldr	r2, [r3, #12]
9000c948:	687b      	ldr	r3, [r7, #4]
9000c94a:	681b      	ldr	r3, [r3, #0]
9000c94c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
9000c950:	629a      	str	r2, [r3, #40]	; 0x28
9000c952:	e02d      	b.n	9000c9b0 <HAL_DMA2D_ConfigLayer+0x144>
  }
  /* Configure the foreground DMA2D layer */
  else
  {

    if (pLayerCfg->InputColorMode == DMA2D_INPUT_YCBCR)
9000c954:	68fb      	ldr	r3, [r7, #12]
9000c956:	685b      	ldr	r3, [r3, #4]
9000c958:	2b0b      	cmp	r3, #11
9000c95a:	d109      	bne.n	9000c970 <HAL_DMA2D_ConfigLayer+0x104>
    {
      regValue |= (pLayerCfg->ChromaSubSampling << DMA2D_FGPFCCR_CSS_Pos);
9000c95c:	68fb      	ldr	r3, [r7, #12]
9000c95e:	699b      	ldr	r3, [r3, #24]
9000c960:	049b      	lsls	r3, r3, #18
9000c962:	693a      	ldr	r2, [r7, #16]
9000c964:	4313      	orrs	r3, r2
9000c966:	613b      	str	r3, [r7, #16]
      regMask  |= DMA2D_FGPFCCR_CSS;
9000c968:	697b      	ldr	r3, [r7, #20]
9000c96a:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
9000c96e:	617b      	str	r3, [r7, #20]
    }

    /* Write DMA2D FGPFCCR register */
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
9000c970:	687b      	ldr	r3, [r7, #4]
9000c972:	681b      	ldr	r3, [r3, #0]
9000c974:	69da      	ldr	r2, [r3, #28]
9000c976:	697b      	ldr	r3, [r7, #20]
9000c978:	43db      	mvns	r3, r3
9000c97a:	ea02 0103 	and.w	r1, r2, r3
9000c97e:	687b      	ldr	r3, [r7, #4]
9000c980:	681b      	ldr	r3, [r3, #0]
9000c982:	693a      	ldr	r2, [r7, #16]
9000c984:	430a      	orrs	r2, r1
9000c986:	61da      	str	r2, [r3, #28]

    /* DMA2D FGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
9000c988:	687b      	ldr	r3, [r7, #4]
9000c98a:	681b      	ldr	r3, [r3, #0]
9000c98c:	68fa      	ldr	r2, [r7, #12]
9000c98e:	6812      	ldr	r2, [r2, #0]
9000c990:	611a      	str	r2, [r3, #16]

    /* DMA2D FGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
9000c992:	68fb      	ldr	r3, [r7, #12]
9000c994:	685b      	ldr	r3, [r3, #4]
9000c996:	2b0a      	cmp	r3, #10
9000c998:	d003      	beq.n	9000c9a2 <HAL_DMA2D_ConfigLayer+0x136>
9000c99a:	68fb      	ldr	r3, [r7, #12]
9000c99c:	685b      	ldr	r3, [r3, #4]
9000c99e:	2b09      	cmp	r3, #9
9000c9a0:	d106      	bne.n	9000c9b0 <HAL_DMA2D_ConfigLayer+0x144>
    {
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
9000c9a2:	68fb      	ldr	r3, [r7, #12]
9000c9a4:	68da      	ldr	r2, [r3, #12]
9000c9a6:	687b      	ldr	r3, [r7, #4]
9000c9a8:	681b      	ldr	r3, [r3, #0]
9000c9aa:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
9000c9ae:	621a      	str	r2, [r3, #32]
                                                                   DMA2D_FGCOLR_RED));
    }
  }
  /* Initialize the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
9000c9b0:	687b      	ldr	r3, [r7, #4]
9000c9b2:	2201      	movs	r2, #1
9000c9b4:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
9000c9b8:	687b      	ldr	r3, [r7, #4]
9000c9ba:	2200      	movs	r2, #0
9000c9bc:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60

  return HAL_OK;
9000c9c0:	2300      	movs	r3, #0
}
9000c9c2:	4618      	mov	r0, r3
9000c9c4:	371c      	adds	r7, #28
9000c9c6:	46bd      	mov	sp, r7
9000c9c8:	f85d 7b04 	ldr.w	r7, [sp], #4
9000c9cc:	4770      	bx	lr
9000c9ce:	bf00      	nop
9000c9d0:	ff33000f 	.word	0xff33000f

9000c9d4 <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
9000c9d4:	b480      	push	{r7}
9000c9d6:	b08b      	sub	sp, #44	; 0x2c
9000c9d8:	af00      	add	r7, sp, #0
9000c9da:	60f8      	str	r0, [r7, #12]
9000c9dc:	60b9      	str	r1, [r7, #8]
9000c9de:	607a      	str	r2, [r7, #4]
9000c9e0:	603b      	str	r3, [r7, #0]
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
9000c9e2:	68fb      	ldr	r3, [r7, #12]
9000c9e4:	681b      	ldr	r3, [r3, #0]
9000c9e6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000c9e8:	f003 4140 	and.w	r1, r3, #3221225472	; 0xc0000000
9000c9ec:	683b      	ldr	r3, [r7, #0]
9000c9ee:	041a      	lsls	r2, r3, #16
9000c9f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9000c9f2:	431a      	orrs	r2, r3
9000c9f4:	68fb      	ldr	r3, [r7, #12]
9000c9f6:	681b      	ldr	r3, [r3, #0]
9000c9f8:	430a      	orrs	r2, r1
9000c9fa:	645a      	str	r2, [r3, #68]	; 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
9000c9fc:	68fb      	ldr	r3, [r7, #12]
9000c9fe:	681b      	ldr	r3, [r3, #0]
9000ca00:	687a      	ldr	r2, [r7, #4]
9000ca02:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
9000ca04:	68fb      	ldr	r3, [r7, #12]
9000ca06:	685b      	ldr	r3, [r3, #4]
9000ca08:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
9000ca0c:	d174      	bne.n	9000caf8 <DMA2D_SetConfig+0x124>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
9000ca0e:	68bb      	ldr	r3, [r7, #8]
9000ca10:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
9000ca14:	623b      	str	r3, [r7, #32]
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
9000ca16:	68bb      	ldr	r3, [r7, #8]
9000ca18:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
9000ca1c:	61fb      	str	r3, [r7, #28]
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
9000ca1e:	68bb      	ldr	r3, [r7, #8]
9000ca20:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
9000ca24:	61bb      	str	r3, [r7, #24]
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
9000ca26:	68bb      	ldr	r3, [r7, #8]
9000ca28:	b2db      	uxtb	r3, r3
9000ca2a:	617b      	str	r3, [r7, #20]

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
9000ca2c:	68fb      	ldr	r3, [r7, #12]
9000ca2e:	689b      	ldr	r3, [r3, #8]
9000ca30:	2b00      	cmp	r3, #0
9000ca32:	d108      	bne.n	9000ca46 <DMA2D_SetConfig+0x72>
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
9000ca34:	69ba      	ldr	r2, [r7, #24]
9000ca36:	69fb      	ldr	r3, [r7, #28]
9000ca38:	431a      	orrs	r2, r3
9000ca3a:	6a3b      	ldr	r3, [r7, #32]
9000ca3c:	4313      	orrs	r3, r2
9000ca3e:	697a      	ldr	r2, [r7, #20]
9000ca40:	4313      	orrs	r3, r2
9000ca42:	627b      	str	r3, [r7, #36]	; 0x24
9000ca44:	e053      	b.n	9000caee <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
9000ca46:	68fb      	ldr	r3, [r7, #12]
9000ca48:	689b      	ldr	r3, [r3, #8]
9000ca4a:	2b01      	cmp	r3, #1
9000ca4c:	d106      	bne.n	9000ca5c <DMA2D_SetConfig+0x88>
    {
      tmp = (tmp3 | tmp2 | tmp4);
9000ca4e:	69ba      	ldr	r2, [r7, #24]
9000ca50:	69fb      	ldr	r3, [r7, #28]
9000ca52:	4313      	orrs	r3, r2
9000ca54:	697a      	ldr	r2, [r7, #20]
9000ca56:	4313      	orrs	r3, r2
9000ca58:	627b      	str	r3, [r7, #36]	; 0x24
9000ca5a:	e048      	b.n	9000caee <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
9000ca5c:	68fb      	ldr	r3, [r7, #12]
9000ca5e:	689b      	ldr	r3, [r3, #8]
9000ca60:	2b02      	cmp	r3, #2
9000ca62:	d111      	bne.n	9000ca88 <DMA2D_SetConfig+0xb4>
    {
      tmp2 = (tmp2 >> 19U);
9000ca64:	69fb      	ldr	r3, [r7, #28]
9000ca66:	0cdb      	lsrs	r3, r3, #19
9000ca68:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 10U);
9000ca6a:	69bb      	ldr	r3, [r7, #24]
9000ca6c:	0a9b      	lsrs	r3, r3, #10
9000ca6e:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
9000ca70:	697b      	ldr	r3, [r7, #20]
9000ca72:	08db      	lsrs	r3, r3, #3
9000ca74:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
9000ca76:	69bb      	ldr	r3, [r7, #24]
9000ca78:	015a      	lsls	r2, r3, #5
9000ca7a:	69fb      	ldr	r3, [r7, #28]
9000ca7c:	02db      	lsls	r3, r3, #11
9000ca7e:	4313      	orrs	r3, r2
9000ca80:	697a      	ldr	r2, [r7, #20]
9000ca82:	4313      	orrs	r3, r2
9000ca84:	627b      	str	r3, [r7, #36]	; 0x24
9000ca86:	e032      	b.n	9000caee <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
9000ca88:	68fb      	ldr	r3, [r7, #12]
9000ca8a:	689b      	ldr	r3, [r3, #8]
9000ca8c:	2b03      	cmp	r3, #3
9000ca8e:	d117      	bne.n	9000cac0 <DMA2D_SetConfig+0xec>
    {
      tmp1 = (tmp1 >> 31U);
9000ca90:	6a3b      	ldr	r3, [r7, #32]
9000ca92:	0fdb      	lsrs	r3, r3, #31
9000ca94:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 19U);
9000ca96:	69fb      	ldr	r3, [r7, #28]
9000ca98:	0cdb      	lsrs	r3, r3, #19
9000ca9a:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 11U);
9000ca9c:	69bb      	ldr	r3, [r7, #24]
9000ca9e:	0adb      	lsrs	r3, r3, #11
9000caa0:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
9000caa2:	697b      	ldr	r3, [r7, #20]
9000caa4:	08db      	lsrs	r3, r3, #3
9000caa6:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
9000caa8:	69bb      	ldr	r3, [r7, #24]
9000caaa:	015a      	lsls	r2, r3, #5
9000caac:	69fb      	ldr	r3, [r7, #28]
9000caae:	029b      	lsls	r3, r3, #10
9000cab0:	431a      	orrs	r2, r3
9000cab2:	6a3b      	ldr	r3, [r7, #32]
9000cab4:	03db      	lsls	r3, r3, #15
9000cab6:	4313      	orrs	r3, r2
9000cab8:	697a      	ldr	r2, [r7, #20]
9000caba:	4313      	orrs	r3, r2
9000cabc:	627b      	str	r3, [r7, #36]	; 0x24
9000cabe:	e016      	b.n	9000caee <DMA2D_SetConfig+0x11a>
    }
    else /* Dhdma2d->Init.ColorMode = DMA2D_OUTPUT_ARGB4444 */
    {
      tmp1 = (tmp1 >> 28U);
9000cac0:	6a3b      	ldr	r3, [r7, #32]
9000cac2:	0f1b      	lsrs	r3, r3, #28
9000cac4:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 20U);
9000cac6:	69fb      	ldr	r3, [r7, #28]
9000cac8:	0d1b      	lsrs	r3, r3, #20
9000caca:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 12U);
9000cacc:	69bb      	ldr	r3, [r7, #24]
9000cace:	0b1b      	lsrs	r3, r3, #12
9000cad0:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 4U);
9000cad2:	697b      	ldr	r3, [r7, #20]
9000cad4:	091b      	lsrs	r3, r3, #4
9000cad6:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
9000cad8:	69bb      	ldr	r3, [r7, #24]
9000cada:	011a      	lsls	r2, r3, #4
9000cadc:	69fb      	ldr	r3, [r7, #28]
9000cade:	021b      	lsls	r3, r3, #8
9000cae0:	431a      	orrs	r2, r3
9000cae2:	6a3b      	ldr	r3, [r7, #32]
9000cae4:	031b      	lsls	r3, r3, #12
9000cae6:	4313      	orrs	r3, r2
9000cae8:	697a      	ldr	r2, [r7, #20]
9000caea:	4313      	orrs	r3, r2
9000caec:	627b      	str	r3, [r7, #36]	; 0x24
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
9000caee:	68fb      	ldr	r3, [r7, #12]
9000caf0:	681b      	ldr	r3, [r3, #0]
9000caf2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
9000caf4:	639a      	str	r2, [r3, #56]	; 0x38
  else /* M2M, M2M_PFC,M2M_Blending or M2M_blending with fixed color BG DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
9000caf6:	e00d      	b.n	9000cb14 <DMA2D_SetConfig+0x140>
  else if (hdma2d->Init.Mode == DMA2D_M2M_BLEND_FG) /*M2M_blending with fixed color FG DMA2D Mode selected*/
9000caf8:	68fb      	ldr	r3, [r7, #12]
9000cafa:	685b      	ldr	r3, [r3, #4]
9000cafc:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
9000cb00:	d104      	bne.n	9000cb0c <DMA2D_SetConfig+0x138>
    WRITE_REG(hdma2d->Instance->BGMAR, pdata);
9000cb02:	68fb      	ldr	r3, [r7, #12]
9000cb04:	681b      	ldr	r3, [r3, #0]
9000cb06:	68ba      	ldr	r2, [r7, #8]
9000cb08:	615a      	str	r2, [r3, #20]
}
9000cb0a:	e003      	b.n	9000cb14 <DMA2D_SetConfig+0x140>
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
9000cb0c:	68fb      	ldr	r3, [r7, #12]
9000cb0e:	681b      	ldr	r3, [r3, #0]
9000cb10:	68ba      	ldr	r2, [r7, #8]
9000cb12:	60da      	str	r2, [r3, #12]
}
9000cb14:	bf00      	nop
9000cb16:	372c      	adds	r7, #44	; 0x2c
9000cb18:	46bd      	mov	sp, r7
9000cb1a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000cb1e:	4770      	bx	lr

9000cb20 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
9000cb20:	b480      	push	{r7}
9000cb22:	b087      	sub	sp, #28
9000cb24:	af00      	add	r7, sp, #0
9000cb26:	60f8      	str	r0, [r7, #12]
9000cb28:	460b      	mov	r3, r1
9000cb2a:	607a      	str	r2, [r7, #4]
9000cb2c:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
9000cb2e:	2300      	movs	r3, #0
9000cb30:	75fb      	strb	r3, [r7, #23]

  /* Check null pointer */
  if (hexti == NULL)
9000cb32:	68fb      	ldr	r3, [r7, #12]
9000cb34:	2b00      	cmp	r3, #0
9000cb36:	d101      	bne.n	9000cb3c <HAL_EXTI_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
9000cb38:	2301      	movs	r3, #1
9000cb3a:	e00a      	b.n	9000cb52 <HAL_EXTI_RegisterCallback+0x32>
  }

  switch (CallbackID)
9000cb3c:	7afb      	ldrb	r3, [r7, #11]
9000cb3e:	2b00      	cmp	r3, #0
9000cb40:	d103      	bne.n	9000cb4a <HAL_EXTI_RegisterCallback+0x2a>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
9000cb42:	68fb      	ldr	r3, [r7, #12]
9000cb44:	687a      	ldr	r2, [r7, #4]
9000cb46:	605a      	str	r2, [r3, #4]
      break;
9000cb48:	e002      	b.n	9000cb50 <HAL_EXTI_RegisterCallback+0x30>

    default:
      status = HAL_ERROR;
9000cb4a:	2301      	movs	r3, #1
9000cb4c:	75fb      	strb	r3, [r7, #23]
      break;
9000cb4e:	bf00      	nop
  }

  return status;
9000cb50:	7dfb      	ldrb	r3, [r7, #23]
}
9000cb52:	4618      	mov	r0, r3
9000cb54:	371c      	adds	r7, #28
9000cb56:	46bd      	mov	sp, r7
9000cb58:	f85d 7b04 	ldr.w	r7, [sp], #4
9000cb5c:	4770      	bx	lr

9000cb5e <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
9000cb5e:	b480      	push	{r7}
9000cb60:	b083      	sub	sp, #12
9000cb62:	af00      	add	r7, sp, #0
9000cb64:	6078      	str	r0, [r7, #4]
9000cb66:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
9000cb68:	687b      	ldr	r3, [r7, #4]
9000cb6a:	2b00      	cmp	r3, #0
9000cb6c:	d101      	bne.n	9000cb72 <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
9000cb6e:	2301      	movs	r3, #1
9000cb70:	e003      	b.n	9000cb7a <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
9000cb72:	687b      	ldr	r3, [r7, #4]
9000cb74:	683a      	ldr	r2, [r7, #0]
9000cb76:	601a      	str	r2, [r3, #0]

    return HAL_OK;
9000cb78:	2300      	movs	r3, #0
  }
}
9000cb7a:	4618      	mov	r0, r3
9000cb7c:	370c      	adds	r7, #12
9000cb7e:	46bd      	mov	sp, r7
9000cb80:	f85d 7b04 	ldr.w	r7, [sp], #4
9000cb84:	4770      	bx	lr
	...

9000cb88 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(EXTI_HandleTypeDef *hexti)
{
9000cb88:	b580      	push	{r7, lr}
9000cb8a:	b086      	sub	sp, #24
9000cb8c:	af00      	add	r7, sp, #0
9000cb8e:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
9000cb90:	687b      	ldr	r3, [r7, #4]
9000cb92:	681b      	ldr	r3, [r3, #0]
9000cb94:	0c1b      	lsrs	r3, r3, #16
9000cb96:	f003 0303 	and.w	r3, r3, #3
9000cb9a:	617b      	str	r3, [r7, #20]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
9000cb9c:	687b      	ldr	r3, [r7, #4]
9000cb9e:	681b      	ldr	r3, [r3, #0]
9000cba0:	f003 031f 	and.w	r3, r3, #31
9000cba4:	2201      	movs	r2, #1
9000cba6:	fa02 f303 	lsl.w	r3, r2, r3
9000cbaa:	613b      	str	r3, [r7, #16]
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
  }
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
9000cbac:	697b      	ldr	r3, [r7, #20]
9000cbae:	011a      	lsls	r2, r3, #4
9000cbb0:	4b0c      	ldr	r3, [pc, #48]	; (9000cbe4 <HAL_EXTI_IRQHandler+0x5c>)
9000cbb2:	4413      	add	r3, r2
9000cbb4:	60fb      	str	r3, [r7, #12]
#endif /* DUAL_CORE */

  /* Get pending bit  */
  regval = (*regaddr & maskline);
9000cbb6:	68fb      	ldr	r3, [r7, #12]
9000cbb8:	681b      	ldr	r3, [r3, #0]
9000cbba:	693a      	ldr	r2, [r7, #16]
9000cbbc:	4013      	ands	r3, r2
9000cbbe:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00U)
9000cbc0:	68bb      	ldr	r3, [r7, #8]
9000cbc2:	2b00      	cmp	r3, #0
9000cbc4:	d009      	beq.n	9000cbda <HAL_EXTI_IRQHandler+0x52>
  {
    /* Clear pending bit */
    *regaddr = maskline;
9000cbc6:	68fb      	ldr	r3, [r7, #12]
9000cbc8:	693a      	ldr	r2, [r7, #16]
9000cbca:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
9000cbcc:	687b      	ldr	r3, [r7, #4]
9000cbce:	685b      	ldr	r3, [r3, #4]
9000cbd0:	2b00      	cmp	r3, #0
9000cbd2:	d002      	beq.n	9000cbda <HAL_EXTI_IRQHandler+0x52>
    {
      hexti->PendingCallback();
9000cbd4:	687b      	ldr	r3, [r7, #4]
9000cbd6:	685b      	ldr	r3, [r3, #4]
9000cbd8:	4798      	blx	r3
    }
  }
}
9000cbda:	bf00      	nop
9000cbdc:	3718      	adds	r7, #24
9000cbde:	46bd      	mov	sp, r7
9000cbe0:	bd80      	pop	{r7, pc}
9000cbe2:	bf00      	nop
9000cbe4:	58000088 	.word	0x58000088

9000cbe8 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
9000cbe8:	b480      	push	{r7}
9000cbea:	b089      	sub	sp, #36	; 0x24
9000cbec:	af00      	add	r7, sp, #0
9000cbee:	6078      	str	r0, [r7, #4]
9000cbf0:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
9000cbf2:	2300      	movs	r3, #0
9000cbf4:	61fb      	str	r3, [r7, #28]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
9000cbf6:	4b89      	ldr	r3, [pc, #548]	; (9000ce1c <HAL_GPIO_Init+0x234>)
9000cbf8:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
9000cbfa:	e194      	b.n	9000cf26 <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
9000cbfc:	683b      	ldr	r3, [r7, #0]
9000cbfe:	681a      	ldr	r2, [r3, #0]
9000cc00:	2101      	movs	r1, #1
9000cc02:	69fb      	ldr	r3, [r7, #28]
9000cc04:	fa01 f303 	lsl.w	r3, r1, r3
9000cc08:	4013      	ands	r3, r2
9000cc0a:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
9000cc0c:	693b      	ldr	r3, [r7, #16]
9000cc0e:	2b00      	cmp	r3, #0
9000cc10:	f000 8186 	beq.w	9000cf20 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
9000cc14:	683b      	ldr	r3, [r7, #0]
9000cc16:	685b      	ldr	r3, [r3, #4]
9000cc18:	f003 0303 	and.w	r3, r3, #3
9000cc1c:	2b01      	cmp	r3, #1
9000cc1e:	d005      	beq.n	9000cc2c <HAL_GPIO_Init+0x44>
9000cc20:	683b      	ldr	r3, [r7, #0]
9000cc22:	685b      	ldr	r3, [r3, #4]
9000cc24:	f003 0303 	and.w	r3, r3, #3
9000cc28:	2b02      	cmp	r3, #2
9000cc2a:	d130      	bne.n	9000cc8e <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
9000cc2c:	687b      	ldr	r3, [r7, #4]
9000cc2e:	689b      	ldr	r3, [r3, #8]
9000cc30:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
9000cc32:	69fb      	ldr	r3, [r7, #28]
9000cc34:	005b      	lsls	r3, r3, #1
9000cc36:	2203      	movs	r2, #3
9000cc38:	fa02 f303 	lsl.w	r3, r2, r3
9000cc3c:	43db      	mvns	r3, r3
9000cc3e:	69ba      	ldr	r2, [r7, #24]
9000cc40:	4013      	ands	r3, r2
9000cc42:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
9000cc44:	683b      	ldr	r3, [r7, #0]
9000cc46:	68da      	ldr	r2, [r3, #12]
9000cc48:	69fb      	ldr	r3, [r7, #28]
9000cc4a:	005b      	lsls	r3, r3, #1
9000cc4c:	fa02 f303 	lsl.w	r3, r2, r3
9000cc50:	69ba      	ldr	r2, [r7, #24]
9000cc52:	4313      	orrs	r3, r2
9000cc54:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
9000cc56:	687b      	ldr	r3, [r7, #4]
9000cc58:	69ba      	ldr	r2, [r7, #24]
9000cc5a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
9000cc5c:	687b      	ldr	r3, [r7, #4]
9000cc5e:	685b      	ldr	r3, [r3, #4]
9000cc60:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
9000cc62:	2201      	movs	r2, #1
9000cc64:	69fb      	ldr	r3, [r7, #28]
9000cc66:	fa02 f303 	lsl.w	r3, r2, r3
9000cc6a:	43db      	mvns	r3, r3
9000cc6c:	69ba      	ldr	r2, [r7, #24]
9000cc6e:	4013      	ands	r3, r2
9000cc70:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
9000cc72:	683b      	ldr	r3, [r7, #0]
9000cc74:	685b      	ldr	r3, [r3, #4]
9000cc76:	091b      	lsrs	r3, r3, #4
9000cc78:	f003 0201 	and.w	r2, r3, #1
9000cc7c:	69fb      	ldr	r3, [r7, #28]
9000cc7e:	fa02 f303 	lsl.w	r3, r2, r3
9000cc82:	69ba      	ldr	r2, [r7, #24]
9000cc84:	4313      	orrs	r3, r2
9000cc86:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
9000cc88:	687b      	ldr	r3, [r7, #4]
9000cc8a:	69ba      	ldr	r2, [r7, #24]
9000cc8c:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
9000cc8e:	683b      	ldr	r3, [r7, #0]
9000cc90:	685b      	ldr	r3, [r3, #4]
9000cc92:	f003 0303 	and.w	r3, r3, #3
9000cc96:	2b03      	cmp	r3, #3
9000cc98:	d017      	beq.n	9000ccca <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
9000cc9a:	687b      	ldr	r3, [r7, #4]
9000cc9c:	68db      	ldr	r3, [r3, #12]
9000cc9e:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
9000cca0:	69fb      	ldr	r3, [r7, #28]
9000cca2:	005b      	lsls	r3, r3, #1
9000cca4:	2203      	movs	r2, #3
9000cca6:	fa02 f303 	lsl.w	r3, r2, r3
9000ccaa:	43db      	mvns	r3, r3
9000ccac:	69ba      	ldr	r2, [r7, #24]
9000ccae:	4013      	ands	r3, r2
9000ccb0:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
9000ccb2:	683b      	ldr	r3, [r7, #0]
9000ccb4:	689a      	ldr	r2, [r3, #8]
9000ccb6:	69fb      	ldr	r3, [r7, #28]
9000ccb8:	005b      	lsls	r3, r3, #1
9000ccba:	fa02 f303 	lsl.w	r3, r2, r3
9000ccbe:	69ba      	ldr	r2, [r7, #24]
9000ccc0:	4313      	orrs	r3, r2
9000ccc2:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
9000ccc4:	687b      	ldr	r3, [r7, #4]
9000ccc6:	69ba      	ldr	r2, [r7, #24]
9000ccc8:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
9000ccca:	683b      	ldr	r3, [r7, #0]
9000cccc:	685b      	ldr	r3, [r3, #4]
9000ccce:	f003 0303 	and.w	r3, r3, #3
9000ccd2:	2b02      	cmp	r3, #2
9000ccd4:	d123      	bne.n	9000cd1e <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
9000ccd6:	69fb      	ldr	r3, [r7, #28]
9000ccd8:	08da      	lsrs	r2, r3, #3
9000ccda:	687b      	ldr	r3, [r7, #4]
9000ccdc:	3208      	adds	r2, #8
9000ccde:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
9000cce2:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
9000cce4:	69fb      	ldr	r3, [r7, #28]
9000cce6:	f003 0307 	and.w	r3, r3, #7
9000ccea:	009b      	lsls	r3, r3, #2
9000ccec:	220f      	movs	r2, #15
9000ccee:	fa02 f303 	lsl.w	r3, r2, r3
9000ccf2:	43db      	mvns	r3, r3
9000ccf4:	69ba      	ldr	r2, [r7, #24]
9000ccf6:	4013      	ands	r3, r2
9000ccf8:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
9000ccfa:	683b      	ldr	r3, [r7, #0]
9000ccfc:	691a      	ldr	r2, [r3, #16]
9000ccfe:	69fb      	ldr	r3, [r7, #28]
9000cd00:	f003 0307 	and.w	r3, r3, #7
9000cd04:	009b      	lsls	r3, r3, #2
9000cd06:	fa02 f303 	lsl.w	r3, r2, r3
9000cd0a:	69ba      	ldr	r2, [r7, #24]
9000cd0c:	4313      	orrs	r3, r2
9000cd0e:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
9000cd10:	69fb      	ldr	r3, [r7, #28]
9000cd12:	08da      	lsrs	r2, r3, #3
9000cd14:	687b      	ldr	r3, [r7, #4]
9000cd16:	3208      	adds	r2, #8
9000cd18:	69b9      	ldr	r1, [r7, #24]
9000cd1a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
9000cd1e:	687b      	ldr	r3, [r7, #4]
9000cd20:	681b      	ldr	r3, [r3, #0]
9000cd22:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
9000cd24:	69fb      	ldr	r3, [r7, #28]
9000cd26:	005b      	lsls	r3, r3, #1
9000cd28:	2203      	movs	r2, #3
9000cd2a:	fa02 f303 	lsl.w	r3, r2, r3
9000cd2e:	43db      	mvns	r3, r3
9000cd30:	69ba      	ldr	r2, [r7, #24]
9000cd32:	4013      	ands	r3, r2
9000cd34:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
9000cd36:	683b      	ldr	r3, [r7, #0]
9000cd38:	685b      	ldr	r3, [r3, #4]
9000cd3a:	f003 0203 	and.w	r2, r3, #3
9000cd3e:	69fb      	ldr	r3, [r7, #28]
9000cd40:	005b      	lsls	r3, r3, #1
9000cd42:	fa02 f303 	lsl.w	r3, r2, r3
9000cd46:	69ba      	ldr	r2, [r7, #24]
9000cd48:	4313      	orrs	r3, r2
9000cd4a:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
9000cd4c:	687b      	ldr	r3, [r7, #4]
9000cd4e:	69ba      	ldr	r2, [r7, #24]
9000cd50:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
9000cd52:	683b      	ldr	r3, [r7, #0]
9000cd54:	685b      	ldr	r3, [r3, #4]
9000cd56:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
9000cd5a:	2b00      	cmp	r3, #0
9000cd5c:	f000 80e0 	beq.w	9000cf20 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
9000cd60:	4b2f      	ldr	r3, [pc, #188]	; (9000ce20 <HAL_GPIO_Init+0x238>)
9000cd62:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
9000cd66:	4a2e      	ldr	r2, [pc, #184]	; (9000ce20 <HAL_GPIO_Init+0x238>)
9000cd68:	f043 0302 	orr.w	r3, r3, #2
9000cd6c:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
9000cd70:	4b2b      	ldr	r3, [pc, #172]	; (9000ce20 <HAL_GPIO_Init+0x238>)
9000cd72:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
9000cd76:	f003 0302 	and.w	r3, r3, #2
9000cd7a:	60fb      	str	r3, [r7, #12]
9000cd7c:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
9000cd7e:	4a29      	ldr	r2, [pc, #164]	; (9000ce24 <HAL_GPIO_Init+0x23c>)
9000cd80:	69fb      	ldr	r3, [r7, #28]
9000cd82:	089b      	lsrs	r3, r3, #2
9000cd84:	3302      	adds	r3, #2
9000cd86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
9000cd8a:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
9000cd8c:	69fb      	ldr	r3, [r7, #28]
9000cd8e:	f003 0303 	and.w	r3, r3, #3
9000cd92:	009b      	lsls	r3, r3, #2
9000cd94:	220f      	movs	r2, #15
9000cd96:	fa02 f303 	lsl.w	r3, r2, r3
9000cd9a:	43db      	mvns	r3, r3
9000cd9c:	69ba      	ldr	r2, [r7, #24]
9000cd9e:	4013      	ands	r3, r2
9000cda0:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
9000cda2:	687b      	ldr	r3, [r7, #4]
9000cda4:	4a20      	ldr	r2, [pc, #128]	; (9000ce28 <HAL_GPIO_Init+0x240>)
9000cda6:	4293      	cmp	r3, r2
9000cda8:	d052      	beq.n	9000ce50 <HAL_GPIO_Init+0x268>
9000cdaa:	687b      	ldr	r3, [r7, #4]
9000cdac:	4a1f      	ldr	r2, [pc, #124]	; (9000ce2c <HAL_GPIO_Init+0x244>)
9000cdae:	4293      	cmp	r3, r2
9000cdb0:	d031      	beq.n	9000ce16 <HAL_GPIO_Init+0x22e>
9000cdb2:	687b      	ldr	r3, [r7, #4]
9000cdb4:	4a1e      	ldr	r2, [pc, #120]	; (9000ce30 <HAL_GPIO_Init+0x248>)
9000cdb6:	4293      	cmp	r3, r2
9000cdb8:	d02b      	beq.n	9000ce12 <HAL_GPIO_Init+0x22a>
9000cdba:	687b      	ldr	r3, [r7, #4]
9000cdbc:	4a1d      	ldr	r2, [pc, #116]	; (9000ce34 <HAL_GPIO_Init+0x24c>)
9000cdbe:	4293      	cmp	r3, r2
9000cdc0:	d025      	beq.n	9000ce0e <HAL_GPIO_Init+0x226>
9000cdc2:	687b      	ldr	r3, [r7, #4]
9000cdc4:	4a1c      	ldr	r2, [pc, #112]	; (9000ce38 <HAL_GPIO_Init+0x250>)
9000cdc6:	4293      	cmp	r3, r2
9000cdc8:	d01f      	beq.n	9000ce0a <HAL_GPIO_Init+0x222>
9000cdca:	687b      	ldr	r3, [r7, #4]
9000cdcc:	4a1b      	ldr	r2, [pc, #108]	; (9000ce3c <HAL_GPIO_Init+0x254>)
9000cdce:	4293      	cmp	r3, r2
9000cdd0:	d019      	beq.n	9000ce06 <HAL_GPIO_Init+0x21e>
9000cdd2:	687b      	ldr	r3, [r7, #4]
9000cdd4:	4a1a      	ldr	r2, [pc, #104]	; (9000ce40 <HAL_GPIO_Init+0x258>)
9000cdd6:	4293      	cmp	r3, r2
9000cdd8:	d013      	beq.n	9000ce02 <HAL_GPIO_Init+0x21a>
9000cdda:	687b      	ldr	r3, [r7, #4]
9000cddc:	4a19      	ldr	r2, [pc, #100]	; (9000ce44 <HAL_GPIO_Init+0x25c>)
9000cdde:	4293      	cmp	r3, r2
9000cde0:	d00d      	beq.n	9000cdfe <HAL_GPIO_Init+0x216>
9000cde2:	687b      	ldr	r3, [r7, #4]
9000cde4:	4a18      	ldr	r2, [pc, #96]	; (9000ce48 <HAL_GPIO_Init+0x260>)
9000cde6:	4293      	cmp	r3, r2
9000cde8:	d007      	beq.n	9000cdfa <HAL_GPIO_Init+0x212>
9000cdea:	687b      	ldr	r3, [r7, #4]
9000cdec:	4a17      	ldr	r2, [pc, #92]	; (9000ce4c <HAL_GPIO_Init+0x264>)
9000cdee:	4293      	cmp	r3, r2
9000cdf0:	d101      	bne.n	9000cdf6 <HAL_GPIO_Init+0x20e>
9000cdf2:	2309      	movs	r3, #9
9000cdf4:	e02d      	b.n	9000ce52 <HAL_GPIO_Init+0x26a>
9000cdf6:	230a      	movs	r3, #10
9000cdf8:	e02b      	b.n	9000ce52 <HAL_GPIO_Init+0x26a>
9000cdfa:	2308      	movs	r3, #8
9000cdfc:	e029      	b.n	9000ce52 <HAL_GPIO_Init+0x26a>
9000cdfe:	2307      	movs	r3, #7
9000ce00:	e027      	b.n	9000ce52 <HAL_GPIO_Init+0x26a>
9000ce02:	2306      	movs	r3, #6
9000ce04:	e025      	b.n	9000ce52 <HAL_GPIO_Init+0x26a>
9000ce06:	2305      	movs	r3, #5
9000ce08:	e023      	b.n	9000ce52 <HAL_GPIO_Init+0x26a>
9000ce0a:	2304      	movs	r3, #4
9000ce0c:	e021      	b.n	9000ce52 <HAL_GPIO_Init+0x26a>
9000ce0e:	2303      	movs	r3, #3
9000ce10:	e01f      	b.n	9000ce52 <HAL_GPIO_Init+0x26a>
9000ce12:	2302      	movs	r3, #2
9000ce14:	e01d      	b.n	9000ce52 <HAL_GPIO_Init+0x26a>
9000ce16:	2301      	movs	r3, #1
9000ce18:	e01b      	b.n	9000ce52 <HAL_GPIO_Init+0x26a>
9000ce1a:	bf00      	nop
9000ce1c:	58000080 	.word	0x58000080
9000ce20:	58024400 	.word	0x58024400
9000ce24:	58000400 	.word	0x58000400
9000ce28:	58020000 	.word	0x58020000
9000ce2c:	58020400 	.word	0x58020400
9000ce30:	58020800 	.word	0x58020800
9000ce34:	58020c00 	.word	0x58020c00
9000ce38:	58021000 	.word	0x58021000
9000ce3c:	58021400 	.word	0x58021400
9000ce40:	58021800 	.word	0x58021800
9000ce44:	58021c00 	.word	0x58021c00
9000ce48:	58022000 	.word	0x58022000
9000ce4c:	58022400 	.word	0x58022400
9000ce50:	2300      	movs	r3, #0
9000ce52:	69fa      	ldr	r2, [r7, #28]
9000ce54:	f002 0203 	and.w	r2, r2, #3
9000ce58:	0092      	lsls	r2, r2, #2
9000ce5a:	4093      	lsls	r3, r2
9000ce5c:	69ba      	ldr	r2, [r7, #24]
9000ce5e:	4313      	orrs	r3, r2
9000ce60:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
9000ce62:	4938      	ldr	r1, [pc, #224]	; (9000cf44 <HAL_GPIO_Init+0x35c>)
9000ce64:	69fb      	ldr	r3, [r7, #28]
9000ce66:	089b      	lsrs	r3, r3, #2
9000ce68:	3302      	adds	r3, #2
9000ce6a:	69ba      	ldr	r2, [r7, #24]
9000ce6c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
9000ce70:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
9000ce74:	681b      	ldr	r3, [r3, #0]
9000ce76:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
9000ce78:	693b      	ldr	r3, [r7, #16]
9000ce7a:	43db      	mvns	r3, r3
9000ce7c:	69ba      	ldr	r2, [r7, #24]
9000ce7e:	4013      	ands	r3, r2
9000ce80:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
9000ce82:	683b      	ldr	r3, [r7, #0]
9000ce84:	685b      	ldr	r3, [r3, #4]
9000ce86:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
9000ce8a:	2b00      	cmp	r3, #0
9000ce8c:	d003      	beq.n	9000ce96 <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
9000ce8e:	69ba      	ldr	r2, [r7, #24]
9000ce90:	693b      	ldr	r3, [r7, #16]
9000ce92:	4313      	orrs	r3, r2
9000ce94:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
9000ce96:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
9000ce9a:	69bb      	ldr	r3, [r7, #24]
9000ce9c:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
9000ce9e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
9000cea2:	685b      	ldr	r3, [r3, #4]
9000cea4:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
9000cea6:	693b      	ldr	r3, [r7, #16]
9000cea8:	43db      	mvns	r3, r3
9000ceaa:	69ba      	ldr	r2, [r7, #24]
9000ceac:	4013      	ands	r3, r2
9000ceae:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
9000ceb0:	683b      	ldr	r3, [r7, #0]
9000ceb2:	685b      	ldr	r3, [r3, #4]
9000ceb4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
9000ceb8:	2b00      	cmp	r3, #0
9000ceba:	d003      	beq.n	9000cec4 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
9000cebc:	69ba      	ldr	r2, [r7, #24]
9000cebe:	693b      	ldr	r3, [r7, #16]
9000cec0:	4313      	orrs	r3, r2
9000cec2:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
9000cec4:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
9000cec8:	69bb      	ldr	r3, [r7, #24]
9000ceca:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
9000cecc:	697b      	ldr	r3, [r7, #20]
9000cece:	685b      	ldr	r3, [r3, #4]
9000ced0:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
9000ced2:	693b      	ldr	r3, [r7, #16]
9000ced4:	43db      	mvns	r3, r3
9000ced6:	69ba      	ldr	r2, [r7, #24]
9000ced8:	4013      	ands	r3, r2
9000ceda:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
9000cedc:	683b      	ldr	r3, [r7, #0]
9000cede:	685b      	ldr	r3, [r3, #4]
9000cee0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
9000cee4:	2b00      	cmp	r3, #0
9000cee6:	d003      	beq.n	9000cef0 <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
9000cee8:	69ba      	ldr	r2, [r7, #24]
9000ceea:	693b      	ldr	r3, [r7, #16]
9000ceec:	4313      	orrs	r3, r2
9000ceee:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
9000cef0:	697b      	ldr	r3, [r7, #20]
9000cef2:	69ba      	ldr	r2, [r7, #24]
9000cef4:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
9000cef6:	697b      	ldr	r3, [r7, #20]
9000cef8:	681b      	ldr	r3, [r3, #0]
9000cefa:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
9000cefc:	693b      	ldr	r3, [r7, #16]
9000cefe:	43db      	mvns	r3, r3
9000cf00:	69ba      	ldr	r2, [r7, #24]
9000cf02:	4013      	ands	r3, r2
9000cf04:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
9000cf06:	683b      	ldr	r3, [r7, #0]
9000cf08:	685b      	ldr	r3, [r3, #4]
9000cf0a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
9000cf0e:	2b00      	cmp	r3, #0
9000cf10:	d003      	beq.n	9000cf1a <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
9000cf12:	69ba      	ldr	r2, [r7, #24]
9000cf14:	693b      	ldr	r3, [r7, #16]
9000cf16:	4313      	orrs	r3, r2
9000cf18:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
9000cf1a:	697b      	ldr	r3, [r7, #20]
9000cf1c:	69ba      	ldr	r2, [r7, #24]
9000cf1e:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
9000cf20:	69fb      	ldr	r3, [r7, #28]
9000cf22:	3301      	adds	r3, #1
9000cf24:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
9000cf26:	683b      	ldr	r3, [r7, #0]
9000cf28:	681a      	ldr	r2, [r3, #0]
9000cf2a:	69fb      	ldr	r3, [r7, #28]
9000cf2c:	fa22 f303 	lsr.w	r3, r2, r3
9000cf30:	2b00      	cmp	r3, #0
9000cf32:	f47f ae63 	bne.w	9000cbfc <HAL_GPIO_Init+0x14>
  }
}
9000cf36:	bf00      	nop
9000cf38:	bf00      	nop
9000cf3a:	3724      	adds	r7, #36	; 0x24
9000cf3c:	46bd      	mov	sp, r7
9000cf3e:	f85d 7b04 	ldr.w	r7, [sp], #4
9000cf42:	4770      	bx	lr
9000cf44:	58000400 	.word	0x58000400

9000cf48 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
9000cf48:	b480      	push	{r7}
9000cf4a:	b087      	sub	sp, #28
9000cf4c:	af00      	add	r7, sp, #0
9000cf4e:	6078      	str	r0, [r7, #4]
9000cf50:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
9000cf52:	2300      	movs	r3, #0
9000cf54:	617b      	str	r3, [r7, #20]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
9000cf56:	4b75      	ldr	r3, [pc, #468]	; (9000d12c <HAL_GPIO_DeInit+0x1e4>)
9000cf58:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0x00U)
9000cf5a:	e0d9      	b.n	9000d110 <HAL_GPIO_DeInit+0x1c8>
  {
    /* Get current io position */
    iocurrent = GPIO_Pin & (1UL << position) ;
9000cf5c:	2201      	movs	r2, #1
9000cf5e:	697b      	ldr	r3, [r7, #20]
9000cf60:	fa02 f303 	lsl.w	r3, r2, r3
9000cf64:	683a      	ldr	r2, [r7, #0]
9000cf66:	4013      	ands	r3, r2
9000cf68:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00U)
9000cf6a:	68fb      	ldr	r3, [r7, #12]
9000cf6c:	2b00      	cmp	r3, #0
9000cf6e:	f000 80cc 	beq.w	9000d10a <HAL_GPIO_DeInit+0x1c2>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
9000cf72:	4a6f      	ldr	r2, [pc, #444]	; (9000d130 <HAL_GPIO_DeInit+0x1e8>)
9000cf74:	697b      	ldr	r3, [r7, #20]
9000cf76:	089b      	lsrs	r3, r3, #2
9000cf78:	3302      	adds	r3, #2
9000cf7a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
9000cf7e:	60bb      	str	r3, [r7, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
9000cf80:	697b      	ldr	r3, [r7, #20]
9000cf82:	f003 0303 	and.w	r3, r3, #3
9000cf86:	009b      	lsls	r3, r3, #2
9000cf88:	220f      	movs	r2, #15
9000cf8a:	fa02 f303 	lsl.w	r3, r2, r3
9000cf8e:	68ba      	ldr	r2, [r7, #8]
9000cf90:	4013      	ands	r3, r2
9000cf92:	60bb      	str	r3, [r7, #8]
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
9000cf94:	687b      	ldr	r3, [r7, #4]
9000cf96:	4a67      	ldr	r2, [pc, #412]	; (9000d134 <HAL_GPIO_DeInit+0x1ec>)
9000cf98:	4293      	cmp	r3, r2
9000cf9a:	d037      	beq.n	9000d00c <HAL_GPIO_DeInit+0xc4>
9000cf9c:	687b      	ldr	r3, [r7, #4]
9000cf9e:	4a66      	ldr	r2, [pc, #408]	; (9000d138 <HAL_GPIO_DeInit+0x1f0>)
9000cfa0:	4293      	cmp	r3, r2
9000cfa2:	d031      	beq.n	9000d008 <HAL_GPIO_DeInit+0xc0>
9000cfa4:	687b      	ldr	r3, [r7, #4]
9000cfa6:	4a65      	ldr	r2, [pc, #404]	; (9000d13c <HAL_GPIO_DeInit+0x1f4>)
9000cfa8:	4293      	cmp	r3, r2
9000cfaa:	d02b      	beq.n	9000d004 <HAL_GPIO_DeInit+0xbc>
9000cfac:	687b      	ldr	r3, [r7, #4]
9000cfae:	4a64      	ldr	r2, [pc, #400]	; (9000d140 <HAL_GPIO_DeInit+0x1f8>)
9000cfb0:	4293      	cmp	r3, r2
9000cfb2:	d025      	beq.n	9000d000 <HAL_GPIO_DeInit+0xb8>
9000cfb4:	687b      	ldr	r3, [r7, #4]
9000cfb6:	4a63      	ldr	r2, [pc, #396]	; (9000d144 <HAL_GPIO_DeInit+0x1fc>)
9000cfb8:	4293      	cmp	r3, r2
9000cfba:	d01f      	beq.n	9000cffc <HAL_GPIO_DeInit+0xb4>
9000cfbc:	687b      	ldr	r3, [r7, #4]
9000cfbe:	4a62      	ldr	r2, [pc, #392]	; (9000d148 <HAL_GPIO_DeInit+0x200>)
9000cfc0:	4293      	cmp	r3, r2
9000cfc2:	d019      	beq.n	9000cff8 <HAL_GPIO_DeInit+0xb0>
9000cfc4:	687b      	ldr	r3, [r7, #4]
9000cfc6:	4a61      	ldr	r2, [pc, #388]	; (9000d14c <HAL_GPIO_DeInit+0x204>)
9000cfc8:	4293      	cmp	r3, r2
9000cfca:	d013      	beq.n	9000cff4 <HAL_GPIO_DeInit+0xac>
9000cfcc:	687b      	ldr	r3, [r7, #4]
9000cfce:	4a60      	ldr	r2, [pc, #384]	; (9000d150 <HAL_GPIO_DeInit+0x208>)
9000cfd0:	4293      	cmp	r3, r2
9000cfd2:	d00d      	beq.n	9000cff0 <HAL_GPIO_DeInit+0xa8>
9000cfd4:	687b      	ldr	r3, [r7, #4]
9000cfd6:	4a5f      	ldr	r2, [pc, #380]	; (9000d154 <HAL_GPIO_DeInit+0x20c>)
9000cfd8:	4293      	cmp	r3, r2
9000cfda:	d007      	beq.n	9000cfec <HAL_GPIO_DeInit+0xa4>
9000cfdc:	687b      	ldr	r3, [r7, #4]
9000cfde:	4a5e      	ldr	r2, [pc, #376]	; (9000d158 <HAL_GPIO_DeInit+0x210>)
9000cfe0:	4293      	cmp	r3, r2
9000cfe2:	d101      	bne.n	9000cfe8 <HAL_GPIO_DeInit+0xa0>
9000cfe4:	2309      	movs	r3, #9
9000cfe6:	e012      	b.n	9000d00e <HAL_GPIO_DeInit+0xc6>
9000cfe8:	230a      	movs	r3, #10
9000cfea:	e010      	b.n	9000d00e <HAL_GPIO_DeInit+0xc6>
9000cfec:	2308      	movs	r3, #8
9000cfee:	e00e      	b.n	9000d00e <HAL_GPIO_DeInit+0xc6>
9000cff0:	2307      	movs	r3, #7
9000cff2:	e00c      	b.n	9000d00e <HAL_GPIO_DeInit+0xc6>
9000cff4:	2306      	movs	r3, #6
9000cff6:	e00a      	b.n	9000d00e <HAL_GPIO_DeInit+0xc6>
9000cff8:	2305      	movs	r3, #5
9000cffa:	e008      	b.n	9000d00e <HAL_GPIO_DeInit+0xc6>
9000cffc:	2304      	movs	r3, #4
9000cffe:	e006      	b.n	9000d00e <HAL_GPIO_DeInit+0xc6>
9000d000:	2303      	movs	r3, #3
9000d002:	e004      	b.n	9000d00e <HAL_GPIO_DeInit+0xc6>
9000d004:	2302      	movs	r3, #2
9000d006:	e002      	b.n	9000d00e <HAL_GPIO_DeInit+0xc6>
9000d008:	2301      	movs	r3, #1
9000d00a:	e000      	b.n	9000d00e <HAL_GPIO_DeInit+0xc6>
9000d00c:	2300      	movs	r3, #0
9000d00e:	697a      	ldr	r2, [r7, #20]
9000d010:	f002 0203 	and.w	r2, r2, #3
9000d014:	0092      	lsls	r2, r2, #2
9000d016:	4093      	lsls	r3, r2
9000d018:	68ba      	ldr	r2, [r7, #8]
9000d01a:	429a      	cmp	r2, r3
9000d01c:	d136      	bne.n	9000d08c <HAL_GPIO_DeInit+0x144>
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
9000d01e:	693b      	ldr	r3, [r7, #16]
9000d020:	681a      	ldr	r2, [r3, #0]
9000d022:	68fb      	ldr	r3, [r7, #12]
9000d024:	43db      	mvns	r3, r3
9000d026:	401a      	ands	r2, r3
9000d028:	693b      	ldr	r3, [r7, #16]
9000d02a:	601a      	str	r2, [r3, #0]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
9000d02c:	693b      	ldr	r3, [r7, #16]
9000d02e:	685a      	ldr	r2, [r3, #4]
9000d030:	68fb      	ldr	r3, [r7, #12]
9000d032:	43db      	mvns	r3, r3
9000d034:	401a      	ands	r2, r3
9000d036:	693b      	ldr	r3, [r7, #16]
9000d038:	605a      	str	r2, [r3, #4]

        /* Clear Rising Falling edge configuration */
        EXTI->FTSR1 &= ~(iocurrent);
9000d03a:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
9000d03e:	685a      	ldr	r2, [r3, #4]
9000d040:	68fb      	ldr	r3, [r7, #12]
9000d042:	43db      	mvns	r3, r3
9000d044:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
9000d048:	4013      	ands	r3, r2
9000d04a:	604b      	str	r3, [r1, #4]
        EXTI->RTSR1 &= ~(iocurrent);
9000d04c:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
9000d050:	681a      	ldr	r2, [r3, #0]
9000d052:	68fb      	ldr	r3, [r7, #12]
9000d054:	43db      	mvns	r3, r3
9000d056:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
9000d05a:	4013      	ands	r3, r2
9000d05c:	600b      	str	r3, [r1, #0]

        tmp = 0x0FUL << (4U * (position & 0x03U));
9000d05e:	697b      	ldr	r3, [r7, #20]
9000d060:	f003 0303 	and.w	r3, r3, #3
9000d064:	009b      	lsls	r3, r3, #2
9000d066:	220f      	movs	r2, #15
9000d068:	fa02 f303 	lsl.w	r3, r2, r3
9000d06c:	60bb      	str	r3, [r7, #8]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
9000d06e:	4a30      	ldr	r2, [pc, #192]	; (9000d130 <HAL_GPIO_DeInit+0x1e8>)
9000d070:	697b      	ldr	r3, [r7, #20]
9000d072:	089b      	lsrs	r3, r3, #2
9000d074:	3302      	adds	r3, #2
9000d076:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
9000d07a:	68bb      	ldr	r3, [r7, #8]
9000d07c:	43da      	mvns	r2, r3
9000d07e:	482c      	ldr	r0, [pc, #176]	; (9000d130 <HAL_GPIO_DeInit+0x1e8>)
9000d080:	697b      	ldr	r3, [r7, #20]
9000d082:	089b      	lsrs	r3, r3, #2
9000d084:	400a      	ands	r2, r1
9000d086:	3302      	adds	r3, #2
9000d088:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
      }

      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO in Analog Mode */
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
9000d08c:	687b      	ldr	r3, [r7, #4]
9000d08e:	681a      	ldr	r2, [r3, #0]
9000d090:	697b      	ldr	r3, [r7, #20]
9000d092:	005b      	lsls	r3, r3, #1
9000d094:	2103      	movs	r1, #3
9000d096:	fa01 f303 	lsl.w	r3, r1, r3
9000d09a:	431a      	orrs	r2, r3
9000d09c:	687b      	ldr	r3, [r7, #4]
9000d09e:	601a      	str	r2, [r3, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
9000d0a0:	697b      	ldr	r3, [r7, #20]
9000d0a2:	08da      	lsrs	r2, r3, #3
9000d0a4:	687b      	ldr	r3, [r7, #4]
9000d0a6:	3208      	adds	r2, #8
9000d0a8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
9000d0ac:	697b      	ldr	r3, [r7, #20]
9000d0ae:	f003 0307 	and.w	r3, r3, #7
9000d0b2:	009b      	lsls	r3, r3, #2
9000d0b4:	220f      	movs	r2, #15
9000d0b6:	fa02 f303 	lsl.w	r3, r2, r3
9000d0ba:	43db      	mvns	r3, r3
9000d0bc:	697a      	ldr	r2, [r7, #20]
9000d0be:	08d2      	lsrs	r2, r2, #3
9000d0c0:	4019      	ands	r1, r3
9000d0c2:	687b      	ldr	r3, [r7, #4]
9000d0c4:	3208      	adds	r2, #8
9000d0c6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
9000d0ca:	687b      	ldr	r3, [r7, #4]
9000d0cc:	68da      	ldr	r2, [r3, #12]
9000d0ce:	697b      	ldr	r3, [r7, #20]
9000d0d0:	005b      	lsls	r3, r3, #1
9000d0d2:	2103      	movs	r1, #3
9000d0d4:	fa01 f303 	lsl.w	r3, r1, r3
9000d0d8:	43db      	mvns	r3, r3
9000d0da:	401a      	ands	r2, r3
9000d0dc:	687b      	ldr	r3, [r7, #4]
9000d0de:	60da      	str	r2, [r3, #12]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
9000d0e0:	687b      	ldr	r3, [r7, #4]
9000d0e2:	685a      	ldr	r2, [r3, #4]
9000d0e4:	2101      	movs	r1, #1
9000d0e6:	697b      	ldr	r3, [r7, #20]
9000d0e8:	fa01 f303 	lsl.w	r3, r1, r3
9000d0ec:	43db      	mvns	r3, r3
9000d0ee:	401a      	ands	r2, r3
9000d0f0:	687b      	ldr	r3, [r7, #4]
9000d0f2:	605a      	str	r2, [r3, #4]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
9000d0f4:	687b      	ldr	r3, [r7, #4]
9000d0f6:	689a      	ldr	r2, [r3, #8]
9000d0f8:	697b      	ldr	r3, [r7, #20]
9000d0fa:	005b      	lsls	r3, r3, #1
9000d0fc:	2103      	movs	r1, #3
9000d0fe:	fa01 f303 	lsl.w	r3, r1, r3
9000d102:	43db      	mvns	r3, r3
9000d104:	401a      	ands	r2, r3
9000d106:	687b      	ldr	r3, [r7, #4]
9000d108:	609a      	str	r2, [r3, #8]
    }

    position++;
9000d10a:	697b      	ldr	r3, [r7, #20]
9000d10c:	3301      	adds	r3, #1
9000d10e:	617b      	str	r3, [r7, #20]
  while ((GPIO_Pin >> position) != 0x00U)
9000d110:	683a      	ldr	r2, [r7, #0]
9000d112:	697b      	ldr	r3, [r7, #20]
9000d114:	fa22 f303 	lsr.w	r3, r2, r3
9000d118:	2b00      	cmp	r3, #0
9000d11a:	f47f af1f 	bne.w	9000cf5c <HAL_GPIO_DeInit+0x14>
  }
}
9000d11e:	bf00      	nop
9000d120:	bf00      	nop
9000d122:	371c      	adds	r7, #28
9000d124:	46bd      	mov	sp, r7
9000d126:	f85d 7b04 	ldr.w	r7, [sp], #4
9000d12a:	4770      	bx	lr
9000d12c:	58000080 	.word	0x58000080
9000d130:	58000400 	.word	0x58000400
9000d134:	58020000 	.word	0x58020000
9000d138:	58020400 	.word	0x58020400
9000d13c:	58020800 	.word	0x58020800
9000d140:	58020c00 	.word	0x58020c00
9000d144:	58021000 	.word	0x58021000
9000d148:	58021400 	.word	0x58021400
9000d14c:	58021800 	.word	0x58021800
9000d150:	58021c00 	.word	0x58021c00
9000d154:	58022000 	.word	0x58022000
9000d158:	58022400 	.word	0x58022400

9000d15c <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
9000d15c:	b480      	push	{r7}
9000d15e:	b085      	sub	sp, #20
9000d160:	af00      	add	r7, sp, #0
9000d162:	6078      	str	r0, [r7, #4]
9000d164:	460b      	mov	r3, r1
9000d166:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
9000d168:	687b      	ldr	r3, [r7, #4]
9000d16a:	691a      	ldr	r2, [r3, #16]
9000d16c:	887b      	ldrh	r3, [r7, #2]
9000d16e:	4013      	ands	r3, r2
9000d170:	2b00      	cmp	r3, #0
9000d172:	d002      	beq.n	9000d17a <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
9000d174:	2301      	movs	r3, #1
9000d176:	73fb      	strb	r3, [r7, #15]
9000d178:	e001      	b.n	9000d17e <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
9000d17a:	2300      	movs	r3, #0
9000d17c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
9000d17e:	7bfb      	ldrb	r3, [r7, #15]
}
9000d180:	4618      	mov	r0, r3
9000d182:	3714      	adds	r7, #20
9000d184:	46bd      	mov	sp, r7
9000d186:	f85d 7b04 	ldr.w	r7, [sp], #4
9000d18a:	4770      	bx	lr

9000d18c <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
9000d18c:	b480      	push	{r7}
9000d18e:	b083      	sub	sp, #12
9000d190:	af00      	add	r7, sp, #0
9000d192:	6078      	str	r0, [r7, #4]
9000d194:	460b      	mov	r3, r1
9000d196:	807b      	strh	r3, [r7, #2]
9000d198:	4613      	mov	r3, r2
9000d19a:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
9000d19c:	787b      	ldrb	r3, [r7, #1]
9000d19e:	2b00      	cmp	r3, #0
9000d1a0:	d003      	beq.n	9000d1aa <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
9000d1a2:	887a      	ldrh	r2, [r7, #2]
9000d1a4:	687b      	ldr	r3, [r7, #4]
9000d1a6:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
9000d1a8:	e003      	b.n	9000d1b2 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
9000d1aa:	887b      	ldrh	r3, [r7, #2]
9000d1ac:	041a      	lsls	r2, r3, #16
9000d1ae:	687b      	ldr	r3, [r7, #4]
9000d1b0:	619a      	str	r2, [r3, #24]
}
9000d1b2:	bf00      	nop
9000d1b4:	370c      	adds	r7, #12
9000d1b6:	46bd      	mov	sp, r7
9000d1b8:	f85d 7b04 	ldr.w	r7, [sp], #4
9000d1bc:	4770      	bx	lr
	...

9000d1c0 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
9000d1c0:	b580      	push	{r7, lr}
9000d1c2:	b082      	sub	sp, #8
9000d1c4:	af00      	add	r7, sp, #0
9000d1c6:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
9000d1c8:	687b      	ldr	r3, [r7, #4]
9000d1ca:	2b00      	cmp	r3, #0
9000d1cc:	d101      	bne.n	9000d1d2 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
9000d1ce:	2301      	movs	r3, #1
9000d1d0:	e07f      	b.n	9000d2d2 <HAL_I2C_Init+0x112>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
9000d1d2:	687b      	ldr	r3, [r7, #4]
9000d1d4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
9000d1d8:	b2db      	uxtb	r3, r3
9000d1da:	2b00      	cmp	r3, #0
9000d1dc:	d106      	bne.n	9000d1ec <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
9000d1de:	687b      	ldr	r3, [r7, #4]
9000d1e0:	2200      	movs	r2, #0
9000d1e2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
9000d1e6:	6878      	ldr	r0, [r7, #4]
9000d1e8:	f000 f8a9 	bl	9000d33e <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
9000d1ec:	687b      	ldr	r3, [r7, #4]
9000d1ee:	2224      	movs	r2, #36	; 0x24
9000d1f0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
9000d1f4:	687b      	ldr	r3, [r7, #4]
9000d1f6:	681b      	ldr	r3, [r3, #0]
9000d1f8:	681a      	ldr	r2, [r3, #0]
9000d1fa:	687b      	ldr	r3, [r7, #4]
9000d1fc:	681b      	ldr	r3, [r3, #0]
9000d1fe:	f022 0201 	bic.w	r2, r2, #1
9000d202:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
9000d204:	687b      	ldr	r3, [r7, #4]
9000d206:	685a      	ldr	r2, [r3, #4]
9000d208:	687b      	ldr	r3, [r7, #4]
9000d20a:	681b      	ldr	r3, [r3, #0]
9000d20c:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
9000d210:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
9000d212:	687b      	ldr	r3, [r7, #4]
9000d214:	681b      	ldr	r3, [r3, #0]
9000d216:	689a      	ldr	r2, [r3, #8]
9000d218:	687b      	ldr	r3, [r7, #4]
9000d21a:	681b      	ldr	r3, [r3, #0]
9000d21c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
9000d220:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
9000d222:	687b      	ldr	r3, [r7, #4]
9000d224:	68db      	ldr	r3, [r3, #12]
9000d226:	2b01      	cmp	r3, #1
9000d228:	d107      	bne.n	9000d23a <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
9000d22a:	687b      	ldr	r3, [r7, #4]
9000d22c:	689a      	ldr	r2, [r3, #8]
9000d22e:	687b      	ldr	r3, [r7, #4]
9000d230:	681b      	ldr	r3, [r3, #0]
9000d232:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
9000d236:	609a      	str	r2, [r3, #8]
9000d238:	e006      	b.n	9000d248 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
9000d23a:	687b      	ldr	r3, [r7, #4]
9000d23c:	689a      	ldr	r2, [r3, #8]
9000d23e:	687b      	ldr	r3, [r7, #4]
9000d240:	681b      	ldr	r3, [r3, #0]
9000d242:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
9000d246:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
9000d248:	687b      	ldr	r3, [r7, #4]
9000d24a:	68db      	ldr	r3, [r3, #12]
9000d24c:	2b02      	cmp	r3, #2
9000d24e:	d104      	bne.n	9000d25a <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
9000d250:	687b      	ldr	r3, [r7, #4]
9000d252:	681b      	ldr	r3, [r3, #0]
9000d254:	f44f 6200 	mov.w	r2, #2048	; 0x800
9000d258:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
9000d25a:	687b      	ldr	r3, [r7, #4]
9000d25c:	681b      	ldr	r3, [r3, #0]
9000d25e:	6859      	ldr	r1, [r3, #4]
9000d260:	687b      	ldr	r3, [r7, #4]
9000d262:	681a      	ldr	r2, [r3, #0]
9000d264:	4b1d      	ldr	r3, [pc, #116]	; (9000d2dc <HAL_I2C_Init+0x11c>)
9000d266:	430b      	orrs	r3, r1
9000d268:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
9000d26a:	687b      	ldr	r3, [r7, #4]
9000d26c:	681b      	ldr	r3, [r3, #0]
9000d26e:	68da      	ldr	r2, [r3, #12]
9000d270:	687b      	ldr	r3, [r7, #4]
9000d272:	681b      	ldr	r3, [r3, #0]
9000d274:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
9000d278:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
9000d27a:	687b      	ldr	r3, [r7, #4]
9000d27c:	691a      	ldr	r2, [r3, #16]
9000d27e:	687b      	ldr	r3, [r7, #4]
9000d280:	695b      	ldr	r3, [r3, #20]
9000d282:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
9000d286:	687b      	ldr	r3, [r7, #4]
9000d288:	699b      	ldr	r3, [r3, #24]
9000d28a:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
9000d28c:	687b      	ldr	r3, [r7, #4]
9000d28e:	681b      	ldr	r3, [r3, #0]
9000d290:	430a      	orrs	r2, r1
9000d292:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
9000d294:	687b      	ldr	r3, [r7, #4]
9000d296:	69d9      	ldr	r1, [r3, #28]
9000d298:	687b      	ldr	r3, [r7, #4]
9000d29a:	6a1a      	ldr	r2, [r3, #32]
9000d29c:	687b      	ldr	r3, [r7, #4]
9000d29e:	681b      	ldr	r3, [r3, #0]
9000d2a0:	430a      	orrs	r2, r1
9000d2a2:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
9000d2a4:	687b      	ldr	r3, [r7, #4]
9000d2a6:	681b      	ldr	r3, [r3, #0]
9000d2a8:	681a      	ldr	r2, [r3, #0]
9000d2aa:	687b      	ldr	r3, [r7, #4]
9000d2ac:	681b      	ldr	r3, [r3, #0]
9000d2ae:	f042 0201 	orr.w	r2, r2, #1
9000d2b2:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
9000d2b4:	687b      	ldr	r3, [r7, #4]
9000d2b6:	2200      	movs	r2, #0
9000d2b8:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
9000d2ba:	687b      	ldr	r3, [r7, #4]
9000d2bc:	2220      	movs	r2, #32
9000d2be:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
9000d2c2:	687b      	ldr	r3, [r7, #4]
9000d2c4:	2200      	movs	r2, #0
9000d2c6:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
9000d2c8:	687b      	ldr	r3, [r7, #4]
9000d2ca:	2200      	movs	r2, #0
9000d2cc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
9000d2d0:	2300      	movs	r3, #0
}
9000d2d2:	4618      	mov	r0, r3
9000d2d4:	3708      	adds	r7, #8
9000d2d6:	46bd      	mov	sp, r7
9000d2d8:	bd80      	pop	{r7, pc}
9000d2da:	bf00      	nop
9000d2dc:	02008000 	.word	0x02008000

9000d2e0 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
9000d2e0:	b580      	push	{r7, lr}
9000d2e2:	b082      	sub	sp, #8
9000d2e4:	af00      	add	r7, sp, #0
9000d2e6:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
9000d2e8:	687b      	ldr	r3, [r7, #4]
9000d2ea:	2b00      	cmp	r3, #0
9000d2ec:	d101      	bne.n	9000d2f2 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
9000d2ee:	2301      	movs	r3, #1
9000d2f0:	e021      	b.n	9000d336 <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
9000d2f2:	687b      	ldr	r3, [r7, #4]
9000d2f4:	2224      	movs	r2, #36	; 0x24
9000d2f6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
9000d2fa:	687b      	ldr	r3, [r7, #4]
9000d2fc:	681b      	ldr	r3, [r3, #0]
9000d2fe:	681a      	ldr	r2, [r3, #0]
9000d300:	687b      	ldr	r3, [r7, #4]
9000d302:	681b      	ldr	r3, [r3, #0]
9000d304:	f022 0201 	bic.w	r2, r2, #1
9000d308:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
9000d30a:	6878      	ldr	r0, [r7, #4]
9000d30c:	f000 f821 	bl	9000d352 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
9000d310:	687b      	ldr	r3, [r7, #4]
9000d312:	2200      	movs	r2, #0
9000d314:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
9000d316:	687b      	ldr	r3, [r7, #4]
9000d318:	2200      	movs	r2, #0
9000d31a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
9000d31e:	687b      	ldr	r3, [r7, #4]
9000d320:	2200      	movs	r2, #0
9000d322:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
9000d324:	687b      	ldr	r3, [r7, #4]
9000d326:	2200      	movs	r2, #0
9000d328:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
9000d32c:	687b      	ldr	r3, [r7, #4]
9000d32e:	2200      	movs	r2, #0
9000d330:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
9000d334:	2300      	movs	r3, #0
}
9000d336:	4618      	mov	r0, r3
9000d338:	3708      	adds	r7, #8
9000d33a:	46bd      	mov	sp, r7
9000d33c:	bd80      	pop	{r7, pc}

9000d33e <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
9000d33e:	b480      	push	{r7}
9000d340:	b083      	sub	sp, #12
9000d342:	af00      	add	r7, sp, #0
9000d344:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
9000d346:	bf00      	nop
9000d348:	370c      	adds	r7, #12
9000d34a:	46bd      	mov	sp, r7
9000d34c:	f85d 7b04 	ldr.w	r7, [sp], #4
9000d350:	4770      	bx	lr

9000d352 <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
9000d352:	b480      	push	{r7}
9000d354:	b083      	sub	sp, #12
9000d356:	af00      	add	r7, sp, #0
9000d358:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
9000d35a:	bf00      	nop
9000d35c:	370c      	adds	r7, #12
9000d35e:	46bd      	mov	sp, r7
9000d360:	f85d 7b04 	ldr.w	r7, [sp], #4
9000d364:	4770      	bx	lr
	...

9000d368 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
9000d368:	b580      	push	{r7, lr}
9000d36a:	b088      	sub	sp, #32
9000d36c:	af02      	add	r7, sp, #8
9000d36e:	60f8      	str	r0, [r7, #12]
9000d370:	4608      	mov	r0, r1
9000d372:	4611      	mov	r1, r2
9000d374:	461a      	mov	r2, r3
9000d376:	4603      	mov	r3, r0
9000d378:	817b      	strh	r3, [r7, #10]
9000d37a:	460b      	mov	r3, r1
9000d37c:	813b      	strh	r3, [r7, #8]
9000d37e:	4613      	mov	r3, r2
9000d380:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
9000d382:	68fb      	ldr	r3, [r7, #12]
9000d384:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
9000d388:	b2db      	uxtb	r3, r3
9000d38a:	2b20      	cmp	r3, #32
9000d38c:	f040 80f9 	bne.w	9000d582 <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
9000d390:	6a3b      	ldr	r3, [r7, #32]
9000d392:	2b00      	cmp	r3, #0
9000d394:	d002      	beq.n	9000d39c <HAL_I2C_Mem_Write+0x34>
9000d396:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
9000d398:	2b00      	cmp	r3, #0
9000d39a:	d105      	bne.n	9000d3a8 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
9000d39c:	68fb      	ldr	r3, [r7, #12]
9000d39e:	f44f 7200 	mov.w	r2, #512	; 0x200
9000d3a2:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
9000d3a4:	2301      	movs	r3, #1
9000d3a6:	e0ed      	b.n	9000d584 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
9000d3a8:	68fb      	ldr	r3, [r7, #12]
9000d3aa:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
9000d3ae:	2b01      	cmp	r3, #1
9000d3b0:	d101      	bne.n	9000d3b6 <HAL_I2C_Mem_Write+0x4e>
9000d3b2:	2302      	movs	r3, #2
9000d3b4:	e0e6      	b.n	9000d584 <HAL_I2C_Mem_Write+0x21c>
9000d3b6:	68fb      	ldr	r3, [r7, #12]
9000d3b8:	2201      	movs	r2, #1
9000d3ba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
9000d3be:	f7fc f801 	bl	900093c4 <HAL_GetTick>
9000d3c2:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
9000d3c4:	697b      	ldr	r3, [r7, #20]
9000d3c6:	9300      	str	r3, [sp, #0]
9000d3c8:	2319      	movs	r3, #25
9000d3ca:	2201      	movs	r2, #1
9000d3cc:	f44f 4100 	mov.w	r1, #32768	; 0x8000
9000d3d0:	68f8      	ldr	r0, [r7, #12]
9000d3d2:	f000 fadd 	bl	9000d990 <I2C_WaitOnFlagUntilTimeout>
9000d3d6:	4603      	mov	r3, r0
9000d3d8:	2b00      	cmp	r3, #0
9000d3da:	d001      	beq.n	9000d3e0 <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
9000d3dc:	2301      	movs	r3, #1
9000d3de:	e0d1      	b.n	9000d584 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
9000d3e0:	68fb      	ldr	r3, [r7, #12]
9000d3e2:	2221      	movs	r2, #33	; 0x21
9000d3e4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
9000d3e8:	68fb      	ldr	r3, [r7, #12]
9000d3ea:	2240      	movs	r2, #64	; 0x40
9000d3ec:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
9000d3f0:	68fb      	ldr	r3, [r7, #12]
9000d3f2:	2200      	movs	r2, #0
9000d3f4:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
9000d3f6:	68fb      	ldr	r3, [r7, #12]
9000d3f8:	6a3a      	ldr	r2, [r7, #32]
9000d3fa:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
9000d3fc:	68fb      	ldr	r3, [r7, #12]
9000d3fe:	8cba      	ldrh	r2, [r7, #36]	; 0x24
9000d400:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
9000d402:	68fb      	ldr	r3, [r7, #12]
9000d404:	2200      	movs	r2, #0
9000d406:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
9000d408:	88f8      	ldrh	r0, [r7, #6]
9000d40a:	893a      	ldrh	r2, [r7, #8]
9000d40c:	8979      	ldrh	r1, [r7, #10]
9000d40e:	697b      	ldr	r3, [r7, #20]
9000d410:	9301      	str	r3, [sp, #4]
9000d412:	6abb      	ldr	r3, [r7, #40]	; 0x28
9000d414:	9300      	str	r3, [sp, #0]
9000d416:	4603      	mov	r3, r0
9000d418:	68f8      	ldr	r0, [r7, #12]
9000d41a:	f000 f9ed 	bl	9000d7f8 <I2C_RequestMemoryWrite>
9000d41e:	4603      	mov	r3, r0
9000d420:	2b00      	cmp	r3, #0
9000d422:	d005      	beq.n	9000d430 <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
9000d424:	68fb      	ldr	r3, [r7, #12]
9000d426:	2200      	movs	r2, #0
9000d428:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
9000d42c:	2301      	movs	r3, #1
9000d42e:	e0a9      	b.n	9000d584 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
9000d430:	68fb      	ldr	r3, [r7, #12]
9000d432:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d434:	b29b      	uxth	r3, r3
9000d436:	2bff      	cmp	r3, #255	; 0xff
9000d438:	d90e      	bls.n	9000d458 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
9000d43a:	68fb      	ldr	r3, [r7, #12]
9000d43c:	22ff      	movs	r2, #255	; 0xff
9000d43e:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
9000d440:	68fb      	ldr	r3, [r7, #12]
9000d442:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d444:	b2da      	uxtb	r2, r3
9000d446:	8979      	ldrh	r1, [r7, #10]
9000d448:	2300      	movs	r3, #0
9000d44a:	9300      	str	r3, [sp, #0]
9000d44c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
9000d450:	68f8      	ldr	r0, [r7, #12]
9000d452:	f000 fc45 	bl	9000dce0 <I2C_TransferConfig>
9000d456:	e00f      	b.n	9000d478 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
9000d458:	68fb      	ldr	r3, [r7, #12]
9000d45a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d45c:	b29a      	uxth	r2, r3
9000d45e:	68fb      	ldr	r3, [r7, #12]
9000d460:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
9000d462:	68fb      	ldr	r3, [r7, #12]
9000d464:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d466:	b2da      	uxtb	r2, r3
9000d468:	8979      	ldrh	r1, [r7, #10]
9000d46a:	2300      	movs	r3, #0
9000d46c:	9300      	str	r3, [sp, #0]
9000d46e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
9000d472:	68f8      	ldr	r0, [r7, #12]
9000d474:	f000 fc34 	bl	9000dce0 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
9000d478:	697a      	ldr	r2, [r7, #20]
9000d47a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
9000d47c:	68f8      	ldr	r0, [r7, #12]
9000d47e:	f000 fac7 	bl	9000da10 <I2C_WaitOnTXISFlagUntilTimeout>
9000d482:	4603      	mov	r3, r0
9000d484:	2b00      	cmp	r3, #0
9000d486:	d001      	beq.n	9000d48c <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
9000d488:	2301      	movs	r3, #1
9000d48a:	e07b      	b.n	9000d584 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
9000d48c:	68fb      	ldr	r3, [r7, #12]
9000d48e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9000d490:	781a      	ldrb	r2, [r3, #0]
9000d492:	68fb      	ldr	r3, [r7, #12]
9000d494:	681b      	ldr	r3, [r3, #0]
9000d496:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
9000d498:	68fb      	ldr	r3, [r7, #12]
9000d49a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9000d49c:	1c5a      	adds	r2, r3, #1
9000d49e:	68fb      	ldr	r3, [r7, #12]
9000d4a0:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
9000d4a2:	68fb      	ldr	r3, [r7, #12]
9000d4a4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d4a6:	b29b      	uxth	r3, r3
9000d4a8:	3b01      	subs	r3, #1
9000d4aa:	b29a      	uxth	r2, r3
9000d4ac:	68fb      	ldr	r3, [r7, #12]
9000d4ae:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
9000d4b0:	68fb      	ldr	r3, [r7, #12]
9000d4b2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d4b4:	3b01      	subs	r3, #1
9000d4b6:	b29a      	uxth	r2, r3
9000d4b8:	68fb      	ldr	r3, [r7, #12]
9000d4ba:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
9000d4bc:	68fb      	ldr	r3, [r7, #12]
9000d4be:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d4c0:	b29b      	uxth	r3, r3
9000d4c2:	2b00      	cmp	r3, #0
9000d4c4:	d034      	beq.n	9000d530 <HAL_I2C_Mem_Write+0x1c8>
9000d4c6:	68fb      	ldr	r3, [r7, #12]
9000d4c8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d4ca:	2b00      	cmp	r3, #0
9000d4cc:	d130      	bne.n	9000d530 <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
9000d4ce:	697b      	ldr	r3, [r7, #20]
9000d4d0:	9300      	str	r3, [sp, #0]
9000d4d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
9000d4d4:	2200      	movs	r2, #0
9000d4d6:	2180      	movs	r1, #128	; 0x80
9000d4d8:	68f8      	ldr	r0, [r7, #12]
9000d4da:	f000 fa59 	bl	9000d990 <I2C_WaitOnFlagUntilTimeout>
9000d4de:	4603      	mov	r3, r0
9000d4e0:	2b00      	cmp	r3, #0
9000d4e2:	d001      	beq.n	9000d4e8 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
9000d4e4:	2301      	movs	r3, #1
9000d4e6:	e04d      	b.n	9000d584 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
9000d4e8:	68fb      	ldr	r3, [r7, #12]
9000d4ea:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d4ec:	b29b      	uxth	r3, r3
9000d4ee:	2bff      	cmp	r3, #255	; 0xff
9000d4f0:	d90e      	bls.n	9000d510 <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
9000d4f2:	68fb      	ldr	r3, [r7, #12]
9000d4f4:	22ff      	movs	r2, #255	; 0xff
9000d4f6:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
9000d4f8:	68fb      	ldr	r3, [r7, #12]
9000d4fa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d4fc:	b2da      	uxtb	r2, r3
9000d4fe:	8979      	ldrh	r1, [r7, #10]
9000d500:	2300      	movs	r3, #0
9000d502:	9300      	str	r3, [sp, #0]
9000d504:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
9000d508:	68f8      	ldr	r0, [r7, #12]
9000d50a:	f000 fbe9 	bl	9000dce0 <I2C_TransferConfig>
9000d50e:	e00f      	b.n	9000d530 <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
9000d510:	68fb      	ldr	r3, [r7, #12]
9000d512:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d514:	b29a      	uxth	r2, r3
9000d516:	68fb      	ldr	r3, [r7, #12]
9000d518:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
9000d51a:	68fb      	ldr	r3, [r7, #12]
9000d51c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d51e:	b2da      	uxtb	r2, r3
9000d520:	8979      	ldrh	r1, [r7, #10]
9000d522:	2300      	movs	r3, #0
9000d524:	9300      	str	r3, [sp, #0]
9000d526:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
9000d52a:	68f8      	ldr	r0, [r7, #12]
9000d52c:	f000 fbd8 	bl	9000dce0 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
9000d530:	68fb      	ldr	r3, [r7, #12]
9000d532:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d534:	b29b      	uxth	r3, r3
9000d536:	2b00      	cmp	r3, #0
9000d538:	d19e      	bne.n	9000d478 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
9000d53a:	697a      	ldr	r2, [r7, #20]
9000d53c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
9000d53e:	68f8      	ldr	r0, [r7, #12]
9000d540:	f000 faa6 	bl	9000da90 <I2C_WaitOnSTOPFlagUntilTimeout>
9000d544:	4603      	mov	r3, r0
9000d546:	2b00      	cmp	r3, #0
9000d548:	d001      	beq.n	9000d54e <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
9000d54a:	2301      	movs	r3, #1
9000d54c:	e01a      	b.n	9000d584 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
9000d54e:	68fb      	ldr	r3, [r7, #12]
9000d550:	681b      	ldr	r3, [r3, #0]
9000d552:	2220      	movs	r2, #32
9000d554:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
9000d556:	68fb      	ldr	r3, [r7, #12]
9000d558:	681b      	ldr	r3, [r3, #0]
9000d55a:	6859      	ldr	r1, [r3, #4]
9000d55c:	68fb      	ldr	r3, [r7, #12]
9000d55e:	681a      	ldr	r2, [r3, #0]
9000d560:	4b0a      	ldr	r3, [pc, #40]	; (9000d58c <HAL_I2C_Mem_Write+0x224>)
9000d562:	400b      	ands	r3, r1
9000d564:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
9000d566:	68fb      	ldr	r3, [r7, #12]
9000d568:	2220      	movs	r2, #32
9000d56a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
9000d56e:	68fb      	ldr	r3, [r7, #12]
9000d570:	2200      	movs	r2, #0
9000d572:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
9000d576:	68fb      	ldr	r3, [r7, #12]
9000d578:	2200      	movs	r2, #0
9000d57a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
9000d57e:	2300      	movs	r3, #0
9000d580:	e000      	b.n	9000d584 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
9000d582:	2302      	movs	r3, #2
  }
}
9000d584:	4618      	mov	r0, r3
9000d586:	3718      	adds	r7, #24
9000d588:	46bd      	mov	sp, r7
9000d58a:	bd80      	pop	{r7, pc}
9000d58c:	fe00e800 	.word	0xfe00e800

9000d590 <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
9000d590:	b580      	push	{r7, lr}
9000d592:	b088      	sub	sp, #32
9000d594:	af02      	add	r7, sp, #8
9000d596:	60f8      	str	r0, [r7, #12]
9000d598:	4608      	mov	r0, r1
9000d59a:	4611      	mov	r1, r2
9000d59c:	461a      	mov	r2, r3
9000d59e:	4603      	mov	r3, r0
9000d5a0:	817b      	strh	r3, [r7, #10]
9000d5a2:	460b      	mov	r3, r1
9000d5a4:	813b      	strh	r3, [r7, #8]
9000d5a6:	4613      	mov	r3, r2
9000d5a8:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
9000d5aa:	68fb      	ldr	r3, [r7, #12]
9000d5ac:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
9000d5b0:	b2db      	uxtb	r3, r3
9000d5b2:	2b20      	cmp	r3, #32
9000d5b4:	f040 80fd 	bne.w	9000d7b2 <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
9000d5b8:	6a3b      	ldr	r3, [r7, #32]
9000d5ba:	2b00      	cmp	r3, #0
9000d5bc:	d002      	beq.n	9000d5c4 <HAL_I2C_Mem_Read+0x34>
9000d5be:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
9000d5c0:	2b00      	cmp	r3, #0
9000d5c2:	d105      	bne.n	9000d5d0 <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
9000d5c4:	68fb      	ldr	r3, [r7, #12]
9000d5c6:	f44f 7200 	mov.w	r2, #512	; 0x200
9000d5ca:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
9000d5cc:	2301      	movs	r3, #1
9000d5ce:	e0f1      	b.n	9000d7b4 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
9000d5d0:	68fb      	ldr	r3, [r7, #12]
9000d5d2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
9000d5d6:	2b01      	cmp	r3, #1
9000d5d8:	d101      	bne.n	9000d5de <HAL_I2C_Mem_Read+0x4e>
9000d5da:	2302      	movs	r3, #2
9000d5dc:	e0ea      	b.n	9000d7b4 <HAL_I2C_Mem_Read+0x224>
9000d5de:	68fb      	ldr	r3, [r7, #12]
9000d5e0:	2201      	movs	r2, #1
9000d5e2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
9000d5e6:	f7fb feed 	bl	900093c4 <HAL_GetTick>
9000d5ea:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
9000d5ec:	697b      	ldr	r3, [r7, #20]
9000d5ee:	9300      	str	r3, [sp, #0]
9000d5f0:	2319      	movs	r3, #25
9000d5f2:	2201      	movs	r2, #1
9000d5f4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
9000d5f8:	68f8      	ldr	r0, [r7, #12]
9000d5fa:	f000 f9c9 	bl	9000d990 <I2C_WaitOnFlagUntilTimeout>
9000d5fe:	4603      	mov	r3, r0
9000d600:	2b00      	cmp	r3, #0
9000d602:	d001      	beq.n	9000d608 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
9000d604:	2301      	movs	r3, #1
9000d606:	e0d5      	b.n	9000d7b4 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
9000d608:	68fb      	ldr	r3, [r7, #12]
9000d60a:	2222      	movs	r2, #34	; 0x22
9000d60c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
9000d610:	68fb      	ldr	r3, [r7, #12]
9000d612:	2240      	movs	r2, #64	; 0x40
9000d614:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
9000d618:	68fb      	ldr	r3, [r7, #12]
9000d61a:	2200      	movs	r2, #0
9000d61c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
9000d61e:	68fb      	ldr	r3, [r7, #12]
9000d620:	6a3a      	ldr	r2, [r7, #32]
9000d622:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
9000d624:	68fb      	ldr	r3, [r7, #12]
9000d626:	8cba      	ldrh	r2, [r7, #36]	; 0x24
9000d628:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
9000d62a:	68fb      	ldr	r3, [r7, #12]
9000d62c:	2200      	movs	r2, #0
9000d62e:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
9000d630:	88f8      	ldrh	r0, [r7, #6]
9000d632:	893a      	ldrh	r2, [r7, #8]
9000d634:	8979      	ldrh	r1, [r7, #10]
9000d636:	697b      	ldr	r3, [r7, #20]
9000d638:	9301      	str	r3, [sp, #4]
9000d63a:	6abb      	ldr	r3, [r7, #40]	; 0x28
9000d63c:	9300      	str	r3, [sp, #0]
9000d63e:	4603      	mov	r3, r0
9000d640:	68f8      	ldr	r0, [r7, #12]
9000d642:	f000 f92d 	bl	9000d8a0 <I2C_RequestMemoryRead>
9000d646:	4603      	mov	r3, r0
9000d648:	2b00      	cmp	r3, #0
9000d64a:	d005      	beq.n	9000d658 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
9000d64c:	68fb      	ldr	r3, [r7, #12]
9000d64e:	2200      	movs	r2, #0
9000d650:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
9000d654:	2301      	movs	r3, #1
9000d656:	e0ad      	b.n	9000d7b4 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
9000d658:	68fb      	ldr	r3, [r7, #12]
9000d65a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d65c:	b29b      	uxth	r3, r3
9000d65e:	2bff      	cmp	r3, #255	; 0xff
9000d660:	d90e      	bls.n	9000d680 <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
9000d662:	68fb      	ldr	r3, [r7, #12]
9000d664:	22ff      	movs	r2, #255	; 0xff
9000d666:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
9000d668:	68fb      	ldr	r3, [r7, #12]
9000d66a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d66c:	b2da      	uxtb	r2, r3
9000d66e:	8979      	ldrh	r1, [r7, #10]
9000d670:	4b52      	ldr	r3, [pc, #328]	; (9000d7bc <HAL_I2C_Mem_Read+0x22c>)
9000d672:	9300      	str	r3, [sp, #0]
9000d674:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
9000d678:	68f8      	ldr	r0, [r7, #12]
9000d67a:	f000 fb31 	bl	9000dce0 <I2C_TransferConfig>
9000d67e:	e00f      	b.n	9000d6a0 <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
9000d680:	68fb      	ldr	r3, [r7, #12]
9000d682:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d684:	b29a      	uxth	r2, r3
9000d686:	68fb      	ldr	r3, [r7, #12]
9000d688:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
9000d68a:	68fb      	ldr	r3, [r7, #12]
9000d68c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d68e:	b2da      	uxtb	r2, r3
9000d690:	8979      	ldrh	r1, [r7, #10]
9000d692:	4b4a      	ldr	r3, [pc, #296]	; (9000d7bc <HAL_I2C_Mem_Read+0x22c>)
9000d694:	9300      	str	r3, [sp, #0]
9000d696:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
9000d69a:	68f8      	ldr	r0, [r7, #12]
9000d69c:	f000 fb20 	bl	9000dce0 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
9000d6a0:	697b      	ldr	r3, [r7, #20]
9000d6a2:	9300      	str	r3, [sp, #0]
9000d6a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
9000d6a6:	2200      	movs	r2, #0
9000d6a8:	2104      	movs	r1, #4
9000d6aa:	68f8      	ldr	r0, [r7, #12]
9000d6ac:	f000 f970 	bl	9000d990 <I2C_WaitOnFlagUntilTimeout>
9000d6b0:	4603      	mov	r3, r0
9000d6b2:	2b00      	cmp	r3, #0
9000d6b4:	d001      	beq.n	9000d6ba <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
9000d6b6:	2301      	movs	r3, #1
9000d6b8:	e07c      	b.n	9000d7b4 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
9000d6ba:	68fb      	ldr	r3, [r7, #12]
9000d6bc:	681b      	ldr	r3, [r3, #0]
9000d6be:	6a5a      	ldr	r2, [r3, #36]	; 0x24
9000d6c0:	68fb      	ldr	r3, [r7, #12]
9000d6c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9000d6c4:	b2d2      	uxtb	r2, r2
9000d6c6:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
9000d6c8:	68fb      	ldr	r3, [r7, #12]
9000d6ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9000d6cc:	1c5a      	adds	r2, r3, #1
9000d6ce:	68fb      	ldr	r3, [r7, #12]
9000d6d0:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
9000d6d2:	68fb      	ldr	r3, [r7, #12]
9000d6d4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d6d6:	3b01      	subs	r3, #1
9000d6d8:	b29a      	uxth	r2, r3
9000d6da:	68fb      	ldr	r3, [r7, #12]
9000d6dc:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
9000d6de:	68fb      	ldr	r3, [r7, #12]
9000d6e0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d6e2:	b29b      	uxth	r3, r3
9000d6e4:	3b01      	subs	r3, #1
9000d6e6:	b29a      	uxth	r2, r3
9000d6e8:	68fb      	ldr	r3, [r7, #12]
9000d6ea:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
9000d6ec:	68fb      	ldr	r3, [r7, #12]
9000d6ee:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d6f0:	b29b      	uxth	r3, r3
9000d6f2:	2b00      	cmp	r3, #0
9000d6f4:	d034      	beq.n	9000d760 <HAL_I2C_Mem_Read+0x1d0>
9000d6f6:	68fb      	ldr	r3, [r7, #12]
9000d6f8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d6fa:	2b00      	cmp	r3, #0
9000d6fc:	d130      	bne.n	9000d760 <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
9000d6fe:	697b      	ldr	r3, [r7, #20]
9000d700:	9300      	str	r3, [sp, #0]
9000d702:	6abb      	ldr	r3, [r7, #40]	; 0x28
9000d704:	2200      	movs	r2, #0
9000d706:	2180      	movs	r1, #128	; 0x80
9000d708:	68f8      	ldr	r0, [r7, #12]
9000d70a:	f000 f941 	bl	9000d990 <I2C_WaitOnFlagUntilTimeout>
9000d70e:	4603      	mov	r3, r0
9000d710:	2b00      	cmp	r3, #0
9000d712:	d001      	beq.n	9000d718 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
9000d714:	2301      	movs	r3, #1
9000d716:	e04d      	b.n	9000d7b4 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
9000d718:	68fb      	ldr	r3, [r7, #12]
9000d71a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d71c:	b29b      	uxth	r3, r3
9000d71e:	2bff      	cmp	r3, #255	; 0xff
9000d720:	d90e      	bls.n	9000d740 <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
9000d722:	68fb      	ldr	r3, [r7, #12]
9000d724:	22ff      	movs	r2, #255	; 0xff
9000d726:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
9000d728:	68fb      	ldr	r3, [r7, #12]
9000d72a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d72c:	b2da      	uxtb	r2, r3
9000d72e:	8979      	ldrh	r1, [r7, #10]
9000d730:	2300      	movs	r3, #0
9000d732:	9300      	str	r3, [sp, #0]
9000d734:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
9000d738:	68f8      	ldr	r0, [r7, #12]
9000d73a:	f000 fad1 	bl	9000dce0 <I2C_TransferConfig>
9000d73e:	e00f      	b.n	9000d760 <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
9000d740:	68fb      	ldr	r3, [r7, #12]
9000d742:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d744:	b29a      	uxth	r2, r3
9000d746:	68fb      	ldr	r3, [r7, #12]
9000d748:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
9000d74a:	68fb      	ldr	r3, [r7, #12]
9000d74c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
9000d74e:	b2da      	uxtb	r2, r3
9000d750:	8979      	ldrh	r1, [r7, #10]
9000d752:	2300      	movs	r3, #0
9000d754:	9300      	str	r3, [sp, #0]
9000d756:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
9000d75a:	68f8      	ldr	r0, [r7, #12]
9000d75c:	f000 fac0 	bl	9000dce0 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
9000d760:	68fb      	ldr	r3, [r7, #12]
9000d762:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
9000d764:	b29b      	uxth	r3, r3
9000d766:	2b00      	cmp	r3, #0
9000d768:	d19a      	bne.n	9000d6a0 <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
9000d76a:	697a      	ldr	r2, [r7, #20]
9000d76c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
9000d76e:	68f8      	ldr	r0, [r7, #12]
9000d770:	f000 f98e 	bl	9000da90 <I2C_WaitOnSTOPFlagUntilTimeout>
9000d774:	4603      	mov	r3, r0
9000d776:	2b00      	cmp	r3, #0
9000d778:	d001      	beq.n	9000d77e <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
9000d77a:	2301      	movs	r3, #1
9000d77c:	e01a      	b.n	9000d7b4 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
9000d77e:	68fb      	ldr	r3, [r7, #12]
9000d780:	681b      	ldr	r3, [r3, #0]
9000d782:	2220      	movs	r2, #32
9000d784:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
9000d786:	68fb      	ldr	r3, [r7, #12]
9000d788:	681b      	ldr	r3, [r3, #0]
9000d78a:	6859      	ldr	r1, [r3, #4]
9000d78c:	68fb      	ldr	r3, [r7, #12]
9000d78e:	681a      	ldr	r2, [r3, #0]
9000d790:	4b0b      	ldr	r3, [pc, #44]	; (9000d7c0 <HAL_I2C_Mem_Read+0x230>)
9000d792:	400b      	ands	r3, r1
9000d794:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
9000d796:	68fb      	ldr	r3, [r7, #12]
9000d798:	2220      	movs	r2, #32
9000d79a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
9000d79e:	68fb      	ldr	r3, [r7, #12]
9000d7a0:	2200      	movs	r2, #0
9000d7a2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
9000d7a6:	68fb      	ldr	r3, [r7, #12]
9000d7a8:	2200      	movs	r2, #0
9000d7aa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
9000d7ae:	2300      	movs	r3, #0
9000d7b0:	e000      	b.n	9000d7b4 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
9000d7b2:	2302      	movs	r3, #2
  }
}
9000d7b4:	4618      	mov	r0, r3
9000d7b6:	3718      	adds	r7, #24
9000d7b8:	46bd      	mov	sp, r7
9000d7ba:	bd80      	pop	{r7, pc}
9000d7bc:	80002400 	.word	0x80002400
9000d7c0:	fe00e800 	.word	0xfe00e800

9000d7c4 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
9000d7c4:	b480      	push	{r7}
9000d7c6:	b083      	sub	sp, #12
9000d7c8:	af00      	add	r7, sp, #0
9000d7ca:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
9000d7cc:	687b      	ldr	r3, [r7, #4]
9000d7ce:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
9000d7d2:	b2db      	uxtb	r3, r3
}
9000d7d4:	4618      	mov	r0, r3
9000d7d6:	370c      	adds	r7, #12
9000d7d8:	46bd      	mov	sp, r7
9000d7da:	f85d 7b04 	ldr.w	r7, [sp], #4
9000d7de:	4770      	bx	lr

9000d7e0 <HAL_I2C_GetError>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *              the configuration information for the specified I2C.
  * @retval I2C Error Code
  */
uint32_t HAL_I2C_GetError(I2C_HandleTypeDef *hi2c)
{
9000d7e0:	b480      	push	{r7}
9000d7e2:	b083      	sub	sp, #12
9000d7e4:	af00      	add	r7, sp, #0
9000d7e6:	6078      	str	r0, [r7, #4]
  return hi2c->ErrorCode;
9000d7e8:	687b      	ldr	r3, [r7, #4]
9000d7ea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
9000d7ec:	4618      	mov	r0, r3
9000d7ee:	370c      	adds	r7, #12
9000d7f0:	46bd      	mov	sp, r7
9000d7f2:	f85d 7b04 	ldr.w	r7, [sp], #4
9000d7f6:	4770      	bx	lr

9000d7f8 <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
9000d7f8:	b580      	push	{r7, lr}
9000d7fa:	b086      	sub	sp, #24
9000d7fc:	af02      	add	r7, sp, #8
9000d7fe:	60f8      	str	r0, [r7, #12]
9000d800:	4608      	mov	r0, r1
9000d802:	4611      	mov	r1, r2
9000d804:	461a      	mov	r2, r3
9000d806:	4603      	mov	r3, r0
9000d808:	817b      	strh	r3, [r7, #10]
9000d80a:	460b      	mov	r3, r1
9000d80c:	813b      	strh	r3, [r7, #8]
9000d80e:	4613      	mov	r3, r2
9000d810:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
9000d812:	88fb      	ldrh	r3, [r7, #6]
9000d814:	b2da      	uxtb	r2, r3
9000d816:	8979      	ldrh	r1, [r7, #10]
9000d818:	4b20      	ldr	r3, [pc, #128]	; (9000d89c <I2C_RequestMemoryWrite+0xa4>)
9000d81a:	9300      	str	r3, [sp, #0]
9000d81c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
9000d820:	68f8      	ldr	r0, [r7, #12]
9000d822:	f000 fa5d 	bl	9000dce0 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
9000d826:	69fa      	ldr	r2, [r7, #28]
9000d828:	69b9      	ldr	r1, [r7, #24]
9000d82a:	68f8      	ldr	r0, [r7, #12]
9000d82c:	f000 f8f0 	bl	9000da10 <I2C_WaitOnTXISFlagUntilTimeout>
9000d830:	4603      	mov	r3, r0
9000d832:	2b00      	cmp	r3, #0
9000d834:	d001      	beq.n	9000d83a <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
9000d836:	2301      	movs	r3, #1
9000d838:	e02c      	b.n	9000d894 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
9000d83a:	88fb      	ldrh	r3, [r7, #6]
9000d83c:	2b01      	cmp	r3, #1
9000d83e:	d105      	bne.n	9000d84c <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
9000d840:	893b      	ldrh	r3, [r7, #8]
9000d842:	b2da      	uxtb	r2, r3
9000d844:	68fb      	ldr	r3, [r7, #12]
9000d846:	681b      	ldr	r3, [r3, #0]
9000d848:	629a      	str	r2, [r3, #40]	; 0x28
9000d84a:	e015      	b.n	9000d878 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
9000d84c:	893b      	ldrh	r3, [r7, #8]
9000d84e:	0a1b      	lsrs	r3, r3, #8
9000d850:	b29b      	uxth	r3, r3
9000d852:	b2da      	uxtb	r2, r3
9000d854:	68fb      	ldr	r3, [r7, #12]
9000d856:	681b      	ldr	r3, [r3, #0]
9000d858:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
9000d85a:	69fa      	ldr	r2, [r7, #28]
9000d85c:	69b9      	ldr	r1, [r7, #24]
9000d85e:	68f8      	ldr	r0, [r7, #12]
9000d860:	f000 f8d6 	bl	9000da10 <I2C_WaitOnTXISFlagUntilTimeout>
9000d864:	4603      	mov	r3, r0
9000d866:	2b00      	cmp	r3, #0
9000d868:	d001      	beq.n	9000d86e <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
9000d86a:	2301      	movs	r3, #1
9000d86c:	e012      	b.n	9000d894 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
9000d86e:	893b      	ldrh	r3, [r7, #8]
9000d870:	b2da      	uxtb	r2, r3
9000d872:	68fb      	ldr	r3, [r7, #12]
9000d874:	681b      	ldr	r3, [r3, #0]
9000d876:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
9000d878:	69fb      	ldr	r3, [r7, #28]
9000d87a:	9300      	str	r3, [sp, #0]
9000d87c:	69bb      	ldr	r3, [r7, #24]
9000d87e:	2200      	movs	r2, #0
9000d880:	2180      	movs	r1, #128	; 0x80
9000d882:	68f8      	ldr	r0, [r7, #12]
9000d884:	f000 f884 	bl	9000d990 <I2C_WaitOnFlagUntilTimeout>
9000d888:	4603      	mov	r3, r0
9000d88a:	2b00      	cmp	r3, #0
9000d88c:	d001      	beq.n	9000d892 <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
9000d88e:	2301      	movs	r3, #1
9000d890:	e000      	b.n	9000d894 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
9000d892:	2300      	movs	r3, #0
}
9000d894:	4618      	mov	r0, r3
9000d896:	3710      	adds	r7, #16
9000d898:	46bd      	mov	sp, r7
9000d89a:	bd80      	pop	{r7, pc}
9000d89c:	80002000 	.word	0x80002000

9000d8a0 <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
9000d8a0:	b580      	push	{r7, lr}
9000d8a2:	b086      	sub	sp, #24
9000d8a4:	af02      	add	r7, sp, #8
9000d8a6:	60f8      	str	r0, [r7, #12]
9000d8a8:	4608      	mov	r0, r1
9000d8aa:	4611      	mov	r1, r2
9000d8ac:	461a      	mov	r2, r3
9000d8ae:	4603      	mov	r3, r0
9000d8b0:	817b      	strh	r3, [r7, #10]
9000d8b2:	460b      	mov	r3, r1
9000d8b4:	813b      	strh	r3, [r7, #8]
9000d8b6:	4613      	mov	r3, r2
9000d8b8:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
9000d8ba:	88fb      	ldrh	r3, [r7, #6]
9000d8bc:	b2da      	uxtb	r2, r3
9000d8be:	8979      	ldrh	r1, [r7, #10]
9000d8c0:	4b20      	ldr	r3, [pc, #128]	; (9000d944 <I2C_RequestMemoryRead+0xa4>)
9000d8c2:	9300      	str	r3, [sp, #0]
9000d8c4:	2300      	movs	r3, #0
9000d8c6:	68f8      	ldr	r0, [r7, #12]
9000d8c8:	f000 fa0a 	bl	9000dce0 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
9000d8cc:	69fa      	ldr	r2, [r7, #28]
9000d8ce:	69b9      	ldr	r1, [r7, #24]
9000d8d0:	68f8      	ldr	r0, [r7, #12]
9000d8d2:	f000 f89d 	bl	9000da10 <I2C_WaitOnTXISFlagUntilTimeout>
9000d8d6:	4603      	mov	r3, r0
9000d8d8:	2b00      	cmp	r3, #0
9000d8da:	d001      	beq.n	9000d8e0 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
9000d8dc:	2301      	movs	r3, #1
9000d8de:	e02c      	b.n	9000d93a <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
9000d8e0:	88fb      	ldrh	r3, [r7, #6]
9000d8e2:	2b01      	cmp	r3, #1
9000d8e4:	d105      	bne.n	9000d8f2 <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
9000d8e6:	893b      	ldrh	r3, [r7, #8]
9000d8e8:	b2da      	uxtb	r2, r3
9000d8ea:	68fb      	ldr	r3, [r7, #12]
9000d8ec:	681b      	ldr	r3, [r3, #0]
9000d8ee:	629a      	str	r2, [r3, #40]	; 0x28
9000d8f0:	e015      	b.n	9000d91e <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
9000d8f2:	893b      	ldrh	r3, [r7, #8]
9000d8f4:	0a1b      	lsrs	r3, r3, #8
9000d8f6:	b29b      	uxth	r3, r3
9000d8f8:	b2da      	uxtb	r2, r3
9000d8fa:	68fb      	ldr	r3, [r7, #12]
9000d8fc:	681b      	ldr	r3, [r3, #0]
9000d8fe:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
9000d900:	69fa      	ldr	r2, [r7, #28]
9000d902:	69b9      	ldr	r1, [r7, #24]
9000d904:	68f8      	ldr	r0, [r7, #12]
9000d906:	f000 f883 	bl	9000da10 <I2C_WaitOnTXISFlagUntilTimeout>
9000d90a:	4603      	mov	r3, r0
9000d90c:	2b00      	cmp	r3, #0
9000d90e:	d001      	beq.n	9000d914 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
9000d910:	2301      	movs	r3, #1
9000d912:	e012      	b.n	9000d93a <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
9000d914:	893b      	ldrh	r3, [r7, #8]
9000d916:	b2da      	uxtb	r2, r3
9000d918:	68fb      	ldr	r3, [r7, #12]
9000d91a:	681b      	ldr	r3, [r3, #0]
9000d91c:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
9000d91e:	69fb      	ldr	r3, [r7, #28]
9000d920:	9300      	str	r3, [sp, #0]
9000d922:	69bb      	ldr	r3, [r7, #24]
9000d924:	2200      	movs	r2, #0
9000d926:	2140      	movs	r1, #64	; 0x40
9000d928:	68f8      	ldr	r0, [r7, #12]
9000d92a:	f000 f831 	bl	9000d990 <I2C_WaitOnFlagUntilTimeout>
9000d92e:	4603      	mov	r3, r0
9000d930:	2b00      	cmp	r3, #0
9000d932:	d001      	beq.n	9000d938 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
9000d934:	2301      	movs	r3, #1
9000d936:	e000      	b.n	9000d93a <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
9000d938:	2300      	movs	r3, #0
}
9000d93a:	4618      	mov	r0, r3
9000d93c:	3710      	adds	r7, #16
9000d93e:	46bd      	mov	sp, r7
9000d940:	bd80      	pop	{r7, pc}
9000d942:	bf00      	nop
9000d944:	80002000 	.word	0x80002000

9000d948 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
9000d948:	b480      	push	{r7}
9000d94a:	b083      	sub	sp, #12
9000d94c:	af00      	add	r7, sp, #0
9000d94e:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
9000d950:	687b      	ldr	r3, [r7, #4]
9000d952:	681b      	ldr	r3, [r3, #0]
9000d954:	699b      	ldr	r3, [r3, #24]
9000d956:	f003 0302 	and.w	r3, r3, #2
9000d95a:	2b02      	cmp	r3, #2
9000d95c:	d103      	bne.n	9000d966 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
9000d95e:	687b      	ldr	r3, [r7, #4]
9000d960:	681b      	ldr	r3, [r3, #0]
9000d962:	2200      	movs	r2, #0
9000d964:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
9000d966:	687b      	ldr	r3, [r7, #4]
9000d968:	681b      	ldr	r3, [r3, #0]
9000d96a:	699b      	ldr	r3, [r3, #24]
9000d96c:	f003 0301 	and.w	r3, r3, #1
9000d970:	2b01      	cmp	r3, #1
9000d972:	d007      	beq.n	9000d984 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
9000d974:	687b      	ldr	r3, [r7, #4]
9000d976:	681b      	ldr	r3, [r3, #0]
9000d978:	699a      	ldr	r2, [r3, #24]
9000d97a:	687b      	ldr	r3, [r7, #4]
9000d97c:	681b      	ldr	r3, [r3, #0]
9000d97e:	f042 0201 	orr.w	r2, r2, #1
9000d982:	619a      	str	r2, [r3, #24]
  }
}
9000d984:	bf00      	nop
9000d986:	370c      	adds	r7, #12
9000d988:	46bd      	mov	sp, r7
9000d98a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000d98e:	4770      	bx	lr

9000d990 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
9000d990:	b580      	push	{r7, lr}
9000d992:	b084      	sub	sp, #16
9000d994:	af00      	add	r7, sp, #0
9000d996:	60f8      	str	r0, [r7, #12]
9000d998:	60b9      	str	r1, [r7, #8]
9000d99a:	603b      	str	r3, [r7, #0]
9000d99c:	4613      	mov	r3, r2
9000d99e:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
9000d9a0:	e022      	b.n	9000d9e8 <I2C_WaitOnFlagUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
9000d9a2:	683b      	ldr	r3, [r7, #0]
9000d9a4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
9000d9a8:	d01e      	beq.n	9000d9e8 <I2C_WaitOnFlagUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
9000d9aa:	f7fb fd0b 	bl	900093c4 <HAL_GetTick>
9000d9ae:	4602      	mov	r2, r0
9000d9b0:	69bb      	ldr	r3, [r7, #24]
9000d9b2:	1ad3      	subs	r3, r2, r3
9000d9b4:	683a      	ldr	r2, [r7, #0]
9000d9b6:	429a      	cmp	r2, r3
9000d9b8:	d302      	bcc.n	9000d9c0 <I2C_WaitOnFlagUntilTimeout+0x30>
9000d9ba:	683b      	ldr	r3, [r7, #0]
9000d9bc:	2b00      	cmp	r3, #0
9000d9be:	d113      	bne.n	9000d9e8 <I2C_WaitOnFlagUntilTimeout+0x58>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
9000d9c0:	68fb      	ldr	r3, [r7, #12]
9000d9c2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000d9c4:	f043 0220 	orr.w	r2, r3, #32
9000d9c8:	68fb      	ldr	r3, [r7, #12]
9000d9ca:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
9000d9cc:	68fb      	ldr	r3, [r7, #12]
9000d9ce:	2220      	movs	r2, #32
9000d9d0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
9000d9d4:	68fb      	ldr	r3, [r7, #12]
9000d9d6:	2200      	movs	r2, #0
9000d9d8:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
9000d9dc:	68fb      	ldr	r3, [r7, #12]
9000d9de:	2200      	movs	r2, #0
9000d9e0:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
9000d9e4:	2301      	movs	r3, #1
9000d9e6:	e00f      	b.n	9000da08 <I2C_WaitOnFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
9000d9e8:	68fb      	ldr	r3, [r7, #12]
9000d9ea:	681b      	ldr	r3, [r3, #0]
9000d9ec:	699a      	ldr	r2, [r3, #24]
9000d9ee:	68bb      	ldr	r3, [r7, #8]
9000d9f0:	4013      	ands	r3, r2
9000d9f2:	68ba      	ldr	r2, [r7, #8]
9000d9f4:	429a      	cmp	r2, r3
9000d9f6:	bf0c      	ite	eq
9000d9f8:	2301      	moveq	r3, #1
9000d9fa:	2300      	movne	r3, #0
9000d9fc:	b2db      	uxtb	r3, r3
9000d9fe:	461a      	mov	r2, r3
9000da00:	79fb      	ldrb	r3, [r7, #7]
9000da02:	429a      	cmp	r2, r3
9000da04:	d0cd      	beq.n	9000d9a2 <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
9000da06:	2300      	movs	r3, #0
}
9000da08:	4618      	mov	r0, r3
9000da0a:	3710      	adds	r7, #16
9000da0c:	46bd      	mov	sp, r7
9000da0e:	bd80      	pop	{r7, pc}

9000da10 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
9000da10:	b580      	push	{r7, lr}
9000da12:	b084      	sub	sp, #16
9000da14:	af00      	add	r7, sp, #0
9000da16:	60f8      	str	r0, [r7, #12]
9000da18:	60b9      	str	r1, [r7, #8]
9000da1a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
9000da1c:	e02c      	b.n	9000da78 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
9000da1e:	687a      	ldr	r2, [r7, #4]
9000da20:	68b9      	ldr	r1, [r7, #8]
9000da22:	68f8      	ldr	r0, [r7, #12]
9000da24:	f000 f870 	bl	9000db08 <I2C_IsErrorOccurred>
9000da28:	4603      	mov	r3, r0
9000da2a:	2b00      	cmp	r3, #0
9000da2c:	d001      	beq.n	9000da32 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
9000da2e:	2301      	movs	r3, #1
9000da30:	e02a      	b.n	9000da88 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
9000da32:	68bb      	ldr	r3, [r7, #8]
9000da34:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
9000da38:	d01e      	beq.n	9000da78 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
9000da3a:	f7fb fcc3 	bl	900093c4 <HAL_GetTick>
9000da3e:	4602      	mov	r2, r0
9000da40:	687b      	ldr	r3, [r7, #4]
9000da42:	1ad3      	subs	r3, r2, r3
9000da44:	68ba      	ldr	r2, [r7, #8]
9000da46:	429a      	cmp	r2, r3
9000da48:	d302      	bcc.n	9000da50 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
9000da4a:	68bb      	ldr	r3, [r7, #8]
9000da4c:	2b00      	cmp	r3, #0
9000da4e:	d113      	bne.n	9000da78 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
9000da50:	68fb      	ldr	r3, [r7, #12]
9000da52:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000da54:	f043 0220 	orr.w	r2, r3, #32
9000da58:	68fb      	ldr	r3, [r7, #12]
9000da5a:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
9000da5c:	68fb      	ldr	r3, [r7, #12]
9000da5e:	2220      	movs	r2, #32
9000da60:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
9000da64:	68fb      	ldr	r3, [r7, #12]
9000da66:	2200      	movs	r2, #0
9000da68:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
9000da6c:	68fb      	ldr	r3, [r7, #12]
9000da6e:	2200      	movs	r2, #0
9000da70:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
9000da74:	2301      	movs	r3, #1
9000da76:	e007      	b.n	9000da88 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
9000da78:	68fb      	ldr	r3, [r7, #12]
9000da7a:	681b      	ldr	r3, [r3, #0]
9000da7c:	699b      	ldr	r3, [r3, #24]
9000da7e:	f003 0302 	and.w	r3, r3, #2
9000da82:	2b02      	cmp	r3, #2
9000da84:	d1cb      	bne.n	9000da1e <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
9000da86:	2300      	movs	r3, #0
}
9000da88:	4618      	mov	r0, r3
9000da8a:	3710      	adds	r7, #16
9000da8c:	46bd      	mov	sp, r7
9000da8e:	bd80      	pop	{r7, pc}

9000da90 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
9000da90:	b580      	push	{r7, lr}
9000da92:	b084      	sub	sp, #16
9000da94:	af00      	add	r7, sp, #0
9000da96:	60f8      	str	r0, [r7, #12]
9000da98:	60b9      	str	r1, [r7, #8]
9000da9a:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
9000da9c:	e028      	b.n	9000daf0 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
9000da9e:	687a      	ldr	r2, [r7, #4]
9000daa0:	68b9      	ldr	r1, [r7, #8]
9000daa2:	68f8      	ldr	r0, [r7, #12]
9000daa4:	f000 f830 	bl	9000db08 <I2C_IsErrorOccurred>
9000daa8:	4603      	mov	r3, r0
9000daaa:	2b00      	cmp	r3, #0
9000daac:	d001      	beq.n	9000dab2 <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
9000daae:	2301      	movs	r3, #1
9000dab0:	e026      	b.n	9000db00 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
9000dab2:	f7fb fc87 	bl	900093c4 <HAL_GetTick>
9000dab6:	4602      	mov	r2, r0
9000dab8:	687b      	ldr	r3, [r7, #4]
9000daba:	1ad3      	subs	r3, r2, r3
9000dabc:	68ba      	ldr	r2, [r7, #8]
9000dabe:	429a      	cmp	r2, r3
9000dac0:	d302      	bcc.n	9000dac8 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
9000dac2:	68bb      	ldr	r3, [r7, #8]
9000dac4:	2b00      	cmp	r3, #0
9000dac6:	d113      	bne.n	9000daf0 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
9000dac8:	68fb      	ldr	r3, [r7, #12]
9000daca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000dacc:	f043 0220 	orr.w	r2, r3, #32
9000dad0:	68fb      	ldr	r3, [r7, #12]
9000dad2:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
9000dad4:	68fb      	ldr	r3, [r7, #12]
9000dad6:	2220      	movs	r2, #32
9000dad8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
9000dadc:	68fb      	ldr	r3, [r7, #12]
9000dade:	2200      	movs	r2, #0
9000dae0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
9000dae4:	68fb      	ldr	r3, [r7, #12]
9000dae6:	2200      	movs	r2, #0
9000dae8:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
9000daec:	2301      	movs	r3, #1
9000daee:	e007      	b.n	9000db00 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
9000daf0:	68fb      	ldr	r3, [r7, #12]
9000daf2:	681b      	ldr	r3, [r3, #0]
9000daf4:	699b      	ldr	r3, [r3, #24]
9000daf6:	f003 0320 	and.w	r3, r3, #32
9000dafa:	2b20      	cmp	r3, #32
9000dafc:	d1cf      	bne.n	9000da9e <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
9000dafe:	2300      	movs	r3, #0
}
9000db00:	4618      	mov	r0, r3
9000db02:	3710      	adds	r7, #16
9000db04:	46bd      	mov	sp, r7
9000db06:	bd80      	pop	{r7, pc}

9000db08 <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
9000db08:	b580      	push	{r7, lr}
9000db0a:	b08a      	sub	sp, #40	; 0x28
9000db0c:	af00      	add	r7, sp, #0
9000db0e:	60f8      	str	r0, [r7, #12]
9000db10:	60b9      	str	r1, [r7, #8]
9000db12:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
9000db14:	2300      	movs	r3, #0
9000db16:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  uint32_t itflag   = hi2c->Instance->ISR;
9000db1a:	68fb      	ldr	r3, [r7, #12]
9000db1c:	681b      	ldr	r3, [r3, #0]
9000db1e:	699b      	ldr	r3, [r3, #24]
9000db20:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
9000db22:	2300      	movs	r3, #0
9000db24:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
9000db26:	687b      	ldr	r3, [r7, #4]
9000db28:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
9000db2a:	69bb      	ldr	r3, [r7, #24]
9000db2c:	f003 0310 	and.w	r3, r3, #16
9000db30:	2b00      	cmp	r3, #0
9000db32:	d075      	beq.n	9000dc20 <I2C_IsErrorOccurred+0x118>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
9000db34:	68fb      	ldr	r3, [r7, #12]
9000db36:	681b      	ldr	r3, [r3, #0]
9000db38:	2210      	movs	r2, #16
9000db3a:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
9000db3c:	e056      	b.n	9000dbec <I2C_IsErrorOccurred+0xe4>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
9000db3e:	68bb      	ldr	r3, [r7, #8]
9000db40:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
9000db44:	d052      	beq.n	9000dbec <I2C_IsErrorOccurred+0xe4>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
9000db46:	f7fb fc3d 	bl	900093c4 <HAL_GetTick>
9000db4a:	4602      	mov	r2, r0
9000db4c:	69fb      	ldr	r3, [r7, #28]
9000db4e:	1ad3      	subs	r3, r2, r3
9000db50:	68ba      	ldr	r2, [r7, #8]
9000db52:	429a      	cmp	r2, r3
9000db54:	d302      	bcc.n	9000db5c <I2C_IsErrorOccurred+0x54>
9000db56:	68bb      	ldr	r3, [r7, #8]
9000db58:	2b00      	cmp	r3, #0
9000db5a:	d147      	bne.n	9000dbec <I2C_IsErrorOccurred+0xe4>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
9000db5c:	68fb      	ldr	r3, [r7, #12]
9000db5e:	681b      	ldr	r3, [r3, #0]
9000db60:	685b      	ldr	r3, [r3, #4]
9000db62:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
9000db66:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
9000db68:	68fb      	ldr	r3, [r7, #12]
9000db6a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
9000db6e:	74fb      	strb	r3, [r7, #19]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
9000db70:	68fb      	ldr	r3, [r7, #12]
9000db72:	681b      	ldr	r3, [r3, #0]
9000db74:	699b      	ldr	r3, [r3, #24]
9000db76:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
9000db7a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
9000db7e:	d12e      	bne.n	9000dbde <I2C_IsErrorOccurred+0xd6>
9000db80:	697b      	ldr	r3, [r7, #20]
9000db82:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
9000db86:	d02a      	beq.n	9000dbde <I2C_IsErrorOccurred+0xd6>
              (tmp1 != I2C_CR2_STOP) && \
9000db88:	7cfb      	ldrb	r3, [r7, #19]
9000db8a:	2b20      	cmp	r3, #32
9000db8c:	d027      	beq.n	9000dbde <I2C_IsErrorOccurred+0xd6>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
9000db8e:	68fb      	ldr	r3, [r7, #12]
9000db90:	681b      	ldr	r3, [r3, #0]
9000db92:	685a      	ldr	r2, [r3, #4]
9000db94:	68fb      	ldr	r3, [r7, #12]
9000db96:	681b      	ldr	r3, [r3, #0]
9000db98:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
9000db9c:	605a      	str	r2, [r3, #4]
            
            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
9000db9e:	f7fb fc11 	bl	900093c4 <HAL_GetTick>
9000dba2:	61f8      	str	r0, [r7, #28]
          }
          
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
9000dba4:	e01b      	b.n	9000dbde <I2C_IsErrorOccurred+0xd6>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
9000dba6:	f7fb fc0d 	bl	900093c4 <HAL_GetTick>
9000dbaa:	4602      	mov	r2, r0
9000dbac:	69fb      	ldr	r3, [r7, #28]
9000dbae:	1ad3      	subs	r3, r2, r3
9000dbb0:	2b19      	cmp	r3, #25
9000dbb2:	d914      	bls.n	9000dbde <I2C_IsErrorOccurred+0xd6>
            {
              hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
9000dbb4:	68fb      	ldr	r3, [r7, #12]
9000dbb6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000dbb8:	f043 0220 	orr.w	r2, r3, #32
9000dbbc:	68fb      	ldr	r3, [r7, #12]
9000dbbe:	645a      	str	r2, [r3, #68]	; 0x44
              hi2c->State = HAL_I2C_STATE_READY;
9000dbc0:	68fb      	ldr	r3, [r7, #12]
9000dbc2:	2220      	movs	r2, #32
9000dbc4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
              hi2c->Mode = HAL_I2C_MODE_NONE;
9000dbc8:	68fb      	ldr	r3, [r7, #12]
9000dbca:	2200      	movs	r2, #0
9000dbcc:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
              
              /* Process Unlocked */
              __HAL_UNLOCK(hi2c);
9000dbd0:	68fb      	ldr	r3, [r7, #12]
9000dbd2:	2200      	movs	r2, #0
9000dbd4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
              
              status = HAL_ERROR;
9000dbd8:	2301      	movs	r3, #1
9000dbda:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
9000dbde:	68fb      	ldr	r3, [r7, #12]
9000dbe0:	681b      	ldr	r3, [r3, #0]
9000dbe2:	699b      	ldr	r3, [r3, #24]
9000dbe4:	f003 0320 	and.w	r3, r3, #32
9000dbe8:	2b20      	cmp	r3, #32
9000dbea:	d1dc      	bne.n	9000dba6 <I2C_IsErrorOccurred+0x9e>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
9000dbec:	68fb      	ldr	r3, [r7, #12]
9000dbee:	681b      	ldr	r3, [r3, #0]
9000dbf0:	699b      	ldr	r3, [r3, #24]
9000dbf2:	f003 0320 	and.w	r3, r3, #32
9000dbf6:	2b20      	cmp	r3, #32
9000dbf8:	d003      	beq.n	9000dc02 <I2C_IsErrorOccurred+0xfa>
9000dbfa:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
9000dbfe:	2b00      	cmp	r3, #0
9000dc00:	d09d      	beq.n	9000db3e <I2C_IsErrorOccurred+0x36>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
9000dc02:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
9000dc06:	2b00      	cmp	r3, #0
9000dc08:	d103      	bne.n	9000dc12 <I2C_IsErrorOccurred+0x10a>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
9000dc0a:	68fb      	ldr	r3, [r7, #12]
9000dc0c:	681b      	ldr	r3, [r3, #0]
9000dc0e:	2220      	movs	r2, #32
9000dc10:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
9000dc12:	6a3b      	ldr	r3, [r7, #32]
9000dc14:	f043 0304 	orr.w	r3, r3, #4
9000dc18:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
9000dc1a:	2301      	movs	r3, #1
9000dc1c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
9000dc20:	68fb      	ldr	r3, [r7, #12]
9000dc22:	681b      	ldr	r3, [r3, #0]
9000dc24:	699b      	ldr	r3, [r3, #24]
9000dc26:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
9000dc28:	69bb      	ldr	r3, [r7, #24]
9000dc2a:	f403 7380 	and.w	r3, r3, #256	; 0x100
9000dc2e:	2b00      	cmp	r3, #0
9000dc30:	d00b      	beq.n	9000dc4a <I2C_IsErrorOccurred+0x142>
  {
    error_code |= HAL_I2C_ERROR_BERR;
9000dc32:	6a3b      	ldr	r3, [r7, #32]
9000dc34:	f043 0301 	orr.w	r3, r3, #1
9000dc38:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
9000dc3a:	68fb      	ldr	r3, [r7, #12]
9000dc3c:	681b      	ldr	r3, [r3, #0]
9000dc3e:	f44f 7280 	mov.w	r2, #256	; 0x100
9000dc42:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
9000dc44:	2301      	movs	r3, #1
9000dc46:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
9000dc4a:	69bb      	ldr	r3, [r7, #24]
9000dc4c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
9000dc50:	2b00      	cmp	r3, #0
9000dc52:	d00b      	beq.n	9000dc6c <I2C_IsErrorOccurred+0x164>
  {
    error_code |= HAL_I2C_ERROR_OVR;
9000dc54:	6a3b      	ldr	r3, [r7, #32]
9000dc56:	f043 0308 	orr.w	r3, r3, #8
9000dc5a:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
9000dc5c:	68fb      	ldr	r3, [r7, #12]
9000dc5e:	681b      	ldr	r3, [r3, #0]
9000dc60:	f44f 6280 	mov.w	r2, #1024	; 0x400
9000dc64:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
9000dc66:	2301      	movs	r3, #1
9000dc68:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
9000dc6c:	69bb      	ldr	r3, [r7, #24]
9000dc6e:	f403 7300 	and.w	r3, r3, #512	; 0x200
9000dc72:	2b00      	cmp	r3, #0
9000dc74:	d00b      	beq.n	9000dc8e <I2C_IsErrorOccurred+0x186>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
9000dc76:	6a3b      	ldr	r3, [r7, #32]
9000dc78:	f043 0302 	orr.w	r3, r3, #2
9000dc7c:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
9000dc7e:	68fb      	ldr	r3, [r7, #12]
9000dc80:	681b      	ldr	r3, [r3, #0]
9000dc82:	f44f 7200 	mov.w	r2, #512	; 0x200
9000dc86:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
9000dc88:	2301      	movs	r3, #1
9000dc8a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  if (status != HAL_OK)
9000dc8e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
9000dc92:	2b00      	cmp	r3, #0
9000dc94:	d01c      	beq.n	9000dcd0 <I2C_IsErrorOccurred+0x1c8>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
9000dc96:	68f8      	ldr	r0, [r7, #12]
9000dc98:	f7ff fe56 	bl	9000d948 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
9000dc9c:	68fb      	ldr	r3, [r7, #12]
9000dc9e:	681b      	ldr	r3, [r3, #0]
9000dca0:	6859      	ldr	r1, [r3, #4]
9000dca2:	68fb      	ldr	r3, [r7, #12]
9000dca4:	681a      	ldr	r2, [r3, #0]
9000dca6:	4b0d      	ldr	r3, [pc, #52]	; (9000dcdc <I2C_IsErrorOccurred+0x1d4>)
9000dca8:	400b      	ands	r3, r1
9000dcaa:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
9000dcac:	68fb      	ldr	r3, [r7, #12]
9000dcae:	6c5a      	ldr	r2, [r3, #68]	; 0x44
9000dcb0:	6a3b      	ldr	r3, [r7, #32]
9000dcb2:	431a      	orrs	r2, r3
9000dcb4:	68fb      	ldr	r3, [r7, #12]
9000dcb6:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
9000dcb8:	68fb      	ldr	r3, [r7, #12]
9000dcba:	2220      	movs	r2, #32
9000dcbc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
9000dcc0:	68fb      	ldr	r3, [r7, #12]
9000dcc2:	2200      	movs	r2, #0
9000dcc4:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
9000dcc8:	68fb      	ldr	r3, [r7, #12]
9000dcca:	2200      	movs	r2, #0
9000dccc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  }

  return status;
9000dcd0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
9000dcd4:	4618      	mov	r0, r3
9000dcd6:	3728      	adds	r7, #40	; 0x28
9000dcd8:	46bd      	mov	sp, r7
9000dcda:	bd80      	pop	{r7, pc}
9000dcdc:	fe00e800 	.word	0xfe00e800

9000dce0 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
9000dce0:	b480      	push	{r7}
9000dce2:	b087      	sub	sp, #28
9000dce4:	af00      	add	r7, sp, #0
9000dce6:	60f8      	str	r0, [r7, #12]
9000dce8:	607b      	str	r3, [r7, #4]
9000dcea:	460b      	mov	r3, r1
9000dcec:	817b      	strh	r3, [r7, #10]
9000dcee:	4613      	mov	r3, r2
9000dcf0:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
9000dcf2:	897b      	ldrh	r3, [r7, #10]
9000dcf4:	f3c3 0209 	ubfx	r2, r3, #0, #10
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
9000dcf8:	7a7b      	ldrb	r3, [r7, #9]
9000dcfa:	041b      	lsls	r3, r3, #16
9000dcfc:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
9000dd00:	431a      	orrs	r2, r3
                            (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
9000dd02:	687b      	ldr	r3, [r7, #4]
9000dd04:	431a      	orrs	r2, r3
  uint32_t tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
9000dd06:	6a3b      	ldr	r3, [r7, #32]
9000dd08:	4313      	orrs	r3, r2
9000dd0a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
9000dd0e:	617b      	str	r3, [r7, #20]
                              (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
9000dd10:	68fb      	ldr	r3, [r7, #12]
9000dd12:	681b      	ldr	r3, [r3, #0]
9000dd14:	685a      	ldr	r2, [r3, #4]
9000dd16:	6a3b      	ldr	r3, [r7, #32]
9000dd18:	0d5b      	lsrs	r3, r3, #21
9000dd1a:	f403 6180 	and.w	r1, r3, #1024	; 0x400
9000dd1e:	4b08      	ldr	r3, [pc, #32]	; (9000dd40 <I2C_TransferConfig+0x60>)
9000dd20:	430b      	orrs	r3, r1
9000dd22:	43db      	mvns	r3, r3
9000dd24:	ea02 0103 	and.w	r1, r2, r3
9000dd28:	68fb      	ldr	r3, [r7, #12]
9000dd2a:	681b      	ldr	r3, [r3, #0]
9000dd2c:	697a      	ldr	r2, [r7, #20]
9000dd2e:	430a      	orrs	r2, r1
9000dd30:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
                I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
9000dd32:	bf00      	nop
9000dd34:	371c      	adds	r7, #28
9000dd36:	46bd      	mov	sp, r7
9000dd38:	f85d 7b04 	ldr.w	r7, [sp], #4
9000dd3c:	4770      	bx	lr
9000dd3e:	bf00      	nop
9000dd40:	03ff63ff 	.word	0x03ff63ff

9000dd44 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
9000dd44:	b480      	push	{r7}
9000dd46:	b083      	sub	sp, #12
9000dd48:	af00      	add	r7, sp, #0
9000dd4a:	6078      	str	r0, [r7, #4]
9000dd4c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
9000dd4e:	687b      	ldr	r3, [r7, #4]
9000dd50:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
9000dd54:	b2db      	uxtb	r3, r3
9000dd56:	2b20      	cmp	r3, #32
9000dd58:	d138      	bne.n	9000ddcc <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
9000dd5a:	687b      	ldr	r3, [r7, #4]
9000dd5c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
9000dd60:	2b01      	cmp	r3, #1
9000dd62:	d101      	bne.n	9000dd68 <HAL_I2CEx_ConfigAnalogFilter+0x24>
9000dd64:	2302      	movs	r3, #2
9000dd66:	e032      	b.n	9000ddce <HAL_I2CEx_ConfigAnalogFilter+0x8a>
9000dd68:	687b      	ldr	r3, [r7, #4]
9000dd6a:	2201      	movs	r2, #1
9000dd6c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
9000dd70:	687b      	ldr	r3, [r7, #4]
9000dd72:	2224      	movs	r2, #36	; 0x24
9000dd74:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
9000dd78:	687b      	ldr	r3, [r7, #4]
9000dd7a:	681b      	ldr	r3, [r3, #0]
9000dd7c:	681a      	ldr	r2, [r3, #0]
9000dd7e:	687b      	ldr	r3, [r7, #4]
9000dd80:	681b      	ldr	r3, [r3, #0]
9000dd82:	f022 0201 	bic.w	r2, r2, #1
9000dd86:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
9000dd88:	687b      	ldr	r3, [r7, #4]
9000dd8a:	681b      	ldr	r3, [r3, #0]
9000dd8c:	681a      	ldr	r2, [r3, #0]
9000dd8e:	687b      	ldr	r3, [r7, #4]
9000dd90:	681b      	ldr	r3, [r3, #0]
9000dd92:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
9000dd96:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
9000dd98:	687b      	ldr	r3, [r7, #4]
9000dd9a:	681b      	ldr	r3, [r3, #0]
9000dd9c:	6819      	ldr	r1, [r3, #0]
9000dd9e:	687b      	ldr	r3, [r7, #4]
9000dda0:	681b      	ldr	r3, [r3, #0]
9000dda2:	683a      	ldr	r2, [r7, #0]
9000dda4:	430a      	orrs	r2, r1
9000dda6:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
9000dda8:	687b      	ldr	r3, [r7, #4]
9000ddaa:	681b      	ldr	r3, [r3, #0]
9000ddac:	681a      	ldr	r2, [r3, #0]
9000ddae:	687b      	ldr	r3, [r7, #4]
9000ddb0:	681b      	ldr	r3, [r3, #0]
9000ddb2:	f042 0201 	orr.w	r2, r2, #1
9000ddb6:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
9000ddb8:	687b      	ldr	r3, [r7, #4]
9000ddba:	2220      	movs	r2, #32
9000ddbc:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
9000ddc0:	687b      	ldr	r3, [r7, #4]
9000ddc2:	2200      	movs	r2, #0
9000ddc4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
9000ddc8:	2300      	movs	r3, #0
9000ddca:	e000      	b.n	9000ddce <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
9000ddcc:	2302      	movs	r3, #2
  }
}
9000ddce:	4618      	mov	r0, r3
9000ddd0:	370c      	adds	r7, #12
9000ddd2:	46bd      	mov	sp, r7
9000ddd4:	f85d 7b04 	ldr.w	r7, [sp], #4
9000ddd8:	4770      	bx	lr

9000ddda <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
9000ddda:	b480      	push	{r7}
9000dddc:	b085      	sub	sp, #20
9000ddde:	af00      	add	r7, sp, #0
9000dde0:	6078      	str	r0, [r7, #4]
9000dde2:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
9000dde4:	687b      	ldr	r3, [r7, #4]
9000dde6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
9000ddea:	b2db      	uxtb	r3, r3
9000ddec:	2b20      	cmp	r3, #32
9000ddee:	d139      	bne.n	9000de64 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
9000ddf0:	687b      	ldr	r3, [r7, #4]
9000ddf2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
9000ddf6:	2b01      	cmp	r3, #1
9000ddf8:	d101      	bne.n	9000ddfe <HAL_I2CEx_ConfigDigitalFilter+0x24>
9000ddfa:	2302      	movs	r3, #2
9000ddfc:	e033      	b.n	9000de66 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
9000ddfe:	687b      	ldr	r3, [r7, #4]
9000de00:	2201      	movs	r2, #1
9000de02:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
9000de06:	687b      	ldr	r3, [r7, #4]
9000de08:	2224      	movs	r2, #36	; 0x24
9000de0a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
9000de0e:	687b      	ldr	r3, [r7, #4]
9000de10:	681b      	ldr	r3, [r3, #0]
9000de12:	681a      	ldr	r2, [r3, #0]
9000de14:	687b      	ldr	r3, [r7, #4]
9000de16:	681b      	ldr	r3, [r3, #0]
9000de18:	f022 0201 	bic.w	r2, r2, #1
9000de1c:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
9000de1e:	687b      	ldr	r3, [r7, #4]
9000de20:	681b      	ldr	r3, [r3, #0]
9000de22:	681b      	ldr	r3, [r3, #0]
9000de24:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
9000de26:	68fb      	ldr	r3, [r7, #12]
9000de28:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
9000de2c:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
9000de2e:	683b      	ldr	r3, [r7, #0]
9000de30:	021b      	lsls	r3, r3, #8
9000de32:	68fa      	ldr	r2, [r7, #12]
9000de34:	4313      	orrs	r3, r2
9000de36:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
9000de38:	687b      	ldr	r3, [r7, #4]
9000de3a:	681b      	ldr	r3, [r3, #0]
9000de3c:	68fa      	ldr	r2, [r7, #12]
9000de3e:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
9000de40:	687b      	ldr	r3, [r7, #4]
9000de42:	681b      	ldr	r3, [r3, #0]
9000de44:	681a      	ldr	r2, [r3, #0]
9000de46:	687b      	ldr	r3, [r7, #4]
9000de48:	681b      	ldr	r3, [r3, #0]
9000de4a:	f042 0201 	orr.w	r2, r2, #1
9000de4e:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
9000de50:	687b      	ldr	r3, [r7, #4]
9000de52:	2220      	movs	r2, #32
9000de54:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
9000de58:	687b      	ldr	r3, [r7, #4]
9000de5a:	2200      	movs	r2, #0
9000de5c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
9000de60:	2300      	movs	r3, #0
9000de62:	e000      	b.n	9000de66 <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
9000de64:	2302      	movs	r3, #2
  }
}
9000de66:	4618      	mov	r0, r3
9000de68:	3714      	adds	r7, #20
9000de6a:	46bd      	mov	sp, r7
9000de6c:	f85d 7b04 	ldr.w	r7, [sp], #4
9000de70:	4770      	bx	lr
	...

9000de74 <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
9000de74:	b580      	push	{r7, lr}
9000de76:	b084      	sub	sp, #16
9000de78:	af00      	add	r7, sp, #0
9000de7a:	6078      	str	r0, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
9000de7c:	687b      	ldr	r3, [r7, #4]
9000de7e:	2b00      	cmp	r3, #0
9000de80:	d101      	bne.n	9000de86 <HAL_LTDC_Init+0x12>
  {
    return HAL_ERROR;
9000de82:	2301      	movs	r3, #1
9000de84:	e0bf      	b.n	9000e006 <HAL_LTDC_Init+0x192>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
9000de86:	687b      	ldr	r3, [r7, #4]
9000de88:	f893 30a1 	ldrb.w	r3, [r3, #161]	; 0xa1
9000de8c:	b2db      	uxtb	r3, r3
9000de8e:	2b00      	cmp	r3, #0
9000de90:	d106      	bne.n	9000dea0 <HAL_LTDC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
9000de92:	687b      	ldr	r3, [r7, #4]
9000de94:	2200      	movs	r2, #0
9000de96:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
9000de9a:	6878      	ldr	r0, [r7, #4]
9000de9c:	f000 f911 	bl	9000e0c2 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
9000dea0:	687b      	ldr	r3, [r7, #4]
9000dea2:	2202      	movs	r2, #2
9000dea4:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
9000dea8:	687b      	ldr	r3, [r7, #4]
9000deaa:	681b      	ldr	r3, [r3, #0]
9000deac:	699a      	ldr	r2, [r3, #24]
9000deae:	687b      	ldr	r3, [r7, #4]
9000deb0:	681b      	ldr	r3, [r3, #0]
9000deb2:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
9000deb6:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
9000deb8:	687b      	ldr	r3, [r7, #4]
9000deba:	681b      	ldr	r3, [r3, #0]
9000debc:	6999      	ldr	r1, [r3, #24]
9000debe:	687b      	ldr	r3, [r7, #4]
9000dec0:	685a      	ldr	r2, [r3, #4]
9000dec2:	687b      	ldr	r3, [r7, #4]
9000dec4:	689b      	ldr	r3, [r3, #8]
9000dec6:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
9000dec8:	687b      	ldr	r3, [r7, #4]
9000deca:	68db      	ldr	r3, [r3, #12]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
9000decc:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
9000dece:	687b      	ldr	r3, [r7, #4]
9000ded0:	691b      	ldr	r3, [r3, #16]
9000ded2:	431a      	orrs	r2, r3
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
9000ded4:	687b      	ldr	r3, [r7, #4]
9000ded6:	681b      	ldr	r3, [r3, #0]
9000ded8:	430a      	orrs	r2, r1
9000deda:	619a      	str	r2, [r3, #24]

  /* Set Synchronization size */
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
9000dedc:	687b      	ldr	r3, [r7, #4]
9000dede:	681b      	ldr	r3, [r3, #0]
9000dee0:	6899      	ldr	r1, [r3, #8]
9000dee2:	687b      	ldr	r3, [r7, #4]
9000dee4:	681a      	ldr	r2, [r3, #0]
9000dee6:	4b4a      	ldr	r3, [pc, #296]	; (9000e010 <HAL_LTDC_Init+0x19c>)
9000dee8:	400b      	ands	r3, r1
9000deea:	6093      	str	r3, [r2, #8]
  tmp = (hltdc->Init.HorizontalSync << 16U);
9000deec:	687b      	ldr	r3, [r7, #4]
9000deee:	695b      	ldr	r3, [r3, #20]
9000def0:	041b      	lsls	r3, r3, #16
9000def2:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
9000def4:	687b      	ldr	r3, [r7, #4]
9000def6:	681b      	ldr	r3, [r3, #0]
9000def8:	6899      	ldr	r1, [r3, #8]
9000defa:	687b      	ldr	r3, [r7, #4]
9000defc:	699a      	ldr	r2, [r3, #24]
9000defe:	68fb      	ldr	r3, [r7, #12]
9000df00:	431a      	orrs	r2, r3
9000df02:	687b      	ldr	r3, [r7, #4]
9000df04:	681b      	ldr	r3, [r3, #0]
9000df06:	430a      	orrs	r2, r1
9000df08:	609a      	str	r2, [r3, #8]

  /* Set Accumulated Back porch */
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
9000df0a:	687b      	ldr	r3, [r7, #4]
9000df0c:	681b      	ldr	r3, [r3, #0]
9000df0e:	68d9      	ldr	r1, [r3, #12]
9000df10:	687b      	ldr	r3, [r7, #4]
9000df12:	681a      	ldr	r2, [r3, #0]
9000df14:	4b3e      	ldr	r3, [pc, #248]	; (9000e010 <HAL_LTDC_Init+0x19c>)
9000df16:	400b      	ands	r3, r1
9000df18:	60d3      	str	r3, [r2, #12]
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
9000df1a:	687b      	ldr	r3, [r7, #4]
9000df1c:	69db      	ldr	r3, [r3, #28]
9000df1e:	041b      	lsls	r3, r3, #16
9000df20:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
9000df22:	687b      	ldr	r3, [r7, #4]
9000df24:	681b      	ldr	r3, [r3, #0]
9000df26:	68d9      	ldr	r1, [r3, #12]
9000df28:	687b      	ldr	r3, [r7, #4]
9000df2a:	6a1a      	ldr	r2, [r3, #32]
9000df2c:	68fb      	ldr	r3, [r7, #12]
9000df2e:	431a      	orrs	r2, r3
9000df30:	687b      	ldr	r3, [r7, #4]
9000df32:	681b      	ldr	r3, [r3, #0]
9000df34:	430a      	orrs	r2, r1
9000df36:	60da      	str	r2, [r3, #12]

  /* Set Accumulated Active Width */
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
9000df38:	687b      	ldr	r3, [r7, #4]
9000df3a:	681b      	ldr	r3, [r3, #0]
9000df3c:	6919      	ldr	r1, [r3, #16]
9000df3e:	687b      	ldr	r3, [r7, #4]
9000df40:	681a      	ldr	r2, [r3, #0]
9000df42:	4b33      	ldr	r3, [pc, #204]	; (9000e010 <HAL_LTDC_Init+0x19c>)
9000df44:	400b      	ands	r3, r1
9000df46:	6113      	str	r3, [r2, #16]
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
9000df48:	687b      	ldr	r3, [r7, #4]
9000df4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9000df4c:	041b      	lsls	r3, r3, #16
9000df4e:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
9000df50:	687b      	ldr	r3, [r7, #4]
9000df52:	681b      	ldr	r3, [r3, #0]
9000df54:	6919      	ldr	r1, [r3, #16]
9000df56:	687b      	ldr	r3, [r7, #4]
9000df58:	6a9a      	ldr	r2, [r3, #40]	; 0x28
9000df5a:	68fb      	ldr	r3, [r7, #12]
9000df5c:	431a      	orrs	r2, r3
9000df5e:	687b      	ldr	r3, [r7, #4]
9000df60:	681b      	ldr	r3, [r3, #0]
9000df62:	430a      	orrs	r2, r1
9000df64:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
9000df66:	687b      	ldr	r3, [r7, #4]
9000df68:	681b      	ldr	r3, [r3, #0]
9000df6a:	6959      	ldr	r1, [r3, #20]
9000df6c:	687b      	ldr	r3, [r7, #4]
9000df6e:	681a      	ldr	r2, [r3, #0]
9000df70:	4b27      	ldr	r3, [pc, #156]	; (9000e010 <HAL_LTDC_Init+0x19c>)
9000df72:	400b      	ands	r3, r1
9000df74:	6153      	str	r3, [r2, #20]
  tmp = (hltdc->Init.TotalWidth << 16U);
9000df76:	687b      	ldr	r3, [r7, #4]
9000df78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000df7a:	041b      	lsls	r3, r3, #16
9000df7c:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
9000df7e:	687b      	ldr	r3, [r7, #4]
9000df80:	681b      	ldr	r3, [r3, #0]
9000df82:	6959      	ldr	r1, [r3, #20]
9000df84:	687b      	ldr	r3, [r7, #4]
9000df86:	6b1a      	ldr	r2, [r3, #48]	; 0x30
9000df88:	68fb      	ldr	r3, [r7, #12]
9000df8a:	431a      	orrs	r2, r3
9000df8c:	687b      	ldr	r3, [r7, #4]
9000df8e:	681b      	ldr	r3, [r3, #0]
9000df90:	430a      	orrs	r2, r1
9000df92:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
9000df94:	687b      	ldr	r3, [r7, #4]
9000df96:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
9000df9a:	021b      	lsls	r3, r3, #8
9000df9c:	60fb      	str	r3, [r7, #12]
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
9000df9e:	687b      	ldr	r3, [r7, #4]
9000dfa0:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
9000dfa4:	041b      	lsls	r3, r3, #16
9000dfa6:	60bb      	str	r3, [r7, #8]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
9000dfa8:	687b      	ldr	r3, [r7, #4]
9000dfaa:	681b      	ldr	r3, [r3, #0]
9000dfac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
9000dfae:	687b      	ldr	r3, [r7, #4]
9000dfb0:	681b      	ldr	r3, [r3, #0]
9000dfb2:	f002 427f 	and.w	r2, r2, #4278190080	; 0xff000000
9000dfb6:	62da      	str	r2, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
9000dfb8:	687b      	ldr	r3, [r7, #4]
9000dfba:	681b      	ldr	r3, [r3, #0]
9000dfbc:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
9000dfbe:	68ba      	ldr	r2, [r7, #8]
9000dfc0:	68fb      	ldr	r3, [r7, #12]
9000dfc2:	4313      	orrs	r3, r2
9000dfc4:	687a      	ldr	r2, [r7, #4]
9000dfc6:	f892 2034 	ldrb.w	r2, [r2, #52]	; 0x34
9000dfca:	431a      	orrs	r2, r3
9000dfcc:	687b      	ldr	r3, [r7, #4]
9000dfce:	681b      	ldr	r3, [r3, #0]
9000dfd0:	430a      	orrs	r2, r1
9000dfd2:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the Transfer Error and FIFO underrun interrupts */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
9000dfd4:	687b      	ldr	r3, [r7, #4]
9000dfd6:	681b      	ldr	r3, [r3, #0]
9000dfd8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000dfda:	687b      	ldr	r3, [r7, #4]
9000dfdc:	681b      	ldr	r3, [r3, #0]
9000dfde:	f042 0206 	orr.w	r2, r2, #6
9000dfe2:	635a      	str	r2, [r3, #52]	; 0x34

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
9000dfe4:	687b      	ldr	r3, [r7, #4]
9000dfe6:	681b      	ldr	r3, [r3, #0]
9000dfe8:	699a      	ldr	r2, [r3, #24]
9000dfea:	687b      	ldr	r3, [r7, #4]
9000dfec:	681b      	ldr	r3, [r3, #0]
9000dfee:	f042 0201 	orr.w	r2, r2, #1
9000dff2:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
9000dff4:	687b      	ldr	r3, [r7, #4]
9000dff6:	2200      	movs	r2, #0
9000dff8:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
9000dffc:	687b      	ldr	r3, [r7, #4]
9000dffe:	2201      	movs	r2, #1
9000e000:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  return HAL_OK;
9000e004:	2300      	movs	r3, #0
}
9000e006:	4618      	mov	r0, r3
9000e008:	3710      	adds	r7, #16
9000e00a:	46bd      	mov	sp, r7
9000e00c:	bd80      	pop	{r7, pc}
9000e00e:	bf00      	nop
9000e010:	f000f800 	.word	0xf000f800

9000e014 <HAL_LTDC_DeInit>:
  *                the configuration information for the LTDC.
  * @retval None
  */

HAL_StatusTypeDef HAL_LTDC_DeInit(LTDC_HandleTypeDef *hltdc)
{
9000e014:	b580      	push	{r7, lr}
9000e016:	b084      	sub	sp, #16
9000e018:	af00      	add	r7, sp, #0
9000e01a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
9000e01c:	687b      	ldr	r3, [r7, #4]
9000e01e:	2b00      	cmp	r3, #0
9000e020:	d101      	bne.n	9000e026 <HAL_LTDC_DeInit+0x12>
  {
    return HAL_ERROR;
9000e022:	2301      	movs	r3, #1
9000e024:	e049      	b.n	9000e0ba <HAL_LTDC_DeInit+0xa6>

  /* Check function parameters */
  assert_param(IS_LTDC_ALL_INSTANCE(hltdc->Instance));

  /* Disable LTDC Layer 1 */
  __HAL_LTDC_LAYER_DISABLE(hltdc, LTDC_LAYER_1);
9000e026:	687b      	ldr	r3, [r7, #4]
9000e028:	681b      	ldr	r3, [r3, #0]
9000e02a:	3384      	adds	r3, #132	; 0x84
9000e02c:	681b      	ldr	r3, [r3, #0]
9000e02e:	687a      	ldr	r2, [r7, #4]
9000e030:	6812      	ldr	r2, [r2, #0]
9000e032:	3284      	adds	r2, #132	; 0x84
9000e034:	f023 0301 	bic.w	r3, r3, #1
9000e038:	6013      	str	r3, [r2, #0]

#if defined(LTDC_Layer2_BASE)
  /* Disable LTDC Layer 2 */
  __HAL_LTDC_LAYER_DISABLE(hltdc, LTDC_LAYER_2);
9000e03a:	687b      	ldr	r3, [r7, #4]
9000e03c:	681b      	ldr	r3, [r3, #0]
9000e03e:	f503 7382 	add.w	r3, r3, #260	; 0x104
9000e042:	681b      	ldr	r3, [r3, #0]
9000e044:	687a      	ldr	r2, [r7, #4]
9000e046:	6812      	ldr	r2, [r2, #0]
9000e048:	f502 7282 	add.w	r2, r2, #260	; 0x104
9000e04c:	f023 0301 	bic.w	r3, r3, #1
9000e050:	6013      	str	r3, [r2, #0]
#endif /* LTDC_Layer2_BASE */

  /* Reload during vertical blanking period */
  __HAL_LTDC_VERTICAL_BLANKING_RELOAD_CONFIG(hltdc);
9000e052:	687b      	ldr	r3, [r7, #4]
9000e054:	681b      	ldr	r3, [r3, #0]
9000e056:	6a5a      	ldr	r2, [r3, #36]	; 0x24
9000e058:	687b      	ldr	r3, [r7, #4]
9000e05a:	681b      	ldr	r3, [r3, #0]
9000e05c:	f042 0202 	orr.w	r2, r2, #2
9000e060:	625a      	str	r2, [r3, #36]	; 0x24

  /* Get tick */
  tickstart = HAL_GetTick();
9000e062:	f7fb f9af 	bl	900093c4 <HAL_GetTick>
9000e066:	60f8      	str	r0, [r7, #12]

  /* Wait for VSYNC Interrupt */
  while (READ_BIT(hltdc->Instance->CDSR, LTDC_CDSR_VSYNCS) == 0U)
9000e068:	e006      	b.n	9000e078 <HAL_LTDC_DeInit+0x64>
  {
    /* Check for the Timeout */
    if ((HAL_GetTick() - tickstart) > LTDC_TIMEOUT_VALUE)
9000e06a:	f7fb f9ab 	bl	900093c4 <HAL_GetTick>
9000e06e:	4602      	mov	r2, r0
9000e070:	68fb      	ldr	r3, [r7, #12]
9000e072:	1ad3      	subs	r3, r2, r3
9000e074:	2b64      	cmp	r3, #100	; 0x64
9000e076:	d807      	bhi.n	9000e088 <HAL_LTDC_DeInit+0x74>
  while (READ_BIT(hltdc->Instance->CDSR, LTDC_CDSR_VSYNCS) == 0U)
9000e078:	687b      	ldr	r3, [r7, #4]
9000e07a:	681b      	ldr	r3, [r3, #0]
9000e07c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
9000e07e:	f003 0304 	and.w	r3, r3, #4
9000e082:	2b00      	cmp	r3, #0
9000e084:	d0f1      	beq.n	9000e06a <HAL_LTDC_DeInit+0x56>
9000e086:	e000      	b.n	9000e08a <HAL_LTDC_DeInit+0x76>
    {
      break;
9000e088:	bf00      	nop
    }
  }

  /* Disable LTDC  */
  __HAL_LTDC_DISABLE(hltdc);
9000e08a:	687b      	ldr	r3, [r7, #4]
9000e08c:	681b      	ldr	r3, [r3, #0]
9000e08e:	699a      	ldr	r2, [r3, #24]
9000e090:	687b      	ldr	r3, [r7, #4]
9000e092:	681b      	ldr	r3, [r3, #0]
9000e094:	f022 0201 	bic.w	r2, r2, #1
9000e098:	619a      	str	r2, [r3, #24]
  }
  /* DeInit the low level hardware */
  hltdc->MspDeInitCallback(hltdc);
#else
  /* DeInit the low level hardware */
  HAL_LTDC_MspDeInit(hltdc);
9000e09a:	6878      	ldr	r0, [r7, #4]
9000e09c:	f000 f81b 	bl	9000e0d6 <HAL_LTDC_MspDeInit>
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
9000e0a0:	687b      	ldr	r3, [r7, #4]
9000e0a2:	2200      	movs	r2, #0
9000e0a4:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_RESET;
9000e0a8:	687b      	ldr	r3, [r7, #4]
9000e0aa:	2200      	movs	r2, #0
9000e0ac:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Release Lock */
  __HAL_UNLOCK(hltdc);
9000e0b0:	687b      	ldr	r3, [r7, #4]
9000e0b2:	2200      	movs	r2, #0
9000e0b4:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0

  return HAL_OK;
9000e0b8:	2300      	movs	r3, #0
}
9000e0ba:	4618      	mov	r0, r3
9000e0bc:	3710      	adds	r7, #16
9000e0be:	46bd      	mov	sp, r7
9000e0c0:	bd80      	pop	{r7, pc}

9000e0c2 <HAL_LTDC_MspInit>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_MspInit(LTDC_HandleTypeDef *hltdc)
{
9000e0c2:	b480      	push	{r7}
9000e0c4:	b083      	sub	sp, #12
9000e0c6:	af00      	add	r7, sp, #0
9000e0c8:	6078      	str	r0, [r7, #4]
  UNUSED(hltdc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_MspInit could be implemented in the user file
   */
}
9000e0ca:	bf00      	nop
9000e0cc:	370c      	adds	r7, #12
9000e0ce:	46bd      	mov	sp, r7
9000e0d0:	f85d 7b04 	ldr.w	r7, [sp], #4
9000e0d4:	4770      	bx	lr

9000e0d6 <HAL_LTDC_MspDeInit>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_MspDeInit(LTDC_HandleTypeDef *hltdc)
{
9000e0d6:	b480      	push	{r7}
9000e0d8:	b083      	sub	sp, #12
9000e0da:	af00      	add	r7, sp, #0
9000e0dc:	6078      	str	r0, [r7, #4]
  UNUSED(hltdc);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_LTDC_MspDeInit could be implemented in the user file
   */
}
9000e0de:	bf00      	nop
9000e0e0:	370c      	adds	r7, #12
9000e0e2:	46bd      	mov	sp, r7
9000e0e4:	f85d 7b04 	ldr.w	r7, [sp], #4
9000e0e8:	4770      	bx	lr

9000e0ea <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
9000e0ea:	b5b0      	push	{r4, r5, r7, lr}
9000e0ec:	b084      	sub	sp, #16
9000e0ee:	af00      	add	r7, sp, #0
9000e0f0:	60f8      	str	r0, [r7, #12]
9000e0f2:	60b9      	str	r1, [r7, #8]
9000e0f4:	607a      	str	r2, [r7, #4]
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Process locked */
  __HAL_LOCK(hltdc);
9000e0f6:	68fb      	ldr	r3, [r7, #12]
9000e0f8:	f893 30a0 	ldrb.w	r3, [r3, #160]	; 0xa0
9000e0fc:	2b01      	cmp	r3, #1
9000e0fe:	d101      	bne.n	9000e104 <HAL_LTDC_ConfigLayer+0x1a>
9000e100:	2302      	movs	r3, #2
9000e102:	e02c      	b.n	9000e15e <HAL_LTDC_ConfigLayer+0x74>
9000e104:	68fb      	ldr	r3, [r7, #12]
9000e106:	2201      	movs	r2, #1
9000e108:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
9000e10c:	68fb      	ldr	r3, [r7, #12]
9000e10e:	2202      	movs	r2, #2
9000e110:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
9000e114:	68fa      	ldr	r2, [r7, #12]
9000e116:	687b      	ldr	r3, [r7, #4]
9000e118:	2134      	movs	r1, #52	; 0x34
9000e11a:	fb01 f303 	mul.w	r3, r1, r3
9000e11e:	4413      	add	r3, r2
9000e120:	f103 0238 	add.w	r2, r3, #56	; 0x38
9000e124:	68bb      	ldr	r3, [r7, #8]
9000e126:	4614      	mov	r4, r2
9000e128:	461d      	mov	r5, r3
9000e12a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
9000e12c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
9000e12e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
9000e130:	c40f      	stmia	r4!, {r0, r1, r2, r3}
9000e132:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
9000e134:	c40f      	stmia	r4!, {r0, r1, r2, r3}
9000e136:	682b      	ldr	r3, [r5, #0]
9000e138:	6023      	str	r3, [r4, #0]

  /* Configure the LTDC Layer */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
9000e13a:	687a      	ldr	r2, [r7, #4]
9000e13c:	68b9      	ldr	r1, [r7, #8]
9000e13e:	68f8      	ldr	r0, [r7, #12]
9000e140:	f000 f812 	bl	9000e168 <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
9000e144:	68fb      	ldr	r3, [r7, #12]
9000e146:	681b      	ldr	r3, [r3, #0]
9000e148:	2201      	movs	r2, #1
9000e14a:	625a      	str	r2, [r3, #36]	; 0x24

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
9000e14c:	68fb      	ldr	r3, [r7, #12]
9000e14e:	2201      	movs	r2, #1
9000e150:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
9000e154:	68fb      	ldr	r3, [r7, #12]
9000e156:	2200      	movs	r2, #0
9000e158:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0

  return HAL_OK;
9000e15c:	2300      	movs	r3, #0
}
9000e15e:	4618      	mov	r0, r3
9000e160:	3710      	adds	r7, #16
9000e162:	46bd      	mov	sp, r7
9000e164:	bdb0      	pop	{r4, r5, r7, pc}
	...

9000e168 <LTDC_SetConfig>:
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values: LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval None
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
9000e168:	b480      	push	{r7}
9000e16a:	b089      	sub	sp, #36	; 0x24
9000e16c:	af00      	add	r7, sp, #0
9000e16e:	60f8      	str	r0, [r7, #12]
9000e170:	60b9      	str	r1, [r7, #8]
9000e172:	607a      	str	r2, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
9000e174:	68bb      	ldr	r3, [r7, #8]
9000e176:	685a      	ldr	r2, [r3, #4]
9000e178:	68fb      	ldr	r3, [r7, #12]
9000e17a:	681b      	ldr	r3, [r3, #0]
9000e17c:	68db      	ldr	r3, [r3, #12]
9000e17e:	0c1b      	lsrs	r3, r3, #16
9000e180:	f3c3 030b 	ubfx	r3, r3, #0, #12
9000e184:	4413      	add	r3, r2
9000e186:	041b      	lsls	r3, r3, #16
9000e188:	61fb      	str	r3, [r7, #28]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
9000e18a:	68fb      	ldr	r3, [r7, #12]
9000e18c:	681b      	ldr	r3, [r3, #0]
9000e18e:	461a      	mov	r2, r3
9000e190:	687b      	ldr	r3, [r7, #4]
9000e192:	01db      	lsls	r3, r3, #7
9000e194:	4413      	add	r3, r2
9000e196:	3384      	adds	r3, #132	; 0x84
9000e198:	685b      	ldr	r3, [r3, #4]
9000e19a:	68fa      	ldr	r2, [r7, #12]
9000e19c:	6812      	ldr	r2, [r2, #0]
9000e19e:	4611      	mov	r1, r2
9000e1a0:	687a      	ldr	r2, [r7, #4]
9000e1a2:	01d2      	lsls	r2, r2, #7
9000e1a4:	440a      	add	r2, r1
9000e1a6:	3284      	adds	r2, #132	; 0x84
9000e1a8:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
9000e1ac:	6053      	str	r3, [r2, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + \
9000e1ae:	68bb      	ldr	r3, [r7, #8]
9000e1b0:	681a      	ldr	r2, [r3, #0]
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
9000e1b2:	68fb      	ldr	r3, [r7, #12]
9000e1b4:	681b      	ldr	r3, [r3, #0]
9000e1b6:	68db      	ldr	r3, [r3, #12]
9000e1b8:	0c1b      	lsrs	r3, r3, #16
9000e1ba:	f3c3 030b 	ubfx	r3, r3, #0, #12
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + \
9000e1be:	4413      	add	r3, r2
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
9000e1c0:	1c5a      	adds	r2, r3, #1
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + \
9000e1c2:	68fb      	ldr	r3, [r7, #12]
9000e1c4:	681b      	ldr	r3, [r3, #0]
9000e1c6:	4619      	mov	r1, r3
9000e1c8:	687b      	ldr	r3, [r7, #4]
9000e1ca:	01db      	lsls	r3, r3, #7
9000e1cc:	440b      	add	r3, r1
9000e1ce:	3384      	adds	r3, #132	; 0x84
9000e1d0:	4619      	mov	r1, r3
                                         ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
9000e1d2:	69fb      	ldr	r3, [r7, #28]
9000e1d4:	4313      	orrs	r3, r2
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + \
9000e1d6:	604b      	str	r3, [r1, #4]

  /* Configure the vertical start and stop position */
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
9000e1d8:	68bb      	ldr	r3, [r7, #8]
9000e1da:	68da      	ldr	r2, [r3, #12]
9000e1dc:	68fb      	ldr	r3, [r7, #12]
9000e1de:	681b      	ldr	r3, [r3, #0]
9000e1e0:	68db      	ldr	r3, [r3, #12]
9000e1e2:	f3c3 030a 	ubfx	r3, r3, #0, #11
9000e1e6:	4413      	add	r3, r2
9000e1e8:	041b      	lsls	r3, r3, #16
9000e1ea:	61fb      	str	r3, [r7, #28]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
9000e1ec:	68fb      	ldr	r3, [r7, #12]
9000e1ee:	681b      	ldr	r3, [r3, #0]
9000e1f0:	461a      	mov	r2, r3
9000e1f2:	687b      	ldr	r3, [r7, #4]
9000e1f4:	01db      	lsls	r3, r3, #7
9000e1f6:	4413      	add	r3, r2
9000e1f8:	3384      	adds	r3, #132	; 0x84
9000e1fa:	689b      	ldr	r3, [r3, #8]
9000e1fc:	68fa      	ldr	r2, [r7, #12]
9000e1fe:	6812      	ldr	r2, [r2, #0]
9000e200:	4611      	mov	r1, r2
9000e202:	687a      	ldr	r2, [r7, #4]
9000e204:	01d2      	lsls	r2, r2, #7
9000e206:	440a      	add	r2, r1
9000e208:	3284      	adds	r2, #132	; 0x84
9000e20a:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
9000e20e:	6093      	str	r3, [r2, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
9000e210:	68bb      	ldr	r3, [r7, #8]
9000e212:	689a      	ldr	r2, [r3, #8]
9000e214:	68fb      	ldr	r3, [r7, #12]
9000e216:	681b      	ldr	r3, [r3, #0]
9000e218:	68db      	ldr	r3, [r3, #12]
9000e21a:	f3c3 030a 	ubfx	r3, r3, #0, #11
9000e21e:	4413      	add	r3, r2
9000e220:	1c5a      	adds	r2, r3, #1
9000e222:	68fb      	ldr	r3, [r7, #12]
9000e224:	681b      	ldr	r3, [r3, #0]
9000e226:	4619      	mov	r1, r3
9000e228:	687b      	ldr	r3, [r7, #4]
9000e22a:	01db      	lsls	r3, r3, #7
9000e22c:	440b      	add	r3, r1
9000e22e:	3384      	adds	r3, #132	; 0x84
9000e230:	4619      	mov	r1, r3
9000e232:	69fb      	ldr	r3, [r7, #28]
9000e234:	4313      	orrs	r3, r2
9000e236:	608b      	str	r3, [r1, #8]

  /* Specifies the pixel format */
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
9000e238:	68fb      	ldr	r3, [r7, #12]
9000e23a:	681b      	ldr	r3, [r3, #0]
9000e23c:	461a      	mov	r2, r3
9000e23e:	687b      	ldr	r3, [r7, #4]
9000e240:	01db      	lsls	r3, r3, #7
9000e242:	4413      	add	r3, r2
9000e244:	3384      	adds	r3, #132	; 0x84
9000e246:	691b      	ldr	r3, [r3, #16]
9000e248:	68fa      	ldr	r2, [r7, #12]
9000e24a:	6812      	ldr	r2, [r2, #0]
9000e24c:	4611      	mov	r1, r2
9000e24e:	687a      	ldr	r2, [r7, #4]
9000e250:	01d2      	lsls	r2, r2, #7
9000e252:	440a      	add	r2, r1
9000e254:	3284      	adds	r2, #132	; 0x84
9000e256:	f023 0307 	bic.w	r3, r3, #7
9000e25a:	6113      	str	r3, [r2, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
9000e25c:	68fb      	ldr	r3, [r7, #12]
9000e25e:	681b      	ldr	r3, [r3, #0]
9000e260:	461a      	mov	r2, r3
9000e262:	687b      	ldr	r3, [r7, #4]
9000e264:	01db      	lsls	r3, r3, #7
9000e266:	4413      	add	r3, r2
9000e268:	3384      	adds	r3, #132	; 0x84
9000e26a:	461a      	mov	r2, r3
9000e26c:	68bb      	ldr	r3, [r7, #8]
9000e26e:	691b      	ldr	r3, [r3, #16]
9000e270:	6113      	str	r3, [r2, #16]

  /* Configure the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
9000e272:	68bb      	ldr	r3, [r7, #8]
9000e274:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
9000e278:	021b      	lsls	r3, r3, #8
9000e27a:	61fb      	str	r3, [r7, #28]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
9000e27c:	68bb      	ldr	r3, [r7, #8]
9000e27e:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
9000e282:	041b      	lsls	r3, r3, #16
9000e284:	61bb      	str	r3, [r7, #24]
  tmp2 = (pLayerCfg->Alpha0 << 24U);
9000e286:	68bb      	ldr	r3, [r7, #8]
9000e288:	699b      	ldr	r3, [r3, #24]
9000e28a:	061b      	lsls	r3, r3, #24
9000e28c:	617b      	str	r3, [r7, #20]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED |
9000e28e:	68fb      	ldr	r3, [r7, #12]
9000e290:	681b      	ldr	r3, [r3, #0]
9000e292:	461a      	mov	r2, r3
9000e294:	687b      	ldr	r3, [r7, #4]
9000e296:	01db      	lsls	r3, r3, #7
9000e298:	4413      	add	r3, r2
9000e29a:	3384      	adds	r3, #132	; 0x84
9000e29c:	699b      	ldr	r3, [r3, #24]
9000e29e:	68fb      	ldr	r3, [r7, #12]
9000e2a0:	681b      	ldr	r3, [r3, #0]
9000e2a2:	461a      	mov	r2, r3
9000e2a4:	687b      	ldr	r3, [r7, #4]
9000e2a6:	01db      	lsls	r3, r3, #7
9000e2a8:	4413      	add	r3, r2
9000e2aa:	3384      	adds	r3, #132	; 0x84
9000e2ac:	461a      	mov	r2, r3
9000e2ae:	2300      	movs	r3, #0
9000e2b0:	6193      	str	r3, [r2, #24]
                                         LTDC_LxDCCR_DCALPHA);
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
9000e2b2:	68bb      	ldr	r3, [r7, #8]
9000e2b4:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
9000e2b8:	461a      	mov	r2, r3
9000e2ba:	69fb      	ldr	r3, [r7, #28]
9000e2bc:	431a      	orrs	r2, r3
9000e2be:	69bb      	ldr	r3, [r7, #24]
9000e2c0:	431a      	orrs	r2, r3
9000e2c2:	68fb      	ldr	r3, [r7, #12]
9000e2c4:	681b      	ldr	r3, [r3, #0]
9000e2c6:	4619      	mov	r1, r3
9000e2c8:	687b      	ldr	r3, [r7, #4]
9000e2ca:	01db      	lsls	r3, r3, #7
9000e2cc:	440b      	add	r3, r1
9000e2ce:	3384      	adds	r3, #132	; 0x84
9000e2d0:	4619      	mov	r1, r3
9000e2d2:	697b      	ldr	r3, [r7, #20]
9000e2d4:	4313      	orrs	r3, r2
9000e2d6:	618b      	str	r3, [r1, #24]

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
9000e2d8:	68fb      	ldr	r3, [r7, #12]
9000e2da:	681b      	ldr	r3, [r3, #0]
9000e2dc:	461a      	mov	r2, r3
9000e2de:	687b      	ldr	r3, [r7, #4]
9000e2e0:	01db      	lsls	r3, r3, #7
9000e2e2:	4413      	add	r3, r2
9000e2e4:	3384      	adds	r3, #132	; 0x84
9000e2e6:	695b      	ldr	r3, [r3, #20]
9000e2e8:	68fa      	ldr	r2, [r7, #12]
9000e2ea:	6812      	ldr	r2, [r2, #0]
9000e2ec:	4611      	mov	r1, r2
9000e2ee:	687a      	ldr	r2, [r7, #4]
9000e2f0:	01d2      	lsls	r2, r2, #7
9000e2f2:	440a      	add	r2, r1
9000e2f4:	3284      	adds	r2, #132	; 0x84
9000e2f6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
9000e2fa:	6153      	str	r3, [r2, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
9000e2fc:	68fb      	ldr	r3, [r7, #12]
9000e2fe:	681b      	ldr	r3, [r3, #0]
9000e300:	461a      	mov	r2, r3
9000e302:	687b      	ldr	r3, [r7, #4]
9000e304:	01db      	lsls	r3, r3, #7
9000e306:	4413      	add	r3, r2
9000e308:	3384      	adds	r3, #132	; 0x84
9000e30a:	461a      	mov	r2, r3
9000e30c:	68bb      	ldr	r3, [r7, #8]
9000e30e:	695b      	ldr	r3, [r3, #20]
9000e310:	6153      	str	r3, [r2, #20]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
9000e312:	68fb      	ldr	r3, [r7, #12]
9000e314:	681b      	ldr	r3, [r3, #0]
9000e316:	461a      	mov	r2, r3
9000e318:	687b      	ldr	r3, [r7, #4]
9000e31a:	01db      	lsls	r3, r3, #7
9000e31c:	4413      	add	r3, r2
9000e31e:	3384      	adds	r3, #132	; 0x84
9000e320:	69da      	ldr	r2, [r3, #28]
9000e322:	68fb      	ldr	r3, [r7, #12]
9000e324:	681b      	ldr	r3, [r3, #0]
9000e326:	4619      	mov	r1, r3
9000e328:	687b      	ldr	r3, [r7, #4]
9000e32a:	01db      	lsls	r3, r3, #7
9000e32c:	440b      	add	r3, r1
9000e32e:	3384      	adds	r3, #132	; 0x84
9000e330:	4619      	mov	r1, r3
9000e332:	4b58      	ldr	r3, [pc, #352]	; (9000e494 <LTDC_SetConfig+0x32c>)
9000e334:	4013      	ands	r3, r2
9000e336:	61cb      	str	r3, [r1, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
9000e338:	68bb      	ldr	r3, [r7, #8]
9000e33a:	69da      	ldr	r2, [r3, #28]
9000e33c:	68bb      	ldr	r3, [r7, #8]
9000e33e:	6a1b      	ldr	r3, [r3, #32]
9000e340:	68f9      	ldr	r1, [r7, #12]
9000e342:	6809      	ldr	r1, [r1, #0]
9000e344:	4608      	mov	r0, r1
9000e346:	6879      	ldr	r1, [r7, #4]
9000e348:	01c9      	lsls	r1, r1, #7
9000e34a:	4401      	add	r1, r0
9000e34c:	3184      	adds	r1, #132	; 0x84
9000e34e:	4313      	orrs	r3, r2
9000e350:	61cb      	str	r3, [r1, #28]

  /* Configure the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
9000e352:	68fb      	ldr	r3, [r7, #12]
9000e354:	681b      	ldr	r3, [r3, #0]
9000e356:	461a      	mov	r2, r3
9000e358:	687b      	ldr	r3, [r7, #4]
9000e35a:	01db      	lsls	r3, r3, #7
9000e35c:	4413      	add	r3, r2
9000e35e:	3384      	adds	r3, #132	; 0x84
9000e360:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9000e362:	68fb      	ldr	r3, [r7, #12]
9000e364:	681b      	ldr	r3, [r3, #0]
9000e366:	461a      	mov	r2, r3
9000e368:	687b      	ldr	r3, [r7, #4]
9000e36a:	01db      	lsls	r3, r3, #7
9000e36c:	4413      	add	r3, r2
9000e36e:	3384      	adds	r3, #132	; 0x84
9000e370:	461a      	mov	r2, r3
9000e372:	2300      	movs	r3, #0
9000e374:	6293      	str	r3, [r2, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
9000e376:	68fb      	ldr	r3, [r7, #12]
9000e378:	681b      	ldr	r3, [r3, #0]
9000e37a:	461a      	mov	r2, r3
9000e37c:	687b      	ldr	r3, [r7, #4]
9000e37e:	01db      	lsls	r3, r3, #7
9000e380:	4413      	add	r3, r2
9000e382:	3384      	adds	r3, #132	; 0x84
9000e384:	461a      	mov	r2, r3
9000e386:	68bb      	ldr	r3, [r7, #8]
9000e388:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9000e38a:	6293      	str	r3, [r2, #40]	; 0x28

  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
9000e38c:	68bb      	ldr	r3, [r7, #8]
9000e38e:	691b      	ldr	r3, [r3, #16]
9000e390:	2b00      	cmp	r3, #0
9000e392:	d102      	bne.n	9000e39a <LTDC_SetConfig+0x232>
  {
    tmp = 4U;
9000e394:	2304      	movs	r3, #4
9000e396:	61fb      	str	r3, [r7, #28]
9000e398:	e01b      	b.n	9000e3d2 <LTDC_SetConfig+0x26a>
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
9000e39a:	68bb      	ldr	r3, [r7, #8]
9000e39c:	691b      	ldr	r3, [r3, #16]
9000e39e:	2b01      	cmp	r3, #1
9000e3a0:	d102      	bne.n	9000e3a8 <LTDC_SetConfig+0x240>
  {
    tmp = 3U;
9000e3a2:	2303      	movs	r3, #3
9000e3a4:	61fb      	str	r3, [r7, #28]
9000e3a6:	e014      	b.n	9000e3d2 <LTDC_SetConfig+0x26a>
  }
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
9000e3a8:	68bb      	ldr	r3, [r7, #8]
9000e3aa:	691b      	ldr	r3, [r3, #16]
9000e3ac:	2b04      	cmp	r3, #4
9000e3ae:	d00b      	beq.n	9000e3c8 <LTDC_SetConfig+0x260>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
9000e3b0:	68bb      	ldr	r3, [r7, #8]
9000e3b2:	691b      	ldr	r3, [r3, #16]
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
9000e3b4:	2b02      	cmp	r3, #2
9000e3b6:	d007      	beq.n	9000e3c8 <LTDC_SetConfig+0x260>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
9000e3b8:	68bb      	ldr	r3, [r7, #8]
9000e3ba:	691b      	ldr	r3, [r3, #16]
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
9000e3bc:	2b03      	cmp	r3, #3
9000e3be:	d003      	beq.n	9000e3c8 <LTDC_SetConfig+0x260>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_AL88))
9000e3c0:	68bb      	ldr	r3, [r7, #8]
9000e3c2:	691b      	ldr	r3, [r3, #16]
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
9000e3c4:	2b07      	cmp	r3, #7
9000e3c6:	d102      	bne.n	9000e3ce <LTDC_SetConfig+0x266>
  {
    tmp = 2U;
9000e3c8:	2302      	movs	r3, #2
9000e3ca:	61fb      	str	r3, [r7, #28]
9000e3cc:	e001      	b.n	9000e3d2 <LTDC_SetConfig+0x26a>
  }
  else
  {
    tmp = 1U;
9000e3ce:	2301      	movs	r3, #1
9000e3d0:	61fb      	str	r3, [r7, #28]
  }

  /* Configure the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
9000e3d2:	68fb      	ldr	r3, [r7, #12]
9000e3d4:	681b      	ldr	r3, [r3, #0]
9000e3d6:	461a      	mov	r2, r3
9000e3d8:	687b      	ldr	r3, [r7, #4]
9000e3da:	01db      	lsls	r3, r3, #7
9000e3dc:	4413      	add	r3, r2
9000e3de:	3384      	adds	r3, #132	; 0x84
9000e3e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000e3e2:	68fa      	ldr	r2, [r7, #12]
9000e3e4:	6812      	ldr	r2, [r2, #0]
9000e3e6:	4611      	mov	r1, r2
9000e3e8:	687a      	ldr	r2, [r7, #4]
9000e3ea:	01d2      	lsls	r2, r2, #7
9000e3ec:	440a      	add	r2, r1
9000e3ee:	3284      	adds	r2, #132	; 0x84
9000e3f0:	f003 23e0 	and.w	r3, r3, #3758153728	; 0xe000e000
9000e3f4:	62d3      	str	r3, [r2, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 7U));
9000e3f6:	68bb      	ldr	r3, [r7, #8]
9000e3f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9000e3fa:	69fa      	ldr	r2, [r7, #28]
9000e3fc:	fb02 f303 	mul.w	r3, r2, r3
9000e400:	041a      	lsls	r2, r3, #16
9000e402:	68bb      	ldr	r3, [r7, #8]
9000e404:	6859      	ldr	r1, [r3, #4]
9000e406:	68bb      	ldr	r3, [r7, #8]
9000e408:	681b      	ldr	r3, [r3, #0]
9000e40a:	1acb      	subs	r3, r1, r3
9000e40c:	69f9      	ldr	r1, [r7, #28]
9000e40e:	fb01 f303 	mul.w	r3, r1, r3
9000e412:	3307      	adds	r3, #7
9000e414:	68f9      	ldr	r1, [r7, #12]
9000e416:	6809      	ldr	r1, [r1, #0]
9000e418:	4608      	mov	r0, r1
9000e41a:	6879      	ldr	r1, [r7, #4]
9000e41c:	01c9      	lsls	r1, r1, #7
9000e41e:	4401      	add	r1, r0
9000e420:	3184      	adds	r1, #132	; 0x84
9000e422:	4313      	orrs	r3, r2
9000e424:	62cb      	str	r3, [r1, #44]	; 0x2c
  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
9000e426:	68fb      	ldr	r3, [r7, #12]
9000e428:	681b      	ldr	r3, [r3, #0]
9000e42a:	461a      	mov	r2, r3
9000e42c:	687b      	ldr	r3, [r7, #4]
9000e42e:	01db      	lsls	r3, r3, #7
9000e430:	4413      	add	r3, r2
9000e432:	3384      	adds	r3, #132	; 0x84
9000e434:	6b1a      	ldr	r2, [r3, #48]	; 0x30
9000e436:	68fb      	ldr	r3, [r7, #12]
9000e438:	681b      	ldr	r3, [r3, #0]
9000e43a:	4619      	mov	r1, r3
9000e43c:	687b      	ldr	r3, [r7, #4]
9000e43e:	01db      	lsls	r3, r3, #7
9000e440:	440b      	add	r3, r1
9000e442:	3384      	adds	r3, #132	; 0x84
9000e444:	4619      	mov	r1, r3
9000e446:	4b14      	ldr	r3, [pc, #80]	; (9000e498 <LTDC_SetConfig+0x330>)
9000e448:	4013      	ands	r3, r2
9000e44a:	630b      	str	r3, [r1, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
9000e44c:	68fb      	ldr	r3, [r7, #12]
9000e44e:	681b      	ldr	r3, [r3, #0]
9000e450:	461a      	mov	r2, r3
9000e452:	687b      	ldr	r3, [r7, #4]
9000e454:	01db      	lsls	r3, r3, #7
9000e456:	4413      	add	r3, r2
9000e458:	3384      	adds	r3, #132	; 0x84
9000e45a:	461a      	mov	r2, r3
9000e45c:	68bb      	ldr	r3, [r7, #8]
9000e45e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000e460:	6313      	str	r3, [r2, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
9000e462:	68fb      	ldr	r3, [r7, #12]
9000e464:	681b      	ldr	r3, [r3, #0]
9000e466:	461a      	mov	r2, r3
9000e468:	687b      	ldr	r3, [r7, #4]
9000e46a:	01db      	lsls	r3, r3, #7
9000e46c:	4413      	add	r3, r2
9000e46e:	3384      	adds	r3, #132	; 0x84
9000e470:	681b      	ldr	r3, [r3, #0]
9000e472:	68fa      	ldr	r2, [r7, #12]
9000e474:	6812      	ldr	r2, [r2, #0]
9000e476:	4611      	mov	r1, r2
9000e478:	687a      	ldr	r2, [r7, #4]
9000e47a:	01d2      	lsls	r2, r2, #7
9000e47c:	440a      	add	r2, r1
9000e47e:	3284      	adds	r2, #132	; 0x84
9000e480:	f043 0301 	orr.w	r3, r3, #1
9000e484:	6013      	str	r3, [r2, #0]
}
9000e486:	bf00      	nop
9000e488:	3724      	adds	r7, #36	; 0x24
9000e48a:	46bd      	mov	sp, r7
9000e48c:	f85d 7b04 	ldr.w	r7, [sp], #4
9000e490:	4770      	bx	lr
9000e492:	bf00      	nop
9000e494:	fffff8f8 	.word	0xfffff8f8
9000e498:	fffff800 	.word	0xfffff800

9000e49c <HAL_MDMA_Init>:
  * @param  hmdma: Pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
9000e49c:	b580      	push	{r7, lr}
9000e49e:	b084      	sub	sp, #16
9000e4a0:	af00      	add	r7, sp, #0
9000e4a2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
9000e4a4:	f7fa ff8e 	bl	900093c4 <HAL_GetTick>
9000e4a8:	60f8      	str	r0, [r7, #12]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
9000e4aa:	687b      	ldr	r3, [r7, #4]
9000e4ac:	2b00      	cmp	r3, #0
9000e4ae:	d101      	bne.n	9000e4b4 <HAL_MDMA_Init+0x18>
  {
    return HAL_ERROR;
9000e4b0:	2301      	movs	r3, #1
9000e4b2:	e03b      	b.n	9000e52c <HAL_MDMA_Init+0x90>
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.SourceBlockAddressOffset));
  assert_param(IS_MDMA_BLOCK_ADDR_OFFSET(hmdma->Init.DestBlockAddressOffset));


  /* Allocate lock resource */
  __HAL_UNLOCK(hmdma);
9000e4b4:	687b      	ldr	r3, [r7, #4]
9000e4b6:	2200      	movs	r2, #0
9000e4b8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change MDMA peripheral state */
  hmdma->State = HAL_MDMA_STATE_BUSY;
9000e4bc:	687b      	ldr	r3, [r7, #4]
9000e4be:	2202      	movs	r2, #2
9000e4c0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the MDMA channel */
  __HAL_MDMA_DISABLE(hmdma);
9000e4c4:	687b      	ldr	r3, [r7, #4]
9000e4c6:	681b      	ldr	r3, [r3, #0]
9000e4c8:	68da      	ldr	r2, [r3, #12]
9000e4ca:	687b      	ldr	r3, [r7, #4]
9000e4cc:	681b      	ldr	r3, [r3, #0]
9000e4ce:	f022 0201 	bic.w	r2, r2, #1
9000e4d2:	60da      	str	r2, [r3, #12]

  /* Check if the MDMA channel is effectively disabled */
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
9000e4d4:	e00f      	b.n	9000e4f6 <HAL_MDMA_Init+0x5a>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_MDMA_ABORT)
9000e4d6:	f7fa ff75 	bl	900093c4 <HAL_GetTick>
9000e4da:	4602      	mov	r2, r0
9000e4dc:	68fb      	ldr	r3, [r7, #12]
9000e4de:	1ad3      	subs	r3, r2, r3
9000e4e0:	2b05      	cmp	r3, #5
9000e4e2:	d908      	bls.n	9000e4f6 <HAL_MDMA_Init+0x5a>
    {
      /* Update error code */
      hmdma->ErrorCode = HAL_MDMA_ERROR_TIMEOUT;
9000e4e4:	687b      	ldr	r3, [r7, #4]
9000e4e6:	2240      	movs	r2, #64	; 0x40
9000e4e8:	669a      	str	r2, [r3, #104]	; 0x68

      /* Change the MDMA state */
      hmdma->State = HAL_MDMA_STATE_ERROR;
9000e4ea:	687b      	ldr	r3, [r7, #4]
9000e4ec:	2203      	movs	r2, #3
9000e4ee:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      return HAL_ERROR;
9000e4f2:	2301      	movs	r3, #1
9000e4f4:	e01a      	b.n	9000e52c <HAL_MDMA_Init+0x90>
  while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
9000e4f6:	687b      	ldr	r3, [r7, #4]
9000e4f8:	681b      	ldr	r3, [r3, #0]
9000e4fa:	68db      	ldr	r3, [r3, #12]
9000e4fc:	f003 0301 	and.w	r3, r3, #1
9000e500:	2b00      	cmp	r3, #0
9000e502:	d1e8      	bne.n	9000e4d6 <HAL_MDMA_Init+0x3a>
    }
  }

  /* Initialize the MDMA channel registers */
  MDMA_Init(hmdma);
9000e504:	6878      	ldr	r0, [r7, #4]
9000e506:	f000 fab5 	bl	9000ea74 <MDMA_Init>

  /* Reset the MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
9000e50a:	687b      	ldr	r3, [r7, #4]
9000e50c:	2200      	movs	r2, #0
9000e50e:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
9000e510:	687b      	ldr	r3, [r7, #4]
9000e512:	2200      	movs	r2, #0
9000e514:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
9000e516:	687b      	ldr	r3, [r7, #4]
9000e518:	2200      	movs	r2, #0
9000e51a:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
9000e51c:	687b      	ldr	r3, [r7, #4]
9000e51e:	2200      	movs	r2, #0
9000e520:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_READY;
9000e522:	687b      	ldr	r3, [r7, #4]
9000e524:	2201      	movs	r2, #1
9000e526:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
9000e52a:	2300      	movs	r3, #0
}
9000e52c:	4618      	mov	r0, r3
9000e52e:	3710      	adds	r7, #16
9000e530:	46bd      	mov	sp, r7
9000e532:	bd80      	pop	{r7, pc}

9000e534 <HAL_MDMA_DeInit>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_DeInit(MDMA_HandleTypeDef *hmdma)
{
9000e534:	b480      	push	{r7}
9000e536:	b083      	sub	sp, #12
9000e538:	af00      	add	r7, sp, #0
9000e53a:	6078      	str	r0, [r7, #4]

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
9000e53c:	687b      	ldr	r3, [r7, #4]
9000e53e:	2b00      	cmp	r3, #0
9000e540:	d101      	bne.n	9000e546 <HAL_MDMA_DeInit+0x12>
  {
    return HAL_ERROR;
9000e542:	2301      	movs	r3, #1
9000e544:	e048      	b.n	9000e5d8 <HAL_MDMA_DeInit+0xa4>
  }

  /* Disable the selected MDMA Channelx */
  __HAL_MDMA_DISABLE(hmdma);
9000e546:	687b      	ldr	r3, [r7, #4]
9000e548:	681b      	ldr	r3, [r3, #0]
9000e54a:	68da      	ldr	r2, [r3, #12]
9000e54c:	687b      	ldr	r3, [r7, #4]
9000e54e:	681b      	ldr	r3, [r3, #0]
9000e550:	f022 0201 	bic.w	r2, r2, #1
9000e554:	60da      	str	r2, [r3, #12]

  /* Reset MDMA Channel control register */
  hmdma->Instance->CCR  = 0;
9000e556:	687b      	ldr	r3, [r7, #4]
9000e558:	681b      	ldr	r3, [r3, #0]
9000e55a:	2200      	movs	r2, #0
9000e55c:	60da      	str	r2, [r3, #12]
  hmdma->Instance->CTCR = 0;
9000e55e:	687b      	ldr	r3, [r7, #4]
9000e560:	681b      	ldr	r3, [r3, #0]
9000e562:	2200      	movs	r2, #0
9000e564:	611a      	str	r2, [r3, #16]
  hmdma->Instance->CBNDTR = 0;
9000e566:	687b      	ldr	r3, [r7, #4]
9000e568:	681b      	ldr	r3, [r3, #0]
9000e56a:	2200      	movs	r2, #0
9000e56c:	615a      	str	r2, [r3, #20]
  hmdma->Instance->CSAR = 0;
9000e56e:	687b      	ldr	r3, [r7, #4]
9000e570:	681b      	ldr	r3, [r3, #0]
9000e572:	2200      	movs	r2, #0
9000e574:	619a      	str	r2, [r3, #24]
  hmdma->Instance->CDAR = 0;
9000e576:	687b      	ldr	r3, [r7, #4]
9000e578:	681b      	ldr	r3, [r3, #0]
9000e57a:	2200      	movs	r2, #0
9000e57c:	61da      	str	r2, [r3, #28]
  hmdma->Instance->CBRUR = 0;
9000e57e:	687b      	ldr	r3, [r7, #4]
9000e580:	681b      	ldr	r3, [r3, #0]
9000e582:	2200      	movs	r2, #0
9000e584:	621a      	str	r2, [r3, #32]
  hmdma->Instance->CLAR = 0;
9000e586:	687b      	ldr	r3, [r7, #4]
9000e588:	681b      	ldr	r3, [r3, #0]
9000e58a:	2200      	movs	r2, #0
9000e58c:	625a      	str	r2, [r3, #36]	; 0x24
  hmdma->Instance->CTBR = 0;
9000e58e:	687b      	ldr	r3, [r7, #4]
9000e590:	681b      	ldr	r3, [r3, #0]
9000e592:	2200      	movs	r2, #0
9000e594:	629a      	str	r2, [r3, #40]	; 0x28
  hmdma->Instance->CMAR = 0;
9000e596:	687b      	ldr	r3, [r7, #4]
9000e598:	681b      	ldr	r3, [r3, #0]
9000e59a:	2200      	movs	r2, #0
9000e59c:	631a      	str	r2, [r3, #48]	; 0x30
  hmdma->Instance->CMDR = 0;
9000e59e:	687b      	ldr	r3, [r7, #4]
9000e5a0:	681b      	ldr	r3, [r3, #0]
9000e5a2:	2200      	movs	r2, #0
9000e5a4:	635a      	str	r2, [r3, #52]	; 0x34

  /* Clear all flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma,(MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_FLAG_BRT | MDMA_FLAG_BT | MDMA_FLAG_BFTC));
9000e5a6:	687b      	ldr	r3, [r7, #4]
9000e5a8:	681b      	ldr	r3, [r3, #0]
9000e5aa:	221f      	movs	r2, #31
9000e5ac:	605a      	str	r2, [r3, #4]

  /* Reset the  MDMA first/last linkedlist node addresses and node counter */
  hmdma->FirstLinkedListNodeAddress  = 0;
9000e5ae:	687b      	ldr	r3, [r7, #4]
9000e5b0:	2200      	movs	r2, #0
9000e5b2:	65da      	str	r2, [r3, #92]	; 0x5c
  hmdma->LastLinkedListNodeAddress   = 0;
9000e5b4:	687b      	ldr	r3, [r7, #4]
9000e5b6:	2200      	movs	r2, #0
9000e5b8:	661a      	str	r2, [r3, #96]	; 0x60
  hmdma->LinkedListNodeCounter  = 0;
9000e5ba:	687b      	ldr	r3, [r7, #4]
9000e5bc:	2200      	movs	r2, #0
9000e5be:	665a      	str	r2, [r3, #100]	; 0x64

  /* Initialize the error code */
  hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
9000e5c0:	687b      	ldr	r3, [r7, #4]
9000e5c2:	2200      	movs	r2, #0
9000e5c4:	669a      	str	r2, [r3, #104]	; 0x68

  /* Initialize the MDMA state */
  hmdma->State = HAL_MDMA_STATE_RESET;
9000e5c6:	687b      	ldr	r3, [r7, #4]
9000e5c8:	2200      	movs	r2, #0
9000e5ca:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(hmdma);
9000e5ce:	687b      	ldr	r3, [r7, #4]
9000e5d0:	2200      	movs	r2, #0
9000e5d2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
9000e5d6:	2300      	movs	r3, #0
}
9000e5d8:	4618      	mov	r0, r3
9000e5da:	370c      	adds	r7, #12
9000e5dc:	46bd      	mov	sp, r7
9000e5de:	f85d 7b04 	ldr.w	r7, [sp], #4
9000e5e2:	4770      	bx	lr

9000e5e4 <HAL_MDMA_Start_IT>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount      : The number of a blocks to be transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MDMA_Start_IT(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
9000e5e4:	b580      	push	{r7, lr}
9000e5e6:	b086      	sub	sp, #24
9000e5e8:	af02      	add	r7, sp, #8
9000e5ea:	60f8      	str	r0, [r7, #12]
9000e5ec:	60b9      	str	r1, [r7, #8]
9000e5ee:	607a      	str	r2, [r7, #4]
9000e5f0:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_MDMA_TRANSFER_LENGTH(BlockDataLength));
  assert_param(IS_MDMA_BLOCK_COUNT(BlockCount));

  /* Check the MDMA peripheral handle */
  if(hmdma == NULL)
9000e5f2:	68fb      	ldr	r3, [r7, #12]
9000e5f4:	2b00      	cmp	r3, #0
9000e5f6:	d101      	bne.n	9000e5fc <HAL_MDMA_Start_IT+0x18>
  {
    return HAL_ERROR;
9000e5f8:	2301      	movs	r3, #1
9000e5fa:	e070      	b.n	9000e6de <HAL_MDMA_Start_IT+0xfa>
  }

  /* Process locked */
  __HAL_LOCK(hmdma);
9000e5fc:	68fb      	ldr	r3, [r7, #12]
9000e5fe:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
9000e602:	2b01      	cmp	r3, #1
9000e604:	d101      	bne.n	9000e60a <HAL_MDMA_Start_IT+0x26>
9000e606:	2302      	movs	r3, #2
9000e608:	e069      	b.n	9000e6de <HAL_MDMA_Start_IT+0xfa>
9000e60a:	68fb      	ldr	r3, [r7, #12]
9000e60c:	2201      	movs	r2, #1
9000e60e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  if(HAL_MDMA_STATE_READY == hmdma->State)
9000e612:	68fb      	ldr	r3, [r7, #12]
9000e614:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
9000e618:	b2db      	uxtb	r3, r3
9000e61a:	2b01      	cmp	r3, #1
9000e61c:	d158      	bne.n	9000e6d0 <HAL_MDMA_Start_IT+0xec>
  {
    /* Change MDMA peripheral state */
    hmdma->State = HAL_MDMA_STATE_BUSY;
9000e61e:	68fb      	ldr	r3, [r7, #12]
9000e620:	2202      	movs	r2, #2
9000e622:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Initialize the error code */
    hmdma->ErrorCode = HAL_MDMA_ERROR_NONE;
9000e626:	68fb      	ldr	r3, [r7, #12]
9000e628:	2200      	movs	r2, #0
9000e62a:	669a      	str	r2, [r3, #104]	; 0x68

    /* Disable the peripheral */
    __HAL_MDMA_DISABLE(hmdma);
9000e62c:	68fb      	ldr	r3, [r7, #12]
9000e62e:	681b      	ldr	r3, [r3, #0]
9000e630:	68da      	ldr	r2, [r3, #12]
9000e632:	68fb      	ldr	r3, [r7, #12]
9000e634:	681b      	ldr	r3, [r3, #0]
9000e636:	f022 0201 	bic.w	r2, r2, #1
9000e63a:	60da      	str	r2, [r3, #12]

    /* Configure the source, destination address and the data length */
    MDMA_SetConfig(hmdma, SrcAddress, DstAddress, BlockDataLength, BlockCount);
9000e63c:	69bb      	ldr	r3, [r7, #24]
9000e63e:	9300      	str	r3, [sp, #0]
9000e640:	683b      	ldr	r3, [r7, #0]
9000e642:	687a      	ldr	r2, [r7, #4]
9000e644:	68b9      	ldr	r1, [r7, #8]
9000e646:	68f8      	ldr	r0, [r7, #12]
9000e648:	f000 f9a4 	bl	9000e994 <MDMA_SetConfig>

    /* Enable Common interrupts i.e Transfer Error IT and Channel Transfer Complete IT*/
    __HAL_MDMA_ENABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC));
9000e64c:	68fb      	ldr	r3, [r7, #12]
9000e64e:	681b      	ldr	r3, [r3, #0]
9000e650:	68da      	ldr	r2, [r3, #12]
9000e652:	68fb      	ldr	r3, [r7, #12]
9000e654:	681b      	ldr	r3, [r3, #0]
9000e656:	f042 0206 	orr.w	r2, r2, #6
9000e65a:	60da      	str	r2, [r3, #12]

    if(hmdma->XferBlockCpltCallback != NULL)
9000e65c:	68fb      	ldr	r3, [r7, #12]
9000e65e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000e660:	2b00      	cmp	r3, #0
9000e662:	d007      	beq.n	9000e674 <HAL_MDMA_Start_IT+0x90>
    {
      /* if Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BT);
9000e664:	68fb      	ldr	r3, [r7, #12]
9000e666:	681b      	ldr	r3, [r3, #0]
9000e668:	68da      	ldr	r2, [r3, #12]
9000e66a:	68fb      	ldr	r3, [r7, #12]
9000e66c:	681b      	ldr	r3, [r3, #0]
9000e66e:	f042 0210 	orr.w	r2, r2, #16
9000e672:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferRepeatBlockCpltCallback != NULL)
9000e674:	68fb      	ldr	r3, [r7, #12]
9000e676:	6d1b      	ldr	r3, [r3, #80]	; 0x50
9000e678:	2b00      	cmp	r3, #0
9000e67a:	d007      	beq.n	9000e68c <HAL_MDMA_Start_IT+0xa8>
    {
      /* if Repeated Block transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BRT);
9000e67c:	68fb      	ldr	r3, [r7, #12]
9000e67e:	681b      	ldr	r3, [r3, #0]
9000e680:	68da      	ldr	r2, [r3, #12]
9000e682:	68fb      	ldr	r3, [r7, #12]
9000e684:	681b      	ldr	r3, [r3, #0]
9000e686:	f042 0208 	orr.w	r2, r2, #8
9000e68a:	60da      	str	r2, [r3, #12]
    }

    if(hmdma->XferBufferCpltCallback != NULL)
9000e68c:	68fb      	ldr	r3, [r7, #12]
9000e68e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
9000e690:	2b00      	cmp	r3, #0
9000e692:	d007      	beq.n	9000e6a4 <HAL_MDMA_Start_IT+0xc0>
    {
      /* if buffer transfer complete Callback is set enable the corresponding IT*/
      __HAL_MDMA_ENABLE_IT(hmdma, MDMA_IT_BFTC);
9000e694:	68fb      	ldr	r3, [r7, #12]
9000e696:	681b      	ldr	r3, [r3, #0]
9000e698:	68da      	ldr	r2, [r3, #12]
9000e69a:	68fb      	ldr	r3, [r7, #12]
9000e69c:	681b      	ldr	r3, [r3, #0]
9000e69e:	f042 0220 	orr.w	r2, r2, #32
9000e6a2:	60da      	str	r2, [r3, #12]
    }

    /* Enable the Peripheral */
    __HAL_MDMA_ENABLE(hmdma);
9000e6a4:	68fb      	ldr	r3, [r7, #12]
9000e6a6:	681b      	ldr	r3, [r3, #0]
9000e6a8:	68da      	ldr	r2, [r3, #12]
9000e6aa:	68fb      	ldr	r3, [r7, #12]
9000e6ac:	681b      	ldr	r3, [r3, #0]
9000e6ae:	f042 0201 	orr.w	r2, r2, #1
9000e6b2:	60da      	str	r2, [r3, #12]

    if(hmdma->Init.Request == MDMA_REQUEST_SW)
9000e6b4:	68fb      	ldr	r3, [r7, #12]
9000e6b6:	685b      	ldr	r3, [r3, #4]
9000e6b8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
9000e6bc:	d10e      	bne.n	9000e6dc <HAL_MDMA_Start_IT+0xf8>
    {
      /* activate If SW request mode*/
      hmdma->Instance->CCR |=  MDMA_CCR_SWRQ;
9000e6be:	68fb      	ldr	r3, [r7, #12]
9000e6c0:	681b      	ldr	r3, [r3, #0]
9000e6c2:	68da      	ldr	r2, [r3, #12]
9000e6c4:	68fb      	ldr	r3, [r7, #12]
9000e6c6:	681b      	ldr	r3, [r3, #0]
9000e6c8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
9000e6cc:	60da      	str	r2, [r3, #12]
9000e6ce:	e005      	b.n	9000e6dc <HAL_MDMA_Start_IT+0xf8>
    }
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hmdma);
9000e6d0:	68fb      	ldr	r3, [r7, #12]
9000e6d2:	2200      	movs	r2, #0
9000e6d4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    /* Return error status */
    return HAL_BUSY;
9000e6d8:	2302      	movs	r3, #2
9000e6da:	e000      	b.n	9000e6de <HAL_MDMA_Start_IT+0xfa>
  }

  return HAL_OK;
9000e6dc:	2300      	movs	r3, #0
}
9000e6de:	4618      	mov	r0, r3
9000e6e0:	3710      	adds	r7, #16
9000e6e2:	46bd      	mov	sp, r7
9000e6e4:	bd80      	pop	{r7, pc}
	...

9000e6e8 <HAL_MDMA_IRQHandler>:
  * @param  hmdma: pointer to a MDMA_HandleTypeDef structure that contains
  *               the configuration information for the specified MDMA Channel.
  * @retval None
  */
void HAL_MDMA_IRQHandler(MDMA_HandleTypeDef *hmdma)
{
9000e6e8:	b580      	push	{r7, lr}
9000e6ea:	b086      	sub	sp, #24
9000e6ec:	af00      	add	r7, sp, #0
9000e6ee:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0;
9000e6f0:	2300      	movs	r3, #0
9000e6f2:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600U;
9000e6f4:	4b9a      	ldr	r3, [pc, #616]	; (9000e960 <HAL_MDMA_IRQHandler+0x278>)
9000e6f6:	681b      	ldr	r3, [r3, #0]
9000e6f8:	4a9a      	ldr	r2, [pc, #616]	; (9000e964 <HAL_MDMA_IRQHandler+0x27c>)
9000e6fa:	fba2 2303 	umull	r2, r3, r2, r3
9000e6fe:	0a9b      	lsrs	r3, r3, #10
9000e700:	617b      	str	r3, [r7, #20]

  uint32_t generalIntFlag, errorFlag;

  /* General Interrupt Flag management ****************************************/
  generalIntFlag =  1UL << ((((uint32_t)hmdma->Instance - (uint32_t)(MDMA_Channel0))/HAL_MDMA_CHANNEL_SIZE) & 0x1FU);
9000e702:	687b      	ldr	r3, [r7, #4]
9000e704:	681b      	ldr	r3, [r3, #0]
9000e706:	461a      	mov	r2, r3
9000e708:	4b97      	ldr	r3, [pc, #604]	; (9000e968 <HAL_MDMA_IRQHandler+0x280>)
9000e70a:	4413      	add	r3, r2
9000e70c:	099b      	lsrs	r3, r3, #6
9000e70e:	f003 031f 	and.w	r3, r3, #31
9000e712:	2201      	movs	r2, #1
9000e714:	fa02 f303 	lsl.w	r3, r2, r3
9000e718:	613b      	str	r3, [r7, #16]
  if((MDMA->GISR0 & generalIntFlag) == 0U)
9000e71a:	f04f 43a4 	mov.w	r3, #1375731712	; 0x52000000
9000e71e:	681a      	ldr	r2, [r3, #0]
9000e720:	693b      	ldr	r3, [r7, #16]
9000e722:	4013      	ands	r3, r2
9000e724:	2b00      	cmp	r3, #0
9000e726:	f000 812e 	beq.w	9000e986 <HAL_MDMA_IRQHandler+0x29e>
  {
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
  }

  /* Transfer Error Interrupt management ***************************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_TE) != 0U))
9000e72a:	687b      	ldr	r3, [r7, #4]
9000e72c:	681b      	ldr	r3, [r3, #0]
9000e72e:	681b      	ldr	r3, [r3, #0]
9000e730:	f003 0301 	and.w	r3, r3, #1
9000e734:	2b00      	cmp	r3, #0
9000e736:	d054      	beq.n	9000e7e2 <HAL_MDMA_IRQHandler+0xfa>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_TE) != 0U)
9000e738:	687b      	ldr	r3, [r7, #4]
9000e73a:	681b      	ldr	r3, [r3, #0]
9000e73c:	68db      	ldr	r3, [r3, #12]
9000e73e:	f003 0302 	and.w	r3, r3, #2
9000e742:	2b00      	cmp	r3, #0
9000e744:	d04d      	beq.n	9000e7e2 <HAL_MDMA_IRQHandler+0xfa>
    {
      /* Disable the transfer error interrupt */
      __HAL_MDMA_DISABLE_IT(hmdma, MDMA_IT_TE);
9000e746:	687b      	ldr	r3, [r7, #4]
9000e748:	681b      	ldr	r3, [r3, #0]
9000e74a:	68da      	ldr	r2, [r3, #12]
9000e74c:	687b      	ldr	r3, [r7, #4]
9000e74e:	681b      	ldr	r3, [r3, #0]
9000e750:	f022 0202 	bic.w	r2, r2, #2
9000e754:	60da      	str	r2, [r3, #12]

      /* Get the transfer error source flag */
      errorFlag = hmdma->Instance->CESR;
9000e756:	687b      	ldr	r3, [r7, #4]
9000e758:	681b      	ldr	r3, [r3, #0]
9000e75a:	689b      	ldr	r3, [r3, #8]
9000e75c:	60fb      	str	r3, [r7, #12]

      if((errorFlag & MDMA_CESR_TED) == 0U)
9000e75e:	68fb      	ldr	r3, [r7, #12]
9000e760:	f003 0380 	and.w	r3, r3, #128	; 0x80
9000e764:	2b00      	cmp	r3, #0
9000e766:	d106      	bne.n	9000e776 <HAL_MDMA_IRQHandler+0x8e>
      {
        /* Update error code : Read Transfer error  */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_READ_XFER;
9000e768:	687b      	ldr	r3, [r7, #4]
9000e76a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
9000e76c:	f043 0201 	orr.w	r2, r3, #1
9000e770:	687b      	ldr	r3, [r7, #4]
9000e772:	669a      	str	r2, [r3, #104]	; 0x68
9000e774:	e005      	b.n	9000e782 <HAL_MDMA_IRQHandler+0x9a>
      }
      else
      {
        /* Update error code : Write Transfer error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_WRITE_XFER;
9000e776:	687b      	ldr	r3, [r7, #4]
9000e778:	6e9b      	ldr	r3, [r3, #104]	; 0x68
9000e77a:	f043 0202 	orr.w	r2, r3, #2
9000e77e:	687b      	ldr	r3, [r7, #4]
9000e780:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TEMD) != 0U)
9000e782:	68fb      	ldr	r3, [r7, #12]
9000e784:	f403 7300 	and.w	r3, r3, #512	; 0x200
9000e788:	2b00      	cmp	r3, #0
9000e78a:	d005      	beq.n	9000e798 <HAL_MDMA_IRQHandler+0xb0>
      {
        /* Update error code : Error Mask Data */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_MASK_DATA;
9000e78c:	687b      	ldr	r3, [r7, #4]
9000e78e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
9000e790:	f043 0204 	orr.w	r2, r3, #4
9000e794:	687b      	ldr	r3, [r7, #4]
9000e796:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_TELD) != 0U)
9000e798:	68fb      	ldr	r3, [r7, #12]
9000e79a:	f403 7380 	and.w	r3, r3, #256	; 0x100
9000e79e:	2b00      	cmp	r3, #0
9000e7a0:	d005      	beq.n	9000e7ae <HAL_MDMA_IRQHandler+0xc6>
      {
        /* Update error code : Error Linked list */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_LINKED_LIST;
9000e7a2:	687b      	ldr	r3, [r7, #4]
9000e7a4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
9000e7a6:	f043 0208 	orr.w	r2, r3, #8
9000e7aa:	687b      	ldr	r3, [r7, #4]
9000e7ac:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_ASE) != 0U)
9000e7ae:	68fb      	ldr	r3, [r7, #12]
9000e7b0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
9000e7b4:	2b00      	cmp	r3, #0
9000e7b6:	d005      	beq.n	9000e7c4 <HAL_MDMA_IRQHandler+0xdc>
      {
        /* Update error code : Address/Size alignment error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_ALIGNMENT;
9000e7b8:	687b      	ldr	r3, [r7, #4]
9000e7ba:	6e9b      	ldr	r3, [r3, #104]	; 0x68
9000e7bc:	f043 0210 	orr.w	r2, r3, #16
9000e7c0:	687b      	ldr	r3, [r7, #4]
9000e7c2:	669a      	str	r2, [r3, #104]	; 0x68
      }

      if((errorFlag & MDMA_CESR_BSE) != 0U)
9000e7c4:	68fb      	ldr	r3, [r7, #12]
9000e7c6:	f403 6300 	and.w	r3, r3, #2048	; 0x800
9000e7ca:	2b00      	cmp	r3, #0
9000e7cc:	d005      	beq.n	9000e7da <HAL_MDMA_IRQHandler+0xf2>
      {
        /* Update error code : Block Size error error */
        hmdma->ErrorCode |= HAL_MDMA_ERROR_BLOCK_SIZE;
9000e7ce:	687b      	ldr	r3, [r7, #4]
9000e7d0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
9000e7d2:	f043 0220 	orr.w	r2, r3, #32
9000e7d6:	687b      	ldr	r3, [r7, #4]
9000e7d8:	669a      	str	r2, [r3, #104]	; 0x68
      }

      /* Clear the transfer error flags */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE);
9000e7da:	687b      	ldr	r3, [r7, #4]
9000e7dc:	681b      	ldr	r3, [r3, #0]
9000e7de:	2201      	movs	r2, #1
9000e7e0:	605a      	str	r2, [r3, #4]
    }
  }

  /* Buffer Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BFTC) != 0U))
9000e7e2:	687b      	ldr	r3, [r7, #4]
9000e7e4:	681b      	ldr	r3, [r3, #0]
9000e7e6:	681b      	ldr	r3, [r3, #0]
9000e7e8:	f003 0310 	and.w	r3, r3, #16
9000e7ec:	2b00      	cmp	r3, #0
9000e7ee:	d012      	beq.n	9000e816 <HAL_MDMA_IRQHandler+0x12e>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BFTC) != 0U)
9000e7f0:	687b      	ldr	r3, [r7, #4]
9000e7f2:	681b      	ldr	r3, [r3, #0]
9000e7f4:	68db      	ldr	r3, [r3, #12]
9000e7f6:	f003 0320 	and.w	r3, r3, #32
9000e7fa:	2b00      	cmp	r3, #0
9000e7fc:	d00b      	beq.n	9000e816 <HAL_MDMA_IRQHandler+0x12e>
    {
      /* Clear the buffer transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BFTC);
9000e7fe:	687b      	ldr	r3, [r7, #4]
9000e800:	681b      	ldr	r3, [r3, #0]
9000e802:	2210      	movs	r2, #16
9000e804:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBufferCpltCallback != NULL)
9000e806:	687b      	ldr	r3, [r7, #4]
9000e808:	6c9b      	ldr	r3, [r3, #72]	; 0x48
9000e80a:	2b00      	cmp	r3, #0
9000e80c:	d003      	beq.n	9000e816 <HAL_MDMA_IRQHandler+0x12e>
      {
        /* Buffer transfer callback */
        hmdma->XferBufferCpltCallback(hmdma);
9000e80e:	687b      	ldr	r3, [r7, #4]
9000e810:	6c9b      	ldr	r3, [r3, #72]	; 0x48
9000e812:	6878      	ldr	r0, [r7, #4]
9000e814:	4798      	blx	r3
      }
    }
  }

  /* Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BT) != 0U))
9000e816:	687b      	ldr	r3, [r7, #4]
9000e818:	681b      	ldr	r3, [r3, #0]
9000e81a:	681b      	ldr	r3, [r3, #0]
9000e81c:	f003 0308 	and.w	r3, r3, #8
9000e820:	2b00      	cmp	r3, #0
9000e822:	d012      	beq.n	9000e84a <HAL_MDMA_IRQHandler+0x162>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BT) != 0U)
9000e824:	687b      	ldr	r3, [r7, #4]
9000e826:	681b      	ldr	r3, [r3, #0]
9000e828:	68db      	ldr	r3, [r3, #12]
9000e82a:	f003 0310 	and.w	r3, r3, #16
9000e82e:	2b00      	cmp	r3, #0
9000e830:	d00b      	beq.n	9000e84a <HAL_MDMA_IRQHandler+0x162>
    {
      /* Clear the block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BT);
9000e832:	687b      	ldr	r3, [r7, #4]
9000e834:	681b      	ldr	r3, [r3, #0]
9000e836:	2208      	movs	r2, #8
9000e838:	605a      	str	r2, [r3, #4]

      if(hmdma->XferBlockCpltCallback != NULL)
9000e83a:	687b      	ldr	r3, [r7, #4]
9000e83c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000e83e:	2b00      	cmp	r3, #0
9000e840:	d003      	beq.n	9000e84a <HAL_MDMA_IRQHandler+0x162>
      {
        /* Block transfer callback */
        hmdma->XferBlockCpltCallback(hmdma);
9000e842:	687b      	ldr	r3, [r7, #4]
9000e844:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000e846:	6878      	ldr	r0, [r7, #4]
9000e848:	4798      	blx	r3
      }
    }
  }

  /* Repeated Block Transfer Complete Interrupt management ******************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_BRT) != 0U))
9000e84a:	687b      	ldr	r3, [r7, #4]
9000e84c:	681b      	ldr	r3, [r3, #0]
9000e84e:	681b      	ldr	r3, [r3, #0]
9000e850:	f003 0304 	and.w	r3, r3, #4
9000e854:	2b00      	cmp	r3, #0
9000e856:	d012      	beq.n	9000e87e <HAL_MDMA_IRQHandler+0x196>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_BRT) != 0U)
9000e858:	687b      	ldr	r3, [r7, #4]
9000e85a:	681b      	ldr	r3, [r3, #0]
9000e85c:	68db      	ldr	r3, [r3, #12]
9000e85e:	f003 0308 	and.w	r3, r3, #8
9000e862:	2b00      	cmp	r3, #0
9000e864:	d00b      	beq.n	9000e87e <HAL_MDMA_IRQHandler+0x196>
    {
      /* Clear the repeat block transfer complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_BRT);
9000e866:	687b      	ldr	r3, [r7, #4]
9000e868:	681b      	ldr	r3, [r3, #0]
9000e86a:	2204      	movs	r2, #4
9000e86c:	605a      	str	r2, [r3, #4]

      if(hmdma->XferRepeatBlockCpltCallback != NULL)
9000e86e:	687b      	ldr	r3, [r7, #4]
9000e870:	6d1b      	ldr	r3, [r3, #80]	; 0x50
9000e872:	2b00      	cmp	r3, #0
9000e874:	d003      	beq.n	9000e87e <HAL_MDMA_IRQHandler+0x196>
      {
        /* Repeated Block transfer callback */
        hmdma->XferRepeatBlockCpltCallback(hmdma);
9000e876:	687b      	ldr	r3, [r7, #4]
9000e878:	6d1b      	ldr	r3, [r3, #80]	; 0x50
9000e87a:	6878      	ldr	r0, [r7, #4]
9000e87c:	4798      	blx	r3
      }
    }
  }

  /* Channel Transfer Complete Interrupt management ***********************************/
  if((__HAL_MDMA_GET_FLAG(hmdma, MDMA_FLAG_CTC) != 0U))
9000e87e:	687b      	ldr	r3, [r7, #4]
9000e880:	681b      	ldr	r3, [r3, #0]
9000e882:	681b      	ldr	r3, [r3, #0]
9000e884:	f003 0302 	and.w	r3, r3, #2
9000e888:	2b00      	cmp	r3, #0
9000e88a:	d039      	beq.n	9000e900 <HAL_MDMA_IRQHandler+0x218>
  {
    if(__HAL_MDMA_GET_IT_SOURCE(hmdma, MDMA_IT_CTC) != 0U)
9000e88c:	687b      	ldr	r3, [r7, #4]
9000e88e:	681b      	ldr	r3, [r3, #0]
9000e890:	68db      	ldr	r3, [r3, #12]
9000e892:	f003 0304 	and.w	r3, r3, #4
9000e896:	2b00      	cmp	r3, #0
9000e898:	d032      	beq.n	9000e900 <HAL_MDMA_IRQHandler+0x218>
    {
      /* Disable all the transfer interrupts */
      __HAL_MDMA_DISABLE_IT(hmdma, (MDMA_IT_TE | MDMA_IT_CTC | MDMA_IT_BT | MDMA_IT_BRT | MDMA_IT_BFTC));
9000e89a:	687b      	ldr	r3, [r7, #4]
9000e89c:	681b      	ldr	r3, [r3, #0]
9000e89e:	68da      	ldr	r2, [r3, #12]
9000e8a0:	687b      	ldr	r3, [r7, #4]
9000e8a2:	681b      	ldr	r3, [r3, #0]
9000e8a4:	f022 023e 	bic.w	r2, r2, #62	; 0x3e
9000e8a8:	60da      	str	r2, [r3, #12]

      if(HAL_MDMA_STATE_ABORT == hmdma->State)
9000e8aa:	687b      	ldr	r3, [r7, #4]
9000e8ac:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
9000e8b0:	b2db      	uxtb	r3, r3
9000e8b2:	2b04      	cmp	r3, #4
9000e8b4:	d110      	bne.n	9000e8d8 <HAL_MDMA_IRQHandler+0x1f0>
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hmdma);
9000e8b6:	687b      	ldr	r3, [r7, #4]
9000e8b8:	2200      	movs	r2, #0
9000e8ba:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

        /* Change the DMA state */
        hmdma->State = HAL_MDMA_STATE_READY;
9000e8be:	687b      	ldr	r3, [r7, #4]
9000e8c0:	2201      	movs	r2, #1
9000e8c2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

        if(hmdma->XferAbortCallback != NULL)
9000e8c6:	687b      	ldr	r3, [r7, #4]
9000e8c8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000e8ca:	2b00      	cmp	r3, #0
9000e8cc:	d05d      	beq.n	9000e98a <HAL_MDMA_IRQHandler+0x2a2>
        {
          hmdma->XferAbortCallback(hmdma);
9000e8ce:	687b      	ldr	r3, [r7, #4]
9000e8d0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000e8d2:	6878      	ldr	r0, [r7, #4]
9000e8d4:	4798      	blx	r3
        }
        return;
9000e8d6:	e058      	b.n	9000e98a <HAL_MDMA_IRQHandler+0x2a2>
      }

      /* Clear the Channel Transfer Complete flag */
      __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_CTC);
9000e8d8:	687b      	ldr	r3, [r7, #4]
9000e8da:	681b      	ldr	r3, [r3, #0]
9000e8dc:	2202      	movs	r2, #2
9000e8de:	605a      	str	r2, [r3, #4]

      /* Process Unlocked */
      __HAL_UNLOCK(hmdma);
9000e8e0:	687b      	ldr	r3, [r7, #4]
9000e8e2:	2200      	movs	r2, #0
9000e8e4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

      /* Change MDMA peripheral state */
      hmdma->State = HAL_MDMA_STATE_READY;
9000e8e8:	687b      	ldr	r3, [r7, #4]
9000e8ea:	2201      	movs	r2, #1
9000e8ec:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

      if(hmdma->XferCpltCallback != NULL)
9000e8f0:	687b      	ldr	r3, [r7, #4]
9000e8f2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000e8f4:	2b00      	cmp	r3, #0
9000e8f6:	d003      	beq.n	9000e900 <HAL_MDMA_IRQHandler+0x218>
      {
        /* Channel Transfer Complete callback */
        hmdma->XferCpltCallback(hmdma);
9000e8f8:	687b      	ldr	r3, [r7, #4]
9000e8fa:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000e8fc:	6878      	ldr	r0, [r7, #4]
9000e8fe:	4798      	blx	r3
      }
    }
  }

  /* manage error case */
  if(hmdma->ErrorCode != HAL_MDMA_ERROR_NONE)
9000e900:	687b      	ldr	r3, [r7, #4]
9000e902:	6e9b      	ldr	r3, [r3, #104]	; 0x68
9000e904:	2b00      	cmp	r3, #0
9000e906:	d041      	beq.n	9000e98c <HAL_MDMA_IRQHandler+0x2a4>
  {
    hmdma->State = HAL_MDMA_STATE_ABORT;
9000e908:	687b      	ldr	r3, [r7, #4]
9000e90a:	2204      	movs	r2, #4
9000e90c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

    /* Disable the channel */
    __HAL_MDMA_DISABLE(hmdma);
9000e910:	687b      	ldr	r3, [r7, #4]
9000e912:	681b      	ldr	r3, [r3, #0]
9000e914:	68da      	ldr	r2, [r3, #12]
9000e916:	687b      	ldr	r3, [r7, #4]
9000e918:	681b      	ldr	r3, [r3, #0]
9000e91a:	f022 0201 	bic.w	r2, r2, #1
9000e91e:	60da      	str	r2, [r3, #12]

    do
    {
      if (++count > timeout)
9000e920:	68bb      	ldr	r3, [r7, #8]
9000e922:	3301      	adds	r3, #1
9000e924:	60bb      	str	r3, [r7, #8]
9000e926:	697a      	ldr	r2, [r7, #20]
9000e928:	429a      	cmp	r2, r3
9000e92a:	d307      	bcc.n	9000e93c <HAL_MDMA_IRQHandler+0x254>
      {
        break;
      }
    }
    while((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U);
9000e92c:	687b      	ldr	r3, [r7, #4]
9000e92e:	681b      	ldr	r3, [r3, #0]
9000e930:	68db      	ldr	r3, [r3, #12]
9000e932:	f003 0301 	and.w	r3, r3, #1
9000e936:	2b00      	cmp	r3, #0
9000e938:	d1f2      	bne.n	9000e920 <HAL_MDMA_IRQHandler+0x238>
9000e93a:	e000      	b.n	9000e93e <HAL_MDMA_IRQHandler+0x256>
        break;
9000e93c:	bf00      	nop

    /* Process Unlocked */
    __HAL_UNLOCK(hmdma);
9000e93e:	687b      	ldr	r3, [r7, #4]
9000e940:	2200      	movs	r2, #0
9000e942:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

    if((hmdma->Instance->CCR & MDMA_CCR_EN) != 0U)
9000e946:	687b      	ldr	r3, [r7, #4]
9000e948:	681b      	ldr	r3, [r3, #0]
9000e94a:	68db      	ldr	r3, [r3, #12]
9000e94c:	f003 0301 	and.w	r3, r3, #1
9000e950:	2b00      	cmp	r3, #0
9000e952:	d00b      	beq.n	9000e96c <HAL_MDMA_IRQHandler+0x284>
    {
      /* Change the MDMA state to error if MDMA disable fails */
      hmdma->State = HAL_MDMA_STATE_ERROR;
9000e954:	687b      	ldr	r3, [r7, #4]
9000e956:	2203      	movs	r2, #3
9000e958:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
9000e95c:	e00a      	b.n	9000e974 <HAL_MDMA_IRQHandler+0x28c>
9000e95e:	bf00      	nop
9000e960:	24000090 	.word	0x24000090
9000e964:	1b4e81b5 	.word	0x1b4e81b5
9000e968:	adffffc0 	.word	0xadffffc0
    }
    else
    {
      /* Change the MDMA state to Ready if MDMA disable success */
      hmdma->State = HAL_MDMA_STATE_READY;
9000e96c:	687b      	ldr	r3, [r7, #4]
9000e96e:	2201      	movs	r2, #1
9000e970:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    }


    if (hmdma->XferErrorCallback != NULL)
9000e974:	687b      	ldr	r3, [r7, #4]
9000e976:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000e978:	2b00      	cmp	r3, #0
9000e97a:	d007      	beq.n	9000e98c <HAL_MDMA_IRQHandler+0x2a4>
    {
      /* Transfer error callback */
      hmdma->XferErrorCallback(hmdma);
9000e97c:	687b      	ldr	r3, [r7, #4]
9000e97e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000e980:	6878      	ldr	r0, [r7, #4]
9000e982:	4798      	blx	r3
9000e984:	e002      	b.n	9000e98c <HAL_MDMA_IRQHandler+0x2a4>
    return; /* the  General interrupt flag for the current channel is down , nothing to do */
9000e986:	bf00      	nop
9000e988:	e000      	b.n	9000e98c <HAL_MDMA_IRQHandler+0x2a4>
        return;
9000e98a:	bf00      	nop
    }
  }
}
9000e98c:	3718      	adds	r7, #24
9000e98e:	46bd      	mov	sp, r7
9000e990:	bd80      	pop	{r7, pc}
9000e992:	bf00      	nop

9000e994 <MDMA_SetConfig>:
  * @param  BlockDataLength : The length of a block transfer in bytes
  * @param  BlockCount: The number of blocks to be transferred
  * @retval HAL status
  */
static void MDMA_SetConfig(MDMA_HandleTypeDef *hmdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t BlockDataLength, uint32_t BlockCount)
{
9000e994:	b480      	push	{r7}
9000e996:	b087      	sub	sp, #28
9000e998:	af00      	add	r7, sp, #0
9000e99a:	60f8      	str	r0, [r7, #12]
9000e99c:	60b9      	str	r1, [r7, #8]
9000e99e:	607a      	str	r2, [r7, #4]
9000e9a0:	603b      	str	r3, [r7, #0]
  uint32_t addressMask;

  /* Configure the MDMA Channel data length */
  MODIFY_REG(hmdma->Instance->CBNDTR ,MDMA_CBNDTR_BNDT, (BlockDataLength & MDMA_CBNDTR_BNDT));
9000e9a2:	68fb      	ldr	r3, [r7, #12]
9000e9a4:	681b      	ldr	r3, [r3, #0]
9000e9a6:	695a      	ldr	r2, [r3, #20]
9000e9a8:	4b31      	ldr	r3, [pc, #196]	; (9000ea70 <MDMA_SetConfig+0xdc>)
9000e9aa:	4013      	ands	r3, r2
9000e9ac:	683a      	ldr	r2, [r7, #0]
9000e9ae:	f3c2 0110 	ubfx	r1, r2, #0, #17
9000e9b2:	68fa      	ldr	r2, [r7, #12]
9000e9b4:	6812      	ldr	r2, [r2, #0]
9000e9b6:	430b      	orrs	r3, r1
9000e9b8:	6153      	str	r3, [r2, #20]

  /* Configure the MDMA block repeat count */
  MODIFY_REG(hmdma->Instance->CBNDTR , MDMA_CBNDTR_BRC , ((BlockCount - 1U) << MDMA_CBNDTR_BRC_Pos) & MDMA_CBNDTR_BRC);
9000e9ba:	68fb      	ldr	r3, [r7, #12]
9000e9bc:	681b      	ldr	r3, [r3, #0]
9000e9be:	695b      	ldr	r3, [r3, #20]
9000e9c0:	f3c3 0113 	ubfx	r1, r3, #0, #20
9000e9c4:	6a3b      	ldr	r3, [r7, #32]
9000e9c6:	3b01      	subs	r3, #1
9000e9c8:	051a      	lsls	r2, r3, #20
9000e9ca:	68fb      	ldr	r3, [r7, #12]
9000e9cc:	681b      	ldr	r3, [r3, #0]
9000e9ce:	430a      	orrs	r2, r1
9000e9d0:	615a      	str	r2, [r3, #20]

  /* Clear all interrupt flags */
  __HAL_MDMA_CLEAR_FLAG(hmdma, MDMA_FLAG_TE | MDMA_FLAG_CTC | MDMA_CISR_BRTIF | MDMA_CISR_BTIF | MDMA_CISR_TCIF);
9000e9d2:	68fb      	ldr	r3, [r7, #12]
9000e9d4:	681b      	ldr	r3, [r3, #0]
9000e9d6:	221f      	movs	r2, #31
9000e9d8:	605a      	str	r2, [r3, #4]

  /* Configure MDMA Channel destination address */
  hmdma->Instance->CDAR = DstAddress;
9000e9da:	68fb      	ldr	r3, [r7, #12]
9000e9dc:	681b      	ldr	r3, [r3, #0]
9000e9de:	687a      	ldr	r2, [r7, #4]
9000e9e0:	61da      	str	r2, [r3, #28]

  /* Configure MDMA Channel Source address */
  hmdma->Instance->CSAR = SrcAddress;
9000e9e2:	68fb      	ldr	r3, [r7, #12]
9000e9e4:	681b      	ldr	r3, [r3, #0]
9000e9e6:	68ba      	ldr	r2, [r7, #8]
9000e9e8:	619a      	str	r2, [r3, #24]

  addressMask = SrcAddress & 0xFF000000U;
9000e9ea:	68bb      	ldr	r3, [r7, #8]
9000e9ec:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
9000e9f0:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
9000e9f2:	697b      	ldr	r3, [r7, #20]
9000e9f4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
9000e9f8:	d002      	beq.n	9000ea00 <MDMA_SetConfig+0x6c>
9000e9fa:	697b      	ldr	r3, [r7, #20]
9000e9fc:	2b00      	cmp	r3, #0
9000e9fe:	d108      	bne.n	9000ea12 <MDMA_SetConfig+0x7e>
  {
    /*The AHBSbus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_SBUS;
9000ea00:	68fb      	ldr	r3, [r7, #12]
9000ea02:	681b      	ldr	r3, [r3, #0]
9000ea04:	6a9a      	ldr	r2, [r3, #40]	; 0x28
9000ea06:	68fb      	ldr	r3, [r7, #12]
9000ea08:	681b      	ldr	r3, [r3, #0]
9000ea0a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
9000ea0e:	629a      	str	r2, [r3, #40]	; 0x28
9000ea10:	e007      	b.n	9000ea22 <MDMA_SetConfig+0x8e>
  }
  else
  {
    /*The AXI bus is used as source (read operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_SBUS);
9000ea12:	68fb      	ldr	r3, [r7, #12]
9000ea14:	681b      	ldr	r3, [r3, #0]
9000ea16:	6a9a      	ldr	r2, [r3, #40]	; 0x28
9000ea18:	68fb      	ldr	r3, [r7, #12]
9000ea1a:	681b      	ldr	r3, [r3, #0]
9000ea1c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
9000ea20:	629a      	str	r2, [r3, #40]	; 0x28
  }

  addressMask = DstAddress & 0xFF000000U;
9000ea22:	687b      	ldr	r3, [r7, #4]
9000ea24:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
9000ea28:	617b      	str	r3, [r7, #20]
  if((addressMask == 0x20000000U) || (addressMask == 0x00000000U))
9000ea2a:	697b      	ldr	r3, [r7, #20]
9000ea2c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
9000ea30:	d002      	beq.n	9000ea38 <MDMA_SetConfig+0xa4>
9000ea32:	697b      	ldr	r3, [r7, #20]
9000ea34:	2b00      	cmp	r3, #0
9000ea36:	d108      	bne.n	9000ea4a <MDMA_SetConfig+0xb6>
  {
    /*The AHB bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR |= MDMA_CTBR_DBUS;
9000ea38:	68fb      	ldr	r3, [r7, #12]
9000ea3a:	681b      	ldr	r3, [r3, #0]
9000ea3c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
9000ea3e:	68fb      	ldr	r3, [r7, #12]
9000ea40:	681b      	ldr	r3, [r3, #0]
9000ea42:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
9000ea46:	629a      	str	r2, [r3, #40]	; 0x28
9000ea48:	e007      	b.n	9000ea5a <MDMA_SetConfig+0xc6>
  }
  else
  {
    /*The AXI bus is used as destination (write operation) on channel x */
    hmdma->Instance->CTBR &= (~MDMA_CTBR_DBUS);
9000ea4a:	68fb      	ldr	r3, [r7, #12]
9000ea4c:	681b      	ldr	r3, [r3, #0]
9000ea4e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
9000ea50:	68fb      	ldr	r3, [r7, #12]
9000ea52:	681b      	ldr	r3, [r3, #0]
9000ea54:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
9000ea58:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Set the linked list register to the first node of the list */
  hmdma->Instance->CLAR = (uint32_t)hmdma->FirstLinkedListNodeAddress;
9000ea5a:	68fb      	ldr	r3, [r7, #12]
9000ea5c:	6dda      	ldr	r2, [r3, #92]	; 0x5c
9000ea5e:	68fb      	ldr	r3, [r7, #12]
9000ea60:	681b      	ldr	r3, [r3, #0]
9000ea62:	625a      	str	r2, [r3, #36]	; 0x24
}
9000ea64:	bf00      	nop
9000ea66:	371c      	adds	r7, #28
9000ea68:	46bd      	mov	sp, r7
9000ea6a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000ea6e:	4770      	bx	lr
9000ea70:	fffe0000 	.word	0xfffe0000

9000ea74 <MDMA_Init>:
  * @param  hmdma:       pointer to a MDMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified MDMA Channel.
  * @retval None
  */
static void MDMA_Init(MDMA_HandleTypeDef *hmdma)
{
9000ea74:	b480      	push	{r7}
9000ea76:	b085      	sub	sp, #20
9000ea78:	af00      	add	r7, sp, #0
9000ea7a:	6078      	str	r0, [r7, #4]
  uint32_t blockoffset;

  /* Prepare the MDMA Channel configuration */
  hmdma->Instance->CCR = hmdma->Init.Priority  | hmdma->Init.Endianness;
9000ea7c:	687b      	ldr	r3, [r7, #4]
9000ea7e:	68d9      	ldr	r1, [r3, #12]
9000ea80:	687b      	ldr	r3, [r7, #4]
9000ea82:	691a      	ldr	r2, [r3, #16]
9000ea84:	687b      	ldr	r3, [r7, #4]
9000ea86:	681b      	ldr	r3, [r3, #0]
9000ea88:	430a      	orrs	r2, r1
9000ea8a:	60da      	str	r2, [r3, #12]

  /* Write new CTCR Register value */
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
9000ea8c:	687b      	ldr	r3, [r7, #4]
9000ea8e:	695a      	ldr	r2, [r3, #20]
9000ea90:	687b      	ldr	r3, [r7, #4]
9000ea92:	699b      	ldr	r3, [r3, #24]
9000ea94:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
9000ea96:	687b      	ldr	r3, [r7, #4]
9000ea98:	69db      	ldr	r3, [r3, #28]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
9000ea9a:	431a      	orrs	r2, r3
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
9000ea9c:	687b      	ldr	r3, [r7, #4]
9000ea9e:	6a1b      	ldr	r3, [r3, #32]
9000eaa0:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
9000eaa2:	687b      	ldr	r3, [r7, #4]
9000eaa4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                           hmdma->Init.SourceDataSize | hmdma->Init.DestDataSize   | \
9000eaa6:	431a      	orrs	r2, r3
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
9000eaa8:	687b      	ldr	r3, [r7, #4]
9000eaaa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9000eaac:	431a      	orrs	r2, r3
                           hmdma->Init.DestBurst                                   | \
9000eaae:	687b      	ldr	r3, [r7, #4]
9000eab0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                           hmdma->Init.DataAlignment  | hmdma->Init.SourceBurst    | \
9000eab2:	431a      	orrs	r2, r3
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
9000eab4:	687b      	ldr	r3, [r7, #4]
9000eab6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9000eab8:	3b01      	subs	r3, #1
9000eaba:	049b      	lsls	r3, r3, #18
                           hmdma->Init.DestBurst                                   | \
9000eabc:	ea42 0103 	orr.w	r1, r2, r3
                           hmdma->Init.TransferTriggerMode;
9000eac0:	687b      	ldr	r3, [r7, #4]
9000eac2:	689a      	ldr	r2, [r3, #8]
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
9000eac4:	687b      	ldr	r3, [r7, #4]
9000eac6:	681b      	ldr	r3, [r3, #0]
                           ((hmdma->Init.BufferTransferLength - 1U) << MDMA_CTCR_TLEN_Pos) | \
9000eac8:	430a      	orrs	r2, r1
  hmdma->Instance->CTCR =  hmdma->Init.SourceInc      | hmdma->Init.DestinationInc | \
9000eaca:	611a      	str	r2, [r3, #16]

  /* If SW request set the CTCR register to SW Request Mode */
  if(hmdma->Init.Request == MDMA_REQUEST_SW)
9000eacc:	687b      	ldr	r3, [r7, #4]
9000eace:	685b      	ldr	r3, [r3, #4]
9000ead0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
9000ead4:	d107      	bne.n	9000eae6 <MDMA_Init+0x72>
    -If the request is done by SW : BWM could be set to 1 or 0.
    -If the request is done by a peripheral :
    If mask address not set (0) => BWM must be set to 0
    If mask address set (different than 0) => BWM could be set to 1 or 0
    */
    hmdma->Instance->CTCR |= (MDMA_CTCR_SWRM | MDMA_CTCR_BWM);
9000ead6:	687b      	ldr	r3, [r7, #4]
9000ead8:	681b      	ldr	r3, [r3, #0]
9000eada:	691a      	ldr	r2, [r3, #16]
9000eadc:	687b      	ldr	r3, [r7, #4]
9000eade:	681b      	ldr	r3, [r3, #0]
9000eae0:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
9000eae4:	611a      	str	r2, [r3, #16]
  }

  /* Reset CBNDTR Register */
  hmdma->Instance->CBNDTR = 0;
9000eae6:	687b      	ldr	r3, [r7, #4]
9000eae8:	681b      	ldr	r3, [r3, #0]
9000eaea:	2200      	movs	r2, #0
9000eaec:	615a      	str	r2, [r3, #20]

  /* if block source address offset is negative set the Block Repeat Source address Update Mode to decrement */
  if(hmdma->Init.SourceBlockAddressOffset < 0)
9000eaee:	687b      	ldr	r3, [r7, #4]
9000eaf0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000eaf2:	2b00      	cmp	r3, #0
9000eaf4:	da11      	bge.n	9000eb1a <MDMA_Init+0xa6>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRSUM;
9000eaf6:	687b      	ldr	r3, [r7, #4]
9000eaf8:	681b      	ldr	r3, [r3, #0]
9000eafa:	695a      	ldr	r2, [r3, #20]
9000eafc:	687b      	ldr	r3, [r7, #4]
9000eafe:	681b      	ldr	r3, [r3, #0]
9000eb00:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
9000eb04:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : source repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.SourceBlockAddressOffset);
9000eb06:	687b      	ldr	r3, [r7, #4]
9000eb08:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000eb0a:	425b      	negs	r3, r3
9000eb0c:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR = (blockoffset & 0x0000FFFFU);
9000eb0e:	687b      	ldr	r3, [r7, #4]
9000eb10:	681b      	ldr	r3, [r3, #0]
9000eb12:	68fa      	ldr	r2, [r7, #12]
9000eb14:	b292      	uxth	r2, r2
9000eb16:	621a      	str	r2, [r3, #32]
9000eb18:	e006      	b.n	9000eb28 <MDMA_Init+0xb4>
  }
  else
  {
    /* Write new CBRUR Register value : source repeat block offset */
    hmdma->Instance->CBRUR = (((uint32_t)hmdma->Init.SourceBlockAddressOffset) & 0x0000FFFFU);
9000eb1a:	687b      	ldr	r3, [r7, #4]
9000eb1c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000eb1e:	461a      	mov	r2, r3
9000eb20:	687b      	ldr	r3, [r7, #4]
9000eb22:	681b      	ldr	r3, [r3, #0]
9000eb24:	b292      	uxth	r2, r2
9000eb26:	621a      	str	r2, [r3, #32]
  }

  /* If block destination address offset is negative set the Block Repeat destination address Update Mode to decrement */
  if(hmdma->Init.DestBlockAddressOffset < 0)
9000eb28:	687b      	ldr	r3, [r7, #4]
9000eb2a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9000eb2c:	2b00      	cmp	r3, #0
9000eb2e:	da15      	bge.n	9000eb5c <MDMA_Init+0xe8>
  {
    hmdma->Instance->CBNDTR |= MDMA_CBNDTR_BRDUM;
9000eb30:	687b      	ldr	r3, [r7, #4]
9000eb32:	681b      	ldr	r3, [r3, #0]
9000eb34:	695a      	ldr	r2, [r3, #20]
9000eb36:	687b      	ldr	r3, [r7, #4]
9000eb38:	681b      	ldr	r3, [r3, #0]
9000eb3a:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
9000eb3e:	615a      	str	r2, [r3, #20]
    /* Write new CBRUR Register value : destination repeat block offset */
    blockoffset = (uint32_t)(- hmdma->Init.DestBlockAddressOffset);
9000eb40:	687b      	ldr	r3, [r7, #4]
9000eb42:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9000eb44:	425b      	negs	r3, r3
9000eb46:	60fb      	str	r3, [r7, #12]
    hmdma->Instance->CBRUR |= ((blockoffset & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
9000eb48:	687b      	ldr	r3, [r7, #4]
9000eb4a:	681b      	ldr	r3, [r3, #0]
9000eb4c:	6a19      	ldr	r1, [r3, #32]
9000eb4e:	68fb      	ldr	r3, [r7, #12]
9000eb50:	041a      	lsls	r2, r3, #16
9000eb52:	687b      	ldr	r3, [r7, #4]
9000eb54:	681b      	ldr	r3, [r3, #0]
9000eb56:	430a      	orrs	r2, r1
9000eb58:	621a      	str	r2, [r3, #32]
9000eb5a:	e009      	b.n	9000eb70 <MDMA_Init+0xfc>
  }
  else
  {
    /*write new CBRUR Register value : destination repeat block offset */
    hmdma->Instance->CBRUR |= ((((uint32_t)hmdma->Init.DestBlockAddressOffset) & 0x0000FFFFU) << MDMA_CBRUR_DUV_Pos);
9000eb5c:	687b      	ldr	r3, [r7, #4]
9000eb5e:	681b      	ldr	r3, [r3, #0]
9000eb60:	6a19      	ldr	r1, [r3, #32]
9000eb62:	687b      	ldr	r3, [r7, #4]
9000eb64:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9000eb66:	041a      	lsls	r2, r3, #16
9000eb68:	687b      	ldr	r3, [r7, #4]
9000eb6a:	681b      	ldr	r3, [r3, #0]
9000eb6c:	430a      	orrs	r2, r1
9000eb6e:	621a      	str	r2, [r3, #32]
  }

  /* if HW request set the HW request and the requet CleraMask and ClearData MaskData, */
  if(hmdma->Init.Request != MDMA_REQUEST_SW)
9000eb70:	687b      	ldr	r3, [r7, #4]
9000eb72:	685b      	ldr	r3, [r3, #4]
9000eb74:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
9000eb78:	d006      	beq.n	9000eb88 <MDMA_Init+0x114>
  {
    /* Set the HW request in CTRB register  */
    hmdma->Instance->CTBR = hmdma->Init.Request & MDMA_CTBR_TSEL;
9000eb7a:	687b      	ldr	r3, [r7, #4]
9000eb7c:	685a      	ldr	r2, [r3, #4]
9000eb7e:	687b      	ldr	r3, [r7, #4]
9000eb80:	681b      	ldr	r3, [r3, #0]
9000eb82:	b2d2      	uxtb	r2, r2
9000eb84:	629a      	str	r2, [r3, #40]	; 0x28
9000eb86:	e003      	b.n	9000eb90 <MDMA_Init+0x11c>
  }
  else /* SW request : reset the CTBR register */
  {
    hmdma->Instance->CTBR = 0;
9000eb88:	687b      	ldr	r3, [r7, #4]
9000eb8a:	681b      	ldr	r3, [r3, #0]
9000eb8c:	2200      	movs	r2, #0
9000eb8e:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Write Link Address Register */
  hmdma->Instance->CLAR =  0;
9000eb90:	687b      	ldr	r3, [r7, #4]
9000eb92:	681b      	ldr	r3, [r3, #0]
9000eb94:	2200      	movs	r2, #0
9000eb96:	625a      	str	r2, [r3, #36]	; 0x24
}
9000eb98:	bf00      	nop
9000eb9a:	3714      	adds	r7, #20
9000eb9c:	46bd      	mov	sp, r7
9000eb9e:	f85d 7b04 	ldr.w	r7, [sp], #4
9000eba2:	4770      	bx	lr

9000eba4 <HAL_MMC_Init>:
            MMC_HandleTypeDef and create the associated handle.
  * @param  hmmc: Pointer to the MMC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_Init(MMC_HandleTypeDef *hmmc)
{
9000eba4:	b580      	push	{r7, lr}
9000eba6:	b082      	sub	sp, #8
9000eba8:	af00      	add	r7, sp, #0
9000ebaa:	6078      	str	r0, [r7, #4]
  /* Check the MMC handle allocation */
  if (hmmc == NULL)
9000ebac:	687b      	ldr	r3, [r7, #4]
9000ebae:	2b00      	cmp	r3, #0
9000ebb0:	d101      	bne.n	9000ebb6 <HAL_MMC_Init+0x12>
  {
    return HAL_ERROR;
9000ebb2:	2301      	movs	r3, #1
9000ebb4:	e031      	b.n	9000ec1a <HAL_MMC_Init+0x76>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hmmc->Init.ClockPowerSave));
  assert_param(IS_SDMMC_BUS_WIDE(hmmc->Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hmmc->Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(hmmc->Init.ClockDiv));

  if (hmmc->State == HAL_MMC_STATE_RESET)
9000ebb6:	687b      	ldr	r3, [r7, #4]
9000ebb8:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
9000ebbc:	b2db      	uxtb	r3, r3
9000ebbe:	2b00      	cmp	r3, #0
9000ebc0:	d105      	bne.n	9000ebce <HAL_MMC_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    hmmc->Lock = HAL_UNLOCKED;
9000ebc2:	687b      	ldr	r3, [r7, #4]
9000ebc4:	2200      	movs	r2, #0
9000ebc6:	761a      	strb	r2, [r3, #24]

    /* Init the low level hardware */
    hmmc->MspInitCallback(hmmc);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_MMC_MspInit(hmmc);
9000ebc8:	6878      	ldr	r0, [r7, #4]
9000ebca:	f000 f8bf 	bl	9000ed4c <HAL_MMC_MspInit>
#endif /* USE_HAL_MMC_REGISTER_CALLBACKS */
  }

  hmmc->State = HAL_MMC_STATE_BUSY;
9000ebce:	687b      	ldr	r3, [r7, #4]
9000ebd0:	2203      	movs	r2, #3
9000ebd2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

  /* Initialize the Card parameters */
  if (HAL_MMC_InitCard(hmmc) == HAL_ERROR)
9000ebd6:	6878      	ldr	r0, [r7, #4]
9000ebd8:	f000 f824 	bl	9000ec24 <HAL_MMC_InitCard>
9000ebdc:	4603      	mov	r3, r0
9000ebde:	2b01      	cmp	r3, #1
9000ebe0:	d101      	bne.n	9000ebe6 <HAL_MMC_Init+0x42>
  {
    return HAL_ERROR;
9000ebe2:	2301      	movs	r3, #1
9000ebe4:	e019      	b.n	9000ec1a <HAL_MMC_Init+0x76>
  }

  /* Initialize the error code */
  hmmc->ErrorCode = HAL_DMA_ERROR_NONE;
9000ebe6:	687b      	ldr	r3, [r7, #4]
9000ebe8:	2200      	movs	r2, #0
9000ebea:	635a      	str	r2, [r3, #52]	; 0x34

  /* Initialize the MMC operation */
  hmmc->Context = MMC_CONTEXT_NONE;
9000ebec:	687b      	ldr	r3, [r7, #4]
9000ebee:	2200      	movs	r2, #0
9000ebf0:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Initialize the MMC state */
  hmmc->State = HAL_MMC_STATE_READY;
9000ebf2:	687b      	ldr	r3, [r7, #4]
9000ebf4:	2201      	movs	r2, #1
9000ebf6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

  /* Configure bus width */
  if (hmmc->Init.BusWide != SDMMC_BUS_WIDE_1B)
9000ebfa:	687b      	ldr	r3, [r7, #4]
9000ebfc:	68db      	ldr	r3, [r3, #12]
9000ebfe:	2b00      	cmp	r3, #0
9000ec00:	d00a      	beq.n	9000ec18 <HAL_MMC_Init+0x74>
  {
    if (HAL_MMC_ConfigWideBusOperation(hmmc, hmmc->Init.BusWide) != HAL_OK)
9000ec02:	687b      	ldr	r3, [r7, #4]
9000ec04:	68db      	ldr	r3, [r3, #12]
9000ec06:	4619      	mov	r1, r3
9000ec08:	6878      	ldr	r0, [r7, #4]
9000ec0a:	f000 ff57 	bl	9000fabc <HAL_MMC_ConfigWideBusOperation>
9000ec0e:	4603      	mov	r3, r0
9000ec10:	2b00      	cmp	r3, #0
9000ec12:	d001      	beq.n	9000ec18 <HAL_MMC_Init+0x74>
    {
      return HAL_ERROR;
9000ec14:	2301      	movs	r3, #1
9000ec16:	e000      	b.n	9000ec1a <HAL_MMC_Init+0x76>
    }
  }

  return HAL_OK;
9000ec18:	2300      	movs	r3, #0
}
9000ec1a:	4618      	mov	r0, r3
9000ec1c:	3708      	adds	r7, #8
9000ec1e:	46bd      	mov	sp, r7
9000ec20:	bd80      	pop	{r7, pc}
	...

9000ec24 <HAL_MMC_InitCard>:
  * @note   This function initializes the MMC card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_InitCard(MMC_HandleTypeDef *hmmc)
{
9000ec24:	b590      	push	{r4, r7, lr}
9000ec26:	b08d      	sub	sp, #52	; 0x34
9000ec28:	af02      	add	r7, sp, #8
9000ec2a:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  MMC_InitTypeDef Init;
  uint32_t sdmmc_clk;

  /* Default SDMMC peripheral configuration for MMC card initialization */
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
9000ec2c:	2300      	movs	r3, #0
9000ec2e:	60fb      	str	r3, [r7, #12]
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
9000ec30:	2300      	movs	r3, #0
9000ec32:	613b      	str	r3, [r7, #16]
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
9000ec34:	2300      	movs	r3, #0
9000ec36:	617b      	str	r3, [r7, #20]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
9000ec38:	2300      	movs	r3, #0
9000ec3a:	61bb      	str	r3, [r7, #24]

  /* Init Clock should be less or equal to 400Khz*/
  sdmmc_clk     = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC);
9000ec3c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
9000ec40:	f003 fbba 	bl	900123b8 <HAL_RCCEx_GetPeriphCLKFreq>
9000ec44:	6278      	str	r0, [r7, #36]	; 0x24
  if (sdmmc_clk == 0U)
9000ec46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9000ec48:	2b00      	cmp	r3, #0
9000ec4a:	d109      	bne.n	9000ec60 <HAL_MMC_InitCard+0x3c>
  {
    hmmc->State = HAL_MMC_STATE_READY;
9000ec4c:	687b      	ldr	r3, [r7, #4]
9000ec4e:	2201      	movs	r2, #1
9000ec50:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    hmmc->ErrorCode = SDMMC_ERROR_INVALID_PARAMETER;
9000ec54:	687b      	ldr	r3, [r7, #4]
9000ec56:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
9000ec5a:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
9000ec5c:	2301      	movs	r3, #1
9000ec5e:	e06a      	b.n	9000ed36 <HAL_MMC_InitCard+0x112>
  }
  Init.ClockDiv = sdmmc_clk / (2U * MMC_INIT_FREQ);
9000ec60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9000ec62:	0a1b      	lsrs	r3, r3, #8
9000ec64:	4a36      	ldr	r2, [pc, #216]	; (9000ed40 <HAL_MMC_InitCard+0x11c>)
9000ec66:	fba2 2303 	umull	r2, r3, r2, r3
9000ec6a:	091b      	lsrs	r3, r3, #4
9000ec6c:	61fb      	str	r3, [r7, #28]
#if (USE_SD_TRANSCEIVER != 0U)
  Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
#endif /* USE_SD_TRANSCEIVER */

  /* Initialize SDMMC peripheral interface with default configuration */
  (void)SDMMC_Init(hmmc->Instance, Init);
9000ec6e:	687b      	ldr	r3, [r7, #4]
9000ec70:	681c      	ldr	r4, [r3, #0]
9000ec72:	466a      	mov	r2, sp
9000ec74:	f107 0318 	add.w	r3, r7, #24
9000ec78:	e893 0003 	ldmia.w	r3, {r0, r1}
9000ec7c:	e882 0003 	stmia.w	r2, {r0, r1}
9000ec80:	f107 030c 	add.w	r3, r7, #12
9000ec84:	cb0e      	ldmia	r3, {r1, r2, r3}
9000ec86:	4620      	mov	r0, r4
9000ec88:	f006 f918 	bl	90014ebc <SDMMC_Init>

  /* Set Power State to ON */
  (void)SDMMC_PowerState_ON(hmmc->Instance);
9000ec8c:	687b      	ldr	r3, [r7, #4]
9000ec8e:	681b      	ldr	r3, [r3, #0]
9000ec90:	4618      	mov	r0, r3
9000ec92:	f006 f95b 	bl	90014f4c <SDMMC_PowerState_ON>

  /* wait 74 Cycles: required power up waiting time before starting
     the MMC initialization sequence */
  sdmmc_clk = sdmmc_clk / (2U * Init.ClockDiv);
9000ec96:	69fb      	ldr	r3, [r7, #28]
9000ec98:	005b      	lsls	r3, r3, #1
9000ec9a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
9000ec9c:	fbb2 f3f3 	udiv	r3, r2, r3
9000eca0:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_Delay(1U + (74U * 1000U / (sdmmc_clk)));
9000eca2:	4a28      	ldr	r2, [pc, #160]	; (9000ed44 <HAL_MMC_InitCard+0x120>)
9000eca4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9000eca6:	fbb2 f3f3 	udiv	r3, r2, r3
9000ecaa:	3301      	adds	r3, #1
9000ecac:	4618      	mov	r0, r3
9000ecae:	f7fa fb95 	bl	900093dc <HAL_Delay>

  /* Identify card operating voltage */
  errorstate = MMC_PowerON(hmmc);
9000ecb2:	6878      	ldr	r0, [r7, #4]
9000ecb4:	f001 f8ec 	bl	9000fe90 <MMC_PowerON>
9000ecb8:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_MMC_ERROR_NONE)
9000ecba:	6a3b      	ldr	r3, [r7, #32]
9000ecbc:	2b00      	cmp	r3, #0
9000ecbe:	d00b      	beq.n	9000ecd8 <HAL_MMC_InitCard+0xb4>
  {
    hmmc->State = HAL_MMC_STATE_READY;
9000ecc0:	687b      	ldr	r3, [r7, #4]
9000ecc2:	2201      	movs	r2, #1
9000ecc4:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    hmmc->ErrorCode |= errorstate;
9000ecc8:	687b      	ldr	r3, [r7, #4]
9000ecca:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000eccc:	6a3b      	ldr	r3, [r7, #32]
9000ecce:	431a      	orrs	r2, r3
9000ecd0:	687b      	ldr	r3, [r7, #4]
9000ecd2:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
9000ecd4:	2301      	movs	r3, #1
9000ecd6:	e02e      	b.n	9000ed36 <HAL_MMC_InitCard+0x112>
  }

  /* Card initialization */
  errorstate = MMC_InitCard(hmmc);
9000ecd8:	6878      	ldr	r0, [r7, #4]
9000ecda:	f000 ffdb 	bl	9000fc94 <MMC_InitCard>
9000ecde:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_MMC_ERROR_NONE)
9000ece0:	6a3b      	ldr	r3, [r7, #32]
9000ece2:	2b00      	cmp	r3, #0
9000ece4:	d00b      	beq.n	9000ecfe <HAL_MMC_InitCard+0xda>
  {
    hmmc->State = HAL_MMC_STATE_READY;
9000ece6:	687b      	ldr	r3, [r7, #4]
9000ece8:	2201      	movs	r2, #1
9000ecea:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    hmmc->ErrorCode |= errorstate;
9000ecee:	687b      	ldr	r3, [r7, #4]
9000ecf0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000ecf2:	6a3b      	ldr	r3, [r7, #32]
9000ecf4:	431a      	orrs	r2, r3
9000ecf6:	687b      	ldr	r3, [r7, #4]
9000ecf8:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
9000ecfa:	2301      	movs	r3, #1
9000ecfc:	e01b      	b.n	9000ed36 <HAL_MMC_InitCard+0x112>
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hmmc->Instance, MMC_BLOCKSIZE);
9000ecfe:	687b      	ldr	r3, [r7, #4]
9000ed00:	681b      	ldr	r3, [r3, #0]
9000ed02:	f44f 7100 	mov.w	r1, #512	; 0x200
9000ed06:	4618      	mov	r0, r3
9000ed08:	f006 f9b6 	bl	90015078 <SDMMC_CmdBlockLength>
9000ed0c:	6238      	str	r0, [r7, #32]
  if (errorstate != HAL_MMC_ERROR_NONE)
9000ed0e:	6a3b      	ldr	r3, [r7, #32]
9000ed10:	2b00      	cmp	r3, #0
9000ed12:	d00f      	beq.n	9000ed34 <HAL_MMC_InitCard+0x110>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000ed14:	687b      	ldr	r3, [r7, #4]
9000ed16:	681b      	ldr	r3, [r3, #0]
9000ed18:	4a0b      	ldr	r2, [pc, #44]	; (9000ed48 <HAL_MMC_InitCard+0x124>)
9000ed1a:	639a      	str	r2, [r3, #56]	; 0x38
    hmmc->ErrorCode |= errorstate;
9000ed1c:	687b      	ldr	r3, [r7, #4]
9000ed1e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000ed20:	6a3b      	ldr	r3, [r7, #32]
9000ed22:	431a      	orrs	r2, r3
9000ed24:	687b      	ldr	r3, [r7, #4]
9000ed26:	635a      	str	r2, [r3, #52]	; 0x34
    hmmc->State = HAL_MMC_STATE_READY;
9000ed28:	687b      	ldr	r3, [r7, #4]
9000ed2a:	2201      	movs	r2, #1
9000ed2c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    return HAL_ERROR;
9000ed30:	2301      	movs	r3, #1
9000ed32:	e000      	b.n	9000ed36 <HAL_MMC_InitCard+0x112>
  }

  return HAL_OK;
9000ed34:	2300      	movs	r3, #0
}
9000ed36:	4618      	mov	r0, r3
9000ed38:	372c      	adds	r7, #44	; 0x2c
9000ed3a:	46bd      	mov	sp, r7
9000ed3c:	bd90      	pop	{r4, r7, pc}
9000ed3e:	bf00      	nop
9000ed40:	014f8b59 	.word	0x014f8b59
9000ed44:	00012110 	.word	0x00012110
9000ed48:	1fe00fff 	.word	0x1fe00fff

9000ed4c <HAL_MMC_MspInit>:
  * @brief  Initializes the MMC MSP.
  * @param  hmmc: Pointer to MMC handle
  * @retval None
  */
__weak void HAL_MMC_MspInit(MMC_HandleTypeDef *hmmc)
{
9000ed4c:	b480      	push	{r7}
9000ed4e:	b083      	sub	sp, #12
9000ed50:	af00      	add	r7, sp, #0
9000ed52:	6078      	str	r0, [r7, #4]
  UNUSED(hmmc);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MMC_MspInit could be implemented in the user file
   */
}
9000ed54:	bf00      	nop
9000ed56:	370c      	adds	r7, #12
9000ed58:	46bd      	mov	sp, r7
9000ed5a:	f85d 7b04 	ldr.w	r7, [sp], #4
9000ed5e:	4770      	bx	lr

9000ed60 <HAL_MMC_ReadBlocks>:
  * @param  Timeout: Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_ReadBlocks(MMC_HandleTypeDef *hmmc, uint8_t *pData, uint32_t BlockAdd,
                                     uint32_t NumberOfBlocks, uint32_t Timeout)
{
9000ed60:	b580      	push	{r7, lr}
9000ed62:	b092      	sub	sp, #72	; 0x48
9000ed64:	af00      	add	r7, sp, #0
9000ed66:	60f8      	str	r0, [r7, #12]
9000ed68:	60b9      	str	r1, [r7, #8]
9000ed6a:	607a      	str	r2, [r7, #4]
9000ed6c:	603b      	str	r3, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
9000ed6e:	f7fa fb29 	bl	900093c4 <HAL_GetTick>
9000ed72:	6338      	str	r0, [r7, #48]	; 0x30
  uint32_t count;
  uint32_t data;
  uint32_t dataremaining;
  uint32_t add = BlockAdd;
9000ed74:	687b      	ldr	r3, [r7, #4]
9000ed76:	63bb      	str	r3, [r7, #56]	; 0x38
  uint8_t *tempbuff = pData;
9000ed78:	68bb      	ldr	r3, [r7, #8]
9000ed7a:	637b      	str	r3, [r7, #52]	; 0x34

  if (NULL == pData)
9000ed7c:	68bb      	ldr	r3, [r7, #8]
9000ed7e:	2b00      	cmp	r3, #0
9000ed80:	d107      	bne.n	9000ed92 <HAL_MMC_ReadBlocks+0x32>
  {
    hmmc->ErrorCode |= HAL_MMC_ERROR_PARAM;
9000ed82:	68fb      	ldr	r3, [r7, #12]
9000ed84:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000ed86:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
9000ed8a:	68fb      	ldr	r3, [r7, #12]
9000ed8c:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
9000ed8e:	2301      	movs	r3, #1
9000ed90:	e172      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
  }

  if (hmmc->State == HAL_MMC_STATE_READY)
9000ed92:	68fb      	ldr	r3, [r7, #12]
9000ed94:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
9000ed98:	b2db      	uxtb	r3, r3
9000ed9a:	2b01      	cmp	r3, #1
9000ed9c:	f040 8165 	bne.w	9000f06a <HAL_MMC_ReadBlocks+0x30a>
  {
    hmmc->ErrorCode = HAL_MMC_ERROR_NONE;
9000eda0:	68fb      	ldr	r3, [r7, #12]
9000eda2:	2200      	movs	r2, #0
9000eda4:	635a      	str	r2, [r3, #52]	; 0x34

    if ((BlockAdd + NumberOfBlocks) > (hmmc->MmcCard.LogBlockNbr))
9000eda6:	687a      	ldr	r2, [r7, #4]
9000eda8:	683b      	ldr	r3, [r7, #0]
9000edaa:	441a      	add	r2, r3
9000edac:	68fb      	ldr	r3, [r7, #12]
9000edae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000edb0:	429a      	cmp	r2, r3
9000edb2:	d907      	bls.n	9000edc4 <HAL_MMC_ReadBlocks+0x64>
    {
      hmmc->ErrorCode |= HAL_MMC_ERROR_ADDR_OUT_OF_RANGE;
9000edb4:	68fb      	ldr	r3, [r7, #12]
9000edb6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000edb8:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
9000edbc:	68fb      	ldr	r3, [r7, #12]
9000edbe:	635a      	str	r2, [r3, #52]	; 0x34
      return HAL_ERROR;
9000edc0:	2301      	movs	r3, #1
9000edc2:	e159      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
    }

    /* Check the case of 4kB blocks (field DATA SECTOR SIZE of extended CSD register) */
    if (((hmmc->Ext_CSD[(MMC_EXT_CSD_DATA_SEC_SIZE_INDEX / 4)] >> MMC_EXT_CSD_DATA_SEC_SIZE_POS)
9000edc4:	68fb      	ldr	r3, [r7, #12]
9000edc6:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
9000edca:	0a1b      	lsrs	r3, r3, #8
         & 0x000000FFU) != 0x0U)
9000edcc:	b2db      	uxtb	r3, r3
    if (((hmmc->Ext_CSD[(MMC_EXT_CSD_DATA_SEC_SIZE_INDEX / 4)] >> MMC_EXT_CSD_DATA_SEC_SIZE_POS)
9000edce:	2b00      	cmp	r3, #0
9000edd0:	d019      	beq.n	9000ee06 <HAL_MMC_ReadBlocks+0xa6>
    {
      if ((NumberOfBlocks % 8U) != 0U)
9000edd2:	683b      	ldr	r3, [r7, #0]
9000edd4:	f003 0307 	and.w	r3, r3, #7
9000edd8:	2b00      	cmp	r3, #0
9000edda:	d007      	beq.n	9000edec <HAL_MMC_ReadBlocks+0x8c>
      {
        /* The number of blocks should be a multiple of 8 sectors of 512 bytes = 4 KBytes */
        hmmc->ErrorCode |= HAL_MMC_ERROR_BLOCK_LEN_ERR;
9000eddc:	68fb      	ldr	r3, [r7, #12]
9000edde:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000ede0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
9000ede4:	68fb      	ldr	r3, [r7, #12]
9000ede6:	635a      	str	r2, [r3, #52]	; 0x34
        return HAL_ERROR;
9000ede8:	2301      	movs	r3, #1
9000edea:	e145      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
      }

      if ((BlockAdd % 8U) != 0U)
9000edec:	687b      	ldr	r3, [r7, #4]
9000edee:	f003 0307 	and.w	r3, r3, #7
9000edf2:	2b00      	cmp	r3, #0
9000edf4:	d007      	beq.n	9000ee06 <HAL_MMC_ReadBlocks+0xa6>
      {
        /* The address should be aligned to 8 (corresponding to 4 KBytes blocks) */
        hmmc->ErrorCode |= HAL_MMC_ERROR_ADDR_MISALIGNED;
9000edf6:	68fb      	ldr	r3, [r7, #12]
9000edf8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000edfa:	f043 0240 	orr.w	r2, r3, #64	; 0x40
9000edfe:	68fb      	ldr	r3, [r7, #12]
9000ee00:	635a      	str	r2, [r3, #52]	; 0x34
        return HAL_ERROR;
9000ee02:	2301      	movs	r3, #1
9000ee04:	e138      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
      }
    }

    hmmc->State = HAL_MMC_STATE_BUSY;
9000ee06:	68fb      	ldr	r3, [r7, #12]
9000ee08:	2203      	movs	r2, #3
9000ee0a:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

    /* Initialize data control register */
    hmmc->Instance->DCTRL = 0U;
9000ee0e:	68fb      	ldr	r3, [r7, #12]
9000ee10:	681b      	ldr	r3, [r3, #0]
9000ee12:	2200      	movs	r2, #0
9000ee14:	62da      	str	r2, [r3, #44]	; 0x2c

    if ((hmmc->MmcCard.CardType) != MMC_HIGH_CAPACITY_CARD)
9000ee16:	68fb      	ldr	r3, [r7, #12]
9000ee18:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9000ee1a:	2b01      	cmp	r3, #1
9000ee1c:	d002      	beq.n	9000ee24 <HAL_MMC_ReadBlocks+0xc4>
    {
      add *= 512U;
9000ee1e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
9000ee20:	025b      	lsls	r3, r3, #9
9000ee22:	63bb      	str	r3, [r7, #56]	; 0x38
    }

    /* Configure the MMC DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
9000ee24:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9000ee28:	617b      	str	r3, [r7, #20]
    config.DataLength    = NumberOfBlocks * MMC_BLOCKSIZE;
9000ee2a:	683b      	ldr	r3, [r7, #0]
9000ee2c:	025b      	lsls	r3, r3, #9
9000ee2e:	61bb      	str	r3, [r7, #24]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
9000ee30:	2390      	movs	r3, #144	; 0x90
9000ee32:	61fb      	str	r3, [r7, #28]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
9000ee34:	2302      	movs	r3, #2
9000ee36:	623b      	str	r3, [r7, #32]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
9000ee38:	2300      	movs	r3, #0
9000ee3a:	627b      	str	r3, [r7, #36]	; 0x24
    config.DPSM          = SDMMC_DPSM_DISABLE;
9000ee3c:	2300      	movs	r3, #0
9000ee3e:	62bb      	str	r3, [r7, #40]	; 0x28
    (void)SDMMC_ConfigData(hmmc->Instance, &config);
9000ee40:	68fb      	ldr	r3, [r7, #12]
9000ee42:	681b      	ldr	r3, [r3, #0]
9000ee44:	f107 0214 	add.w	r2, r7, #20
9000ee48:	4611      	mov	r1, r2
9000ee4a:	4618      	mov	r0, r3
9000ee4c:	f006 f8e8 	bl	90015020 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE(hmmc->Instance);
9000ee50:	68fb      	ldr	r3, [r7, #12]
9000ee52:	681b      	ldr	r3, [r3, #0]
9000ee54:	68da      	ldr	r2, [r3, #12]
9000ee56:	68fb      	ldr	r3, [r7, #12]
9000ee58:	681b      	ldr	r3, [r3, #0]
9000ee5a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
9000ee5e:	60da      	str	r2, [r3, #12]

    /* Read block(s) in polling mode */
    if (NumberOfBlocks > 1U)
9000ee60:	683b      	ldr	r3, [r7, #0]
9000ee62:	2b01      	cmp	r3, #1
9000ee64:	d90a      	bls.n	9000ee7c <HAL_MMC_ReadBlocks+0x11c>
    {
      hmmc->Context = MMC_CONTEXT_READ_MULTIPLE_BLOCK;
9000ee66:	68fb      	ldr	r3, [r7, #12]
9000ee68:	2202      	movs	r2, #2
9000ee6a:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Read Multi Block command */
      errorstate = SDMMC_CmdReadMultiBlock(hmmc->Instance, add);
9000ee6c:	68fb      	ldr	r3, [r7, #12]
9000ee6e:	681b      	ldr	r3, [r3, #0]
9000ee70:	6bb9      	ldr	r1, [r7, #56]	; 0x38
9000ee72:	4618      	mov	r0, r3
9000ee74:	f006 f946 	bl	90015104 <SDMMC_CmdReadMultiBlock>
9000ee78:	6478      	str	r0, [r7, #68]	; 0x44
9000ee7a:	e009      	b.n	9000ee90 <HAL_MMC_ReadBlocks+0x130>
    }
    else
    {
      hmmc->Context = MMC_CONTEXT_READ_SINGLE_BLOCK;
9000ee7c:	68fb      	ldr	r3, [r7, #12]
9000ee7e:	2201      	movs	r2, #1
9000ee80:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Read Single Block command */
      errorstate = SDMMC_CmdReadSingleBlock(hmmc->Instance, add);
9000ee82:	68fb      	ldr	r3, [r7, #12]
9000ee84:	681b      	ldr	r3, [r3, #0]
9000ee86:	6bb9      	ldr	r1, [r7, #56]	; 0x38
9000ee88:	4618      	mov	r0, r3
9000ee8a:	f006 f918 	bl	900150be <SDMMC_CmdReadSingleBlock>
9000ee8e:	6478      	str	r0, [r7, #68]	; 0x44
    }
    if (errorstate != HAL_MMC_ERROR_NONE)
9000ee90:	6c7b      	ldr	r3, [r7, #68]	; 0x44
9000ee92:	2b00      	cmp	r3, #0
9000ee94:	d00f      	beq.n	9000eeb6 <HAL_MMC_ReadBlocks+0x156>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000ee96:	68fb      	ldr	r3, [r7, #12]
9000ee98:	681b      	ldr	r3, [r3, #0]
9000ee9a:	4a79      	ldr	r2, [pc, #484]	; (9000f080 <HAL_MMC_ReadBlocks+0x320>)
9000ee9c:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= errorstate;
9000ee9e:	68fb      	ldr	r3, [r7, #12]
9000eea0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000eea2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
9000eea4:	431a      	orrs	r2, r3
9000eea6:	68fb      	ldr	r3, [r7, #12]
9000eea8:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000eeaa:	68fb      	ldr	r3, [r7, #12]
9000eeac:	2201      	movs	r2, #1
9000eeae:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000eeb2:	2301      	movs	r3, #1
9000eeb4:	e0e0      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
    }

    /* Poll on SDMMC flags */
    dataremaining = config.DataLength;
9000eeb6:	69bb      	ldr	r3, [r7, #24]
9000eeb8:	63fb      	str	r3, [r7, #60]	; 0x3c
    while (!__HAL_MMC_GET_FLAG(hmmc,
9000eeba:	e055      	b.n	9000ef68 <HAL_MMC_ReadBlocks+0x208>
                               SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
    {
      if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXFIFOHF) && (dataremaining >= 32U))
9000eebc:	68fb      	ldr	r3, [r7, #12]
9000eebe:	681b      	ldr	r3, [r3, #0]
9000eec0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000eec2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
9000eec6:	2b00      	cmp	r3, #0
9000eec8:	d033      	beq.n	9000ef32 <HAL_MMC_ReadBlocks+0x1d2>
9000eeca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
9000eecc:	2b1f      	cmp	r3, #31
9000eece:	d930      	bls.n	9000ef32 <HAL_MMC_ReadBlocks+0x1d2>
      {
        /* Read data from SDMMC Rx FIFO */
        for (count = 0U; count < 8U; count++)
9000eed0:	2300      	movs	r3, #0
9000eed2:	643b      	str	r3, [r7, #64]	; 0x40
9000eed4:	e027      	b.n	9000ef26 <HAL_MMC_ReadBlocks+0x1c6>
        {
          data = SDMMC_ReadFIFO(hmmc->Instance);
9000eed6:	68fb      	ldr	r3, [r7, #12]
9000eed8:	681b      	ldr	r3, [r3, #0]
9000eeda:	4618      	mov	r0, r3
9000eedc:	f006 f818 	bl	90014f10 <SDMMC_ReadFIFO>
9000eee0:	62f8      	str	r0, [r7, #44]	; 0x2c
          *tempbuff = (uint8_t)(data & 0xFFU);
9000eee2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
9000eee4:	b2da      	uxtb	r2, r3
9000eee6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000eee8:	701a      	strb	r2, [r3, #0]
          tempbuff++;
9000eeea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000eeec:	3301      	adds	r3, #1
9000eeee:	637b      	str	r3, [r7, #52]	; 0x34
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
9000eef0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
9000eef2:	0a1b      	lsrs	r3, r3, #8
9000eef4:	b2da      	uxtb	r2, r3
9000eef6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000eef8:	701a      	strb	r2, [r3, #0]
          tempbuff++;
9000eefa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000eefc:	3301      	adds	r3, #1
9000eefe:	637b      	str	r3, [r7, #52]	; 0x34
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
9000ef00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
9000ef02:	0c1b      	lsrs	r3, r3, #16
9000ef04:	b2da      	uxtb	r2, r3
9000ef06:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000ef08:	701a      	strb	r2, [r3, #0]
          tempbuff++;
9000ef0a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000ef0c:	3301      	adds	r3, #1
9000ef0e:	637b      	str	r3, [r7, #52]	; 0x34
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
9000ef10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
9000ef12:	0e1b      	lsrs	r3, r3, #24
9000ef14:	b2da      	uxtb	r2, r3
9000ef16:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000ef18:	701a      	strb	r2, [r3, #0]
          tempbuff++;
9000ef1a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000ef1c:	3301      	adds	r3, #1
9000ef1e:	637b      	str	r3, [r7, #52]	; 0x34
        for (count = 0U; count < 8U; count++)
9000ef20:	6c3b      	ldr	r3, [r7, #64]	; 0x40
9000ef22:	3301      	adds	r3, #1
9000ef24:	643b      	str	r3, [r7, #64]	; 0x40
9000ef26:	6c3b      	ldr	r3, [r7, #64]	; 0x40
9000ef28:	2b07      	cmp	r3, #7
9000ef2a:	d9d4      	bls.n	9000eed6 <HAL_MMC_ReadBlocks+0x176>
        }
        dataremaining -= 32U;
9000ef2c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
9000ef2e:	3b20      	subs	r3, #32
9000ef30:	63fb      	str	r3, [r7, #60]	; 0x3c
      }

      if (((HAL_GetTick() - tickstart) >=  Timeout) || (Timeout == 0U))
9000ef32:	f7fa fa47 	bl	900093c4 <HAL_GetTick>
9000ef36:	4602      	mov	r2, r0
9000ef38:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9000ef3a:	1ad3      	subs	r3, r2, r3
9000ef3c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
9000ef3e:	429a      	cmp	r2, r3
9000ef40:	d902      	bls.n	9000ef48 <HAL_MMC_ReadBlocks+0x1e8>
9000ef42:	6d3b      	ldr	r3, [r7, #80]	; 0x50
9000ef44:	2b00      	cmp	r3, #0
9000ef46:	d10f      	bne.n	9000ef68 <HAL_MMC_ReadBlocks+0x208>
      {
        /* Clear all the static flags */
        __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000ef48:	68fb      	ldr	r3, [r7, #12]
9000ef4a:	681b      	ldr	r3, [r3, #0]
9000ef4c:	4a4c      	ldr	r2, [pc, #304]	; (9000f080 <HAL_MMC_ReadBlocks+0x320>)
9000ef4e:	639a      	str	r2, [r3, #56]	; 0x38
        hmmc->ErrorCode |= HAL_MMC_ERROR_TIMEOUT;
9000ef50:	68fb      	ldr	r3, [r7, #12]
9000ef52:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000ef54:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
9000ef58:	68fb      	ldr	r3, [r7, #12]
9000ef5a:	635a      	str	r2, [r3, #52]	; 0x34
        hmmc->State = HAL_MMC_STATE_READY;
9000ef5c:	68fb      	ldr	r3, [r7, #12]
9000ef5e:	2201      	movs	r2, #1
9000ef60:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        return HAL_TIMEOUT;
9000ef64:	2303      	movs	r3, #3
9000ef66:	e087      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
    while (!__HAL_MMC_GET_FLAG(hmmc,
9000ef68:	68fb      	ldr	r3, [r7, #12]
9000ef6a:	681b      	ldr	r3, [r3, #0]
9000ef6c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000ef6e:	f403 7395 	and.w	r3, r3, #298	; 0x12a
9000ef72:	2b00      	cmp	r3, #0
9000ef74:	d0a2      	beq.n	9000eebc <HAL_MMC_ReadBlocks+0x15c>
      }
    }
    __SDMMC_CMDTRANS_DISABLE(hmmc->Instance);
9000ef76:	68fb      	ldr	r3, [r7, #12]
9000ef78:	681b      	ldr	r3, [r3, #0]
9000ef7a:	68da      	ldr	r2, [r3, #12]
9000ef7c:	68fb      	ldr	r3, [r7, #12]
9000ef7e:	681b      	ldr	r3, [r3, #0]
9000ef80:	f022 0240 	bic.w	r2, r2, #64	; 0x40
9000ef84:	60da      	str	r2, [r3, #12]

    /* Send stop transmission command in case of multiblock read */
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
9000ef86:	68fb      	ldr	r3, [r7, #12]
9000ef88:	681b      	ldr	r3, [r3, #0]
9000ef8a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000ef8c:	f403 7380 	and.w	r3, r3, #256	; 0x100
9000ef90:	2b00      	cmp	r3, #0
9000ef92:	d01b      	beq.n	9000efcc <HAL_MMC_ReadBlocks+0x26c>
9000ef94:	683b      	ldr	r3, [r7, #0]
9000ef96:	2b01      	cmp	r3, #1
9000ef98:	d918      	bls.n	9000efcc <HAL_MMC_ReadBlocks+0x26c>
    {
      /* Send stop transmission command */
      errorstate = SDMMC_CmdStopTransfer(hmmc->Instance);
9000ef9a:	68fb      	ldr	r3, [r7, #12]
9000ef9c:	681b      	ldr	r3, [r3, #0]
9000ef9e:	4618      	mov	r0, r3
9000efa0:	f006 f982 	bl	900152a8 <SDMMC_CmdStopTransfer>
9000efa4:	6478      	str	r0, [r7, #68]	; 0x44
      if (errorstate != HAL_MMC_ERROR_NONE)
9000efa6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
9000efa8:	2b00      	cmp	r3, #0
9000efaa:	d00f      	beq.n	9000efcc <HAL_MMC_ReadBlocks+0x26c>
      {
        /* Clear all the static flags */
        __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000efac:	68fb      	ldr	r3, [r7, #12]
9000efae:	681b      	ldr	r3, [r3, #0]
9000efb0:	4a33      	ldr	r2, [pc, #204]	; (9000f080 <HAL_MMC_ReadBlocks+0x320>)
9000efb2:	639a      	str	r2, [r3, #56]	; 0x38
        hmmc->ErrorCode |= errorstate;
9000efb4:	68fb      	ldr	r3, [r7, #12]
9000efb6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000efb8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
9000efba:	431a      	orrs	r2, r3
9000efbc:	68fb      	ldr	r3, [r7, #12]
9000efbe:	635a      	str	r2, [r3, #52]	; 0x34
        hmmc->State = HAL_MMC_STATE_READY;
9000efc0:	68fb      	ldr	r3, [r7, #12]
9000efc2:	2201      	movs	r2, #1
9000efc4:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        return HAL_ERROR;
9000efc8:	2301      	movs	r3, #1
9000efca:	e055      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
      }
    }

    /* Get error state */
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DTIMEOUT))
9000efcc:	68fb      	ldr	r3, [r7, #12]
9000efce:	681b      	ldr	r3, [r3, #0]
9000efd0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000efd2:	f003 0308 	and.w	r3, r3, #8
9000efd6:	2b00      	cmp	r3, #0
9000efd8:	d00f      	beq.n	9000effa <HAL_MMC_ReadBlocks+0x29a>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000efda:	68fb      	ldr	r3, [r7, #12]
9000efdc:	681b      	ldr	r3, [r3, #0]
9000efde:	4a28      	ldr	r2, [pc, #160]	; (9000f080 <HAL_MMC_ReadBlocks+0x320>)
9000efe0:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_TIMEOUT;
9000efe2:	68fb      	ldr	r3, [r7, #12]
9000efe4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000efe6:	f043 0208 	orr.w	r2, r3, #8
9000efea:	68fb      	ldr	r3, [r7, #12]
9000efec:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000efee:	68fb      	ldr	r3, [r7, #12]
9000eff0:	2201      	movs	r2, #1
9000eff2:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000eff6:	2301      	movs	r3, #1
9000eff8:	e03e      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
    }
    else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DCRCFAIL))
9000effa:	68fb      	ldr	r3, [r7, #12]
9000effc:	681b      	ldr	r3, [r3, #0]
9000effe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f000:	f003 0302 	and.w	r3, r3, #2
9000f004:	2b00      	cmp	r3, #0
9000f006:	d00f      	beq.n	9000f028 <HAL_MMC_ReadBlocks+0x2c8>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f008:	68fb      	ldr	r3, [r7, #12]
9000f00a:	681b      	ldr	r3, [r3, #0]
9000f00c:	4a1c      	ldr	r2, [pc, #112]	; (9000f080 <HAL_MMC_ReadBlocks+0x320>)
9000f00e:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_CRC_FAIL;
9000f010:	68fb      	ldr	r3, [r7, #12]
9000f012:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f014:	f043 0202 	orr.w	r2, r3, #2
9000f018:	68fb      	ldr	r3, [r7, #12]
9000f01a:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f01c:	68fb      	ldr	r3, [r7, #12]
9000f01e:	2201      	movs	r2, #1
9000f020:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f024:	2301      	movs	r3, #1
9000f026:	e027      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
    }
    else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR))
9000f028:	68fb      	ldr	r3, [r7, #12]
9000f02a:	681b      	ldr	r3, [r3, #0]
9000f02c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f02e:	f003 0320 	and.w	r3, r3, #32
9000f032:	2b00      	cmp	r3, #0
9000f034:	d00f      	beq.n	9000f056 <HAL_MMC_ReadBlocks+0x2f6>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f036:	68fb      	ldr	r3, [r7, #12]
9000f038:	681b      	ldr	r3, [r3, #0]
9000f03a:	4a11      	ldr	r2, [pc, #68]	; (9000f080 <HAL_MMC_ReadBlocks+0x320>)
9000f03c:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_RX_OVERRUN;
9000f03e:	68fb      	ldr	r3, [r7, #12]
9000f040:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f042:	f043 0220 	orr.w	r2, r3, #32
9000f046:	68fb      	ldr	r3, [r7, #12]
9000f048:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f04a:	68fb      	ldr	r3, [r7, #12]
9000f04c:	2201      	movs	r2, #1
9000f04e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f052:	2301      	movs	r3, #1
9000f054:	e010      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
    {
      /* Nothing to do */
    }

    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_DATA_FLAGS);
9000f056:	68fb      	ldr	r3, [r7, #12]
9000f058:	681b      	ldr	r3, [r3, #0]
9000f05a:	4a0a      	ldr	r2, [pc, #40]	; (9000f084 <HAL_MMC_ReadBlocks+0x324>)
9000f05c:	639a      	str	r2, [r3, #56]	; 0x38

    hmmc->State = HAL_MMC_STATE_READY;
9000f05e:	68fb      	ldr	r3, [r7, #12]
9000f060:	2201      	movs	r2, #1
9000f062:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

    return HAL_OK;
9000f066:	2300      	movs	r3, #0
9000f068:	e006      	b.n	9000f078 <HAL_MMC_ReadBlocks+0x318>
  }
  else
  {
    hmmc->ErrorCode |= HAL_MMC_ERROR_BUSY;
9000f06a:	68fb      	ldr	r3, [r7, #12]
9000f06c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f06e:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
9000f072:	68fb      	ldr	r3, [r7, #12]
9000f074:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
9000f076:	2301      	movs	r3, #1
  }
}
9000f078:	4618      	mov	r0, r3
9000f07a:	3748      	adds	r7, #72	; 0x48
9000f07c:	46bd      	mov	sp, r7
9000f07e:	bd80      	pop	{r7, pc}
9000f080:	1fe00fff 	.word	0x1fe00fff
9000f084:	18000f3a 	.word	0x18000f3a

9000f088 <HAL_MMC_WriteBlocks>:
  * @param  Timeout: Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_WriteBlocks(MMC_HandleTypeDef *hmmc, uint8_t *pData, uint32_t BlockAdd,
                                      uint32_t NumberOfBlocks, uint32_t Timeout)
{
9000f088:	b580      	push	{r7, lr}
9000f08a:	b092      	sub	sp, #72	; 0x48
9000f08c:	af00      	add	r7, sp, #0
9000f08e:	60f8      	str	r0, [r7, #12]
9000f090:	60b9      	str	r1, [r7, #8]
9000f092:	607a      	str	r2, [r7, #4]
9000f094:	603b      	str	r3, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
9000f096:	f7fa f995 	bl	900093c4 <HAL_GetTick>
9000f09a:	6338      	str	r0, [r7, #48]	; 0x30
  uint32_t count;
  uint32_t data;
  uint32_t dataremaining;
  uint32_t add = BlockAdd;
9000f09c:	687b      	ldr	r3, [r7, #4]
9000f09e:	63bb      	str	r3, [r7, #56]	; 0x38
  uint8_t *tempbuff = pData;
9000f0a0:	68bb      	ldr	r3, [r7, #8]
9000f0a2:	637b      	str	r3, [r7, #52]	; 0x34

  if (NULL == pData)
9000f0a4:	68bb      	ldr	r3, [r7, #8]
9000f0a6:	2b00      	cmp	r3, #0
9000f0a8:	d107      	bne.n	9000f0ba <HAL_MMC_WriteBlocks+0x32>
  {
    hmmc->ErrorCode |= HAL_MMC_ERROR_PARAM;
9000f0aa:	68fb      	ldr	r3, [r7, #12]
9000f0ac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f0ae:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
9000f0b2:	68fb      	ldr	r3, [r7, #12]
9000f0b4:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
9000f0b6:	2301      	movs	r3, #1
9000f0b8:	e176      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
  }

  if (hmmc->State == HAL_MMC_STATE_READY)
9000f0ba:	68fb      	ldr	r3, [r7, #12]
9000f0bc:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
9000f0c0:	b2db      	uxtb	r3, r3
9000f0c2:	2b01      	cmp	r3, #1
9000f0c4:	f040 8169 	bne.w	9000f39a <HAL_MMC_WriteBlocks+0x312>
  {
    hmmc->ErrorCode = HAL_MMC_ERROR_NONE;
9000f0c8:	68fb      	ldr	r3, [r7, #12]
9000f0ca:	2200      	movs	r2, #0
9000f0cc:	635a      	str	r2, [r3, #52]	; 0x34

    if ((BlockAdd + NumberOfBlocks) > (hmmc->MmcCard.LogBlockNbr))
9000f0ce:	687a      	ldr	r2, [r7, #4]
9000f0d0:	683b      	ldr	r3, [r7, #0]
9000f0d2:	441a      	add	r2, r3
9000f0d4:	68fb      	ldr	r3, [r7, #12]
9000f0d6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000f0d8:	429a      	cmp	r2, r3
9000f0da:	d907      	bls.n	9000f0ec <HAL_MMC_WriteBlocks+0x64>
    {
      hmmc->ErrorCode |= HAL_MMC_ERROR_ADDR_OUT_OF_RANGE;
9000f0dc:	68fb      	ldr	r3, [r7, #12]
9000f0de:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f0e0:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
9000f0e4:	68fb      	ldr	r3, [r7, #12]
9000f0e6:	635a      	str	r2, [r3, #52]	; 0x34
      return HAL_ERROR;
9000f0e8:	2301      	movs	r3, #1
9000f0ea:	e15d      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
    }

    /* Check the case of 4kB blocks (field DATA SECTOR SIZE of extended CSD register) */
    if (((hmmc->Ext_CSD[(MMC_EXT_CSD_DATA_SEC_SIZE_INDEX / 4)] >> MMC_EXT_CSD_DATA_SEC_SIZE_POS) & 0x000000FFU) != 0x0U)
9000f0ec:	68fb      	ldr	r3, [r7, #12]
9000f0ee:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
9000f0f2:	0a1b      	lsrs	r3, r3, #8
9000f0f4:	b2db      	uxtb	r3, r3
9000f0f6:	2b00      	cmp	r3, #0
9000f0f8:	d019      	beq.n	9000f12e <HAL_MMC_WriteBlocks+0xa6>
    {
      if ((NumberOfBlocks % 8U) != 0U)
9000f0fa:	683b      	ldr	r3, [r7, #0]
9000f0fc:	f003 0307 	and.w	r3, r3, #7
9000f100:	2b00      	cmp	r3, #0
9000f102:	d007      	beq.n	9000f114 <HAL_MMC_WriteBlocks+0x8c>
      {
        /* The number of blocks should be a multiple of 8 sectors of 512 bytes = 4 KBytes */
        hmmc->ErrorCode |= HAL_MMC_ERROR_BLOCK_LEN_ERR;
9000f104:	68fb      	ldr	r3, [r7, #12]
9000f106:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f108:	f043 0280 	orr.w	r2, r3, #128	; 0x80
9000f10c:	68fb      	ldr	r3, [r7, #12]
9000f10e:	635a      	str	r2, [r3, #52]	; 0x34
        return HAL_ERROR;
9000f110:	2301      	movs	r3, #1
9000f112:	e149      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
      }

      if ((BlockAdd % 8U) != 0U)
9000f114:	687b      	ldr	r3, [r7, #4]
9000f116:	f003 0307 	and.w	r3, r3, #7
9000f11a:	2b00      	cmp	r3, #0
9000f11c:	d007      	beq.n	9000f12e <HAL_MMC_WriteBlocks+0xa6>
      {
        /* The address should be aligned to 8 (corresponding to 4 KBytes blocks) */
        hmmc->ErrorCode |= HAL_MMC_ERROR_ADDR_MISALIGNED;
9000f11e:	68fb      	ldr	r3, [r7, #12]
9000f120:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f122:	f043 0240 	orr.w	r2, r3, #64	; 0x40
9000f126:	68fb      	ldr	r3, [r7, #12]
9000f128:	635a      	str	r2, [r3, #52]	; 0x34
        return HAL_ERROR;
9000f12a:	2301      	movs	r3, #1
9000f12c:	e13c      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
      }
    }

    hmmc->State = HAL_MMC_STATE_BUSY;
9000f12e:	68fb      	ldr	r3, [r7, #12]
9000f130:	2203      	movs	r2, #3
9000f132:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

    /* Initialize data control register */
    hmmc->Instance->DCTRL = 0U;
9000f136:	68fb      	ldr	r3, [r7, #12]
9000f138:	681b      	ldr	r3, [r3, #0]
9000f13a:	2200      	movs	r2, #0
9000f13c:	62da      	str	r2, [r3, #44]	; 0x2c

    if ((hmmc->MmcCard.CardType) != MMC_HIGH_CAPACITY_CARD)
9000f13e:	68fb      	ldr	r3, [r7, #12]
9000f140:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9000f142:	2b01      	cmp	r3, #1
9000f144:	d002      	beq.n	9000f14c <HAL_MMC_WriteBlocks+0xc4>
    {
      add *= 512U;
9000f146:	6bbb      	ldr	r3, [r7, #56]	; 0x38
9000f148:	025b      	lsls	r3, r3, #9
9000f14a:	63bb      	str	r3, [r7, #56]	; 0x38
    }

    /* Configure the MMC DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
9000f14c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9000f150:	61bb      	str	r3, [r7, #24]
    config.DataLength    = NumberOfBlocks * MMC_BLOCKSIZE;
9000f152:	683b      	ldr	r3, [r7, #0]
9000f154:	025b      	lsls	r3, r3, #9
9000f156:	61fb      	str	r3, [r7, #28]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
9000f158:	2390      	movs	r3, #144	; 0x90
9000f15a:	623b      	str	r3, [r7, #32]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
9000f15c:	2300      	movs	r3, #0
9000f15e:	627b      	str	r3, [r7, #36]	; 0x24
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
9000f160:	2300      	movs	r3, #0
9000f162:	62bb      	str	r3, [r7, #40]	; 0x28
    config.DPSM          = SDMMC_DPSM_DISABLE;
9000f164:	2300      	movs	r3, #0
9000f166:	62fb      	str	r3, [r7, #44]	; 0x2c
    (void)SDMMC_ConfigData(hmmc->Instance, &config);
9000f168:	68fb      	ldr	r3, [r7, #12]
9000f16a:	681b      	ldr	r3, [r3, #0]
9000f16c:	f107 0218 	add.w	r2, r7, #24
9000f170:	4611      	mov	r1, r2
9000f172:	4618      	mov	r0, r3
9000f174:	f005 ff54 	bl	90015020 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE(hmmc->Instance);
9000f178:	68fb      	ldr	r3, [r7, #12]
9000f17a:	681b      	ldr	r3, [r3, #0]
9000f17c:	68da      	ldr	r2, [r3, #12]
9000f17e:	68fb      	ldr	r3, [r7, #12]
9000f180:	681b      	ldr	r3, [r3, #0]
9000f182:	f042 0240 	orr.w	r2, r2, #64	; 0x40
9000f186:	60da      	str	r2, [r3, #12]

    /* Write Blocks in Polling mode */
    if (NumberOfBlocks > 1U)
9000f188:	683b      	ldr	r3, [r7, #0]
9000f18a:	2b01      	cmp	r3, #1
9000f18c:	d90a      	bls.n	9000f1a4 <HAL_MMC_WriteBlocks+0x11c>
    {
      hmmc->Context = MMC_CONTEXT_WRITE_MULTIPLE_BLOCK;
9000f18e:	68fb      	ldr	r3, [r7, #12]
9000f190:	2220      	movs	r2, #32
9000f192:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Write Multi Block command */
      errorstate = SDMMC_CmdWriteMultiBlock(hmmc->Instance, add);
9000f194:	68fb      	ldr	r3, [r7, #12]
9000f196:	681b      	ldr	r3, [r3, #0]
9000f198:	6bb9      	ldr	r1, [r7, #56]	; 0x38
9000f19a:	4618      	mov	r0, r3
9000f19c:	f005 fff8 	bl	90015190 <SDMMC_CmdWriteMultiBlock>
9000f1a0:	6478      	str	r0, [r7, #68]	; 0x44
9000f1a2:	e009      	b.n	9000f1b8 <HAL_MMC_WriteBlocks+0x130>
    }
    else
    {
      hmmc->Context = MMC_CONTEXT_WRITE_SINGLE_BLOCK;
9000f1a4:	68fb      	ldr	r3, [r7, #12]
9000f1a6:	2210      	movs	r2, #16
9000f1a8:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Write Single Block command */
      errorstate = SDMMC_CmdWriteSingleBlock(hmmc->Instance, add);
9000f1aa:	68fb      	ldr	r3, [r7, #12]
9000f1ac:	681b      	ldr	r3, [r3, #0]
9000f1ae:	6bb9      	ldr	r1, [r7, #56]	; 0x38
9000f1b0:	4618      	mov	r0, r3
9000f1b2:	f005 ffca 	bl	9001514a <SDMMC_CmdWriteSingleBlock>
9000f1b6:	6478      	str	r0, [r7, #68]	; 0x44
    }
    if (errorstate != HAL_MMC_ERROR_NONE)
9000f1b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
9000f1ba:	2b00      	cmp	r3, #0
9000f1bc:	d00f      	beq.n	9000f1de <HAL_MMC_WriteBlocks+0x156>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f1be:	68fb      	ldr	r3, [r7, #12]
9000f1c0:	681b      	ldr	r3, [r3, #0]
9000f1c2:	4a7b      	ldr	r2, [pc, #492]	; (9000f3b0 <HAL_MMC_WriteBlocks+0x328>)
9000f1c4:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= errorstate;
9000f1c6:	68fb      	ldr	r3, [r7, #12]
9000f1c8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000f1ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
9000f1cc:	431a      	orrs	r2, r3
9000f1ce:	68fb      	ldr	r3, [r7, #12]
9000f1d0:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f1d2:	68fb      	ldr	r3, [r7, #12]
9000f1d4:	2201      	movs	r2, #1
9000f1d6:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f1da:	2301      	movs	r3, #1
9000f1dc:	e0e4      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
    }

    /* Write block(s) in polling mode */
    dataremaining = config.DataLength;
9000f1de:	69fb      	ldr	r3, [r7, #28]
9000f1e0:	63fb      	str	r3, [r7, #60]	; 0x3c
    while (!__HAL_MMC_GET_FLAG(hmmc,
9000f1e2:	e059      	b.n	9000f298 <HAL_MMC_WriteBlocks+0x210>
                               SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
    {
      if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_TXFIFOHE) && (dataremaining >= 32U))
9000f1e4:	68fb      	ldr	r3, [r7, #12]
9000f1e6:	681b      	ldr	r3, [r3, #0]
9000f1e8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f1ea:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
9000f1ee:	2b00      	cmp	r3, #0
9000f1f0:	d037      	beq.n	9000f262 <HAL_MMC_WriteBlocks+0x1da>
9000f1f2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
9000f1f4:	2b1f      	cmp	r3, #31
9000f1f6:	d934      	bls.n	9000f262 <HAL_MMC_WriteBlocks+0x1da>
      {
        /* Write data to SDMMC Tx FIFO */
        for (count = 0U; count < 8U; count++)
9000f1f8:	2300      	movs	r3, #0
9000f1fa:	643b      	str	r3, [r7, #64]	; 0x40
9000f1fc:	e02b      	b.n	9000f256 <HAL_MMC_WriteBlocks+0x1ce>
        {
          data = (uint32_t)(*tempbuff);
9000f1fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000f200:	781b      	ldrb	r3, [r3, #0]
9000f202:	617b      	str	r3, [r7, #20]
          tempbuff++;
9000f204:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000f206:	3301      	adds	r3, #1
9000f208:	637b      	str	r3, [r7, #52]	; 0x34
          data |= ((uint32_t)(*tempbuff) << 8U);
9000f20a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000f20c:	781b      	ldrb	r3, [r3, #0]
9000f20e:	021a      	lsls	r2, r3, #8
9000f210:	697b      	ldr	r3, [r7, #20]
9000f212:	4313      	orrs	r3, r2
9000f214:	617b      	str	r3, [r7, #20]
          tempbuff++;
9000f216:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000f218:	3301      	adds	r3, #1
9000f21a:	637b      	str	r3, [r7, #52]	; 0x34
          data |= ((uint32_t)(*tempbuff) << 16U);
9000f21c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000f21e:	781b      	ldrb	r3, [r3, #0]
9000f220:	041a      	lsls	r2, r3, #16
9000f222:	697b      	ldr	r3, [r7, #20]
9000f224:	4313      	orrs	r3, r2
9000f226:	617b      	str	r3, [r7, #20]
          tempbuff++;
9000f228:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000f22a:	3301      	adds	r3, #1
9000f22c:	637b      	str	r3, [r7, #52]	; 0x34
          data |= ((uint32_t)(*tempbuff) << 24U);
9000f22e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000f230:	781b      	ldrb	r3, [r3, #0]
9000f232:	061a      	lsls	r2, r3, #24
9000f234:	697b      	ldr	r3, [r7, #20]
9000f236:	4313      	orrs	r3, r2
9000f238:	617b      	str	r3, [r7, #20]
          tempbuff++;
9000f23a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000f23c:	3301      	adds	r3, #1
9000f23e:	637b      	str	r3, [r7, #52]	; 0x34
          (void)SDMMC_WriteFIFO(hmmc->Instance, &data);
9000f240:	68fb      	ldr	r3, [r7, #12]
9000f242:	681b      	ldr	r3, [r3, #0]
9000f244:	f107 0214 	add.w	r2, r7, #20
9000f248:	4611      	mov	r1, r2
9000f24a:	4618      	mov	r0, r3
9000f24c:	f005 fe6d 	bl	90014f2a <SDMMC_WriteFIFO>
        for (count = 0U; count < 8U; count++)
9000f250:	6c3b      	ldr	r3, [r7, #64]	; 0x40
9000f252:	3301      	adds	r3, #1
9000f254:	643b      	str	r3, [r7, #64]	; 0x40
9000f256:	6c3b      	ldr	r3, [r7, #64]	; 0x40
9000f258:	2b07      	cmp	r3, #7
9000f25a:	d9d0      	bls.n	9000f1fe <HAL_MMC_WriteBlocks+0x176>
        }
        dataremaining -= 32U;
9000f25c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
9000f25e:	3b20      	subs	r3, #32
9000f260:	63fb      	str	r3, [r7, #60]	; 0x3c
      }

      if (((HAL_GetTick() - tickstart) >=  Timeout) || (Timeout == 0U))
9000f262:	f7fa f8af 	bl	900093c4 <HAL_GetTick>
9000f266:	4602      	mov	r2, r0
9000f268:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9000f26a:	1ad3      	subs	r3, r2, r3
9000f26c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
9000f26e:	429a      	cmp	r2, r3
9000f270:	d902      	bls.n	9000f278 <HAL_MMC_WriteBlocks+0x1f0>
9000f272:	6d3b      	ldr	r3, [r7, #80]	; 0x50
9000f274:	2b00      	cmp	r3, #0
9000f276:	d10f      	bne.n	9000f298 <HAL_MMC_WriteBlocks+0x210>
      {
        /* Clear all the static flags */
        __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f278:	68fb      	ldr	r3, [r7, #12]
9000f27a:	681b      	ldr	r3, [r3, #0]
9000f27c:	4a4c      	ldr	r2, [pc, #304]	; (9000f3b0 <HAL_MMC_WriteBlocks+0x328>)
9000f27e:	639a      	str	r2, [r3, #56]	; 0x38
        hmmc->ErrorCode |= errorstate;
9000f280:	68fb      	ldr	r3, [r7, #12]
9000f282:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000f284:	6c7b      	ldr	r3, [r7, #68]	; 0x44
9000f286:	431a      	orrs	r2, r3
9000f288:	68fb      	ldr	r3, [r7, #12]
9000f28a:	635a      	str	r2, [r3, #52]	; 0x34
        hmmc->State = HAL_MMC_STATE_READY;
9000f28c:	68fb      	ldr	r3, [r7, #12]
9000f28e:	2201      	movs	r2, #1
9000f290:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        return HAL_TIMEOUT;
9000f294:	2303      	movs	r3, #3
9000f296:	e087      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
    while (!__HAL_MMC_GET_FLAG(hmmc,
9000f298:	68fb      	ldr	r3, [r7, #12]
9000f29a:	681b      	ldr	r3, [r3, #0]
9000f29c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f29e:	f403 738d 	and.w	r3, r3, #282	; 0x11a
9000f2a2:	2b00      	cmp	r3, #0
9000f2a4:	d09e      	beq.n	9000f1e4 <HAL_MMC_WriteBlocks+0x15c>
      }
    }
    __SDMMC_CMDTRANS_DISABLE(hmmc->Instance);
9000f2a6:	68fb      	ldr	r3, [r7, #12]
9000f2a8:	681b      	ldr	r3, [r3, #0]
9000f2aa:	68da      	ldr	r2, [r3, #12]
9000f2ac:	68fb      	ldr	r3, [r7, #12]
9000f2ae:	681b      	ldr	r3, [r3, #0]
9000f2b0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
9000f2b4:	60da      	str	r2, [r3, #12]

    /* Send stop transmission command in case of multiblock write */
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
9000f2b6:	68fb      	ldr	r3, [r7, #12]
9000f2b8:	681b      	ldr	r3, [r3, #0]
9000f2ba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f2bc:	f403 7380 	and.w	r3, r3, #256	; 0x100
9000f2c0:	2b00      	cmp	r3, #0
9000f2c2:	d01b      	beq.n	9000f2fc <HAL_MMC_WriteBlocks+0x274>
9000f2c4:	683b      	ldr	r3, [r7, #0]
9000f2c6:	2b01      	cmp	r3, #1
9000f2c8:	d918      	bls.n	9000f2fc <HAL_MMC_WriteBlocks+0x274>
    {
      /* Send stop transmission command */
      errorstate = SDMMC_CmdStopTransfer(hmmc->Instance);
9000f2ca:	68fb      	ldr	r3, [r7, #12]
9000f2cc:	681b      	ldr	r3, [r3, #0]
9000f2ce:	4618      	mov	r0, r3
9000f2d0:	f005 ffea 	bl	900152a8 <SDMMC_CmdStopTransfer>
9000f2d4:	6478      	str	r0, [r7, #68]	; 0x44
      if (errorstate != HAL_MMC_ERROR_NONE)
9000f2d6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
9000f2d8:	2b00      	cmp	r3, #0
9000f2da:	d00f      	beq.n	9000f2fc <HAL_MMC_WriteBlocks+0x274>
      {
        /* Clear all the static flags */
        __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f2dc:	68fb      	ldr	r3, [r7, #12]
9000f2de:	681b      	ldr	r3, [r3, #0]
9000f2e0:	4a33      	ldr	r2, [pc, #204]	; (9000f3b0 <HAL_MMC_WriteBlocks+0x328>)
9000f2e2:	639a      	str	r2, [r3, #56]	; 0x38
        hmmc->ErrorCode |= errorstate;
9000f2e4:	68fb      	ldr	r3, [r7, #12]
9000f2e6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000f2e8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
9000f2ea:	431a      	orrs	r2, r3
9000f2ec:	68fb      	ldr	r3, [r7, #12]
9000f2ee:	635a      	str	r2, [r3, #52]	; 0x34
        hmmc->State = HAL_MMC_STATE_READY;
9000f2f0:	68fb      	ldr	r3, [r7, #12]
9000f2f2:	2201      	movs	r2, #1
9000f2f4:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        return HAL_ERROR;
9000f2f8:	2301      	movs	r3, #1
9000f2fa:	e055      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
      }
    }

    /* Get error state */
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DTIMEOUT))
9000f2fc:	68fb      	ldr	r3, [r7, #12]
9000f2fe:	681b      	ldr	r3, [r3, #0]
9000f300:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f302:	f003 0308 	and.w	r3, r3, #8
9000f306:	2b00      	cmp	r3, #0
9000f308:	d00f      	beq.n	9000f32a <HAL_MMC_WriteBlocks+0x2a2>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f30a:	68fb      	ldr	r3, [r7, #12]
9000f30c:	681b      	ldr	r3, [r3, #0]
9000f30e:	4a28      	ldr	r2, [pc, #160]	; (9000f3b0 <HAL_MMC_WriteBlocks+0x328>)
9000f310:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_TIMEOUT;
9000f312:	68fb      	ldr	r3, [r7, #12]
9000f314:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f316:	f043 0208 	orr.w	r2, r3, #8
9000f31a:	68fb      	ldr	r3, [r7, #12]
9000f31c:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f31e:	68fb      	ldr	r3, [r7, #12]
9000f320:	2201      	movs	r2, #1
9000f322:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f326:	2301      	movs	r3, #1
9000f328:	e03e      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
    }
    else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DCRCFAIL))
9000f32a:	68fb      	ldr	r3, [r7, #12]
9000f32c:	681b      	ldr	r3, [r3, #0]
9000f32e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f330:	f003 0302 	and.w	r3, r3, #2
9000f334:	2b00      	cmp	r3, #0
9000f336:	d00f      	beq.n	9000f358 <HAL_MMC_WriteBlocks+0x2d0>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f338:	68fb      	ldr	r3, [r7, #12]
9000f33a:	681b      	ldr	r3, [r3, #0]
9000f33c:	4a1c      	ldr	r2, [pc, #112]	; (9000f3b0 <HAL_MMC_WriteBlocks+0x328>)
9000f33e:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_CRC_FAIL;
9000f340:	68fb      	ldr	r3, [r7, #12]
9000f342:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f344:	f043 0202 	orr.w	r2, r3, #2
9000f348:	68fb      	ldr	r3, [r7, #12]
9000f34a:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f34c:	68fb      	ldr	r3, [r7, #12]
9000f34e:	2201      	movs	r2, #1
9000f350:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f354:	2301      	movs	r3, #1
9000f356:	e027      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
    }
    else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_TXUNDERR))
9000f358:	68fb      	ldr	r3, [r7, #12]
9000f35a:	681b      	ldr	r3, [r3, #0]
9000f35c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f35e:	f003 0310 	and.w	r3, r3, #16
9000f362:	2b00      	cmp	r3, #0
9000f364:	d00f      	beq.n	9000f386 <HAL_MMC_WriteBlocks+0x2fe>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f366:	68fb      	ldr	r3, [r7, #12]
9000f368:	681b      	ldr	r3, [r3, #0]
9000f36a:	4a11      	ldr	r2, [pc, #68]	; (9000f3b0 <HAL_MMC_WriteBlocks+0x328>)
9000f36c:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_TX_UNDERRUN;
9000f36e:	68fb      	ldr	r3, [r7, #12]
9000f370:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f372:	f043 0210 	orr.w	r2, r3, #16
9000f376:	68fb      	ldr	r3, [r7, #12]
9000f378:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f37a:	68fb      	ldr	r3, [r7, #12]
9000f37c:	2201      	movs	r2, #1
9000f37e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f382:	2301      	movs	r3, #1
9000f384:	e010      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
    {
      /* Nothing to do */
    }

    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_DATA_FLAGS);
9000f386:	68fb      	ldr	r3, [r7, #12]
9000f388:	681b      	ldr	r3, [r3, #0]
9000f38a:	4a0a      	ldr	r2, [pc, #40]	; (9000f3b4 <HAL_MMC_WriteBlocks+0x32c>)
9000f38c:	639a      	str	r2, [r3, #56]	; 0x38

    hmmc->State = HAL_MMC_STATE_READY;
9000f38e:	68fb      	ldr	r3, [r7, #12]
9000f390:	2201      	movs	r2, #1
9000f392:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

    return HAL_OK;
9000f396:	2300      	movs	r3, #0
9000f398:	e006      	b.n	9000f3a8 <HAL_MMC_WriteBlocks+0x320>
  }
  else
  {
    hmmc->ErrorCode |= HAL_MMC_ERROR_BUSY;
9000f39a:	68fb      	ldr	r3, [r7, #12]
9000f39c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f39e:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
9000f3a2:	68fb      	ldr	r3, [r7, #12]
9000f3a4:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
9000f3a6:	2301      	movs	r3, #1
  }
}
9000f3a8:	4618      	mov	r0, r3
9000f3aa:	3748      	adds	r7, #72	; 0x48
9000f3ac:	46bd      	mov	sp, r7
9000f3ae:	bd80      	pop	{r7, pc}
9000f3b0:	1fe00fff 	.word	0x1fe00fff
9000f3b4:	18000f3a 	.word	0x18000f3a

9000f3b8 <HAL_MMC_Erase>:
  * @param  BlockStartAdd: Start Block address
  * @param  BlockEndAdd: End Block address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_Erase(MMC_HandleTypeDef *hmmc, uint32_t BlockStartAdd, uint32_t BlockEndAdd)
{
9000f3b8:	b580      	push	{r7, lr}
9000f3ba:	b088      	sub	sp, #32
9000f3bc:	af00      	add	r7, sp, #0
9000f3be:	60f8      	str	r0, [r7, #12]
9000f3c0:	60b9      	str	r1, [r7, #8]
9000f3c2:	607a      	str	r2, [r7, #4]
  uint32_t errorstate;
  uint32_t start_add = BlockStartAdd;
9000f3c4:	68bb      	ldr	r3, [r7, #8]
9000f3c6:	61fb      	str	r3, [r7, #28]
  uint32_t end_add = BlockEndAdd;
9000f3c8:	687b      	ldr	r3, [r7, #4]
9000f3ca:	61bb      	str	r3, [r7, #24]

  if (hmmc->State == HAL_MMC_STATE_READY)
9000f3cc:	68fb      	ldr	r3, [r7, #12]
9000f3ce:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
9000f3d2:	b2db      	uxtb	r3, r3
9000f3d4:	2b01      	cmp	r3, #1
9000f3d6:	f040 80c9 	bne.w	9000f56c <HAL_MMC_Erase+0x1b4>
  {
    hmmc->ErrorCode = HAL_MMC_ERROR_NONE;
9000f3da:	68fb      	ldr	r3, [r7, #12]
9000f3dc:	2200      	movs	r2, #0
9000f3de:	635a      	str	r2, [r3, #52]	; 0x34

    if (end_add < start_add)
9000f3e0:	69ba      	ldr	r2, [r7, #24]
9000f3e2:	69fb      	ldr	r3, [r7, #28]
9000f3e4:	429a      	cmp	r2, r3
9000f3e6:	d207      	bcs.n	9000f3f8 <HAL_MMC_Erase+0x40>
    {
      hmmc->ErrorCode |= HAL_MMC_ERROR_PARAM;
9000f3e8:	68fb      	ldr	r3, [r7, #12]
9000f3ea:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f3ec:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
9000f3f0:	68fb      	ldr	r3, [r7, #12]
9000f3f2:	635a      	str	r2, [r3, #52]	; 0x34
      return HAL_ERROR;
9000f3f4:	2301      	movs	r3, #1
9000f3f6:	e0ba      	b.n	9000f56e <HAL_MMC_Erase+0x1b6>
    }

    if (end_add > (hmmc->MmcCard.LogBlockNbr))
9000f3f8:	68fb      	ldr	r3, [r7, #12]
9000f3fa:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9000f3fc:	69ba      	ldr	r2, [r7, #24]
9000f3fe:	429a      	cmp	r2, r3
9000f400:	d907      	bls.n	9000f412 <HAL_MMC_Erase+0x5a>
    {
      hmmc->ErrorCode |= HAL_MMC_ERROR_ADDR_OUT_OF_RANGE;
9000f402:	68fb      	ldr	r3, [r7, #12]
9000f404:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f406:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
9000f40a:	68fb      	ldr	r3, [r7, #12]
9000f40c:	635a      	str	r2, [r3, #52]	; 0x34
      return HAL_ERROR;
9000f40e:	2301      	movs	r3, #1
9000f410:	e0ad      	b.n	9000f56e <HAL_MMC_Erase+0x1b6>
    }

    /* Check the case of 4kB blocks (field DATA SECTOR SIZE of extended CSD register) */
    if (((hmmc->Ext_CSD[(MMC_EXT_CSD_DATA_SEC_SIZE_INDEX / 4)] >> MMC_EXT_CSD_DATA_SEC_SIZE_POS)
9000f412:	68fb      	ldr	r3, [r7, #12]
9000f414:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
9000f418:	0a1b      	lsrs	r3, r3, #8
         & 0x000000FFU) != 0x0U)
9000f41a:	b2db      	uxtb	r3, r3
    if (((hmmc->Ext_CSD[(MMC_EXT_CSD_DATA_SEC_SIZE_INDEX / 4)] >> MMC_EXT_CSD_DATA_SEC_SIZE_POS)
9000f41c:	2b00      	cmp	r3, #0
9000f41e:	d011      	beq.n	9000f444 <HAL_MMC_Erase+0x8c>
    {
      if (((start_add % 8U) != 0U) || ((end_add % 8U) != 0U))
9000f420:	69fb      	ldr	r3, [r7, #28]
9000f422:	f003 0307 	and.w	r3, r3, #7
9000f426:	2b00      	cmp	r3, #0
9000f428:	d104      	bne.n	9000f434 <HAL_MMC_Erase+0x7c>
9000f42a:	69bb      	ldr	r3, [r7, #24]
9000f42c:	f003 0307 	and.w	r3, r3, #7
9000f430:	2b00      	cmp	r3, #0
9000f432:	d007      	beq.n	9000f444 <HAL_MMC_Erase+0x8c>
      {
        /* The address should be aligned to 8 (corresponding to 4 KBytes blocks) */
        hmmc->ErrorCode |= HAL_MMC_ERROR_ADDR_MISALIGNED;
9000f434:	68fb      	ldr	r3, [r7, #12]
9000f436:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f438:	f043 0240 	orr.w	r2, r3, #64	; 0x40
9000f43c:	68fb      	ldr	r3, [r7, #12]
9000f43e:	635a      	str	r2, [r3, #52]	; 0x34
        return HAL_ERROR;
9000f440:	2301      	movs	r3, #1
9000f442:	e094      	b.n	9000f56e <HAL_MMC_Erase+0x1b6>
      }
    }

    hmmc->State = HAL_MMC_STATE_BUSY;
9000f444:	68fb      	ldr	r3, [r7, #12]
9000f446:	2203      	movs	r2, #3
9000f448:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

    /* Check if the card command class supports erase command */
    if (((hmmc->MmcCard.Class) & SDMMC_CCCC_ERASE) == 0U)
9000f44c:	68fb      	ldr	r3, [r7, #12]
9000f44e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
9000f450:	f003 0320 	and.w	r3, r3, #32
9000f454:	2b00      	cmp	r3, #0
9000f456:	d10f      	bne.n	9000f478 <HAL_MMC_Erase+0xc0>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f458:	68fb      	ldr	r3, [r7, #12]
9000f45a:	681b      	ldr	r3, [r3, #0]
9000f45c:	4a46      	ldr	r2, [pc, #280]	; (9000f578 <HAL_MMC_Erase+0x1c0>)
9000f45e:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_REQUEST_NOT_APPLICABLE;
9000f460:	68fb      	ldr	r3, [r7, #12]
9000f462:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f464:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
9000f468:	68fb      	ldr	r3, [r7, #12]
9000f46a:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f46c:	68fb      	ldr	r3, [r7, #12]
9000f46e:	2201      	movs	r2, #1
9000f470:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f474:	2301      	movs	r3, #1
9000f476:	e07a      	b.n	9000f56e <HAL_MMC_Erase+0x1b6>
    }

    if ((SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
9000f478:	68fb      	ldr	r3, [r7, #12]
9000f47a:	681b      	ldr	r3, [r3, #0]
9000f47c:	2100      	movs	r1, #0
9000f47e:	4618      	mov	r0, r3
9000f480:	f005 fdbb 	bl	90014ffa <SDMMC_GetResponse>
9000f484:	4603      	mov	r3, r0
9000f486:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
9000f48a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
9000f48e:	d10f      	bne.n	9000f4b0 <HAL_MMC_Erase+0xf8>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f490:	68fb      	ldr	r3, [r7, #12]
9000f492:	681b      	ldr	r3, [r3, #0]
9000f494:	4a38      	ldr	r2, [pc, #224]	; (9000f578 <HAL_MMC_Erase+0x1c0>)
9000f496:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_LOCK_UNLOCK_FAILED;
9000f498:	68fb      	ldr	r3, [r7, #12]
9000f49a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f49c:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
9000f4a0:	68fb      	ldr	r3, [r7, #12]
9000f4a2:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f4a4:	68fb      	ldr	r3, [r7, #12]
9000f4a6:	2201      	movs	r2, #1
9000f4a8:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f4ac:	2301      	movs	r3, #1
9000f4ae:	e05e      	b.n	9000f56e <HAL_MMC_Erase+0x1b6>
    }

    if ((hmmc->MmcCard.CardType) != MMC_HIGH_CAPACITY_CARD)
9000f4b0:	68fb      	ldr	r3, [r7, #12]
9000f4b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9000f4b4:	2b01      	cmp	r3, #1
9000f4b6:	d005      	beq.n	9000f4c4 <HAL_MMC_Erase+0x10c>
    {
      start_add *= 512U;
9000f4b8:	69fb      	ldr	r3, [r7, #28]
9000f4ba:	025b      	lsls	r3, r3, #9
9000f4bc:	61fb      	str	r3, [r7, #28]
      end_add   *= 512U;
9000f4be:	69bb      	ldr	r3, [r7, #24]
9000f4c0:	025b      	lsls	r3, r3, #9
9000f4c2:	61bb      	str	r3, [r7, #24]
    }

    /* Send CMD35 MMC_ERASE_GRP_START with argument as addr  */
    errorstate = SDMMC_CmdEraseStartAdd(hmmc->Instance, start_add);
9000f4c4:	68fb      	ldr	r3, [r7, #12]
9000f4c6:	681b      	ldr	r3, [r3, #0]
9000f4c8:	69f9      	ldr	r1, [r7, #28]
9000f4ca:	4618      	mov	r0, r3
9000f4cc:	f005 fe83 	bl	900151d6 <SDMMC_CmdEraseStartAdd>
9000f4d0:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_MMC_ERROR_NONE)
9000f4d2:	697b      	ldr	r3, [r7, #20]
9000f4d4:	2b00      	cmp	r3, #0
9000f4d6:	d00f      	beq.n	9000f4f8 <HAL_MMC_Erase+0x140>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f4d8:	68fb      	ldr	r3, [r7, #12]
9000f4da:	681b      	ldr	r3, [r3, #0]
9000f4dc:	4a26      	ldr	r2, [pc, #152]	; (9000f578 <HAL_MMC_Erase+0x1c0>)
9000f4de:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= errorstate;
9000f4e0:	68fb      	ldr	r3, [r7, #12]
9000f4e2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000f4e4:	697b      	ldr	r3, [r7, #20]
9000f4e6:	431a      	orrs	r2, r3
9000f4e8:	68fb      	ldr	r3, [r7, #12]
9000f4ea:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f4ec:	68fb      	ldr	r3, [r7, #12]
9000f4ee:	2201      	movs	r2, #1
9000f4f0:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f4f4:	2301      	movs	r3, #1
9000f4f6:	e03a      	b.n	9000f56e <HAL_MMC_Erase+0x1b6>
    }

    /* Send CMD36 MMC_ERASE_GRP_END with argument as addr  */
    errorstate = SDMMC_CmdEraseEndAdd(hmmc->Instance, end_add);
9000f4f8:	68fb      	ldr	r3, [r7, #12]
9000f4fa:	681b      	ldr	r3, [r3, #0]
9000f4fc:	69b9      	ldr	r1, [r7, #24]
9000f4fe:	4618      	mov	r0, r3
9000f500:	f005 fe8c 	bl	9001521c <SDMMC_CmdEraseEndAdd>
9000f504:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_MMC_ERROR_NONE)
9000f506:	697b      	ldr	r3, [r7, #20]
9000f508:	2b00      	cmp	r3, #0
9000f50a:	d00f      	beq.n	9000f52c <HAL_MMC_Erase+0x174>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f50c:	68fb      	ldr	r3, [r7, #12]
9000f50e:	681b      	ldr	r3, [r3, #0]
9000f510:	4a19      	ldr	r2, [pc, #100]	; (9000f578 <HAL_MMC_Erase+0x1c0>)
9000f512:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= errorstate;
9000f514:	68fb      	ldr	r3, [r7, #12]
9000f516:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000f518:	697b      	ldr	r3, [r7, #20]
9000f51a:	431a      	orrs	r2, r3
9000f51c:	68fb      	ldr	r3, [r7, #12]
9000f51e:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f520:	68fb      	ldr	r3, [r7, #12]
9000f522:	2201      	movs	r2, #1
9000f524:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f528:	2301      	movs	r3, #1
9000f52a:	e020      	b.n	9000f56e <HAL_MMC_Erase+0x1b6>
    }

    /* Send CMD38 ERASE */
    errorstate = SDMMC_CmdErase(hmmc->Instance, 0UL);
9000f52c:	68fb      	ldr	r3, [r7, #12]
9000f52e:	681b      	ldr	r3, [r3, #0]
9000f530:	2100      	movs	r1, #0
9000f532:	4618      	mov	r0, r3
9000f534:	f005 fe95 	bl	90015262 <SDMMC_CmdErase>
9000f538:	6178      	str	r0, [r7, #20]
    if (errorstate != HAL_MMC_ERROR_NONE)
9000f53a:	697b      	ldr	r3, [r7, #20]
9000f53c:	2b00      	cmp	r3, #0
9000f53e:	d00f      	beq.n	9000f560 <HAL_MMC_Erase+0x1a8>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f540:	68fb      	ldr	r3, [r7, #12]
9000f542:	681b      	ldr	r3, [r3, #0]
9000f544:	4a0c      	ldr	r2, [pc, #48]	; (9000f578 <HAL_MMC_Erase+0x1c0>)
9000f546:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= errorstate;
9000f548:	68fb      	ldr	r3, [r7, #12]
9000f54a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000f54c:	697b      	ldr	r3, [r7, #20]
9000f54e:	431a      	orrs	r2, r3
9000f550:	68fb      	ldr	r3, [r7, #12]
9000f552:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f554:	68fb      	ldr	r3, [r7, #12]
9000f556:	2201      	movs	r2, #1
9000f558:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f55c:	2301      	movs	r3, #1
9000f55e:	e006      	b.n	9000f56e <HAL_MMC_Erase+0x1b6>
    }

    hmmc->State = HAL_MMC_STATE_READY;
9000f560:	68fb      	ldr	r3, [r7, #12]
9000f562:	2201      	movs	r2, #1
9000f564:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

    return HAL_OK;
9000f568:	2300      	movs	r3, #0
9000f56a:	e000      	b.n	9000f56e <HAL_MMC_Erase+0x1b6>
  }
  else
  {
    return HAL_BUSY;
9000f56c:	2302      	movs	r3, #2
  }
}
9000f56e:	4618      	mov	r0, r3
9000f570:	3720      	adds	r7, #32
9000f572:	46bd      	mov	sp, r7
9000f574:	bd80      	pop	{r7, pc}
9000f576:	bf00      	nop
9000f578:	1fe00fff 	.word	0x1fe00fff

9000f57c <HAL_MMC_GetCardCSD>:
  * @param  pCSD: Pointer to a HAL_MMC_CardCSDTypeDef structure that
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_GetCardCSD(MMC_HandleTypeDef *hmmc, HAL_MMC_CardCSDTypeDef *pCSD)
{
9000f57c:	b580      	push	{r7, lr}
9000f57e:	b084      	sub	sp, #16
9000f580:	af00      	add	r7, sp, #0
9000f582:	6078      	str	r0, [r7, #4]
9000f584:	6039      	str	r1, [r7, #0]
  uint32_t block_nbr = 0;
9000f586:	2300      	movs	r3, #0
9000f588:	60fb      	str	r3, [r7, #12]

  pCSD->CSDStruct = (uint8_t)((hmmc->CSD[0] & 0xC0000000U) >> 30U);
9000f58a:	687b      	ldr	r3, [r7, #4]
9000f58c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000f58e:	0f9b      	lsrs	r3, r3, #30
9000f590:	b2da      	uxtb	r2, r3
9000f592:	683b      	ldr	r3, [r7, #0]
9000f594:	701a      	strb	r2, [r3, #0]

  pCSD->SysSpecVersion = (uint8_t)((hmmc->CSD[0] & 0x3C000000U) >> 26U);
9000f596:	687b      	ldr	r3, [r7, #4]
9000f598:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000f59a:	0e9b      	lsrs	r3, r3, #26
9000f59c:	b2db      	uxtb	r3, r3
9000f59e:	f003 030f 	and.w	r3, r3, #15
9000f5a2:	b2da      	uxtb	r2, r3
9000f5a4:	683b      	ldr	r3, [r7, #0]
9000f5a6:	705a      	strb	r2, [r3, #1]

  pCSD->Reserved1 = (uint8_t)((hmmc->CSD[0] & 0x03000000U) >> 24U);
9000f5a8:	687b      	ldr	r3, [r7, #4]
9000f5aa:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000f5ac:	0e1b      	lsrs	r3, r3, #24
9000f5ae:	b2db      	uxtb	r3, r3
9000f5b0:	f003 0303 	and.w	r3, r3, #3
9000f5b4:	b2da      	uxtb	r2, r3
9000f5b6:	683b      	ldr	r3, [r7, #0]
9000f5b8:	709a      	strb	r2, [r3, #2]

  pCSD->TAAC = (uint8_t)((hmmc->CSD[0] & 0x00FF0000U) >> 16U);
9000f5ba:	687b      	ldr	r3, [r7, #4]
9000f5bc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000f5be:	0c1b      	lsrs	r3, r3, #16
9000f5c0:	b2da      	uxtb	r2, r3
9000f5c2:	683b      	ldr	r3, [r7, #0]
9000f5c4:	70da      	strb	r2, [r3, #3]

  pCSD->NSAC = (uint8_t)((hmmc->CSD[0] & 0x0000FF00U) >> 8U);
9000f5c6:	687b      	ldr	r3, [r7, #4]
9000f5c8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000f5ca:	0a1b      	lsrs	r3, r3, #8
9000f5cc:	b2da      	uxtb	r2, r3
9000f5ce:	683b      	ldr	r3, [r7, #0]
9000f5d0:	711a      	strb	r2, [r3, #4]

  pCSD->MaxBusClkFrec = (uint8_t)(hmmc->CSD[0] & 0x000000FFU);
9000f5d2:	687b      	ldr	r3, [r7, #4]
9000f5d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9000f5d6:	b2da      	uxtb	r2, r3
9000f5d8:	683b      	ldr	r3, [r7, #0]
9000f5da:	715a      	strb	r2, [r3, #5]

  pCSD->CardComdClasses = (uint16_t)((hmmc->CSD[1] & 0xFFF00000U) >> 20U);
9000f5dc:	687b      	ldr	r3, [r7, #4]
9000f5de:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000f5e0:	0d1b      	lsrs	r3, r3, #20
9000f5e2:	b29a      	uxth	r2, r3
9000f5e4:	683b      	ldr	r3, [r7, #0]
9000f5e6:	80da      	strh	r2, [r3, #6]

  pCSD->RdBlockLen = (uint8_t)((hmmc->CSD[1] & 0x000F0000U) >> 16U);
9000f5e8:	687b      	ldr	r3, [r7, #4]
9000f5ea:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000f5ec:	0c1b      	lsrs	r3, r3, #16
9000f5ee:	b2db      	uxtb	r3, r3
9000f5f0:	f003 030f 	and.w	r3, r3, #15
9000f5f4:	b2da      	uxtb	r2, r3
9000f5f6:	683b      	ldr	r3, [r7, #0]
9000f5f8:	721a      	strb	r2, [r3, #8]

  pCSD->PartBlockRead   = (uint8_t)((hmmc->CSD[1] & 0x00008000U) >> 15U);
9000f5fa:	687b      	ldr	r3, [r7, #4]
9000f5fc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000f5fe:	0bdb      	lsrs	r3, r3, #15
9000f600:	b2db      	uxtb	r3, r3
9000f602:	f003 0301 	and.w	r3, r3, #1
9000f606:	b2da      	uxtb	r2, r3
9000f608:	683b      	ldr	r3, [r7, #0]
9000f60a:	725a      	strb	r2, [r3, #9]

  pCSD->WrBlockMisalign = (uint8_t)((hmmc->CSD[1] & 0x00004000U) >> 14U);
9000f60c:	687b      	ldr	r3, [r7, #4]
9000f60e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000f610:	0b9b      	lsrs	r3, r3, #14
9000f612:	b2db      	uxtb	r3, r3
9000f614:	f003 0301 	and.w	r3, r3, #1
9000f618:	b2da      	uxtb	r2, r3
9000f61a:	683b      	ldr	r3, [r7, #0]
9000f61c:	729a      	strb	r2, [r3, #10]

  pCSD->RdBlockMisalign = (uint8_t)((hmmc->CSD[1] & 0x00002000U) >> 13U);
9000f61e:	687b      	ldr	r3, [r7, #4]
9000f620:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000f622:	0b5b      	lsrs	r3, r3, #13
9000f624:	b2db      	uxtb	r3, r3
9000f626:	f003 0301 	and.w	r3, r3, #1
9000f62a:	b2da      	uxtb	r2, r3
9000f62c:	683b      	ldr	r3, [r7, #0]
9000f62e:	72da      	strb	r2, [r3, #11]

  pCSD->DSRImpl = (uint8_t)((hmmc->CSD[1] & 0x00001000U) >> 12U);
9000f630:	687b      	ldr	r3, [r7, #4]
9000f632:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000f634:	0b1b      	lsrs	r3, r3, #12
9000f636:	b2db      	uxtb	r3, r3
9000f638:	f003 0301 	and.w	r3, r3, #1
9000f63c:	b2da      	uxtb	r2, r3
9000f63e:	683b      	ldr	r3, [r7, #0]
9000f640:	731a      	strb	r2, [r3, #12]

  pCSD->Reserved2 = 0U; /*!< Reserved */
9000f642:	683b      	ldr	r3, [r7, #0]
9000f644:	2200      	movs	r2, #0
9000f646:	735a      	strb	r2, [r3, #13]

  if (MMC_ReadExtCSD(hmmc, &block_nbr, 212, 0x0FFFFFFFU) != HAL_OK) /* Field SEC_COUNT [215:212] */
9000f648:	f107 010c 	add.w	r1, r7, #12
9000f64c:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
9000f650:	22d4      	movs	r2, #212	; 0xd4
9000f652:	6878      	ldr	r0, [r7, #4]
9000f654:	f000 fc94 	bl	9000ff80 <MMC_ReadExtCSD>
9000f658:	4603      	mov	r3, r0
9000f65a:	2b00      	cmp	r3, #0
9000f65c:	d001      	beq.n	9000f662 <HAL_MMC_GetCardCSD+0xe6>
  {
    return HAL_ERROR;
9000f65e:	2301      	movs	r3, #1
9000f660:	e129      	b.n	9000f8b6 <HAL_MMC_GetCardCSD+0x33a>
  }

  if (hmmc->MmcCard.CardType == MMC_LOW_CAPACITY_CARD)
9000f662:	687b      	ldr	r3, [r7, #4]
9000f664:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9000f666:	2b00      	cmp	r3, #0
9000f668:	d163      	bne.n	9000f732 <HAL_MMC_GetCardCSD+0x1b6>
  {
    pCSD->DeviceSize = (((hmmc->CSD[1] & 0x000003FFU) << 2U) | ((hmmc->CSD[2] & 0xC0000000U) >> 30U));
9000f66a:	687b      	ldr	r3, [r7, #4]
9000f66c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9000f66e:	009a      	lsls	r2, r3, #2
9000f670:	f640 73fc 	movw	r3, #4092	; 0xffc
9000f674:	4013      	ands	r3, r2
9000f676:	687a      	ldr	r2, [r7, #4]
9000f678:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
9000f67a:	0f92      	lsrs	r2, r2, #30
9000f67c:	431a      	orrs	r2, r3
9000f67e:	683b      	ldr	r3, [r7, #0]
9000f680:	611a      	str	r2, [r3, #16]

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hmmc->CSD[2] & 0x38000000U) >> 27U);
9000f682:	687b      	ldr	r3, [r7, #4]
9000f684:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000f686:	0edb      	lsrs	r3, r3, #27
9000f688:	b2db      	uxtb	r3, r3
9000f68a:	f003 0307 	and.w	r3, r3, #7
9000f68e:	b2da      	uxtb	r2, r3
9000f690:	683b      	ldr	r3, [r7, #0]
9000f692:	751a      	strb	r2, [r3, #20]

    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hmmc->CSD[2] & 0x07000000U) >> 24U);
9000f694:	687b      	ldr	r3, [r7, #4]
9000f696:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000f698:	0e1b      	lsrs	r3, r3, #24
9000f69a:	b2db      	uxtb	r3, r3
9000f69c:	f003 0307 	and.w	r3, r3, #7
9000f6a0:	b2da      	uxtb	r2, r3
9000f6a2:	683b      	ldr	r3, [r7, #0]
9000f6a4:	755a      	strb	r2, [r3, #21]

    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hmmc->CSD[2] & 0x00E00000U) >> 21U);
9000f6a6:	687b      	ldr	r3, [r7, #4]
9000f6a8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000f6aa:	0d5b      	lsrs	r3, r3, #21
9000f6ac:	b2db      	uxtb	r3, r3
9000f6ae:	f003 0307 	and.w	r3, r3, #7
9000f6b2:	b2da      	uxtb	r2, r3
9000f6b4:	683b      	ldr	r3, [r7, #0]
9000f6b6:	759a      	strb	r2, [r3, #22]

    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hmmc->CSD[2] & 0x001C0000U) >> 18U);
9000f6b8:	687b      	ldr	r3, [r7, #4]
9000f6ba:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000f6bc:	0c9b      	lsrs	r3, r3, #18
9000f6be:	b2db      	uxtb	r3, r3
9000f6c0:	f003 0307 	and.w	r3, r3, #7
9000f6c4:	b2da      	uxtb	r2, r3
9000f6c6:	683b      	ldr	r3, [r7, #0]
9000f6c8:	75da      	strb	r2, [r3, #23]

    pCSD->DeviceSizeMul = (uint8_t)((hmmc->CSD[2] & 0x00038000U) >> 15U);
9000f6ca:	687b      	ldr	r3, [r7, #4]
9000f6cc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000f6ce:	0bdb      	lsrs	r3, r3, #15
9000f6d0:	b2db      	uxtb	r3, r3
9000f6d2:	f003 0307 	and.w	r3, r3, #7
9000f6d6:	b2da      	uxtb	r2, r3
9000f6d8:	683b      	ldr	r3, [r7, #0]
9000f6da:	761a      	strb	r2, [r3, #24]

    hmmc->MmcCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
9000f6dc:	683b      	ldr	r3, [r7, #0]
9000f6de:	691b      	ldr	r3, [r3, #16]
9000f6e0:	1c5a      	adds	r2, r3, #1
9000f6e2:	687b      	ldr	r3, [r7, #4]
9000f6e4:	645a      	str	r2, [r3, #68]	; 0x44
    hmmc->MmcCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
9000f6e6:	683b      	ldr	r3, [r7, #0]
9000f6e8:	7e1b      	ldrb	r3, [r3, #24]
9000f6ea:	b2db      	uxtb	r3, r3
9000f6ec:	f003 0307 	and.w	r3, r3, #7
9000f6f0:	3302      	adds	r3, #2
9000f6f2:	2201      	movs	r2, #1
9000f6f4:	fa02 f303 	lsl.w	r3, r2, r3
9000f6f8:	687a      	ldr	r2, [r7, #4]
9000f6fa:	6c52      	ldr	r2, [r2, #68]	; 0x44
9000f6fc:	fb02 f203 	mul.w	r2, r2, r3
9000f700:	687b      	ldr	r3, [r7, #4]
9000f702:	645a      	str	r2, [r3, #68]	; 0x44
    hmmc->MmcCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
9000f704:	683b      	ldr	r3, [r7, #0]
9000f706:	7a1b      	ldrb	r3, [r3, #8]
9000f708:	b2db      	uxtb	r3, r3
9000f70a:	f003 030f 	and.w	r3, r3, #15
9000f70e:	2201      	movs	r2, #1
9000f710:	409a      	lsls	r2, r3
9000f712:	687b      	ldr	r3, [r7, #4]
9000f714:	649a      	str	r2, [r3, #72]	; 0x48

    hmmc->MmcCard.LogBlockNbr = (hmmc->MmcCard.BlockNbr) * ((hmmc->MmcCard.BlockSize) / 512U);
9000f716:	687b      	ldr	r3, [r7, #4]
9000f718:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9000f71a:	687a      	ldr	r2, [r7, #4]
9000f71c:	6c92      	ldr	r2, [r2, #72]	; 0x48
9000f71e:	0a52      	lsrs	r2, r2, #9
9000f720:	fb02 f203 	mul.w	r2, r2, r3
9000f724:	687b      	ldr	r3, [r7, #4]
9000f726:	64da      	str	r2, [r3, #76]	; 0x4c
    hmmc->MmcCard.LogBlockSize = 512U;
9000f728:	687b      	ldr	r3, [r7, #4]
9000f72a:	f44f 7200 	mov.w	r2, #512	; 0x200
9000f72e:	651a      	str	r2, [r3, #80]	; 0x50
9000f730:	e023      	b.n	9000f77a <HAL_MMC_GetCardCSD+0x1fe>
  }
  else if (hmmc->MmcCard.CardType == MMC_HIGH_CAPACITY_CARD)
9000f732:	687b      	ldr	r3, [r7, #4]
9000f734:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9000f736:	2b01      	cmp	r3, #1
9000f738:	d10f      	bne.n	9000f75a <HAL_MMC_GetCardCSD+0x1de>
  {
    hmmc->MmcCard.BlockNbr = block_nbr;
9000f73a:	68fa      	ldr	r2, [r7, #12]
9000f73c:	687b      	ldr	r3, [r7, #4]
9000f73e:	645a      	str	r2, [r3, #68]	; 0x44
    hmmc->MmcCard.LogBlockNbr = hmmc->MmcCard.BlockNbr;
9000f740:	687b      	ldr	r3, [r7, #4]
9000f742:	6c5a      	ldr	r2, [r3, #68]	; 0x44
9000f744:	687b      	ldr	r3, [r7, #4]
9000f746:	64da      	str	r2, [r3, #76]	; 0x4c
    hmmc->MmcCard.BlockSize = 512U;
9000f748:	687b      	ldr	r3, [r7, #4]
9000f74a:	f44f 7200 	mov.w	r2, #512	; 0x200
9000f74e:	649a      	str	r2, [r3, #72]	; 0x48
    hmmc->MmcCard.LogBlockSize = hmmc->MmcCard.BlockSize;
9000f750:	687b      	ldr	r3, [r7, #4]
9000f752:	6c9a      	ldr	r2, [r3, #72]	; 0x48
9000f754:	687b      	ldr	r3, [r7, #4]
9000f756:	651a      	str	r2, [r3, #80]	; 0x50
9000f758:	e00f      	b.n	9000f77a <HAL_MMC_GetCardCSD+0x1fe>
  }
  else
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f75a:	687b      	ldr	r3, [r7, #4]
9000f75c:	681b      	ldr	r3, [r3, #0]
9000f75e:	4a58      	ldr	r2, [pc, #352]	; (9000f8c0 <HAL_MMC_GetCardCSD+0x344>)
9000f760:	639a      	str	r2, [r3, #56]	; 0x38
    hmmc->ErrorCode |= HAL_MMC_ERROR_UNSUPPORTED_FEATURE;
9000f762:	687b      	ldr	r3, [r7, #4]
9000f764:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f766:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
9000f76a:	687b      	ldr	r3, [r7, #4]
9000f76c:	635a      	str	r2, [r3, #52]	; 0x34
    hmmc->State = HAL_MMC_STATE_READY;
9000f76e:	687b      	ldr	r3, [r7, #4]
9000f770:	2201      	movs	r2, #1
9000f772:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    return HAL_ERROR;
9000f776:	2301      	movs	r3, #1
9000f778:	e09d      	b.n	9000f8b6 <HAL_MMC_GetCardCSD+0x33a>
  }

  pCSD->EraseGrSize = (uint8_t)((hmmc->CSD[2] & 0x00004000U) >> 14U);
9000f77a:	687b      	ldr	r3, [r7, #4]
9000f77c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000f77e:	0b9b      	lsrs	r3, r3, #14
9000f780:	b2db      	uxtb	r3, r3
9000f782:	f003 0301 	and.w	r3, r3, #1
9000f786:	b2da      	uxtb	r2, r3
9000f788:	683b      	ldr	r3, [r7, #0]
9000f78a:	765a      	strb	r2, [r3, #25]

  pCSD->EraseGrMul = (uint8_t)((hmmc->CSD[2] & 0x00003F80U) >> 7U);
9000f78c:	687b      	ldr	r3, [r7, #4]
9000f78e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000f790:	09db      	lsrs	r3, r3, #7
9000f792:	b2db      	uxtb	r3, r3
9000f794:	f003 037f 	and.w	r3, r3, #127	; 0x7f
9000f798:	b2da      	uxtb	r2, r3
9000f79a:	683b      	ldr	r3, [r7, #0]
9000f79c:	769a      	strb	r2, [r3, #26]

  pCSD->WrProtectGrSize = (uint8_t)(hmmc->CSD[2] & 0x0000007FU);
9000f79e:	687b      	ldr	r3, [r7, #4]
9000f7a0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9000f7a2:	b2db      	uxtb	r3, r3
9000f7a4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
9000f7a8:	b2da      	uxtb	r2, r3
9000f7aa:	683b      	ldr	r3, [r7, #0]
9000f7ac:	76da      	strb	r2, [r3, #27]

  pCSD->WrProtectGrEnable = (uint8_t)((hmmc->CSD[3] & 0x80000000U) >> 31U);
9000f7ae:	687b      	ldr	r3, [r7, #4]
9000f7b0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f7b2:	0fdb      	lsrs	r3, r3, #31
9000f7b4:	b2da      	uxtb	r2, r3
9000f7b6:	683b      	ldr	r3, [r7, #0]
9000f7b8:	771a      	strb	r2, [r3, #28]

  pCSD->ManDeflECC = (uint8_t)((hmmc->CSD[3] & 0x60000000U) >> 29U);
9000f7ba:	687b      	ldr	r3, [r7, #4]
9000f7bc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f7be:	0f5b      	lsrs	r3, r3, #29
9000f7c0:	b2db      	uxtb	r3, r3
9000f7c2:	f003 0303 	and.w	r3, r3, #3
9000f7c6:	b2da      	uxtb	r2, r3
9000f7c8:	683b      	ldr	r3, [r7, #0]
9000f7ca:	775a      	strb	r2, [r3, #29]

  pCSD->WrSpeedFact = (uint8_t)((hmmc->CSD[3] & 0x1C000000U) >> 26U);
9000f7cc:	687b      	ldr	r3, [r7, #4]
9000f7ce:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f7d0:	0e9b      	lsrs	r3, r3, #26
9000f7d2:	b2db      	uxtb	r3, r3
9000f7d4:	f003 0307 	and.w	r3, r3, #7
9000f7d8:	b2da      	uxtb	r2, r3
9000f7da:	683b      	ldr	r3, [r7, #0]
9000f7dc:	779a      	strb	r2, [r3, #30]

  pCSD->MaxWrBlockLen = (uint8_t)((hmmc->CSD[3] & 0x03C00000U) >> 22U);
9000f7de:	687b      	ldr	r3, [r7, #4]
9000f7e0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f7e2:	0d9b      	lsrs	r3, r3, #22
9000f7e4:	b2db      	uxtb	r3, r3
9000f7e6:	f003 030f 	and.w	r3, r3, #15
9000f7ea:	b2da      	uxtb	r2, r3
9000f7ec:	683b      	ldr	r3, [r7, #0]
9000f7ee:	77da      	strb	r2, [r3, #31]

  pCSD->WriteBlockPaPartial = (uint8_t)((hmmc->CSD[3] & 0x00200000U) >> 21U);
9000f7f0:	687b      	ldr	r3, [r7, #4]
9000f7f2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f7f4:	0d5b      	lsrs	r3, r3, #21
9000f7f6:	b2db      	uxtb	r3, r3
9000f7f8:	f003 0301 	and.w	r3, r3, #1
9000f7fc:	b2da      	uxtb	r2, r3
9000f7fe:	683b      	ldr	r3, [r7, #0]
9000f800:	f883 2020 	strb.w	r2, [r3, #32]

  pCSD->Reserved3 = 0;
9000f804:	683b      	ldr	r3, [r7, #0]
9000f806:	2200      	movs	r2, #0
9000f808:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

  pCSD->ContentProtectAppli = (uint8_t)((hmmc->CSD[3] & 0x00010000U) >> 16U);
9000f80c:	687b      	ldr	r3, [r7, #4]
9000f80e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f810:	0c1b      	lsrs	r3, r3, #16
9000f812:	b2db      	uxtb	r3, r3
9000f814:	f003 0301 	and.w	r3, r3, #1
9000f818:	b2da      	uxtb	r2, r3
9000f81a:	683b      	ldr	r3, [r7, #0]
9000f81c:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

  pCSD->FileFormatGroup = (uint8_t)((hmmc->CSD[3] & 0x00008000U) >> 15U);
9000f820:	687b      	ldr	r3, [r7, #4]
9000f822:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f824:	0bdb      	lsrs	r3, r3, #15
9000f826:	b2db      	uxtb	r3, r3
9000f828:	f003 0301 	and.w	r3, r3, #1
9000f82c:	b2da      	uxtb	r2, r3
9000f82e:	683b      	ldr	r3, [r7, #0]
9000f830:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23

  pCSD->CopyFlag = (uint8_t)((hmmc->CSD[3] & 0x00004000U) >> 14U);
9000f834:	687b      	ldr	r3, [r7, #4]
9000f836:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f838:	0b9b      	lsrs	r3, r3, #14
9000f83a:	b2db      	uxtb	r3, r3
9000f83c:	f003 0301 	and.w	r3, r3, #1
9000f840:	b2da      	uxtb	r2, r3
9000f842:	683b      	ldr	r3, [r7, #0]
9000f844:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  pCSD->PermWrProtect = (uint8_t)((hmmc->CSD[3] & 0x00002000U) >> 13U);
9000f848:	687b      	ldr	r3, [r7, #4]
9000f84a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f84c:	0b5b      	lsrs	r3, r3, #13
9000f84e:	b2db      	uxtb	r3, r3
9000f850:	f003 0301 	and.w	r3, r3, #1
9000f854:	b2da      	uxtb	r2, r3
9000f856:	683b      	ldr	r3, [r7, #0]
9000f858:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  pCSD->TempWrProtect = (uint8_t)((hmmc->CSD[3] & 0x00001000U) >> 12U);
9000f85c:	687b      	ldr	r3, [r7, #4]
9000f85e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f860:	0b1b      	lsrs	r3, r3, #12
9000f862:	b2db      	uxtb	r3, r3
9000f864:	f003 0301 	and.w	r3, r3, #1
9000f868:	b2da      	uxtb	r2, r3
9000f86a:	683b      	ldr	r3, [r7, #0]
9000f86c:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26

  pCSD->FileFormat = (uint8_t)((hmmc->CSD[3] & 0x00000C00U) >> 10U);
9000f870:	687b      	ldr	r3, [r7, #4]
9000f872:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f874:	0a9b      	lsrs	r3, r3, #10
9000f876:	b2db      	uxtb	r3, r3
9000f878:	f003 0303 	and.w	r3, r3, #3
9000f87c:	b2da      	uxtb	r2, r3
9000f87e:	683b      	ldr	r3, [r7, #0]
9000f880:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27

  pCSD->ECC = (uint8_t)((hmmc->CSD[3] & 0x00000300U) >> 8U);
9000f884:	687b      	ldr	r3, [r7, #4]
9000f886:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f888:	0a1b      	lsrs	r3, r3, #8
9000f88a:	b2db      	uxtb	r3, r3
9000f88c:	f003 0303 	and.w	r3, r3, #3
9000f890:	b2da      	uxtb	r2, r3
9000f892:	683b      	ldr	r3, [r7, #0]
9000f894:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28

  pCSD->CSD_CRC = (uint8_t)((hmmc->CSD[3] & 0x000000FEU) >> 1U);
9000f898:	687b      	ldr	r3, [r7, #4]
9000f89a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9000f89c:	085b      	lsrs	r3, r3, #1
9000f89e:	b2db      	uxtb	r3, r3
9000f8a0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
9000f8a4:	b2da      	uxtb	r2, r3
9000f8a6:	683b      	ldr	r3, [r7, #0]
9000f8a8:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29

  pCSD->Reserved4 = 1;
9000f8ac:	683b      	ldr	r3, [r7, #0]
9000f8ae:	2201      	movs	r2, #1
9000f8b0:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a

  return HAL_OK;
9000f8b4:	2300      	movs	r3, #0
}
9000f8b6:	4618      	mov	r0, r3
9000f8b8:	3710      	adds	r7, #16
9000f8ba:	46bd      	mov	sp, r7
9000f8bc:	bd80      	pop	{r7, pc}
9000f8be:	bf00      	nop
9000f8c0:	1fe00fff 	.word	0x1fe00fff

9000f8c4 <HAL_MMC_GetCardExtCSD>:
  *         Extended CSD register parameters
  * @param  Timeout Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_GetCardExtCSD(MMC_HandleTypeDef *hmmc, uint32_t *pExtCSD, uint32_t Timeout)
{
9000f8c4:	b580      	push	{r7, lr}
9000f8c6:	b08e      	sub	sp, #56	; 0x38
9000f8c8:	af00      	add	r7, sp, #0
9000f8ca:	60f8      	str	r0, [r7, #12]
9000f8cc:	60b9      	str	r1, [r7, #8]
9000f8ce:	607a      	str	r2, [r7, #4]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
9000f8d0:	f7f9 fd78 	bl	900093c4 <HAL_GetTick>
9000f8d4:	62f8      	str	r0, [r7, #44]	; 0x2c
  uint32_t count;
  uint32_t *tmp_buf;

  if (NULL == pExtCSD)
9000f8d6:	68bb      	ldr	r3, [r7, #8]
9000f8d8:	2b00      	cmp	r3, #0
9000f8da:	d107      	bne.n	9000f8ec <HAL_MMC_GetCardExtCSD+0x28>
  {
    hmmc->ErrorCode |= HAL_MMC_ERROR_PARAM;
9000f8dc:	68fb      	ldr	r3, [r7, #12]
9000f8de:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f8e0:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
9000f8e4:	68fb      	ldr	r3, [r7, #12]
9000f8e6:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
9000f8e8:	2301      	movs	r3, #1
9000f8ea:	e0de      	b.n	9000faaa <HAL_MMC_GetCardExtCSD+0x1e6>
  }

  if (hmmc->State == HAL_MMC_STATE_READY)
9000f8ec:	68fb      	ldr	r3, [r7, #12]
9000f8ee:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
9000f8f2:	b2db      	uxtb	r3, r3
9000f8f4:	2b01      	cmp	r3, #1
9000f8f6:	f040 80d7 	bne.w	9000faa8 <HAL_MMC_GetCardExtCSD+0x1e4>
  {
    hmmc->ErrorCode = HAL_MMC_ERROR_NONE;
9000f8fa:	68fb      	ldr	r3, [r7, #12]
9000f8fc:	2200      	movs	r2, #0
9000f8fe:	635a      	str	r2, [r3, #52]	; 0x34

    hmmc->State = HAL_MMC_STATE_BUSY;
9000f900:	68fb      	ldr	r3, [r7, #12]
9000f902:	2203      	movs	r2, #3
9000f904:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

    /* Initialize data control register */
    hmmc->Instance->DCTRL = 0;
9000f908:	68fb      	ldr	r3, [r7, #12]
9000f90a:	681b      	ldr	r3, [r3, #0]
9000f90c:	2200      	movs	r2, #0
9000f90e:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Initiaize the destination pointer */
    tmp_buf = pExtCSD;
9000f910:	68bb      	ldr	r3, [r7, #8]
9000f912:	633b      	str	r3, [r7, #48]	; 0x30

    /* Configure the MMC DPSM (Data Path State Machine) */
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
9000f914:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9000f918:	613b      	str	r3, [r7, #16]
    config.DataLength    = 512U;
9000f91a:	f44f 7300 	mov.w	r3, #512	; 0x200
9000f91e:	617b      	str	r3, [r7, #20]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
9000f920:	2390      	movs	r3, #144	; 0x90
9000f922:	61bb      	str	r3, [r7, #24]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
9000f924:	2302      	movs	r3, #2
9000f926:	61fb      	str	r3, [r7, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
9000f928:	2300      	movs	r3, #0
9000f92a:	623b      	str	r3, [r7, #32]
    config.DPSM          = SDMMC_DPSM_DISABLE;
9000f92c:	2300      	movs	r3, #0
9000f92e:	627b      	str	r3, [r7, #36]	; 0x24
    (void)SDMMC_ConfigData(hmmc->Instance, &config);
9000f930:	68fb      	ldr	r3, [r7, #12]
9000f932:	681b      	ldr	r3, [r3, #0]
9000f934:	f107 0210 	add.w	r2, r7, #16
9000f938:	4611      	mov	r1, r2
9000f93a:	4618      	mov	r0, r3
9000f93c:	f005 fb70 	bl	90015020 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE(hmmc->Instance);
9000f940:	68fb      	ldr	r3, [r7, #12]
9000f942:	681b      	ldr	r3, [r3, #0]
9000f944:	68da      	ldr	r2, [r3, #12]
9000f946:	68fb      	ldr	r3, [r7, #12]
9000f948:	681b      	ldr	r3, [r3, #0]
9000f94a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
9000f94e:	60da      	str	r2, [r3, #12]

    /* Send ExtCSD Read command to Card */
    errorstate = SDMMC_CmdSendEXTCSD(hmmc->Instance, 0);
9000f950:	68fb      	ldr	r3, [r7, #12]
9000f952:	681b      	ldr	r3, [r3, #0]
9000f954:	2100      	movs	r1, #0
9000f956:	4618      	mov	r0, r3
9000f958:	f005 fded 	bl	90015536 <SDMMC_CmdSendEXTCSD>
9000f95c:	62b8      	str	r0, [r7, #40]	; 0x28
    if (errorstate != HAL_MMC_ERROR_NONE)
9000f95e:	6abb      	ldr	r3, [r7, #40]	; 0x28
9000f960:	2b00      	cmp	r3, #0
9000f962:	d045      	beq.n	9000f9f0 <HAL_MMC_GetCardExtCSD+0x12c>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f964:	68fb      	ldr	r3, [r7, #12]
9000f966:	681b      	ldr	r3, [r3, #0]
9000f968:	4a52      	ldr	r2, [pc, #328]	; (9000fab4 <HAL_MMC_GetCardExtCSD+0x1f0>)
9000f96a:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= errorstate;
9000f96c:	68fb      	ldr	r3, [r7, #12]
9000f96e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000f970:	6abb      	ldr	r3, [r7, #40]	; 0x28
9000f972:	431a      	orrs	r2, r3
9000f974:	68fb      	ldr	r3, [r7, #12]
9000f976:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000f978:	68fb      	ldr	r3, [r7, #12]
9000f97a:	2201      	movs	r2, #1
9000f97c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000f980:	2301      	movs	r3, #1
9000f982:	e092      	b.n	9000faaa <HAL_MMC_GetCardExtCSD+0x1e6>

    /* Poll on SDMMC flags */
    while (!__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR |
                               SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
    {
      if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXFIFOHF))
9000f984:	68fb      	ldr	r3, [r7, #12]
9000f986:	681b      	ldr	r3, [r3, #0]
9000f988:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f98a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
9000f98e:	2b00      	cmp	r3, #0
9000f990:	d013      	beq.n	9000f9ba <HAL_MMC_GetCardExtCSD+0xf6>
      {
        /* Read data from SDMMC Rx FIFO */
        for (count = 0U; count < 8U; count++)
9000f992:	2300      	movs	r3, #0
9000f994:	637b      	str	r3, [r7, #52]	; 0x34
9000f996:	e00d      	b.n	9000f9b4 <HAL_MMC_GetCardExtCSD+0xf0>
        {
          *tmp_buf = SDMMC_ReadFIFO(hmmc->Instance);
9000f998:	68fb      	ldr	r3, [r7, #12]
9000f99a:	681b      	ldr	r3, [r3, #0]
9000f99c:	4618      	mov	r0, r3
9000f99e:	f005 fab7 	bl	90014f10 <SDMMC_ReadFIFO>
9000f9a2:	4602      	mov	r2, r0
9000f9a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9000f9a6:	601a      	str	r2, [r3, #0]
          tmp_buf++;
9000f9a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9000f9aa:	3304      	adds	r3, #4
9000f9ac:	633b      	str	r3, [r7, #48]	; 0x30
        for (count = 0U; count < 8U; count++)
9000f9ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000f9b0:	3301      	adds	r3, #1
9000f9b2:	637b      	str	r3, [r7, #52]	; 0x34
9000f9b4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9000f9b6:	2b07      	cmp	r3, #7
9000f9b8:	d9ee      	bls.n	9000f998 <HAL_MMC_GetCardExtCSD+0xd4>
        }
      }

      if (((HAL_GetTick() - tickstart) >=  Timeout) || (Timeout == 0U))
9000f9ba:	f7f9 fd03 	bl	900093c4 <HAL_GetTick>
9000f9be:	4602      	mov	r2, r0
9000f9c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
9000f9c2:	1ad3      	subs	r3, r2, r3
9000f9c4:	687a      	ldr	r2, [r7, #4]
9000f9c6:	429a      	cmp	r2, r3
9000f9c8:	d902      	bls.n	9000f9d0 <HAL_MMC_GetCardExtCSD+0x10c>
9000f9ca:	687b      	ldr	r3, [r7, #4]
9000f9cc:	2b00      	cmp	r3, #0
9000f9ce:	d10f      	bne.n	9000f9f0 <HAL_MMC_GetCardExtCSD+0x12c>
      {
        /* Clear all the static flags */
        __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000f9d0:	68fb      	ldr	r3, [r7, #12]
9000f9d2:	681b      	ldr	r3, [r3, #0]
9000f9d4:	4a37      	ldr	r2, [pc, #220]	; (9000fab4 <HAL_MMC_GetCardExtCSD+0x1f0>)
9000f9d6:	639a      	str	r2, [r3, #56]	; 0x38
        hmmc->ErrorCode |= HAL_MMC_ERROR_TIMEOUT;
9000f9d8:	68fb      	ldr	r3, [r7, #12]
9000f9da:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f9dc:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
9000f9e0:	68fb      	ldr	r3, [r7, #12]
9000f9e2:	635a      	str	r2, [r3, #52]	; 0x34
        hmmc->State = HAL_MMC_STATE_READY;
9000f9e4:	68fb      	ldr	r3, [r7, #12]
9000f9e6:	2201      	movs	r2, #1
9000f9e8:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
        return HAL_TIMEOUT;
9000f9ec:	2303      	movs	r3, #3
9000f9ee:	e05c      	b.n	9000faaa <HAL_MMC_GetCardExtCSD+0x1e6>
    while (!__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR |
9000f9f0:	68fb      	ldr	r3, [r7, #12]
9000f9f2:	681b      	ldr	r3, [r3, #0]
9000f9f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000f9f6:	f403 7395 	and.w	r3, r3, #298	; 0x12a
9000f9fa:	2b00      	cmp	r3, #0
9000f9fc:	d0c2      	beq.n	9000f984 <HAL_MMC_GetCardExtCSD+0xc0>
      }
    }

    __SDMMC_CMDTRANS_DISABLE(hmmc->Instance);
9000f9fe:	68fb      	ldr	r3, [r7, #12]
9000fa00:	681b      	ldr	r3, [r3, #0]
9000fa02:	68da      	ldr	r2, [r3, #12]
9000fa04:	68fb      	ldr	r3, [r7, #12]
9000fa06:	681b      	ldr	r3, [r3, #0]
9000fa08:	f022 0240 	bic.w	r2, r2, #64	; 0x40
9000fa0c:	60da      	str	r2, [r3, #12]

    /* Get error state */
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DTIMEOUT))
9000fa0e:	68fb      	ldr	r3, [r7, #12]
9000fa10:	681b      	ldr	r3, [r3, #0]
9000fa12:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000fa14:	f003 0308 	and.w	r3, r3, #8
9000fa18:	2b00      	cmp	r3, #0
9000fa1a:	d00f      	beq.n	9000fa3c <HAL_MMC_GetCardExtCSD+0x178>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000fa1c:	68fb      	ldr	r3, [r7, #12]
9000fa1e:	681b      	ldr	r3, [r3, #0]
9000fa20:	4a24      	ldr	r2, [pc, #144]	; (9000fab4 <HAL_MMC_GetCardExtCSD+0x1f0>)
9000fa22:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_TIMEOUT;
9000fa24:	68fb      	ldr	r3, [r7, #12]
9000fa26:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000fa28:	f043 0208 	orr.w	r2, r3, #8
9000fa2c:	68fb      	ldr	r3, [r7, #12]
9000fa2e:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000fa30:	68fb      	ldr	r3, [r7, #12]
9000fa32:	2201      	movs	r2, #1
9000fa34:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000fa38:	2301      	movs	r3, #1
9000fa3a:	e036      	b.n	9000faaa <HAL_MMC_GetCardExtCSD+0x1e6>
    }
    else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DCRCFAIL))
9000fa3c:	68fb      	ldr	r3, [r7, #12]
9000fa3e:	681b      	ldr	r3, [r3, #0]
9000fa40:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000fa42:	f003 0302 	and.w	r3, r3, #2
9000fa46:	2b00      	cmp	r3, #0
9000fa48:	d00f      	beq.n	9000fa6a <HAL_MMC_GetCardExtCSD+0x1a6>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000fa4a:	68fb      	ldr	r3, [r7, #12]
9000fa4c:	681b      	ldr	r3, [r3, #0]
9000fa4e:	4a19      	ldr	r2, [pc, #100]	; (9000fab4 <HAL_MMC_GetCardExtCSD+0x1f0>)
9000fa50:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_CRC_FAIL;
9000fa52:	68fb      	ldr	r3, [r7, #12]
9000fa54:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000fa56:	f043 0202 	orr.w	r2, r3, #2
9000fa5a:	68fb      	ldr	r3, [r7, #12]
9000fa5c:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000fa5e:	68fb      	ldr	r3, [r7, #12]
9000fa60:	2201      	movs	r2, #1
9000fa62:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000fa66:	2301      	movs	r3, #1
9000fa68:	e01f      	b.n	9000faaa <HAL_MMC_GetCardExtCSD+0x1e6>
    }
    else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR))
9000fa6a:	68fb      	ldr	r3, [r7, #12]
9000fa6c:	681b      	ldr	r3, [r3, #0]
9000fa6e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000fa70:	f003 0320 	and.w	r3, r3, #32
9000fa74:	2b00      	cmp	r3, #0
9000fa76:	d00f      	beq.n	9000fa98 <HAL_MMC_GetCardExtCSD+0x1d4>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000fa78:	68fb      	ldr	r3, [r7, #12]
9000fa7a:	681b      	ldr	r3, [r3, #0]
9000fa7c:	4a0d      	ldr	r2, [pc, #52]	; (9000fab4 <HAL_MMC_GetCardExtCSD+0x1f0>)
9000fa7e:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_RX_OVERRUN;
9000fa80:	68fb      	ldr	r3, [r7, #12]
9000fa82:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000fa84:	f043 0220 	orr.w	r2, r3, #32
9000fa88:	68fb      	ldr	r3, [r7, #12]
9000fa8a:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9000fa8c:	68fb      	ldr	r3, [r7, #12]
9000fa8e:	2201      	movs	r2, #1
9000fa90:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
9000fa94:	2301      	movs	r3, #1
9000fa96:	e008      	b.n	9000faaa <HAL_MMC_GetCardExtCSD+0x1e6>
    {
      /* Nothing to do */
    }

    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_DATA_FLAGS);
9000fa98:	68fb      	ldr	r3, [r7, #12]
9000fa9a:	681b      	ldr	r3, [r3, #0]
9000fa9c:	4a06      	ldr	r2, [pc, #24]	; (9000fab8 <HAL_MMC_GetCardExtCSD+0x1f4>)
9000fa9e:	639a      	str	r2, [r3, #56]	; 0x38
    hmmc->State = HAL_MMC_STATE_READY;
9000faa0:	68fb      	ldr	r3, [r7, #12]
9000faa2:	2201      	movs	r2, #1
9000faa4:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  }

  return HAL_OK;
9000faa8:	2300      	movs	r3, #0
}
9000faaa:	4618      	mov	r0, r3
9000faac:	3738      	adds	r7, #56	; 0x38
9000faae:	46bd      	mov	sp, r7
9000fab0:	bd80      	pop	{r7, pc}
9000fab2:	bf00      	nop
9000fab4:	1fe00fff 	.word	0x1fe00fff
9000fab8:	18000f3a 	.word	0x18000f3a

9000fabc <HAL_MMC_ConfigWideBusOperation>:
  *            @arg SDMMC_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDMMC_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_MMC_ConfigWideBusOperation(MMC_HandleTypeDef *hmmc, uint32_t WideMode)
{
9000fabc:	b5b0      	push	{r4, r5, r7, lr}
9000fabe:	b08c      	sub	sp, #48	; 0x30
9000fac0:	af02      	add	r7, sp, #8
9000fac2:	6078      	str	r0, [r7, #4]
9000fac4:	6039      	str	r1, [r7, #0]
  uint32_t count;
  SDMMC_InitTypeDef Init;
  uint32_t errorstate;
  uint32_t response = 0U;
9000fac6:	2300      	movs	r3, #0
9000fac8:	61fb      	str	r3, [r7, #28]

  /* Check the parameters */
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));

  /* Change State */
  hmmc->State = HAL_MMC_STATE_BUSY;
9000faca:	687b      	ldr	r3, [r7, #4]
9000facc:	2203      	movs	r2, #3
9000face:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

  /* Check and update the power class if needed */
  if ((hmmc->Instance->CLKCR & SDMMC_CLKCR_BUSSPEED) != 0U)
9000fad2:	687b      	ldr	r3, [r7, #4]
9000fad4:	681b      	ldr	r3, [r3, #0]
9000fad6:	685b      	ldr	r3, [r3, #4]
9000fad8:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
9000fadc:	2b00      	cmp	r3, #0
9000fade:	d014      	beq.n	9000fb0a <HAL_MMC_ConfigWideBusOperation+0x4e>
  {
    if ((hmmc->Instance->CLKCR & SDMMC_CLKCR_DDR) != 0U)
9000fae0:	687b      	ldr	r3, [r7, #4]
9000fae2:	681b      	ldr	r3, [r3, #0]
9000fae4:	685b      	ldr	r3, [r3, #4]
9000fae6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
9000faea:	2b00      	cmp	r3, #0
9000faec:	d006      	beq.n	9000fafc <HAL_MMC_ConfigWideBusOperation+0x40>
    {
      errorstate = MMC_PwrClassUpdate(hmmc, WideMode, SDMMC_SPEED_MODE_DDR);
9000faee:	2204      	movs	r2, #4
9000faf0:	6839      	ldr	r1, [r7, #0]
9000faf2:	6878      	ldr	r0, [r7, #4]
9000faf4:	f000 fb38 	bl	90010168 <MMC_PwrClassUpdate>
9000faf8:	6238      	str	r0, [r7, #32]
9000fafa:	e00c      	b.n	9000fb16 <HAL_MMC_ConfigWideBusOperation+0x5a>
    }
    else
    {
      errorstate = MMC_PwrClassUpdate(hmmc, WideMode, SDMMC_SPEED_MODE_HIGH);
9000fafc:	2202      	movs	r2, #2
9000fafe:	6839      	ldr	r1, [r7, #0]
9000fb00:	6878      	ldr	r0, [r7, #4]
9000fb02:	f000 fb31 	bl	90010168 <MMC_PwrClassUpdate>
9000fb06:	6238      	str	r0, [r7, #32]
9000fb08:	e005      	b.n	9000fb16 <HAL_MMC_ConfigWideBusOperation+0x5a>
    }
  }
  else
  {
    errorstate = MMC_PwrClassUpdate(hmmc, WideMode, SDMMC_SPEED_MODE_DEFAULT);
9000fb0a:	2201      	movs	r2, #1
9000fb0c:	6839      	ldr	r1, [r7, #0]
9000fb0e:	6878      	ldr	r0, [r7, #4]
9000fb10:	f000 fb2a 	bl	90010168 <MMC_PwrClassUpdate>
9000fb14:	6238      	str	r0, [r7, #32]
  }

  if (errorstate == HAL_MMC_ERROR_NONE)
9000fb16:	6a3b      	ldr	r3, [r7, #32]
9000fb18:	2b00      	cmp	r3, #0
9000fb1a:	d17b      	bne.n	9000fc14 <HAL_MMC_ConfigWideBusOperation+0x158>
  {
    if (WideMode == SDMMC_BUS_WIDE_8B)
9000fb1c:	683b      	ldr	r3, [r7, #0]
9000fb1e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
9000fb22:	d107      	bne.n	9000fb34 <HAL_MMC_ConfigWideBusOperation+0x78>
    {
      errorstate = SDMMC_CmdSwitch(hmmc->Instance, 0x03B70200U);
9000fb24:	687b      	ldr	r3, [r7, #4]
9000fb26:	681b      	ldr	r3, [r3, #0]
9000fb28:	4946      	ldr	r1, [pc, #280]	; (9000fc44 <HAL_MMC_ConfigWideBusOperation+0x188>)
9000fb2a:	4618      	mov	r0, r3
9000fb2c:	f005 fce0 	bl	900154f0 <SDMMC_CmdSwitch>
9000fb30:	6238      	str	r0, [r7, #32]
9000fb32:	e019      	b.n	9000fb68 <HAL_MMC_ConfigWideBusOperation+0xac>
    }
    else if (WideMode == SDMMC_BUS_WIDE_4B)
9000fb34:	683b      	ldr	r3, [r7, #0]
9000fb36:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
9000fb3a:	d107      	bne.n	9000fb4c <HAL_MMC_ConfigWideBusOperation+0x90>
    {
      errorstate = SDMMC_CmdSwitch(hmmc->Instance, 0x03B70100U);
9000fb3c:	687b      	ldr	r3, [r7, #4]
9000fb3e:	681b      	ldr	r3, [r3, #0]
9000fb40:	4941      	ldr	r1, [pc, #260]	; (9000fc48 <HAL_MMC_ConfigWideBusOperation+0x18c>)
9000fb42:	4618      	mov	r0, r3
9000fb44:	f005 fcd4 	bl	900154f0 <SDMMC_CmdSwitch>
9000fb48:	6238      	str	r0, [r7, #32]
9000fb4a:	e00d      	b.n	9000fb68 <HAL_MMC_ConfigWideBusOperation+0xac>
    }
    else if (WideMode == SDMMC_BUS_WIDE_1B)
9000fb4c:	683b      	ldr	r3, [r7, #0]
9000fb4e:	2b00      	cmp	r3, #0
9000fb50:	d107      	bne.n	9000fb62 <HAL_MMC_ConfigWideBusOperation+0xa6>
    {
      errorstate = SDMMC_CmdSwitch(hmmc->Instance, 0x03B70000U);
9000fb52:	687b      	ldr	r3, [r7, #4]
9000fb54:	681b      	ldr	r3, [r3, #0]
9000fb56:	493d      	ldr	r1, [pc, #244]	; (9000fc4c <HAL_MMC_ConfigWideBusOperation+0x190>)
9000fb58:	4618      	mov	r0, r3
9000fb5a:	f005 fcc9 	bl	900154f0 <SDMMC_CmdSwitch>
9000fb5e:	6238      	str	r0, [r7, #32]
9000fb60:	e002      	b.n	9000fb68 <HAL_MMC_ConfigWideBusOperation+0xac>
    }
    else
    {
      /* WideMode is not a valid argument*/
      errorstate = HAL_MMC_ERROR_PARAM;
9000fb62:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
9000fb66:	623b      	str	r3, [r7, #32]
    }

    /* Check for switch error and violation of the trial number of sending CMD 13 */
    if (errorstate == HAL_MMC_ERROR_NONE)
9000fb68:	6a3b      	ldr	r3, [r7, #32]
9000fb6a:	2b00      	cmp	r3, #0
9000fb6c:	d152      	bne.n	9000fc14 <HAL_MMC_ConfigWideBusOperation+0x158>
    {
      /* While card is not ready for data and trial number for sending CMD13 is not exceeded */
      count = SDMMC_MAX_TRIAL;
9000fb6e:	f64f 73ff 	movw	r3, #65535	; 0xffff
9000fb72:	627b      	str	r3, [r7, #36]	; 0x24
      do
      {
        errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16U));
9000fb74:	687b      	ldr	r3, [r7, #4]
9000fb76:	681a      	ldr	r2, [r3, #0]
9000fb78:	687b      	ldr	r3, [r7, #4]
9000fb7a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000fb7c:	041b      	lsls	r3, r3, #16
9000fb7e:	4619      	mov	r1, r3
9000fb80:	4610      	mov	r0, r2
9000fb82:	f005 fc72 	bl	9001546a <SDMMC_CmdSendStatus>
9000fb86:	6238      	str	r0, [r7, #32]
        if (errorstate != HAL_MMC_ERROR_NONE)
9000fb88:	6a3b      	ldr	r3, [r7, #32]
9000fb8a:	2b00      	cmp	r3, #0
9000fb8c:	d112      	bne.n	9000fbb4 <HAL_MMC_ConfigWideBusOperation+0xf8>
        {
          break;
        }

        /* Get command response */
        response = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
9000fb8e:	687b      	ldr	r3, [r7, #4]
9000fb90:	681b      	ldr	r3, [r3, #0]
9000fb92:	2100      	movs	r1, #0
9000fb94:	4618      	mov	r0, r3
9000fb96:	f005 fa30 	bl	90014ffa <SDMMC_GetResponse>
9000fb9a:	61f8      	str	r0, [r7, #28]
        count--;
9000fb9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9000fb9e:	3b01      	subs	r3, #1
9000fba0:	627b      	str	r3, [r7, #36]	; 0x24
      } while (((response & 0x100U) == 0U) && (count != 0U));
9000fba2:	69fb      	ldr	r3, [r7, #28]
9000fba4:	f403 7380 	and.w	r3, r3, #256	; 0x100
9000fba8:	2b00      	cmp	r3, #0
9000fbaa:	d104      	bne.n	9000fbb6 <HAL_MMC_ConfigWideBusOperation+0xfa>
9000fbac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9000fbae:	2b00      	cmp	r3, #0
9000fbb0:	d1e0      	bne.n	9000fb74 <HAL_MMC_ConfigWideBusOperation+0xb8>
9000fbb2:	e000      	b.n	9000fbb6 <HAL_MMC_ConfigWideBusOperation+0xfa>
          break;
9000fbb4:	bf00      	nop

      /* Check the status after the switch command execution */
      if ((count != 0U) && (errorstate == HAL_MMC_ERROR_NONE))
9000fbb6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9000fbb8:	2b00      	cmp	r3, #0
9000fbba:	d025      	beq.n	9000fc08 <HAL_MMC_ConfigWideBusOperation+0x14c>
9000fbbc:	6a3b      	ldr	r3, [r7, #32]
9000fbbe:	2b00      	cmp	r3, #0
9000fbc0:	d122      	bne.n	9000fc08 <HAL_MMC_ConfigWideBusOperation+0x14c>
      {
        /* Check the bit SWITCH_ERROR of the device status */
        if ((response & 0x80U) != 0U)
9000fbc2:	69fb      	ldr	r3, [r7, #28]
9000fbc4:	f003 0380 	and.w	r3, r3, #128	; 0x80
9000fbc8:	2b00      	cmp	r3, #0
9000fbca:	d003      	beq.n	9000fbd4 <HAL_MMC_ConfigWideBusOperation+0x118>
        {
          errorstate = SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
9000fbcc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
9000fbd0:	623b      	str	r3, [r7, #32]
        if ((response & 0x80U) != 0U)
9000fbd2:	e01f      	b.n	9000fc14 <HAL_MMC_ConfigWideBusOperation+0x158>
        }
        else
        {
          /* Configure the SDMMC peripheral */
          Init = hmmc->Init;
9000fbd4:	687b      	ldr	r3, [r7, #4]
9000fbd6:	f107 0408 	add.w	r4, r7, #8
9000fbda:	1d1d      	adds	r5, r3, #4
9000fbdc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
9000fbde:	c40f      	stmia	r4!, {r0, r1, r2, r3}
9000fbe0:	682b      	ldr	r3, [r5, #0]
9000fbe2:	6023      	str	r3, [r4, #0]
          Init.BusWide = WideMode;
9000fbe4:	683b      	ldr	r3, [r7, #0]
9000fbe6:	613b      	str	r3, [r7, #16]
          (void)SDMMC_Init(hmmc->Instance, Init);
9000fbe8:	687b      	ldr	r3, [r7, #4]
9000fbea:	681c      	ldr	r4, [r3, #0]
9000fbec:	466a      	mov	r2, sp
9000fbee:	f107 0314 	add.w	r3, r7, #20
9000fbf2:	e893 0003 	ldmia.w	r3, {r0, r1}
9000fbf6:	e882 0003 	stmia.w	r2, {r0, r1}
9000fbfa:	f107 0308 	add.w	r3, r7, #8
9000fbfe:	cb0e      	ldmia	r3, {r1, r2, r3}
9000fc00:	4620      	mov	r0, r4
9000fc02:	f005 f95b 	bl	90014ebc <SDMMC_Init>
        if ((response & 0x80U) != 0U)
9000fc06:	e005      	b.n	9000fc14 <HAL_MMC_ConfigWideBusOperation+0x158>
        }
      }
      else if (count == 0U)
9000fc08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9000fc0a:	2b00      	cmp	r3, #0
9000fc0c:	d102      	bne.n	9000fc14 <HAL_MMC_ConfigWideBusOperation+0x158>
      {
        errorstate = SDMMC_ERROR_TIMEOUT;
9000fc0e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
9000fc12:	623b      	str	r3, [r7, #32]
      }
    }
  }

  /* Change State */
  hmmc->State = HAL_MMC_STATE_READY;
9000fc14:	687b      	ldr	r3, [r7, #4]
9000fc16:	2201      	movs	r2, #1
9000fc18:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

  if (errorstate != HAL_MMC_ERROR_NONE)
9000fc1c:	6a3b      	ldr	r3, [r7, #32]
9000fc1e:	2b00      	cmp	r3, #0
9000fc20:	d00b      	beq.n	9000fc3a <HAL_MMC_ConfigWideBusOperation+0x17e>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000fc22:	687b      	ldr	r3, [r7, #4]
9000fc24:	681b      	ldr	r3, [r3, #0]
9000fc26:	4a0a      	ldr	r2, [pc, #40]	; (9000fc50 <HAL_MMC_ConfigWideBusOperation+0x194>)
9000fc28:	639a      	str	r2, [r3, #56]	; 0x38
    hmmc->ErrorCode |= errorstate;
9000fc2a:	687b      	ldr	r3, [r7, #4]
9000fc2c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000fc2e:	6a3b      	ldr	r3, [r7, #32]
9000fc30:	431a      	orrs	r2, r3
9000fc32:	687b      	ldr	r3, [r7, #4]
9000fc34:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
9000fc36:	2301      	movs	r3, #1
9000fc38:	e000      	b.n	9000fc3c <HAL_MMC_ConfigWideBusOperation+0x180>
  }

  return HAL_OK;
9000fc3a:	2300      	movs	r3, #0
}
9000fc3c:	4618      	mov	r0, r3
9000fc3e:	3728      	adds	r7, #40	; 0x28
9000fc40:	46bd      	mov	sp, r7
9000fc42:	bdb0      	pop	{r4, r5, r7, pc}
9000fc44:	03b70200 	.word	0x03b70200
9000fc48:	03b70100 	.word	0x03b70100
9000fc4c:	03b70000 	.word	0x03b70000
9000fc50:	1fe00fff 	.word	0x1fe00fff

9000fc54 <HAL_MMC_GetCardState>:
  * @brief  Gets the current mmc card data state.
  * @param  hmmc: pointer to MMC handle
  * @retval Card state
  */
HAL_MMC_CardStateTypeDef HAL_MMC_GetCardState(MMC_HandleTypeDef *hmmc)
{
9000fc54:	b580      	push	{r7, lr}
9000fc56:	b086      	sub	sp, #24
9000fc58:	af00      	add	r7, sp, #0
9000fc5a:	6078      	str	r0, [r7, #4]
  uint32_t cardstate;
  uint32_t errorstate;
  uint32_t resp1 = 0U;
9000fc5c:	2300      	movs	r3, #0
9000fc5e:	60fb      	str	r3, [r7, #12]

  errorstate = MMC_SendStatus(hmmc, &resp1);
9000fc60:	f107 030c 	add.w	r3, r7, #12
9000fc64:	4619      	mov	r1, r3
9000fc66:	6878      	ldr	r0, [r7, #4]
9000fc68:	f000 f962 	bl	9000ff30 <MMC_SendStatus>
9000fc6c:	6178      	str	r0, [r7, #20]
  if (errorstate != HAL_MMC_ERROR_NONE)
9000fc6e:	697b      	ldr	r3, [r7, #20]
9000fc70:	2b00      	cmp	r3, #0
9000fc72:	d005      	beq.n	9000fc80 <HAL_MMC_GetCardState+0x2c>
  {
    hmmc->ErrorCode |= errorstate;
9000fc74:	687b      	ldr	r3, [r7, #4]
9000fc76:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000fc78:	697b      	ldr	r3, [r7, #20]
9000fc7a:	431a      	orrs	r2, r3
9000fc7c:	687b      	ldr	r3, [r7, #4]
9000fc7e:	635a      	str	r2, [r3, #52]	; 0x34
  }

  cardstate = ((resp1 >> 9U) & 0x0FU);
9000fc80:	68fb      	ldr	r3, [r7, #12]
9000fc82:	0a5b      	lsrs	r3, r3, #9
9000fc84:	f003 030f 	and.w	r3, r3, #15
9000fc88:	613b      	str	r3, [r7, #16]

  return (HAL_MMC_CardStateTypeDef)cardstate;
9000fc8a:	693b      	ldr	r3, [r7, #16]
}
9000fc8c:	4618      	mov	r0, r3
9000fc8e:	3718      	adds	r7, #24
9000fc90:	46bd      	mov	sp, r7
9000fc92:	bd80      	pop	{r7, pc}

9000fc94 <MMC_InitCard>:
  * @brief  Initializes the mmc card.
  * @param  hmmc: Pointer to MMC handle
  * @retval MMC Card error state
  */
static uint32_t MMC_InitCard(MMC_HandleTypeDef *hmmc)
{
9000fc94:	b5b0      	push	{r4, r5, r7, lr}
9000fc96:	b096      	sub	sp, #88	; 0x58
9000fc98:	af02      	add	r7, sp, #8
9000fc9a:	6078      	str	r0, [r7, #4]
  HAL_MMC_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t mmc_rca = 2U;
9000fc9c:	2302      	movs	r3, #2
9000fc9e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
  MMC_InitTypeDef Init;

  /* Check the power State */
  if (SDMMC_GetPowerState(hmmc->Instance) == 0U)
9000fca2:	687b      	ldr	r3, [r7, #4]
9000fca4:	681b      	ldr	r3, [r3, #0]
9000fca6:	4618      	mov	r0, r3
9000fca8:	f005 f961 	bl	90014f6e <SDMMC_GetPowerState>
9000fcac:	4603      	mov	r3, r0
9000fcae:	2b00      	cmp	r3, #0
9000fcb0:	d102      	bne.n	9000fcb8 <MMC_InitCard+0x24>
  {
    /* Power off */
    return HAL_MMC_ERROR_REQUEST_NOT_APPLICABLE;
9000fcb2:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
9000fcb6:	e0e6      	b.n	9000fe86 <MMC_InitCard+0x1f2>
  }

  /* Send CMD2 ALL_SEND_CID */
  errorstate = SDMMC_CmdSendCID(hmmc->Instance);
9000fcb8:	687b      	ldr	r3, [r7, #4]
9000fcba:	681b      	ldr	r3, [r3, #0]
9000fcbc:	4618      	mov	r0, r3
9000fcbe:	f005 fb70 	bl	900153a2 <SDMMC_CmdSendCID>
9000fcc2:	64b8      	str	r0, [r7, #72]	; 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
9000fcc4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fcc6:	2b00      	cmp	r3, #0
9000fcc8:	d001      	beq.n	9000fcce <MMC_InitCard+0x3a>
  {
    return errorstate;
9000fcca:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fccc:	e0db      	b.n	9000fe86 <MMC_InitCard+0x1f2>
  }
  else
  {
    /* Get Card identification number data */
    hmmc->CID[0U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
9000fcce:	687b      	ldr	r3, [r7, #4]
9000fcd0:	681b      	ldr	r3, [r3, #0]
9000fcd2:	2100      	movs	r1, #0
9000fcd4:	4618      	mov	r0, r3
9000fcd6:	f005 f990 	bl	90014ffa <SDMMC_GetResponse>
9000fcda:	4602      	mov	r2, r0
9000fcdc:	687b      	ldr	r3, [r7, #4]
9000fcde:	665a      	str	r2, [r3, #100]	; 0x64
    hmmc->CID[1U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP2);
9000fce0:	687b      	ldr	r3, [r7, #4]
9000fce2:	681b      	ldr	r3, [r3, #0]
9000fce4:	2104      	movs	r1, #4
9000fce6:	4618      	mov	r0, r3
9000fce8:	f005 f987 	bl	90014ffa <SDMMC_GetResponse>
9000fcec:	4602      	mov	r2, r0
9000fcee:	687b      	ldr	r3, [r7, #4]
9000fcf0:	669a      	str	r2, [r3, #104]	; 0x68
    hmmc->CID[2U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP3);
9000fcf2:	687b      	ldr	r3, [r7, #4]
9000fcf4:	681b      	ldr	r3, [r3, #0]
9000fcf6:	2108      	movs	r1, #8
9000fcf8:	4618      	mov	r0, r3
9000fcfa:	f005 f97e 	bl	90014ffa <SDMMC_GetResponse>
9000fcfe:	4602      	mov	r2, r0
9000fd00:	687b      	ldr	r3, [r7, #4]
9000fd02:	66da      	str	r2, [r3, #108]	; 0x6c
    hmmc->CID[3U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP4);
9000fd04:	687b      	ldr	r3, [r7, #4]
9000fd06:	681b      	ldr	r3, [r3, #0]
9000fd08:	210c      	movs	r1, #12
9000fd0a:	4618      	mov	r0, r3
9000fd0c:	f005 f975 	bl	90014ffa <SDMMC_GetResponse>
9000fd10:	4602      	mov	r2, r0
9000fd12:	687b      	ldr	r3, [r7, #4]
9000fd14:	671a      	str	r2, [r3, #112]	; 0x70
  }

  /* Send CMD3 SET_REL_ADDR with RCA = 2 (should be greater than 1) */
  /* MMC Card publishes its RCA. */
  errorstate = SDMMC_CmdSetRelAddMmc(hmmc->Instance, mmc_rca);
9000fd16:	687b      	ldr	r3, [r7, #4]
9000fd18:	681b      	ldr	r3, [r3, #0]
9000fd1a:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
9000fd1e:	4611      	mov	r1, r2
9000fd20:	4618      	mov	r0, r3
9000fd22:	f005 fb7d 	bl	90015420 <SDMMC_CmdSetRelAddMmc>
9000fd26:	64b8      	str	r0, [r7, #72]	; 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
9000fd28:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fd2a:	2b00      	cmp	r3, #0
9000fd2c:	d001      	beq.n	9000fd32 <MMC_InitCard+0x9e>
  {
    return errorstate;
9000fd2e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fd30:	e0a9      	b.n	9000fe86 <MMC_InitCard+0x1f2>
  }

  /* Get the MMC card RCA */
  hmmc->MmcCard.RelCardAdd = mmc_rca;
9000fd32:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
9000fd36:	687b      	ldr	r3, [r7, #4]
9000fd38:	641a      	str	r2, [r3, #64]	; 0x40

  /* Send CMD9 SEND_CSD with argument as card's RCA */
  errorstate = SDMMC_CmdSendCSD(hmmc->Instance, (uint32_t)(hmmc->MmcCard.RelCardAdd << 16U));
9000fd3a:	687b      	ldr	r3, [r7, #4]
9000fd3c:	681a      	ldr	r2, [r3, #0]
9000fd3e:	687b      	ldr	r3, [r7, #4]
9000fd40:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000fd42:	041b      	lsls	r3, r3, #16
9000fd44:	4619      	mov	r1, r3
9000fd46:	4610      	mov	r0, r2
9000fd48:	f005 fb4a 	bl	900153e0 <SDMMC_CmdSendCSD>
9000fd4c:	64b8      	str	r0, [r7, #72]	; 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
9000fd4e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fd50:	2b00      	cmp	r3, #0
9000fd52:	d001      	beq.n	9000fd58 <MMC_InitCard+0xc4>
  {
    return errorstate;
9000fd54:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fd56:	e096      	b.n	9000fe86 <MMC_InitCard+0x1f2>
  }
  else
  {
    /* Get Card Specific Data */
    hmmc->CSD[0U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
9000fd58:	687b      	ldr	r3, [r7, #4]
9000fd5a:	681b      	ldr	r3, [r3, #0]
9000fd5c:	2100      	movs	r1, #0
9000fd5e:	4618      	mov	r0, r3
9000fd60:	f005 f94b 	bl	90014ffa <SDMMC_GetResponse>
9000fd64:	4602      	mov	r2, r0
9000fd66:	687b      	ldr	r3, [r7, #4]
9000fd68:	655a      	str	r2, [r3, #84]	; 0x54
    hmmc->CSD[1U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP2);
9000fd6a:	687b      	ldr	r3, [r7, #4]
9000fd6c:	681b      	ldr	r3, [r3, #0]
9000fd6e:	2104      	movs	r1, #4
9000fd70:	4618      	mov	r0, r3
9000fd72:	f005 f942 	bl	90014ffa <SDMMC_GetResponse>
9000fd76:	4602      	mov	r2, r0
9000fd78:	687b      	ldr	r3, [r7, #4]
9000fd7a:	659a      	str	r2, [r3, #88]	; 0x58
    hmmc->CSD[2U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP3);
9000fd7c:	687b      	ldr	r3, [r7, #4]
9000fd7e:	681b      	ldr	r3, [r3, #0]
9000fd80:	2108      	movs	r1, #8
9000fd82:	4618      	mov	r0, r3
9000fd84:	f005 f939 	bl	90014ffa <SDMMC_GetResponse>
9000fd88:	4602      	mov	r2, r0
9000fd8a:	687b      	ldr	r3, [r7, #4]
9000fd8c:	65da      	str	r2, [r3, #92]	; 0x5c
    hmmc->CSD[3U] = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP4);
9000fd8e:	687b      	ldr	r3, [r7, #4]
9000fd90:	681b      	ldr	r3, [r3, #0]
9000fd92:	210c      	movs	r1, #12
9000fd94:	4618      	mov	r0, r3
9000fd96:	f005 f930 	bl	90014ffa <SDMMC_GetResponse>
9000fd9a:	4602      	mov	r2, r0
9000fd9c:	687b      	ldr	r3, [r7, #4]
9000fd9e:	661a      	str	r2, [r3, #96]	; 0x60
  }

  /* Get the Card Class */
  hmmc->MmcCard.Class = (SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP2) >> 20U);
9000fda0:	687b      	ldr	r3, [r7, #4]
9000fda2:	681b      	ldr	r3, [r3, #0]
9000fda4:	2104      	movs	r1, #4
9000fda6:	4618      	mov	r0, r3
9000fda8:	f005 f927 	bl	90014ffa <SDMMC_GetResponse>
9000fdac:	4603      	mov	r3, r0
9000fdae:	0d1a      	lsrs	r2, r3, #20
9000fdb0:	687b      	ldr	r3, [r7, #4]
9000fdb2:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Select the Card */
  errorstate = SDMMC_CmdSelDesel(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16U));
9000fdb4:	687b      	ldr	r3, [r7, #4]
9000fdb6:	681a      	ldr	r2, [r3, #0]
9000fdb8:	687b      	ldr	r3, [r7, #4]
9000fdba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000fdbc:	041b      	lsls	r3, r3, #16
9000fdbe:	4619      	mov	r1, r3
9000fdc0:	4610      	mov	r0, r2
9000fdc2:	f005 faad 	bl	90015320 <SDMMC_CmdSelDesel>
9000fdc6:	64b8      	str	r0, [r7, #72]	; 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
9000fdc8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fdca:	2b00      	cmp	r3, #0
9000fdcc:	d001      	beq.n	9000fdd2 <MMC_InitCard+0x13e>
  {
    return errorstate;
9000fdce:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fdd0:	e059      	b.n	9000fe86 <MMC_InitCard+0x1f2>
  }

  /* Get CSD parameters */
  if (HAL_MMC_GetCardCSD(hmmc, &CSD) != HAL_OK)
9000fdd2:	f107 031c 	add.w	r3, r7, #28
9000fdd6:	4619      	mov	r1, r3
9000fdd8:	6878      	ldr	r0, [r7, #4]
9000fdda:	f7ff fbcf 	bl	9000f57c <HAL_MMC_GetCardCSD>
9000fdde:	4603      	mov	r3, r0
9000fde0:	2b00      	cmp	r3, #0
9000fde2:	d002      	beq.n	9000fdea <MMC_InitCard+0x156>
  {
    return hmmc->ErrorCode;
9000fde4:	687b      	ldr	r3, [r7, #4]
9000fde6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000fde8:	e04d      	b.n	9000fe86 <MMC_InitCard+0x1f2>
  }

  /* While card is not ready for data and trial number for sending CMD13 is not exceeded */
  errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16U));
9000fdea:	687b      	ldr	r3, [r7, #4]
9000fdec:	681a      	ldr	r2, [r3, #0]
9000fdee:	687b      	ldr	r3, [r7, #4]
9000fdf0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000fdf2:	041b      	lsls	r3, r3, #16
9000fdf4:	4619      	mov	r1, r3
9000fdf6:	4610      	mov	r0, r2
9000fdf8:	f005 fb37 	bl	9001546a <SDMMC_CmdSendStatus>
9000fdfc:	64b8      	str	r0, [r7, #72]	; 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
9000fdfe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fe00:	2b00      	cmp	r3, #0
9000fe02:	d005      	beq.n	9000fe10 <MMC_InitCard+0x17c>
  {
    hmmc->ErrorCode |= errorstate;
9000fe04:	687b      	ldr	r3, [r7, #4]
9000fe06:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000fe08:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fe0a:	431a      	orrs	r2, r3
9000fe0c:	687b      	ldr	r3, [r7, #4]
9000fe0e:	635a      	str	r2, [r3, #52]	; 0x34
  }


  /* Get Extended CSD parameters */
  if (HAL_MMC_GetCardExtCSD(hmmc, hmmc->Ext_CSD, SDMMC_DATATIMEOUT) != HAL_OK)
9000fe10:	687b      	ldr	r3, [r7, #4]
9000fe12:	3374      	adds	r3, #116	; 0x74
9000fe14:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
9000fe18:	4619      	mov	r1, r3
9000fe1a:	6878      	ldr	r0, [r7, #4]
9000fe1c:	f7ff fd52 	bl	9000f8c4 <HAL_MMC_GetCardExtCSD>
9000fe20:	4603      	mov	r3, r0
9000fe22:	2b00      	cmp	r3, #0
9000fe24:	d002      	beq.n	9000fe2c <MMC_InitCard+0x198>
  {
    return hmmc->ErrorCode;
9000fe26:	687b      	ldr	r3, [r7, #4]
9000fe28:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9000fe2a:	e02c      	b.n	9000fe86 <MMC_InitCard+0x1f2>
  }

  /* While card is not ready for data and trial number for sending CMD13 is not exceeded */
  errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16U));
9000fe2c:	687b      	ldr	r3, [r7, #4]
9000fe2e:	681a      	ldr	r2, [r3, #0]
9000fe30:	687b      	ldr	r3, [r7, #4]
9000fe32:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000fe34:	041b      	lsls	r3, r3, #16
9000fe36:	4619      	mov	r1, r3
9000fe38:	4610      	mov	r0, r2
9000fe3a:	f005 fb16 	bl	9001546a <SDMMC_CmdSendStatus>
9000fe3e:	64b8      	str	r0, [r7, #72]	; 0x48
  if (errorstate != HAL_MMC_ERROR_NONE)
9000fe40:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fe42:	2b00      	cmp	r3, #0
9000fe44:	d005      	beq.n	9000fe52 <MMC_InitCard+0x1be>
  {
    hmmc->ErrorCode |= errorstate;
9000fe46:	687b      	ldr	r3, [r7, #4]
9000fe48:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000fe4a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
9000fe4c:	431a      	orrs	r2, r3
9000fe4e:	687b      	ldr	r3, [r7, #4]
9000fe50:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Configure the SDMMC peripheral */
  Init = hmmc->Init;
9000fe52:	687b      	ldr	r3, [r7, #4]
9000fe54:	f107 0408 	add.w	r4, r7, #8
9000fe58:	1d1d      	adds	r5, r3, #4
9000fe5a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
9000fe5c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
9000fe5e:	682b      	ldr	r3, [r5, #0]
9000fe60:	6023      	str	r3, [r4, #0]
  Init.BusWide = SDMMC_BUS_WIDE_1B;
9000fe62:	2300      	movs	r3, #0
9000fe64:	613b      	str	r3, [r7, #16]
  (void)SDMMC_Init(hmmc->Instance, Init);
9000fe66:	687b      	ldr	r3, [r7, #4]
9000fe68:	681c      	ldr	r4, [r3, #0]
9000fe6a:	466a      	mov	r2, sp
9000fe6c:	f107 0314 	add.w	r3, r7, #20
9000fe70:	e893 0003 	ldmia.w	r3, {r0, r1}
9000fe74:	e882 0003 	stmia.w	r2, {r0, r1}
9000fe78:	f107 0308 	add.w	r3, r7, #8
9000fe7c:	cb0e      	ldmia	r3, {r1, r2, r3}
9000fe7e:	4620      	mov	r0, r4
9000fe80:	f005 f81c 	bl	90014ebc <SDMMC_Init>

  /* All cards are initialized */
  return HAL_MMC_ERROR_NONE;
9000fe84:	2300      	movs	r3, #0
}
9000fe86:	4618      	mov	r0, r3
9000fe88:	3750      	adds	r7, #80	; 0x50
9000fe8a:	46bd      	mov	sp, r7
9000fe8c:	bdb0      	pop	{r4, r5, r7, pc}
	...

9000fe90 <MMC_PowerON>:
  *         in the MMC handle.
  * @param  hmmc: Pointer to MMC handle
  * @retval error state
  */
static uint32_t MMC_PowerON(MMC_HandleTypeDef *hmmc)
{
9000fe90:	b580      	push	{r7, lr}
9000fe92:	b086      	sub	sp, #24
9000fe94:	af00      	add	r7, sp, #0
9000fe96:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
9000fe98:	2300      	movs	r3, #0
9000fe9a:	60bb      	str	r3, [r7, #8]
  uint32_t response = 0U;
9000fe9c:	2300      	movs	r3, #0
9000fe9e:	617b      	str	r3, [r7, #20]
  uint32_t validvoltage = 0U;
9000fea0:	2300      	movs	r3, #0
9000fea2:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hmmc->Instance);
9000fea4:	687b      	ldr	r3, [r7, #4]
9000fea6:	681b      	ldr	r3, [r3, #0]
9000fea8:	4618      	mov	r0, r3
9000feaa:	f005 fa5c 	bl	90015366 <SDMMC_CmdGoIdleState>
9000feae:	60f8      	str	r0, [r7, #12]
  if (errorstate != HAL_MMC_ERROR_NONE)
9000feb0:	68fb      	ldr	r3, [r7, #12]
9000feb2:	2b00      	cmp	r3, #0
9000feb4:	d027      	beq.n	9000ff06 <MMC_PowerON+0x76>
  {
    return errorstate;
9000feb6:	68fb      	ldr	r3, [r7, #12]
9000feb8:	e034      	b.n	9000ff24 <MMC_PowerON+0x94>
  }

  while (validvoltage == 0U)
  {
    if (count++ == SDMMC_MAX_VOLT_TRIAL)
9000feba:	68bb      	ldr	r3, [r7, #8]
9000febc:	1c5a      	adds	r2, r3, #1
9000febe:	60ba      	str	r2, [r7, #8]
9000fec0:	f64f 72ff 	movw	r2, #65535	; 0xffff
9000fec4:	4293      	cmp	r3, r2
9000fec6:	d102      	bne.n	9000fece <MMC_PowerON+0x3e>
    {
      return HAL_MMC_ERROR_INVALID_VOLTRANGE;
9000fec8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
9000fecc:	e02a      	b.n	9000ff24 <MMC_PowerON+0x94>
    }

    /* SEND CMD1 APP_CMD with voltage range as argument */
    errorstate = SDMMC_CmdOpCondition(hmmc->Instance, MMC_VOLTAGE_RANGE);
9000fece:	687b      	ldr	r3, [r7, #4]
9000fed0:	681b      	ldr	r3, [r3, #0]
9000fed2:	4916      	ldr	r1, [pc, #88]	; (9000ff2c <MMC_PowerON+0x9c>)
9000fed4:	4618      	mov	r0, r3
9000fed6:	f005 faeb 	bl	900154b0 <SDMMC_CmdOpCondition>
9000feda:	60f8      	str	r0, [r7, #12]
    if (errorstate != HAL_MMC_ERROR_NONE)
9000fedc:	68fb      	ldr	r3, [r7, #12]
9000fede:	2b00      	cmp	r3, #0
9000fee0:	d002      	beq.n	9000fee8 <MMC_PowerON+0x58>
    {
      return HAL_MMC_ERROR_UNSUPPORTED_FEATURE;
9000fee2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
9000fee6:	e01d      	b.n	9000ff24 <MMC_PowerON+0x94>
    }

    /* Get command response */
    response = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
9000fee8:	687b      	ldr	r3, [r7, #4]
9000feea:	681b      	ldr	r3, [r3, #0]
9000feec:	2100      	movs	r1, #0
9000feee:	4618      	mov	r0, r3
9000fef0:	f005 f883 	bl	90014ffa <SDMMC_GetResponse>
9000fef4:	6178      	str	r0, [r7, #20]

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
9000fef6:	697b      	ldr	r3, [r7, #20]
9000fef8:	0fdb      	lsrs	r3, r3, #31
9000fefa:	2b01      	cmp	r3, #1
9000fefc:	d101      	bne.n	9000ff02 <MMC_PowerON+0x72>
9000fefe:	2301      	movs	r3, #1
9000ff00:	e000      	b.n	9000ff04 <MMC_PowerON+0x74>
9000ff02:	2300      	movs	r3, #0
9000ff04:	613b      	str	r3, [r7, #16]
  while (validvoltage == 0U)
9000ff06:	693b      	ldr	r3, [r7, #16]
9000ff08:	2b00      	cmp	r3, #0
9000ff0a:	d0d6      	beq.n	9000feba <MMC_PowerON+0x2a>
  }

  /* When power routine is finished and command returns valid voltage */
  if (((response & (0xFF000000U)) >> 24) == 0xC0U)
9000ff0c:	697b      	ldr	r3, [r7, #20]
9000ff0e:	0e1b      	lsrs	r3, r3, #24
9000ff10:	2bc0      	cmp	r3, #192	; 0xc0
9000ff12:	d103      	bne.n	9000ff1c <MMC_PowerON+0x8c>
  {
    hmmc->MmcCard.CardType = MMC_HIGH_CAPACITY_CARD;
9000ff14:	687b      	ldr	r3, [r7, #4]
9000ff16:	2201      	movs	r2, #1
9000ff18:	639a      	str	r2, [r3, #56]	; 0x38
9000ff1a:	e002      	b.n	9000ff22 <MMC_PowerON+0x92>
  }
  else
  {
    hmmc->MmcCard.CardType = MMC_LOW_CAPACITY_CARD;
9000ff1c:	687b      	ldr	r3, [r7, #4]
9000ff1e:	2200      	movs	r2, #0
9000ff20:	639a      	str	r2, [r3, #56]	; 0x38
  }

  return HAL_MMC_ERROR_NONE;
9000ff22:	2300      	movs	r3, #0
}
9000ff24:	4618      	mov	r0, r3
9000ff26:	3718      	adds	r7, #24
9000ff28:	46bd      	mov	sp, r7
9000ff2a:	bd80      	pop	{r7, pc}
9000ff2c:	c0ff8000 	.word	0xc0ff8000

9000ff30 <MMC_SendStatus>:
  * @param  pCardStatus: pointer to the buffer that will contain the MMC card
  *         status (Card Status register)
  * @retval error state
  */
static uint32_t MMC_SendStatus(MMC_HandleTypeDef *hmmc, uint32_t *pCardStatus)
{
9000ff30:	b580      	push	{r7, lr}
9000ff32:	b084      	sub	sp, #16
9000ff34:	af00      	add	r7, sp, #0
9000ff36:	6078      	str	r0, [r7, #4]
9000ff38:	6039      	str	r1, [r7, #0]
  uint32_t errorstate;

  if (pCardStatus == NULL)
9000ff3a:	683b      	ldr	r3, [r7, #0]
9000ff3c:	2b00      	cmp	r3, #0
9000ff3e:	d102      	bne.n	9000ff46 <MMC_SendStatus+0x16>
  {
    return HAL_MMC_ERROR_PARAM;
9000ff40:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
9000ff44:	e018      	b.n	9000ff78 <MMC_SendStatus+0x48>
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(hmmc->MmcCard.RelCardAdd << 16U));
9000ff46:	687b      	ldr	r3, [r7, #4]
9000ff48:	681a      	ldr	r2, [r3, #0]
9000ff4a:	687b      	ldr	r3, [r7, #4]
9000ff4c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9000ff4e:	041b      	lsls	r3, r3, #16
9000ff50:	4619      	mov	r1, r3
9000ff52:	4610      	mov	r0, r2
9000ff54:	f005 fa89 	bl	9001546a <SDMMC_CmdSendStatus>
9000ff58:	60f8      	str	r0, [r7, #12]
  if (errorstate != HAL_MMC_ERROR_NONE)
9000ff5a:	68fb      	ldr	r3, [r7, #12]
9000ff5c:	2b00      	cmp	r3, #0
9000ff5e:	d001      	beq.n	9000ff64 <MMC_SendStatus+0x34>
  {
    return errorstate;
9000ff60:	68fb      	ldr	r3, [r7, #12]
9000ff62:	e009      	b.n	9000ff78 <MMC_SendStatus+0x48>
  }

  /* Get MMC card status */
  *pCardStatus = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
9000ff64:	687b      	ldr	r3, [r7, #4]
9000ff66:	681b      	ldr	r3, [r3, #0]
9000ff68:	2100      	movs	r1, #0
9000ff6a:	4618      	mov	r0, r3
9000ff6c:	f005 f845 	bl	90014ffa <SDMMC_GetResponse>
9000ff70:	4602      	mov	r2, r0
9000ff72:	683b      	ldr	r3, [r7, #0]
9000ff74:	601a      	str	r2, [r3, #0]

  return HAL_MMC_ERROR_NONE;
9000ff76:	2300      	movs	r3, #0
}
9000ff78:	4618      	mov	r0, r3
9000ff7a:	3710      	adds	r7, #16
9000ff7c:	46bd      	mov	sp, r7
9000ff7e:	bd80      	pop	{r7, pc}

9000ff80 <MMC_ReadExtCSD>:
  * @param  Timeout: Specify timeout value
  * @retval HAL status
  */
static HAL_StatusTypeDef MMC_ReadExtCSD(MMC_HandleTypeDef *hmmc, uint32_t *pFieldData,
                                        uint16_t FieldIndex, uint32_t Timeout)
{
9000ff80:	b580      	push	{r7, lr}
9000ff82:	b090      	sub	sp, #64	; 0x40
9000ff84:	af00      	add	r7, sp, #0
9000ff86:	60f8      	str	r0, [r7, #12]
9000ff88:	60b9      	str	r1, [r7, #8]
9000ff8a:	603b      	str	r3, [r7, #0]
9000ff8c:	4613      	mov	r3, r2
9000ff8e:	80fb      	strh	r3, [r7, #6]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
9000ff90:	f7f9 fa18 	bl	900093c4 <HAL_GetTick>
9000ff94:	6378      	str	r0, [r7, #52]	; 0x34
  uint32_t count;
  uint32_t i = 0;
9000ff96:	2300      	movs	r3, #0
9000ff98:	63bb      	str	r3, [r7, #56]	; 0x38
  uint32_t tmp_data;

  hmmc->ErrorCode = HAL_MMC_ERROR_NONE;
9000ff9a:	68fb      	ldr	r3, [r7, #12]
9000ff9c:	2200      	movs	r2, #0
9000ff9e:	635a      	str	r2, [r3, #52]	; 0x34

  /* Initialize data control register */
  hmmc->Instance->DCTRL = 0;
9000ffa0:	68fb      	ldr	r3, [r7, #12]
9000ffa2:	681b      	ldr	r3, [r3, #0]
9000ffa4:	2200      	movs	r2, #0
9000ffa6:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Configure the MMC DPSM (Data Path State Machine) */
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
9000ffa8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9000ffac:	617b      	str	r3, [r7, #20]
  config.DataLength    = 512U;
9000ffae:	f44f 7300 	mov.w	r3, #512	; 0x200
9000ffb2:	61bb      	str	r3, [r7, #24]
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
9000ffb4:	2390      	movs	r3, #144	; 0x90
9000ffb6:	61fb      	str	r3, [r7, #28]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
9000ffb8:	2302      	movs	r3, #2
9000ffba:	623b      	str	r3, [r7, #32]
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
9000ffbc:	2300      	movs	r3, #0
9000ffbe:	627b      	str	r3, [r7, #36]	; 0x24
  config.DPSM          = SDMMC_DPSM_ENABLE;
9000ffc0:	2301      	movs	r3, #1
9000ffc2:	62bb      	str	r3, [r7, #40]	; 0x28
  (void)SDMMC_ConfigData(hmmc->Instance, &config);
9000ffc4:	68fb      	ldr	r3, [r7, #12]
9000ffc6:	681b      	ldr	r3, [r3, #0]
9000ffc8:	f107 0214 	add.w	r2, r7, #20
9000ffcc:	4611      	mov	r1, r2
9000ffce:	4618      	mov	r0, r3
9000ffd0:	f005 f826 	bl	90015020 <SDMMC_ConfigData>

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdSendEXTCSD(hmmc->Instance, 0);
9000ffd4:	68fb      	ldr	r3, [r7, #12]
9000ffd6:	681b      	ldr	r3, [r3, #0]
9000ffd8:	2100      	movs	r1, #0
9000ffda:	4618      	mov	r0, r3
9000ffdc:	f005 faab 	bl	90015536 <SDMMC_CmdSendEXTCSD>
9000ffe0:	6338      	str	r0, [r7, #48]	; 0x30
  if (errorstate != HAL_MMC_ERROR_NONE)
9000ffe2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9000ffe4:	2b00      	cmp	r3, #0
9000ffe6:	d04e      	beq.n	90010086 <MMC_ReadExtCSD+0x106>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
9000ffe8:	68fb      	ldr	r3, [r7, #12]
9000ffea:	681b      	ldr	r3, [r3, #0]
9000ffec:	4a5c      	ldr	r2, [pc, #368]	; (90010160 <MMC_ReadExtCSD+0x1e0>)
9000ffee:	639a      	str	r2, [r3, #56]	; 0x38
    hmmc->ErrorCode |= errorstate;
9000fff0:	68fb      	ldr	r3, [r7, #12]
9000fff2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9000fff4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9000fff6:	431a      	orrs	r2, r3
9000fff8:	68fb      	ldr	r3, [r7, #12]
9000fffa:	635a      	str	r2, [r3, #52]	; 0x34
    hmmc->State = HAL_MMC_STATE_READY;
9000fffc:	68fb      	ldr	r3, [r7, #12]
9000fffe:	2201      	movs	r2, #1
90010000:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    return HAL_ERROR;
90010004:	2301      	movs	r3, #1
90010006:	e0a6      	b.n	90010156 <MMC_ReadExtCSD+0x1d6>

  /* Poll on SDMMC flags */
  while (!__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT |
                             SDMMC_FLAG_DATAEND))
  {
    if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXFIFOHF))
90010008:	68fb      	ldr	r3, [r7, #12]
9001000a:	681b      	ldr	r3, [r3, #0]
9001000c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9001000e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
90010012:	2b00      	cmp	r3, #0
90010014:	d01c      	beq.n	90010050 <MMC_ReadExtCSD+0xd0>
    {
      /* Read data from SDMMC Rx FIFO */
      for (count = 0U; count < 8U; count++)
90010016:	2300      	movs	r3, #0
90010018:	63fb      	str	r3, [r7, #60]	; 0x3c
9001001a:	e013      	b.n	90010044 <MMC_ReadExtCSD+0xc4>
      {
        tmp_data = SDMMC_ReadFIFO(hmmc->Instance);
9001001c:	68fb      	ldr	r3, [r7, #12]
9001001e:	681b      	ldr	r3, [r3, #0]
90010020:	4618      	mov	r0, r3
90010022:	f004 ff75 	bl	90014f10 <SDMMC_ReadFIFO>
90010026:	62f8      	str	r0, [r7, #44]	; 0x2c
        /* eg : SEC_COUNT   : FieldIndex = 212 => i+count = 53 */
        /*      DEVICE_TYPE : FieldIndex = 196 => i+count = 49 */
        if ((i + count) == ((uint32_t)FieldIndex / 4U))
90010028:	6bba      	ldr	r2, [r7, #56]	; 0x38
9001002a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
9001002c:	4413      	add	r3, r2
9001002e:	88fa      	ldrh	r2, [r7, #6]
90010030:	0892      	lsrs	r2, r2, #2
90010032:	b292      	uxth	r2, r2
90010034:	4293      	cmp	r3, r2
90010036:	d102      	bne.n	9001003e <MMC_ReadExtCSD+0xbe>
        {
          *pFieldData = tmp_data;
90010038:	68bb      	ldr	r3, [r7, #8]
9001003a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
9001003c:	601a      	str	r2, [r3, #0]
      for (count = 0U; count < 8U; count++)
9001003e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
90010040:	3301      	adds	r3, #1
90010042:	63fb      	str	r3, [r7, #60]	; 0x3c
90010044:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
90010046:	2b07      	cmp	r3, #7
90010048:	d9e8      	bls.n	9001001c <MMC_ReadExtCSD+0x9c>
        }
      }
      i += 8U;
9001004a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
9001004c:	3308      	adds	r3, #8
9001004e:	63bb      	str	r3, [r7, #56]	; 0x38
    }

    if (((HAL_GetTick() - tickstart) >=  Timeout) || (Timeout == 0U))
90010050:	f7f9 f9b8 	bl	900093c4 <HAL_GetTick>
90010054:	4602      	mov	r2, r0
90010056:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90010058:	1ad3      	subs	r3, r2, r3
9001005a:	683a      	ldr	r2, [r7, #0]
9001005c:	429a      	cmp	r2, r3
9001005e:	d902      	bls.n	90010066 <MMC_ReadExtCSD+0xe6>
90010060:	683b      	ldr	r3, [r7, #0]
90010062:	2b00      	cmp	r3, #0
90010064:	d10f      	bne.n	90010086 <MMC_ReadExtCSD+0x106>
    {
      /* Clear all the static flags */
      __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
90010066:	68fb      	ldr	r3, [r7, #12]
90010068:	681b      	ldr	r3, [r3, #0]
9001006a:	4a3d      	ldr	r2, [pc, #244]	; (90010160 <MMC_ReadExtCSD+0x1e0>)
9001006c:	639a      	str	r2, [r3, #56]	; 0x38
      hmmc->ErrorCode |= HAL_MMC_ERROR_TIMEOUT;
9001006e:	68fb      	ldr	r3, [r7, #12]
90010070:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90010072:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
90010076:	68fb      	ldr	r3, [r7, #12]
90010078:	635a      	str	r2, [r3, #52]	; 0x34
      hmmc->State = HAL_MMC_STATE_READY;
9001007a:	68fb      	ldr	r3, [r7, #12]
9001007c:	2201      	movs	r2, #1
9001007e:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
      return HAL_TIMEOUT;
90010082:	2303      	movs	r3, #3
90010084:	e067      	b.n	90010156 <MMC_ReadExtCSD+0x1d6>
  while (!__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT |
90010086:	68fb      	ldr	r3, [r7, #12]
90010088:	681b      	ldr	r3, [r3, #0]
9001008a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9001008c:	f403 7395 	and.w	r3, r3, #298	; 0x12a
90010090:	2b00      	cmp	r3, #0
90010092:	d0b9      	beq.n	90010008 <MMC_ReadExtCSD+0x88>
    }
  }

  /* Get error state */
  if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DTIMEOUT))
90010094:	68fb      	ldr	r3, [r7, #12]
90010096:	681b      	ldr	r3, [r3, #0]
90010098:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9001009a:	f003 0308 	and.w	r3, r3, #8
9001009e:	2b00      	cmp	r3, #0
900100a0:	d00f      	beq.n	900100c2 <MMC_ReadExtCSD+0x142>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
900100a2:	68fb      	ldr	r3, [r7, #12]
900100a4:	681b      	ldr	r3, [r3, #0]
900100a6:	4a2e      	ldr	r2, [pc, #184]	; (90010160 <MMC_ReadExtCSD+0x1e0>)
900100a8:	639a      	str	r2, [r3, #56]	; 0x38
    hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_TIMEOUT;
900100aa:	68fb      	ldr	r3, [r7, #12]
900100ac:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900100ae:	f043 0208 	orr.w	r2, r3, #8
900100b2:	68fb      	ldr	r3, [r7, #12]
900100b4:	635a      	str	r2, [r3, #52]	; 0x34
    hmmc->State = HAL_MMC_STATE_READY;
900100b6:	68fb      	ldr	r3, [r7, #12]
900100b8:	2201      	movs	r2, #1
900100ba:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    return HAL_ERROR;
900100be:	2301      	movs	r3, #1
900100c0:	e049      	b.n	90010156 <MMC_ReadExtCSD+0x1d6>
  }
  else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_DCRCFAIL))
900100c2:	68fb      	ldr	r3, [r7, #12]
900100c4:	681b      	ldr	r3, [r3, #0]
900100c6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900100c8:	f003 0302 	and.w	r3, r3, #2
900100cc:	2b00      	cmp	r3, #0
900100ce:	d00f      	beq.n	900100f0 <MMC_ReadExtCSD+0x170>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
900100d0:	68fb      	ldr	r3, [r7, #12]
900100d2:	681b      	ldr	r3, [r3, #0]
900100d4:	4a22      	ldr	r2, [pc, #136]	; (90010160 <MMC_ReadExtCSD+0x1e0>)
900100d6:	639a      	str	r2, [r3, #56]	; 0x38
    hmmc->ErrorCode |= HAL_MMC_ERROR_DATA_CRC_FAIL;
900100d8:	68fb      	ldr	r3, [r7, #12]
900100da:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900100dc:	f043 0202 	orr.w	r2, r3, #2
900100e0:	68fb      	ldr	r3, [r7, #12]
900100e2:	635a      	str	r2, [r3, #52]	; 0x34
    hmmc->State = HAL_MMC_STATE_READY;
900100e4:	68fb      	ldr	r3, [r7, #12]
900100e6:	2201      	movs	r2, #1
900100e8:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    return HAL_ERROR;
900100ec:	2301      	movs	r3, #1
900100ee:	e032      	b.n	90010156 <MMC_ReadExtCSD+0x1d6>
  }
  else if (__HAL_MMC_GET_FLAG(hmmc, SDMMC_FLAG_RXOVERR))
900100f0:	68fb      	ldr	r3, [r7, #12]
900100f2:	681b      	ldr	r3, [r3, #0]
900100f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900100f6:	f003 0320 	and.w	r3, r3, #32
900100fa:	2b00      	cmp	r3, #0
900100fc:	d00f      	beq.n	9001011e <MMC_ReadExtCSD+0x19e>
  {
    /* Clear all the static flags */
    __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_FLAGS);
900100fe:	68fb      	ldr	r3, [r7, #12]
90010100:	681b      	ldr	r3, [r3, #0]
90010102:	4a17      	ldr	r2, [pc, #92]	; (90010160 <MMC_ReadExtCSD+0x1e0>)
90010104:	639a      	str	r2, [r3, #56]	; 0x38
    hmmc->ErrorCode |= HAL_MMC_ERROR_RX_OVERRUN;
90010106:	68fb      	ldr	r3, [r7, #12]
90010108:	6b5b      	ldr	r3, [r3, #52]	; 0x34
9001010a:	f043 0220 	orr.w	r2, r3, #32
9001010e:	68fb      	ldr	r3, [r7, #12]
90010110:	635a      	str	r2, [r3, #52]	; 0x34
    hmmc->State = HAL_MMC_STATE_READY;
90010112:	68fb      	ldr	r3, [r7, #12]
90010114:	2201      	movs	r2, #1
90010116:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    return HAL_ERROR;
9001011a:	2301      	movs	r3, #1
9001011c:	e01b      	b.n	90010156 <MMC_ReadExtCSD+0x1d6>
  {
    /* Nothing to do */
  }

  /* While card is not ready for data and trial number for sending CMD13 is not exceeded */
  errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16));
9001011e:	68fb      	ldr	r3, [r7, #12]
90010120:	681a      	ldr	r2, [r3, #0]
90010122:	68fb      	ldr	r3, [r7, #12]
90010124:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90010126:	041b      	lsls	r3, r3, #16
90010128:	4619      	mov	r1, r3
9001012a:	4610      	mov	r0, r2
9001012c:	f005 f99d 	bl	9001546a <SDMMC_CmdSendStatus>
90010130:	6338      	str	r0, [r7, #48]	; 0x30
  if (errorstate != HAL_MMC_ERROR_NONE)
90010132:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90010134:	2b00      	cmp	r3, #0
90010136:	d005      	beq.n	90010144 <MMC_ReadExtCSD+0x1c4>
  {
    hmmc->ErrorCode |= errorstate;
90010138:	68fb      	ldr	r3, [r7, #12]
9001013a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
9001013c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9001013e:	431a      	orrs	r2, r3
90010140:	68fb      	ldr	r3, [r7, #12]
90010142:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* Clear all the static flags */
  __HAL_MMC_CLEAR_FLAG(hmmc, SDMMC_STATIC_DATA_FLAGS);
90010144:	68fb      	ldr	r3, [r7, #12]
90010146:	681b      	ldr	r3, [r3, #0]
90010148:	4a06      	ldr	r2, [pc, #24]	; (90010164 <MMC_ReadExtCSD+0x1e4>)
9001014a:	639a      	str	r2, [r3, #56]	; 0x38

  hmmc->State = HAL_MMC_STATE_READY;
9001014c:	68fb      	ldr	r3, [r7, #12]
9001014e:	2201      	movs	r2, #1
90010150:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

  return HAL_OK;
90010154:	2300      	movs	r3, #0
}
90010156:	4618      	mov	r0, r3
90010158:	3740      	adds	r7, #64	; 0x40
9001015a:	46bd      	mov	sp, r7
9001015c:	bd80      	pop	{r7, pc}
9001015e:	bf00      	nop
90010160:	1fe00fff 	.word	0x1fe00fff
90010164:	18000f3a 	.word	0x18000f3a

90010168 <MMC_PwrClassUpdate>:
  * @param  Wide Wide of MMC bus
  * @param  Speed Speed of the MMC bus
  * @retval MMC Card error state
  */
static uint32_t MMC_PwrClassUpdate(MMC_HandleTypeDef *hmmc, uint32_t Wide, uint32_t Speed)
{
90010168:	b580      	push	{r7, lr}
9001016a:	b08a      	sub	sp, #40	; 0x28
9001016c:	af00      	add	r7, sp, #0
9001016e:	60f8      	str	r0, [r7, #12]
90010170:	60b9      	str	r1, [r7, #8]
90010172:	607a      	str	r2, [r7, #4]
  uint32_t count;
  uint32_t response = 0U;
90010174:	2300      	movs	r3, #0
90010176:	623b      	str	r3, [r7, #32]
  uint32_t errorstate = HAL_MMC_ERROR_NONE;
90010178:	2300      	movs	r3, #0
9001017a:	61fb      	str	r3, [r7, #28]
  uint32_t power_class;
  uint32_t supported_pwr_class;

  if ((Wide == SDMMC_BUS_WIDE_8B) || (Wide == SDMMC_BUS_WIDE_4B))
9001017c:	68bb      	ldr	r3, [r7, #8]
9001017e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
90010182:	d004      	beq.n	9001018e <MMC_PwrClassUpdate+0x26>
90010184:	68bb      	ldr	r3, [r7, #8]
90010186:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
9001018a:	f040 8085 	bne.w	90010298 <MMC_PwrClassUpdate+0x130>
  {
    power_class = 0U; /* Default value after power-on or software reset */
9001018e:	2300      	movs	r3, #0
90010190:	617b      	str	r3, [r7, #20]

    /* Read the PowerClass field of the Extended CSD register */
    if (MMC_ReadExtCSD(hmmc, &power_class, 187, SDMMC_DATATIMEOUT) != HAL_OK) /* Field POWER_CLASS [187] */
90010192:	f107 0114 	add.w	r1, r7, #20
90010196:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9001019a:	22bb      	movs	r2, #187	; 0xbb
9001019c:	68f8      	ldr	r0, [r7, #12]
9001019e:	f7ff feef 	bl	9000ff80 <MMC_ReadExtCSD>
900101a2:	4603      	mov	r3, r0
900101a4:	2b00      	cmp	r3, #0
900101a6:	d003      	beq.n	900101b0 <MMC_PwrClassUpdate+0x48>
    {
      errorstate = SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
900101a8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
900101ac:	61fb      	str	r3, [r7, #28]
900101ae:	e002      	b.n	900101b6 <MMC_PwrClassUpdate+0x4e>
    }
    else
    {
      power_class = ((power_class >> 24U) & 0x000000FFU);
900101b0:	697b      	ldr	r3, [r7, #20]
900101b2:	0e1b      	lsrs	r3, r3, #24
900101b4:	617b      	str	r3, [r7, #20]
    }

    /* Get the supported PowerClass field of the Extended CSD register */
    if (Speed == SDMMC_SPEED_MODE_DDR)
900101b6:	687b      	ldr	r3, [r7, #4]
900101b8:	2b04      	cmp	r3, #4
900101ba:	d105      	bne.n	900101c8 <MMC_PwrClassUpdate+0x60>
    {
      /* Field PWR_CL_DDR_52_xxx [238 or 239] */
      supported_pwr_class = ((hmmc->Ext_CSD[(MMC_EXT_CSD_PWR_CL_DDR_52_INDEX / 4)] >> MMC_EXT_CSD_PWR_CL_DDR_52_POS) &
900101bc:	68fb      	ldr	r3, [r7, #12]
900101be:	f8d3 3160 	ldr.w	r3, [r3, #352]	; 0x160
900101c2:	0e1b      	lsrs	r3, r3, #24
900101c4:	61bb      	str	r3, [r7, #24]
900101c6:	e00e      	b.n	900101e6 <MMC_PwrClassUpdate+0x7e>
                             0x000000FFU);
    }
    else if (Speed == SDMMC_SPEED_MODE_HIGH)
900101c8:	687b      	ldr	r3, [r7, #4]
900101ca:	2b02      	cmp	r3, #2
900101cc:	d106      	bne.n	900101dc <MMC_PwrClassUpdate+0x74>
    {
      /* Field PWR_CL_52_xxx [200 or 202] */
      supported_pwr_class = ((hmmc->Ext_CSD[(MMC_EXT_CSD_PWR_CL_52_INDEX / 4)] >> MMC_EXT_CSD_PWR_CL_52_POS) &
900101ce:	68fb      	ldr	r3, [r7, #12]
900101d0:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
900101d4:	0c1b      	lsrs	r3, r3, #16
900101d6:	b2db      	uxtb	r3, r3
900101d8:	61bb      	str	r3, [r7, #24]
900101da:	e004      	b.n	900101e6 <MMC_PwrClassUpdate+0x7e>
                             0x000000FFU);
    }
    else
    {
      /* Field PWR_CL_26_xxx [201 or 203] */
      supported_pwr_class = ((hmmc->Ext_CSD[(MMC_EXT_CSD_PWR_CL_26_INDEX / 4)] >> MMC_EXT_CSD_PWR_CL_26_POS) &
900101dc:	68fb      	ldr	r3, [r7, #12]
900101de:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
900101e2:	0e1b      	lsrs	r3, r3, #24
900101e4:	61bb      	str	r3, [r7, #24]
                             0x000000FFU);
    }

    if (errorstate == HAL_MMC_ERROR_NONE)
900101e6:	69fb      	ldr	r3, [r7, #28]
900101e8:	2b00      	cmp	r3, #0
900101ea:	d155      	bne.n	90010298 <MMC_PwrClassUpdate+0x130>
    {
      if (Wide == SDMMC_BUS_WIDE_8B)
900101ec:	68bb      	ldr	r3, [r7, #8]
900101ee:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
900101f2:	d102      	bne.n	900101fa <MMC_PwrClassUpdate+0x92>
      {
        /* Bit [7:4]: power class for 8-bits bus configuration - Bit [3:0]: power class for 4-bits bus configuration */
        supported_pwr_class = (supported_pwr_class >> 4U);
900101f4:	69bb      	ldr	r3, [r7, #24]
900101f6:	091b      	lsrs	r3, r3, #4
900101f8:	61bb      	str	r3, [r7, #24]
      }

      if ((power_class & 0x0FU) != (supported_pwr_class & 0x0FU))
900101fa:	697a      	ldr	r2, [r7, #20]
900101fc:	69bb      	ldr	r3, [r7, #24]
900101fe:	4053      	eors	r3, r2
90010200:	f003 030f 	and.w	r3, r3, #15
90010204:	2b00      	cmp	r3, #0
90010206:	d047      	beq.n	90010298 <MMC_PwrClassUpdate+0x130>
      {
        /* Need to change current power class */
        errorstate = SDMMC_CmdSwitch(hmmc->Instance, (0x03BB0000U | ((supported_pwr_class & 0x0FU) << 8U)));
90010208:	68fb      	ldr	r3, [r7, #12]
9001020a:	6818      	ldr	r0, [r3, #0]
9001020c:	69bb      	ldr	r3, [r7, #24]
9001020e:	021b      	lsls	r3, r3, #8
90010210:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
90010214:	4b23      	ldr	r3, [pc, #140]	; (900102a4 <MMC_PwrClassUpdate+0x13c>)
90010216:	4313      	orrs	r3, r2
90010218:	4619      	mov	r1, r3
9001021a:	f005 f969 	bl	900154f0 <SDMMC_CmdSwitch>
9001021e:	61f8      	str	r0, [r7, #28]

        if (errorstate == HAL_MMC_ERROR_NONE)
90010220:	69fb      	ldr	r3, [r7, #28]
90010222:	2b00      	cmp	r3, #0
90010224:	d138      	bne.n	90010298 <MMC_PwrClassUpdate+0x130>
        {
          /* While card is not ready for data and trial number for sending CMD13 is not exceeded */
          count = SDMMC_MAX_TRIAL;
90010226:	f64f 73ff 	movw	r3, #65535	; 0xffff
9001022a:	627b      	str	r3, [r7, #36]	; 0x24
          do
          {
            errorstate = SDMMC_CmdSendStatus(hmmc->Instance, (uint32_t)(((uint32_t)hmmc->MmcCard.RelCardAdd) << 16U));
9001022c:	68fb      	ldr	r3, [r7, #12]
9001022e:	681a      	ldr	r2, [r3, #0]
90010230:	68fb      	ldr	r3, [r7, #12]
90010232:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90010234:	041b      	lsls	r3, r3, #16
90010236:	4619      	mov	r1, r3
90010238:	4610      	mov	r0, r2
9001023a:	f005 f916 	bl	9001546a <SDMMC_CmdSendStatus>
9001023e:	61f8      	str	r0, [r7, #28]
            if (errorstate != HAL_MMC_ERROR_NONE)
90010240:	69fb      	ldr	r3, [r7, #28]
90010242:	2b00      	cmp	r3, #0
90010244:	d112      	bne.n	9001026c <MMC_PwrClassUpdate+0x104>
            {
              break;
            }

            /* Get command response */
            response = SDMMC_GetResponse(hmmc->Instance, SDMMC_RESP1);
90010246:	68fb      	ldr	r3, [r7, #12]
90010248:	681b      	ldr	r3, [r3, #0]
9001024a:	2100      	movs	r1, #0
9001024c:	4618      	mov	r0, r3
9001024e:	f004 fed4 	bl	90014ffa <SDMMC_GetResponse>
90010252:	6238      	str	r0, [r7, #32]
            count--;
90010254:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90010256:	3b01      	subs	r3, #1
90010258:	627b      	str	r3, [r7, #36]	; 0x24
          } while (((response & 0x100U) == 0U) && (count != 0U));
9001025a:	6a3b      	ldr	r3, [r7, #32]
9001025c:	f403 7380 	and.w	r3, r3, #256	; 0x100
90010260:	2b00      	cmp	r3, #0
90010262:	d104      	bne.n	9001026e <MMC_PwrClassUpdate+0x106>
90010264:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90010266:	2b00      	cmp	r3, #0
90010268:	d1e0      	bne.n	9001022c <MMC_PwrClassUpdate+0xc4>
9001026a:	e000      	b.n	9001026e <MMC_PwrClassUpdate+0x106>
              break;
9001026c:	bf00      	nop

          /* Check the status after the switch command execution */
          if ((count != 0U) && (errorstate == HAL_MMC_ERROR_NONE))
9001026e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90010270:	2b00      	cmp	r3, #0
90010272:	d00b      	beq.n	9001028c <MMC_PwrClassUpdate+0x124>
90010274:	69fb      	ldr	r3, [r7, #28]
90010276:	2b00      	cmp	r3, #0
90010278:	d108      	bne.n	9001028c <MMC_PwrClassUpdate+0x124>
          {
            /* Check the bit SWITCH_ERROR of the device status */
            if ((response & 0x80U) != 0U)
9001027a:	6a3b      	ldr	r3, [r7, #32]
9001027c:	f003 0380 	and.w	r3, r3, #128	; 0x80
90010280:	2b00      	cmp	r3, #0
90010282:	d009      	beq.n	90010298 <MMC_PwrClassUpdate+0x130>
            {
              errorstate = SDMMC_ERROR_UNSUPPORTED_FEATURE;
90010284:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
90010288:	61fb      	str	r3, [r7, #28]
            if ((response & 0x80U) != 0U)
9001028a:	e005      	b.n	90010298 <MMC_PwrClassUpdate+0x130>
            }
          }
          else if (count == 0U)
9001028c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9001028e:	2b00      	cmp	r3, #0
90010290:	d102      	bne.n	90010298 <MMC_PwrClassUpdate+0x130>
          {
            errorstate = SDMMC_ERROR_TIMEOUT;
90010292:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
90010296:	61fb      	str	r3, [r7, #28]
        }
      }
    }
  }

  return errorstate;
90010298:	69fb      	ldr	r3, [r7, #28]
}
9001029a:	4618      	mov	r0, r3
9001029c:	3728      	adds	r7, #40	; 0x28
9001029e:	46bd      	mov	sp, r7
900102a0:	bd80      	pop	{r7, pc}
900102a2:	bf00      	nop
900102a4:	03bb0000 	.word	0x03bb0000

900102a8 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
900102a8:	b580      	push	{r7, lr}
900102aa:	b084      	sub	sp, #16
900102ac:	af00      	add	r7, sp, #0
900102ae:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
900102b0:	4b19      	ldr	r3, [pc, #100]	; (90010318 <HAL_PWREx_ConfigSupply+0x70>)
900102b2:	68db      	ldr	r3, [r3, #12]
900102b4:	f003 0304 	and.w	r3, r3, #4
900102b8:	2b04      	cmp	r3, #4
900102ba:	d00a      	beq.n	900102d2 <HAL_PWREx_ConfigSupply+0x2a>
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
900102bc:	4b16      	ldr	r3, [pc, #88]	; (90010318 <HAL_PWREx_ConfigSupply+0x70>)
900102be:	68db      	ldr	r3, [r3, #12]
900102c0:	f003 0307 	and.w	r3, r3, #7
900102c4:	687a      	ldr	r2, [r7, #4]
900102c6:	429a      	cmp	r2, r3
900102c8:	d001      	beq.n	900102ce <HAL_PWREx_ConfigSupply+0x26>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
900102ca:	2301      	movs	r3, #1
900102cc:	e01f      	b.n	9001030e <HAL_PWREx_ConfigSupply+0x66>
    else
    {
      /* Supply configuration update locked, but new supply configuration
         matches with old supply configuration : nothing to do
      */
      return HAL_OK;
900102ce:	2300      	movs	r3, #0
900102d0:	e01d      	b.n	9001030e <HAL_PWREx_ConfigSupply+0x66>
    }
  }

  /* Set the power supply configuration */
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
900102d2:	4b11      	ldr	r3, [pc, #68]	; (90010318 <HAL_PWREx_ConfigSupply+0x70>)
900102d4:	68db      	ldr	r3, [r3, #12]
900102d6:	f023 0207 	bic.w	r2, r3, #7
900102da:	490f      	ldr	r1, [pc, #60]	; (90010318 <HAL_PWREx_ConfigSupply+0x70>)
900102dc:	687b      	ldr	r3, [r7, #4]
900102de:	4313      	orrs	r3, r2
900102e0:	60cb      	str	r3, [r1, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
900102e2:	f7f9 f86f 	bl	900093c4 <HAL_GetTick>
900102e6:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
900102e8:	e009      	b.n	900102fe <HAL_PWREx_ConfigSupply+0x56>
  {
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
900102ea:	f7f9 f86b 	bl	900093c4 <HAL_GetTick>
900102ee:	4602      	mov	r2, r0
900102f0:	68fb      	ldr	r3, [r7, #12]
900102f2:	1ad3      	subs	r3, r2, r3
900102f4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
900102f8:	d901      	bls.n	900102fe <HAL_PWREx_ConfigSupply+0x56>
    {
      return HAL_ERROR;
900102fa:	2301      	movs	r3, #1
900102fc:	e007      	b.n	9001030e <HAL_PWREx_ConfigSupply+0x66>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
900102fe:	4b06      	ldr	r3, [pc, #24]	; (90010318 <HAL_PWREx_ConfigSupply+0x70>)
90010300:	685b      	ldr	r3, [r3, #4]
90010302:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
90010306:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
9001030a:	d1ee      	bne.n	900102ea <HAL_PWREx_ConfigSupply+0x42>
      }
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
9001030c:	2300      	movs	r3, #0
}
9001030e:	4618      	mov	r0, r3
90010310:	3710      	adds	r7, #16
90010312:	46bd      	mov	sp, r7
90010314:	bd80      	pop	{r7, pc}
90010316:	bf00      	nop
90010318:	58024800 	.word	0x58024800

9001031c <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
9001031c:	b580      	push	{r7, lr}
9001031e:	b08c      	sub	sp, #48	; 0x30
90010320:	af00      	add	r7, sp, #0
90010322:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
90010324:	687b      	ldr	r3, [r7, #4]
90010326:	2b00      	cmp	r3, #0
90010328:	d102      	bne.n	90010330 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
9001032a:	2301      	movs	r3, #1
9001032c:	f000 bc1c 	b.w	90010b68 <HAL_RCC_OscConfig+0x84c>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
90010330:	687b      	ldr	r3, [r7, #4]
90010332:	681b      	ldr	r3, [r3, #0]
90010334:	f003 0301 	and.w	r3, r3, #1
90010338:	2b00      	cmp	r3, #0
9001033a:	f000 8087 	beq.w	9001044c <HAL_RCC_OscConfig+0x130>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
9001033e:	4b9e      	ldr	r3, [pc, #632]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
90010340:	691b      	ldr	r3, [r3, #16]
90010342:	f003 0338 	and.w	r3, r3, #56	; 0x38
90010346:	62fb      	str	r3, [r7, #44]	; 0x2c
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
90010348:	4b9b      	ldr	r3, [pc, #620]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001034a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9001034c:	62bb      	str	r3, [r7, #40]	; 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
9001034e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90010350:	2b10      	cmp	r3, #16
90010352:	d007      	beq.n	90010364 <HAL_RCC_OscConfig+0x48>
90010354:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90010356:	2b18      	cmp	r3, #24
90010358:	d110      	bne.n	9001037c <HAL_RCC_OscConfig+0x60>
9001035a:	6abb      	ldr	r3, [r7, #40]	; 0x28
9001035c:	f003 0303 	and.w	r3, r3, #3
90010360:	2b02      	cmp	r3, #2
90010362:	d10b      	bne.n	9001037c <HAL_RCC_OscConfig+0x60>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
90010364:	4b94      	ldr	r3, [pc, #592]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
90010366:	681b      	ldr	r3, [r3, #0]
90010368:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
9001036c:	2b00      	cmp	r3, #0
9001036e:	d06c      	beq.n	9001044a <HAL_RCC_OscConfig+0x12e>
90010370:	687b      	ldr	r3, [r7, #4]
90010372:	685b      	ldr	r3, [r3, #4]
90010374:	2b00      	cmp	r3, #0
90010376:	d168      	bne.n	9001044a <HAL_RCC_OscConfig+0x12e>
      {
        return HAL_ERROR;
90010378:	2301      	movs	r3, #1
9001037a:	e3f5      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
9001037c:	687b      	ldr	r3, [r7, #4]
9001037e:	685b      	ldr	r3, [r3, #4]
90010380:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
90010384:	d106      	bne.n	90010394 <HAL_RCC_OscConfig+0x78>
90010386:	4b8c      	ldr	r3, [pc, #560]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
90010388:	681b      	ldr	r3, [r3, #0]
9001038a:	4a8b      	ldr	r2, [pc, #556]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001038c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
90010390:	6013      	str	r3, [r2, #0]
90010392:	e02e      	b.n	900103f2 <HAL_RCC_OscConfig+0xd6>
90010394:	687b      	ldr	r3, [r7, #4]
90010396:	685b      	ldr	r3, [r3, #4]
90010398:	2b00      	cmp	r3, #0
9001039a:	d10c      	bne.n	900103b6 <HAL_RCC_OscConfig+0x9a>
9001039c:	4b86      	ldr	r3, [pc, #536]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001039e:	681b      	ldr	r3, [r3, #0]
900103a0:	4a85      	ldr	r2, [pc, #532]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103a2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
900103a6:	6013      	str	r3, [r2, #0]
900103a8:	4b83      	ldr	r3, [pc, #524]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103aa:	681b      	ldr	r3, [r3, #0]
900103ac:	4a82      	ldr	r2, [pc, #520]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103ae:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
900103b2:	6013      	str	r3, [r2, #0]
900103b4:	e01d      	b.n	900103f2 <HAL_RCC_OscConfig+0xd6>
900103b6:	687b      	ldr	r3, [r7, #4]
900103b8:	685b      	ldr	r3, [r3, #4]
900103ba:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
900103be:	d10c      	bne.n	900103da <HAL_RCC_OscConfig+0xbe>
900103c0:	4b7d      	ldr	r3, [pc, #500]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103c2:	681b      	ldr	r3, [r3, #0]
900103c4:	4a7c      	ldr	r2, [pc, #496]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103c6:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
900103ca:	6013      	str	r3, [r2, #0]
900103cc:	4b7a      	ldr	r3, [pc, #488]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103ce:	681b      	ldr	r3, [r3, #0]
900103d0:	4a79      	ldr	r2, [pc, #484]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103d2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
900103d6:	6013      	str	r3, [r2, #0]
900103d8:	e00b      	b.n	900103f2 <HAL_RCC_OscConfig+0xd6>
900103da:	4b77      	ldr	r3, [pc, #476]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103dc:	681b      	ldr	r3, [r3, #0]
900103de:	4a76      	ldr	r2, [pc, #472]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103e0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
900103e4:	6013      	str	r3, [r2, #0]
900103e6:	4b74      	ldr	r3, [pc, #464]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103e8:	681b      	ldr	r3, [r3, #0]
900103ea:	4a73      	ldr	r2, [pc, #460]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900103ec:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
900103f0:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
900103f2:	687b      	ldr	r3, [r7, #4]
900103f4:	685b      	ldr	r3, [r3, #4]
900103f6:	2b00      	cmp	r3, #0
900103f8:	d013      	beq.n	90010422 <HAL_RCC_OscConfig+0x106>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
900103fa:	f7f8 ffe3 	bl	900093c4 <HAL_GetTick>
900103fe:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
90010400:	e008      	b.n	90010414 <HAL_RCC_OscConfig+0xf8>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
90010402:	f7f8 ffdf 	bl	900093c4 <HAL_GetTick>
90010406:	4602      	mov	r2, r0
90010408:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9001040a:	1ad3      	subs	r3, r2, r3
9001040c:	2b64      	cmp	r3, #100	; 0x64
9001040e:	d901      	bls.n	90010414 <HAL_RCC_OscConfig+0xf8>
          {
            return HAL_TIMEOUT;
90010410:	2303      	movs	r3, #3
90010412:	e3a9      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
90010414:	4b68      	ldr	r3, [pc, #416]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
90010416:	681b      	ldr	r3, [r3, #0]
90010418:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
9001041c:	2b00      	cmp	r3, #0
9001041e:	d0f0      	beq.n	90010402 <HAL_RCC_OscConfig+0xe6>
90010420:	e014      	b.n	9001044c <HAL_RCC_OscConfig+0x130>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90010422:	f7f8 ffcf 	bl	900093c4 <HAL_GetTick>
90010426:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
90010428:	e008      	b.n	9001043c <HAL_RCC_OscConfig+0x120>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
9001042a:	f7f8 ffcb 	bl	900093c4 <HAL_GetTick>
9001042e:	4602      	mov	r2, r0
90010430:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90010432:	1ad3      	subs	r3, r2, r3
90010434:	2b64      	cmp	r3, #100	; 0x64
90010436:	d901      	bls.n	9001043c <HAL_RCC_OscConfig+0x120>
          {
            return HAL_TIMEOUT;
90010438:	2303      	movs	r3, #3
9001043a:	e395      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
9001043c:	4b5e      	ldr	r3, [pc, #376]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001043e:	681b      	ldr	r3, [r3, #0]
90010440:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90010444:	2b00      	cmp	r3, #0
90010446:	d1f0      	bne.n	9001042a <HAL_RCC_OscConfig+0x10e>
90010448:	e000      	b.n	9001044c <HAL_RCC_OscConfig+0x130>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
9001044a:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
9001044c:	687b      	ldr	r3, [r7, #4]
9001044e:	681b      	ldr	r3, [r3, #0]
90010450:	f003 0302 	and.w	r3, r3, #2
90010454:	2b00      	cmp	r3, #0
90010456:	f000 80ca 	beq.w	900105ee <HAL_RCC_OscConfig+0x2d2>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
9001045a:	4b57      	ldr	r3, [pc, #348]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001045c:	691b      	ldr	r3, [r3, #16]
9001045e:	f003 0338 	and.w	r3, r3, #56	; 0x38
90010462:	623b      	str	r3, [r7, #32]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
90010464:	4b54      	ldr	r3, [pc, #336]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
90010466:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90010468:	61fb      	str	r3, [r7, #28]
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
9001046a:	6a3b      	ldr	r3, [r7, #32]
9001046c:	2b00      	cmp	r3, #0
9001046e:	d007      	beq.n	90010480 <HAL_RCC_OscConfig+0x164>
90010470:	6a3b      	ldr	r3, [r7, #32]
90010472:	2b18      	cmp	r3, #24
90010474:	d156      	bne.n	90010524 <HAL_RCC_OscConfig+0x208>
90010476:	69fb      	ldr	r3, [r7, #28]
90010478:	f003 0303 	and.w	r3, r3, #3
9001047c:	2b00      	cmp	r3, #0
9001047e:	d151      	bne.n	90010524 <HAL_RCC_OscConfig+0x208>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
90010480:	4b4d      	ldr	r3, [pc, #308]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
90010482:	681b      	ldr	r3, [r3, #0]
90010484:	f003 0304 	and.w	r3, r3, #4
90010488:	2b00      	cmp	r3, #0
9001048a:	d005      	beq.n	90010498 <HAL_RCC_OscConfig+0x17c>
9001048c:	687b      	ldr	r3, [r7, #4]
9001048e:	68db      	ldr	r3, [r3, #12]
90010490:	2b00      	cmp	r3, #0
90010492:	d101      	bne.n	90010498 <HAL_RCC_OscConfig+0x17c>
      {
        return HAL_ERROR;
90010494:	2301      	movs	r3, #1
90010496:	e367      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
      }
      /* Otherwise, only HSI division and calibration are allowed */
      else
      {
          /* Enable the Internal High Speed oscillator (HSI, HSIDIV2, HSIDIV4, or HSIDIV8) */
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
90010498:	4b47      	ldr	r3, [pc, #284]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001049a:	681b      	ldr	r3, [r3, #0]
9001049c:	f023 0219 	bic.w	r2, r3, #25
900104a0:	687b      	ldr	r3, [r7, #4]
900104a2:	68db      	ldr	r3, [r3, #12]
900104a4:	4944      	ldr	r1, [pc, #272]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900104a6:	4313      	orrs	r3, r2
900104a8:	600b      	str	r3, [r1, #0]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
900104aa:	f7f8 ff8b 	bl	900093c4 <HAL_GetTick>
900104ae:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till HSI is ready */
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
900104b0:	e008      	b.n	900104c4 <HAL_RCC_OscConfig+0x1a8>
          {
            if((uint32_t) (HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
900104b2:	f7f8 ff87 	bl	900093c4 <HAL_GetTick>
900104b6:	4602      	mov	r2, r0
900104b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
900104ba:	1ad3      	subs	r3, r2, r3
900104bc:	2b02      	cmp	r3, #2
900104be:	d901      	bls.n	900104c4 <HAL_RCC_OscConfig+0x1a8>
            {
              return HAL_TIMEOUT;
900104c0:	2303      	movs	r3, #3
900104c2:	e351      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
900104c4:	4b3c      	ldr	r3, [pc, #240]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900104c6:	681b      	ldr	r3, [r3, #0]
900104c8:	f003 0304 	and.w	r3, r3, #4
900104cc:	2b00      	cmp	r3, #0
900104ce:	d0f0      	beq.n	900104b2 <HAL_RCC_OscConfig+0x196>
            }
          }
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
900104d0:	f7f8 ffa8 	bl	90009424 <HAL_GetREVID>
900104d4:	4603      	mov	r3, r0
900104d6:	f241 0203 	movw	r2, #4099	; 0x1003
900104da:	4293      	cmp	r3, r2
900104dc:	d817      	bhi.n	9001050e <HAL_RCC_OscConfig+0x1f2>
900104de:	687b      	ldr	r3, [r7, #4]
900104e0:	691b      	ldr	r3, [r3, #16]
900104e2:	2b40      	cmp	r3, #64	; 0x40
900104e4:	d108      	bne.n	900104f8 <HAL_RCC_OscConfig+0x1dc>
900104e6:	4b34      	ldr	r3, [pc, #208]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900104e8:	685b      	ldr	r3, [r3, #4]
900104ea:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
900104ee:	4a32      	ldr	r2, [pc, #200]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900104f0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
900104f4:	6053      	str	r3, [r2, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
900104f6:	e07a      	b.n	900105ee <HAL_RCC_OscConfig+0x2d2>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
900104f8:	4b2f      	ldr	r3, [pc, #188]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900104fa:	685b      	ldr	r3, [r3, #4]
900104fc:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
90010500:	687b      	ldr	r3, [r7, #4]
90010502:	691b      	ldr	r3, [r3, #16]
90010504:	031b      	lsls	r3, r3, #12
90010506:	492c      	ldr	r1, [pc, #176]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
90010508:	4313      	orrs	r3, r2
9001050a:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
9001050c:	e06f      	b.n	900105ee <HAL_RCC_OscConfig+0x2d2>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
9001050e:	4b2a      	ldr	r3, [pc, #168]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
90010510:	685b      	ldr	r3, [r3, #4]
90010512:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
90010516:	687b      	ldr	r3, [r7, #4]
90010518:	691b      	ldr	r3, [r3, #16]
9001051a:	061b      	lsls	r3, r3, #24
9001051c:	4926      	ldr	r1, [pc, #152]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001051e:	4313      	orrs	r3, r2
90010520:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
90010522:	e064      	b.n	900105ee <HAL_RCC_OscConfig+0x2d2>
    }

    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
90010524:	687b      	ldr	r3, [r7, #4]
90010526:	68db      	ldr	r3, [r3, #12]
90010528:	2b00      	cmp	r3, #0
9001052a:	d047      	beq.n	900105bc <HAL_RCC_OscConfig+0x2a0>
      {
     /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
9001052c:	4b22      	ldr	r3, [pc, #136]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001052e:	681b      	ldr	r3, [r3, #0]
90010530:	f023 0219 	bic.w	r2, r3, #25
90010534:	687b      	ldr	r3, [r7, #4]
90010536:	68db      	ldr	r3, [r3, #12]
90010538:	491f      	ldr	r1, [pc, #124]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001053a:	4313      	orrs	r3, r2
9001053c:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
9001053e:	f7f8 ff41 	bl	900093c4 <HAL_GetTick>
90010542:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
90010544:	e008      	b.n	90010558 <HAL_RCC_OscConfig+0x23c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
90010546:	f7f8 ff3d 	bl	900093c4 <HAL_GetTick>
9001054a:	4602      	mov	r2, r0
9001054c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9001054e:	1ad3      	subs	r3, r2, r3
90010550:	2b02      	cmp	r3, #2
90010552:	d901      	bls.n	90010558 <HAL_RCC_OscConfig+0x23c>
          {
            return HAL_TIMEOUT;
90010554:	2303      	movs	r3, #3
90010556:	e307      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
90010558:	4b17      	ldr	r3, [pc, #92]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001055a:	681b      	ldr	r3, [r3, #0]
9001055c:	f003 0304 	and.w	r3, r3, #4
90010560:	2b00      	cmp	r3, #0
90010562:	d0f0      	beq.n	90010546 <HAL_RCC_OscConfig+0x22a>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
90010564:	f7f8 ff5e 	bl	90009424 <HAL_GetREVID>
90010568:	4603      	mov	r3, r0
9001056a:	f241 0203 	movw	r2, #4099	; 0x1003
9001056e:	4293      	cmp	r3, r2
90010570:	d817      	bhi.n	900105a2 <HAL_RCC_OscConfig+0x286>
90010572:	687b      	ldr	r3, [r7, #4]
90010574:	691b      	ldr	r3, [r3, #16]
90010576:	2b40      	cmp	r3, #64	; 0x40
90010578:	d108      	bne.n	9001058c <HAL_RCC_OscConfig+0x270>
9001057a:	4b0f      	ldr	r3, [pc, #60]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001057c:	685b      	ldr	r3, [r3, #4]
9001057e:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
90010582:	4a0d      	ldr	r2, [pc, #52]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
90010584:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90010588:	6053      	str	r3, [r2, #4]
9001058a:	e030      	b.n	900105ee <HAL_RCC_OscConfig+0x2d2>
9001058c:	4b0a      	ldr	r3, [pc, #40]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001058e:	685b      	ldr	r3, [r3, #4]
90010590:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
90010594:	687b      	ldr	r3, [r7, #4]
90010596:	691b      	ldr	r3, [r3, #16]
90010598:	031b      	lsls	r3, r3, #12
9001059a:	4907      	ldr	r1, [pc, #28]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
9001059c:	4313      	orrs	r3, r2
9001059e:	604b      	str	r3, [r1, #4]
900105a0:	e025      	b.n	900105ee <HAL_RCC_OscConfig+0x2d2>
900105a2:	4b05      	ldr	r3, [pc, #20]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900105a4:	685b      	ldr	r3, [r3, #4]
900105a6:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
900105aa:	687b      	ldr	r3, [r7, #4]
900105ac:	691b      	ldr	r3, [r3, #16]
900105ae:	061b      	lsls	r3, r3, #24
900105b0:	4901      	ldr	r1, [pc, #4]	; (900105b8 <HAL_RCC_OscConfig+0x29c>)
900105b2:	4313      	orrs	r3, r2
900105b4:	604b      	str	r3, [r1, #4]
900105b6:	e01a      	b.n	900105ee <HAL_RCC_OscConfig+0x2d2>
900105b8:	58024400 	.word	0x58024400
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
900105bc:	4b9e      	ldr	r3, [pc, #632]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900105be:	681b      	ldr	r3, [r3, #0]
900105c0:	4a9d      	ldr	r2, [pc, #628]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900105c2:	f023 0301 	bic.w	r3, r3, #1
900105c6:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
900105c8:	f7f8 fefc 	bl	900093c4 <HAL_GetTick>
900105cc:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
900105ce:	e008      	b.n	900105e2 <HAL_RCC_OscConfig+0x2c6>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
900105d0:	f7f8 fef8 	bl	900093c4 <HAL_GetTick>
900105d4:	4602      	mov	r2, r0
900105d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
900105d8:	1ad3      	subs	r3, r2, r3
900105da:	2b02      	cmp	r3, #2
900105dc:	d901      	bls.n	900105e2 <HAL_RCC_OscConfig+0x2c6>
          {
            return HAL_TIMEOUT;
900105de:	2303      	movs	r3, #3
900105e0:	e2c2      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
900105e2:	4b95      	ldr	r3, [pc, #596]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900105e4:	681b      	ldr	r3, [r3, #0]
900105e6:	f003 0304 	and.w	r3, r3, #4
900105ea:	2b00      	cmp	r3, #0
900105ec:	d1f0      	bne.n	900105d0 <HAL_RCC_OscConfig+0x2b4>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
900105ee:	687b      	ldr	r3, [r7, #4]
900105f0:	681b      	ldr	r3, [r3, #0]
900105f2:	f003 0310 	and.w	r3, r3, #16
900105f6:	2b00      	cmp	r3, #0
900105f8:	f000 80a9 	beq.w	9001074e <HAL_RCC_OscConfig+0x432>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
900105fc:	4b8e      	ldr	r3, [pc, #568]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900105fe:	691b      	ldr	r3, [r3, #16]
90010600:	f003 0338 	and.w	r3, r3, #56	; 0x38
90010604:	61bb      	str	r3, [r7, #24]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
90010606:	4b8c      	ldr	r3, [pc, #560]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010608:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9001060a:	617b      	str	r3, [r7, #20]
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
9001060c:	69bb      	ldr	r3, [r7, #24]
9001060e:	2b08      	cmp	r3, #8
90010610:	d007      	beq.n	90010622 <HAL_RCC_OscConfig+0x306>
90010612:	69bb      	ldr	r3, [r7, #24]
90010614:	2b18      	cmp	r3, #24
90010616:	d13a      	bne.n	9001068e <HAL_RCC_OscConfig+0x372>
90010618:	697b      	ldr	r3, [r7, #20]
9001061a:	f003 0303 	and.w	r3, r3, #3
9001061e:	2b01      	cmp	r3, #1
90010620:	d135      	bne.n	9001068e <HAL_RCC_OscConfig+0x372>
    {
      /* When CSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
90010622:	4b85      	ldr	r3, [pc, #532]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010624:	681b      	ldr	r3, [r3, #0]
90010626:	f403 7380 	and.w	r3, r3, #256	; 0x100
9001062a:	2b00      	cmp	r3, #0
9001062c:	d005      	beq.n	9001063a <HAL_RCC_OscConfig+0x31e>
9001062e:	687b      	ldr	r3, [r7, #4]
90010630:	69db      	ldr	r3, [r3, #28]
90010632:	2b80      	cmp	r3, #128	; 0x80
90010634:	d001      	beq.n	9001063a <HAL_RCC_OscConfig+0x31e>
      {
        return HAL_ERROR;
90010636:	2301      	movs	r3, #1
90010638:	e296      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
9001063a:	f7f8 fef3 	bl	90009424 <HAL_GetREVID>
9001063e:	4603      	mov	r3, r0
90010640:	f241 0203 	movw	r2, #4099	; 0x1003
90010644:	4293      	cmp	r3, r2
90010646:	d817      	bhi.n	90010678 <HAL_RCC_OscConfig+0x35c>
90010648:	687b      	ldr	r3, [r7, #4]
9001064a:	6a1b      	ldr	r3, [r3, #32]
9001064c:	2b20      	cmp	r3, #32
9001064e:	d108      	bne.n	90010662 <HAL_RCC_OscConfig+0x346>
90010650:	4b79      	ldr	r3, [pc, #484]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010652:	685b      	ldr	r3, [r3, #4]
90010654:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
90010658:	4a77      	ldr	r2, [pc, #476]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
9001065a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
9001065e:	6053      	str	r3, [r2, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
90010660:	e075      	b.n	9001074e <HAL_RCC_OscConfig+0x432>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
90010662:	4b75      	ldr	r3, [pc, #468]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010664:	685b      	ldr	r3, [r3, #4]
90010666:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
9001066a:	687b      	ldr	r3, [r7, #4]
9001066c:	6a1b      	ldr	r3, [r3, #32]
9001066e:	069b      	lsls	r3, r3, #26
90010670:	4971      	ldr	r1, [pc, #452]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010672:	4313      	orrs	r3, r2
90010674:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
90010676:	e06a      	b.n	9001074e <HAL_RCC_OscConfig+0x432>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
90010678:	4b6f      	ldr	r3, [pc, #444]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
9001067a:	68db      	ldr	r3, [r3, #12]
9001067c:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
90010680:	687b      	ldr	r3, [r7, #4]
90010682:	6a1b      	ldr	r3, [r3, #32]
90010684:	061b      	lsls	r3, r3, #24
90010686:	496c      	ldr	r1, [pc, #432]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010688:	4313      	orrs	r3, r2
9001068a:	60cb      	str	r3, [r1, #12]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
9001068c:	e05f      	b.n	9001074e <HAL_RCC_OscConfig+0x432>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
9001068e:	687b      	ldr	r3, [r7, #4]
90010690:	69db      	ldr	r3, [r3, #28]
90010692:	2b00      	cmp	r3, #0
90010694:	d042      	beq.n	9001071c <HAL_RCC_OscConfig+0x400>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
90010696:	4b68      	ldr	r3, [pc, #416]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010698:	681b      	ldr	r3, [r3, #0]
9001069a:	4a67      	ldr	r2, [pc, #412]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
9001069c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
900106a0:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
900106a2:	f7f8 fe8f 	bl	900093c4 <HAL_GetTick>
900106a6:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
900106a8:	e008      	b.n	900106bc <HAL_RCC_OscConfig+0x3a0>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
900106aa:	f7f8 fe8b 	bl	900093c4 <HAL_GetTick>
900106ae:	4602      	mov	r2, r0
900106b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
900106b2:	1ad3      	subs	r3, r2, r3
900106b4:	2b02      	cmp	r3, #2
900106b6:	d901      	bls.n	900106bc <HAL_RCC_OscConfig+0x3a0>
          {
            return HAL_TIMEOUT;
900106b8:	2303      	movs	r3, #3
900106ba:	e255      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
900106bc:	4b5e      	ldr	r3, [pc, #376]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900106be:	681b      	ldr	r3, [r3, #0]
900106c0:	f403 7380 	and.w	r3, r3, #256	; 0x100
900106c4:	2b00      	cmp	r3, #0
900106c6:	d0f0      	beq.n	900106aa <HAL_RCC_OscConfig+0x38e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
900106c8:	f7f8 feac 	bl	90009424 <HAL_GetREVID>
900106cc:	4603      	mov	r3, r0
900106ce:	f241 0203 	movw	r2, #4099	; 0x1003
900106d2:	4293      	cmp	r3, r2
900106d4:	d817      	bhi.n	90010706 <HAL_RCC_OscConfig+0x3ea>
900106d6:	687b      	ldr	r3, [r7, #4]
900106d8:	6a1b      	ldr	r3, [r3, #32]
900106da:	2b20      	cmp	r3, #32
900106dc:	d108      	bne.n	900106f0 <HAL_RCC_OscConfig+0x3d4>
900106de:	4b56      	ldr	r3, [pc, #344]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900106e0:	685b      	ldr	r3, [r3, #4]
900106e2:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
900106e6:	4a54      	ldr	r2, [pc, #336]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900106e8:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
900106ec:	6053      	str	r3, [r2, #4]
900106ee:	e02e      	b.n	9001074e <HAL_RCC_OscConfig+0x432>
900106f0:	4b51      	ldr	r3, [pc, #324]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900106f2:	685b      	ldr	r3, [r3, #4]
900106f4:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
900106f8:	687b      	ldr	r3, [r7, #4]
900106fa:	6a1b      	ldr	r3, [r3, #32]
900106fc:	069b      	lsls	r3, r3, #26
900106fe:	494e      	ldr	r1, [pc, #312]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010700:	4313      	orrs	r3, r2
90010702:	604b      	str	r3, [r1, #4]
90010704:	e023      	b.n	9001074e <HAL_RCC_OscConfig+0x432>
90010706:	4b4c      	ldr	r3, [pc, #304]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010708:	68db      	ldr	r3, [r3, #12]
9001070a:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
9001070e:	687b      	ldr	r3, [r7, #4]
90010710:	6a1b      	ldr	r3, [r3, #32]
90010712:	061b      	lsls	r3, r3, #24
90010714:	4948      	ldr	r1, [pc, #288]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010716:	4313      	orrs	r3, r2
90010718:	60cb      	str	r3, [r1, #12]
9001071a:	e018      	b.n	9001074e <HAL_RCC_OscConfig+0x432>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
9001071c:	4b46      	ldr	r3, [pc, #280]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
9001071e:	681b      	ldr	r3, [r3, #0]
90010720:	4a45      	ldr	r2, [pc, #276]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010722:	f023 0380 	bic.w	r3, r3, #128	; 0x80
90010726:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90010728:	f7f8 fe4c 	bl	900093c4 <HAL_GetTick>
9001072c:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
9001072e:	e008      	b.n	90010742 <HAL_RCC_OscConfig+0x426>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
90010730:	f7f8 fe48 	bl	900093c4 <HAL_GetTick>
90010734:	4602      	mov	r2, r0
90010736:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90010738:	1ad3      	subs	r3, r2, r3
9001073a:	2b02      	cmp	r3, #2
9001073c:	d901      	bls.n	90010742 <HAL_RCC_OscConfig+0x426>
          {
            return HAL_TIMEOUT;
9001073e:	2303      	movs	r3, #3
90010740:	e212      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
90010742:	4b3d      	ldr	r3, [pc, #244]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010744:	681b      	ldr	r3, [r3, #0]
90010746:	f403 7380 	and.w	r3, r3, #256	; 0x100
9001074a:	2b00      	cmp	r3, #0
9001074c:	d1f0      	bne.n	90010730 <HAL_RCC_OscConfig+0x414>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
9001074e:	687b      	ldr	r3, [r7, #4]
90010750:	681b      	ldr	r3, [r3, #0]
90010752:	f003 0308 	and.w	r3, r3, #8
90010756:	2b00      	cmp	r3, #0
90010758:	d036      	beq.n	900107c8 <HAL_RCC_OscConfig+0x4ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
9001075a:	687b      	ldr	r3, [r7, #4]
9001075c:	695b      	ldr	r3, [r3, #20]
9001075e:	2b00      	cmp	r3, #0
90010760:	d019      	beq.n	90010796 <HAL_RCC_OscConfig+0x47a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
90010762:	4b35      	ldr	r3, [pc, #212]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010764:	6f5b      	ldr	r3, [r3, #116]	; 0x74
90010766:	4a34      	ldr	r2, [pc, #208]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010768:	f043 0301 	orr.w	r3, r3, #1
9001076c:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
9001076e:	f7f8 fe29 	bl	900093c4 <HAL_GetTick>
90010772:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
90010774:	e008      	b.n	90010788 <HAL_RCC_OscConfig+0x46c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
90010776:	f7f8 fe25 	bl	900093c4 <HAL_GetTick>
9001077a:	4602      	mov	r2, r0
9001077c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9001077e:	1ad3      	subs	r3, r2, r3
90010780:	2b02      	cmp	r3, #2
90010782:	d901      	bls.n	90010788 <HAL_RCC_OscConfig+0x46c>
        {
          return HAL_TIMEOUT;
90010784:	2303      	movs	r3, #3
90010786:	e1ef      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
90010788:	4b2b      	ldr	r3, [pc, #172]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
9001078a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
9001078c:	f003 0302 	and.w	r3, r3, #2
90010790:	2b00      	cmp	r3, #0
90010792:	d0f0      	beq.n	90010776 <HAL_RCC_OscConfig+0x45a>
90010794:	e018      	b.n	900107c8 <HAL_RCC_OscConfig+0x4ac>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
90010796:	4b28      	ldr	r3, [pc, #160]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010798:	6f5b      	ldr	r3, [r3, #116]	; 0x74
9001079a:	4a27      	ldr	r2, [pc, #156]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
9001079c:	f023 0301 	bic.w	r3, r3, #1
900107a0:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
900107a2:	f7f8 fe0f 	bl	900093c4 <HAL_GetTick>
900107a6:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
900107a8:	e008      	b.n	900107bc <HAL_RCC_OscConfig+0x4a0>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
900107aa:	f7f8 fe0b 	bl	900093c4 <HAL_GetTick>
900107ae:	4602      	mov	r2, r0
900107b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
900107b2:	1ad3      	subs	r3, r2, r3
900107b4:	2b02      	cmp	r3, #2
900107b6:	d901      	bls.n	900107bc <HAL_RCC_OscConfig+0x4a0>
        {
          return HAL_TIMEOUT;
900107b8:	2303      	movs	r3, #3
900107ba:	e1d5      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
900107bc:	4b1e      	ldr	r3, [pc, #120]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900107be:	6f5b      	ldr	r3, [r3, #116]	; 0x74
900107c0:	f003 0302 	and.w	r3, r3, #2
900107c4:	2b00      	cmp	r3, #0
900107c6:	d1f0      	bne.n	900107aa <HAL_RCC_OscConfig+0x48e>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
900107c8:	687b      	ldr	r3, [r7, #4]
900107ca:	681b      	ldr	r3, [r3, #0]
900107cc:	f003 0320 	and.w	r3, r3, #32
900107d0:	2b00      	cmp	r3, #0
900107d2:	d039      	beq.n	90010848 <HAL_RCC_OscConfig+0x52c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
900107d4:	687b      	ldr	r3, [r7, #4]
900107d6:	699b      	ldr	r3, [r3, #24]
900107d8:	2b00      	cmp	r3, #0
900107da:	d019      	beq.n	90010810 <HAL_RCC_OscConfig+0x4f4>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
900107dc:	4b16      	ldr	r3, [pc, #88]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900107de:	681b      	ldr	r3, [r3, #0]
900107e0:	4a15      	ldr	r2, [pc, #84]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
900107e2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
900107e6:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
900107e8:	f7f8 fdec 	bl	900093c4 <HAL_GetTick>
900107ec:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
900107ee:	e008      	b.n	90010802 <HAL_RCC_OscConfig+0x4e6>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
900107f0:	f7f8 fde8 	bl	900093c4 <HAL_GetTick>
900107f4:	4602      	mov	r2, r0
900107f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
900107f8:	1ad3      	subs	r3, r2, r3
900107fa:	2b02      	cmp	r3, #2
900107fc:	d901      	bls.n	90010802 <HAL_RCC_OscConfig+0x4e6>
        {
          return HAL_TIMEOUT;
900107fe:	2303      	movs	r3, #3
90010800:	e1b2      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
90010802:	4b0d      	ldr	r3, [pc, #52]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010804:	681b      	ldr	r3, [r3, #0]
90010806:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
9001080a:	2b00      	cmp	r3, #0
9001080c:	d0f0      	beq.n	900107f0 <HAL_RCC_OscConfig+0x4d4>
9001080e:	e01b      	b.n	90010848 <HAL_RCC_OscConfig+0x52c>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
90010810:	4b09      	ldr	r3, [pc, #36]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010812:	681b      	ldr	r3, [r3, #0]
90010814:	4a08      	ldr	r2, [pc, #32]	; (90010838 <HAL_RCC_OscConfig+0x51c>)
90010816:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
9001081a:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
9001081c:	f7f8 fdd2 	bl	900093c4 <HAL_GetTick>
90010820:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
90010822:	e00b      	b.n	9001083c <HAL_RCC_OscConfig+0x520>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
90010824:	f7f8 fdce 	bl	900093c4 <HAL_GetTick>
90010828:	4602      	mov	r2, r0
9001082a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9001082c:	1ad3      	subs	r3, r2, r3
9001082e:	2b02      	cmp	r3, #2
90010830:	d904      	bls.n	9001083c <HAL_RCC_OscConfig+0x520>
        {
          return HAL_TIMEOUT;
90010832:	2303      	movs	r3, #3
90010834:	e198      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
90010836:	bf00      	nop
90010838:	58024400 	.word	0x58024400
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
9001083c:	4ba3      	ldr	r3, [pc, #652]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
9001083e:	681b      	ldr	r3, [r3, #0]
90010840:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
90010844:	2b00      	cmp	r3, #0
90010846:	d1ed      	bne.n	90010824 <HAL_RCC_OscConfig+0x508>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
90010848:	687b      	ldr	r3, [r7, #4]
9001084a:	681b      	ldr	r3, [r3, #0]
9001084c:	f003 0304 	and.w	r3, r3, #4
90010850:	2b00      	cmp	r3, #0
90010852:	f000 8081 	beq.w	90010958 <HAL_RCC_OscConfig+0x63c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
90010856:	4b9e      	ldr	r3, [pc, #632]	; (90010ad0 <HAL_RCC_OscConfig+0x7b4>)
90010858:	681b      	ldr	r3, [r3, #0]
9001085a:	4a9d      	ldr	r2, [pc, #628]	; (90010ad0 <HAL_RCC_OscConfig+0x7b4>)
9001085c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
90010860:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
90010862:	f7f8 fdaf 	bl	900093c4 <HAL_GetTick>
90010866:	6278      	str	r0, [r7, #36]	; 0x24

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
90010868:	e008      	b.n	9001087c <HAL_RCC_OscConfig+0x560>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
9001086a:	f7f8 fdab 	bl	900093c4 <HAL_GetTick>
9001086e:	4602      	mov	r2, r0
90010870:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90010872:	1ad3      	subs	r3, r2, r3
90010874:	2b64      	cmp	r3, #100	; 0x64
90010876:	d901      	bls.n	9001087c <HAL_RCC_OscConfig+0x560>
      {
        return HAL_TIMEOUT;
90010878:	2303      	movs	r3, #3
9001087a:	e175      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
9001087c:	4b94      	ldr	r3, [pc, #592]	; (90010ad0 <HAL_RCC_OscConfig+0x7b4>)
9001087e:	681b      	ldr	r3, [r3, #0]
90010880:	f403 7380 	and.w	r3, r3, #256	; 0x100
90010884:	2b00      	cmp	r3, #0
90010886:	d0f0      	beq.n	9001086a <HAL_RCC_OscConfig+0x54e>
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
90010888:	687b      	ldr	r3, [r7, #4]
9001088a:	689b      	ldr	r3, [r3, #8]
9001088c:	2b01      	cmp	r3, #1
9001088e:	d106      	bne.n	9001089e <HAL_RCC_OscConfig+0x582>
90010890:	4b8e      	ldr	r3, [pc, #568]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010892:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90010894:	4a8d      	ldr	r2, [pc, #564]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010896:	f043 0301 	orr.w	r3, r3, #1
9001089a:	6713      	str	r3, [r2, #112]	; 0x70
9001089c:	e02d      	b.n	900108fa <HAL_RCC_OscConfig+0x5de>
9001089e:	687b      	ldr	r3, [r7, #4]
900108a0:	689b      	ldr	r3, [r3, #8]
900108a2:	2b00      	cmp	r3, #0
900108a4:	d10c      	bne.n	900108c0 <HAL_RCC_OscConfig+0x5a4>
900108a6:	4b89      	ldr	r3, [pc, #548]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900108aa:	4a88      	ldr	r2, [pc, #544]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108ac:	f023 0301 	bic.w	r3, r3, #1
900108b0:	6713      	str	r3, [r2, #112]	; 0x70
900108b2:	4b86      	ldr	r3, [pc, #536]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108b4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900108b6:	4a85      	ldr	r2, [pc, #532]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108b8:	f023 0304 	bic.w	r3, r3, #4
900108bc:	6713      	str	r3, [r2, #112]	; 0x70
900108be:	e01c      	b.n	900108fa <HAL_RCC_OscConfig+0x5de>
900108c0:	687b      	ldr	r3, [r7, #4]
900108c2:	689b      	ldr	r3, [r3, #8]
900108c4:	2b05      	cmp	r3, #5
900108c6:	d10c      	bne.n	900108e2 <HAL_RCC_OscConfig+0x5c6>
900108c8:	4b80      	ldr	r3, [pc, #512]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108ca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900108cc:	4a7f      	ldr	r2, [pc, #508]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108ce:	f043 0304 	orr.w	r3, r3, #4
900108d2:	6713      	str	r3, [r2, #112]	; 0x70
900108d4:	4b7d      	ldr	r3, [pc, #500]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900108d8:	4a7c      	ldr	r2, [pc, #496]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108da:	f043 0301 	orr.w	r3, r3, #1
900108de:	6713      	str	r3, [r2, #112]	; 0x70
900108e0:	e00b      	b.n	900108fa <HAL_RCC_OscConfig+0x5de>
900108e2:	4b7a      	ldr	r3, [pc, #488]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108e4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900108e6:	4a79      	ldr	r2, [pc, #484]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108e8:	f023 0301 	bic.w	r3, r3, #1
900108ec:	6713      	str	r3, [r2, #112]	; 0x70
900108ee:	4b77      	ldr	r3, [pc, #476]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900108f2:	4a76      	ldr	r2, [pc, #472]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900108f4:	f023 0304 	bic.w	r3, r3, #4
900108f8:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
900108fa:	687b      	ldr	r3, [r7, #4]
900108fc:	689b      	ldr	r3, [r3, #8]
900108fe:	2b00      	cmp	r3, #0
90010900:	d015      	beq.n	9001092e <HAL_RCC_OscConfig+0x612>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
90010902:	f7f8 fd5f 	bl	900093c4 <HAL_GetTick>
90010906:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
90010908:	e00a      	b.n	90010920 <HAL_RCC_OscConfig+0x604>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
9001090a:	f7f8 fd5b 	bl	900093c4 <HAL_GetTick>
9001090e:	4602      	mov	r2, r0
90010910:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90010912:	1ad3      	subs	r3, r2, r3
90010914:	f241 3288 	movw	r2, #5000	; 0x1388
90010918:	4293      	cmp	r3, r2
9001091a:	d901      	bls.n	90010920 <HAL_RCC_OscConfig+0x604>
        {
          return HAL_TIMEOUT;
9001091c:	2303      	movs	r3, #3
9001091e:	e123      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
90010920:	4b6a      	ldr	r3, [pc, #424]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010922:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90010924:	f003 0302 	and.w	r3, r3, #2
90010928:	2b00      	cmp	r3, #0
9001092a:	d0ee      	beq.n	9001090a <HAL_RCC_OscConfig+0x5ee>
9001092c:	e014      	b.n	90010958 <HAL_RCC_OscConfig+0x63c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
9001092e:	f7f8 fd49 	bl	900093c4 <HAL_GetTick>
90010932:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
90010934:	e00a      	b.n	9001094c <HAL_RCC_OscConfig+0x630>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
90010936:	f7f8 fd45 	bl	900093c4 <HAL_GetTick>
9001093a:	4602      	mov	r2, r0
9001093c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9001093e:	1ad3      	subs	r3, r2, r3
90010940:	f241 3288 	movw	r2, #5000	; 0x1388
90010944:	4293      	cmp	r3, r2
90010946:	d901      	bls.n	9001094c <HAL_RCC_OscConfig+0x630>
        {
          return HAL_TIMEOUT;
90010948:	2303      	movs	r3, #3
9001094a:	e10d      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
9001094c:	4b5f      	ldr	r3, [pc, #380]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
9001094e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90010950:	f003 0302 	and.w	r3, r3, #2
90010954:	2b00      	cmp	r3, #0
90010956:	d1ee      	bne.n	90010936 <HAL_RCC_OscConfig+0x61a>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
90010958:	687b      	ldr	r3, [r7, #4]
9001095a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9001095c:	2b00      	cmp	r3, #0
9001095e:	f000 8102 	beq.w	90010b66 <HAL_RCC_OscConfig+0x84a>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
90010962:	4b5a      	ldr	r3, [pc, #360]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010964:	691b      	ldr	r3, [r3, #16]
90010966:	f003 0338 	and.w	r3, r3, #56	; 0x38
9001096a:	2b18      	cmp	r3, #24
9001096c:	f000 80bd 	beq.w	90010aea <HAL_RCC_OscConfig+0x7ce>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
90010970:	687b      	ldr	r3, [r7, #4]
90010972:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90010974:	2b02      	cmp	r3, #2
90010976:	f040 8095 	bne.w	90010aa4 <HAL_RCC_OscConfig+0x788>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
9001097a:	4b54      	ldr	r3, [pc, #336]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
9001097c:	681b      	ldr	r3, [r3, #0]
9001097e:	4a53      	ldr	r2, [pc, #332]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010980:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
90010984:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90010986:	f7f8 fd1d 	bl	900093c4 <HAL_GetTick>
9001098a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
9001098c:	e008      	b.n	900109a0 <HAL_RCC_OscConfig+0x684>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
9001098e:	f7f8 fd19 	bl	900093c4 <HAL_GetTick>
90010992:	4602      	mov	r2, r0
90010994:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90010996:	1ad3      	subs	r3, r2, r3
90010998:	2b02      	cmp	r3, #2
9001099a:	d901      	bls.n	900109a0 <HAL_RCC_OscConfig+0x684>
          {
            return HAL_TIMEOUT;
9001099c:	2303      	movs	r3, #3
9001099e:	e0e3      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
900109a0:	4b4a      	ldr	r3, [pc, #296]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900109a2:	681b      	ldr	r3, [r3, #0]
900109a4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
900109a8:	2b00      	cmp	r3, #0
900109aa:	d1f0      	bne.n	9001098e <HAL_RCC_OscConfig+0x672>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
900109ac:	4b47      	ldr	r3, [pc, #284]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900109ae:	6a9a      	ldr	r2, [r3, #40]	; 0x28
900109b0:	4b48      	ldr	r3, [pc, #288]	; (90010ad4 <HAL_RCC_OscConfig+0x7b8>)
900109b2:	4013      	ands	r3, r2
900109b4:	687a      	ldr	r2, [r7, #4]
900109b6:	6a91      	ldr	r1, [r2, #40]	; 0x28
900109b8:	687a      	ldr	r2, [r7, #4]
900109ba:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
900109bc:	0112      	lsls	r2, r2, #4
900109be:	430a      	orrs	r2, r1
900109c0:	4942      	ldr	r1, [pc, #264]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900109c2:	4313      	orrs	r3, r2
900109c4:	628b      	str	r3, [r1, #40]	; 0x28
900109c6:	687b      	ldr	r3, [r7, #4]
900109c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900109ca:	3b01      	subs	r3, #1
900109cc:	f3c3 0208 	ubfx	r2, r3, #0, #9
900109d0:	687b      	ldr	r3, [r7, #4]
900109d2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900109d4:	3b01      	subs	r3, #1
900109d6:	025b      	lsls	r3, r3, #9
900109d8:	b29b      	uxth	r3, r3
900109da:	431a      	orrs	r2, r3
900109dc:	687b      	ldr	r3, [r7, #4]
900109de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
900109e0:	3b01      	subs	r3, #1
900109e2:	041b      	lsls	r3, r3, #16
900109e4:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
900109e8:	431a      	orrs	r2, r3
900109ea:	687b      	ldr	r3, [r7, #4]
900109ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
900109ee:	3b01      	subs	r3, #1
900109f0:	061b      	lsls	r3, r3, #24
900109f2:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
900109f6:	4935      	ldr	r1, [pc, #212]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900109f8:	4313      	orrs	r3, r2
900109fa:	630b      	str	r3, [r1, #48]	; 0x30
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();
900109fc:	4b33      	ldr	r3, [pc, #204]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
900109fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90010a00:	4a32      	ldr	r2, [pc, #200]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a02:	f023 0301 	bic.w	r3, r3, #1
90010a06:	62d3      	str	r3, [r2, #44]	; 0x2c

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
90010a08:	4b30      	ldr	r3, [pc, #192]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a0a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
90010a0c:	4b32      	ldr	r3, [pc, #200]	; (90010ad8 <HAL_RCC_OscConfig+0x7bc>)
90010a0e:	4013      	ands	r3, r2
90010a10:	687a      	ldr	r2, [r7, #4]
90010a12:	6c92      	ldr	r2, [r2, #72]	; 0x48
90010a14:	00d2      	lsls	r2, r2, #3
90010a16:	492d      	ldr	r1, [pc, #180]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a18:	4313      	orrs	r3, r2
90010a1a:	634b      	str	r3, [r1, #52]	; 0x34

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
90010a1c:	4b2b      	ldr	r3, [pc, #172]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a1e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90010a20:	f023 020c 	bic.w	r2, r3, #12
90010a24:	687b      	ldr	r3, [r7, #4]
90010a26:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90010a28:	4928      	ldr	r1, [pc, #160]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a2a:	4313      	orrs	r3, r2
90010a2c:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
90010a2e:	4b27      	ldr	r3, [pc, #156]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a30:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90010a32:	f023 0202 	bic.w	r2, r3, #2
90010a36:	687b      	ldr	r3, [r7, #4]
90010a38:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90010a3a:	4924      	ldr	r1, [pc, #144]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a3c:	4313      	orrs	r3, r2
90010a3e:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
90010a40:	4b22      	ldr	r3, [pc, #136]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a42:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90010a44:	4a21      	ldr	r2, [pc, #132]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a46:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
90010a4a:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1Q Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90010a4c:	4b1f      	ldr	r3, [pc, #124]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90010a50:	4a1e      	ldr	r2, [pc, #120]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a52:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90010a56:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1R  Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
90010a58:	4b1c      	ldr	r3, [pc, #112]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90010a5c:	4a1b      	ldr	r2, [pc, #108]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a5e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
90010a62:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1FRACN . */
         __HAL_RCC_PLLFRACN_ENABLE();
90010a64:	4b19      	ldr	r3, [pc, #100]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90010a68:	4a18      	ldr	r2, [pc, #96]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a6a:	f043 0301 	orr.w	r3, r3, #1
90010a6e:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
90010a70:	4b16      	ldr	r3, [pc, #88]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a72:	681b      	ldr	r3, [r3, #0]
90010a74:	4a15      	ldr	r2, [pc, #84]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a76:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
90010a7a:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90010a7c:	f7f8 fca2 	bl	900093c4 <HAL_GetTick>
90010a80:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
90010a82:	e008      	b.n	90010a96 <HAL_RCC_OscConfig+0x77a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
90010a84:	f7f8 fc9e 	bl	900093c4 <HAL_GetTick>
90010a88:	4602      	mov	r2, r0
90010a8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90010a8c:	1ad3      	subs	r3, r2, r3
90010a8e:	2b02      	cmp	r3, #2
90010a90:	d901      	bls.n	90010a96 <HAL_RCC_OscConfig+0x77a>
          {
            return HAL_TIMEOUT;
90010a92:	2303      	movs	r3, #3
90010a94:	e068      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
90010a96:	4b0d      	ldr	r3, [pc, #52]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010a98:	681b      	ldr	r3, [r3, #0]
90010a9a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90010a9e:	2b00      	cmp	r3, #0
90010aa0:	d0f0      	beq.n	90010a84 <HAL_RCC_OscConfig+0x768>
90010aa2:	e060      	b.n	90010b66 <HAL_RCC_OscConfig+0x84a>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
90010aa4:	4b09      	ldr	r3, [pc, #36]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010aa6:	681b      	ldr	r3, [r3, #0]
90010aa8:	4a08      	ldr	r2, [pc, #32]	; (90010acc <HAL_RCC_OscConfig+0x7b0>)
90010aaa:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
90010aae:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
90010ab0:	f7f8 fc88 	bl	900093c4 <HAL_GetTick>
90010ab4:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
90010ab6:	e011      	b.n	90010adc <HAL_RCC_OscConfig+0x7c0>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
90010ab8:	f7f8 fc84 	bl	900093c4 <HAL_GetTick>
90010abc:	4602      	mov	r2, r0
90010abe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90010ac0:	1ad3      	subs	r3, r2, r3
90010ac2:	2b02      	cmp	r3, #2
90010ac4:	d90a      	bls.n	90010adc <HAL_RCC_OscConfig+0x7c0>
          {
            return HAL_TIMEOUT;
90010ac6:	2303      	movs	r3, #3
90010ac8:	e04e      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
90010aca:	bf00      	nop
90010acc:	58024400 	.word	0x58024400
90010ad0:	58024800 	.word	0x58024800
90010ad4:	fffffc0c 	.word	0xfffffc0c
90010ad8:	ffff0007 	.word	0xffff0007
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
90010adc:	4b24      	ldr	r3, [pc, #144]	; (90010b70 <HAL_RCC_OscConfig+0x854>)
90010ade:	681b      	ldr	r3, [r3, #0]
90010ae0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90010ae4:	2b00      	cmp	r3, #0
90010ae6:	d1e7      	bne.n	90010ab8 <HAL_RCC_OscConfig+0x79c>
90010ae8:	e03d      	b.n	90010b66 <HAL_RCC_OscConfig+0x84a>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLLCKSELR;
90010aea:	4b21      	ldr	r3, [pc, #132]	; (90010b70 <HAL_RCC_OscConfig+0x854>)
90010aec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90010aee:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
90010af0:	4b1f      	ldr	r3, [pc, #124]	; (90010b70 <HAL_RCC_OscConfig+0x854>)
90010af2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90010af4:	60fb      	str	r3, [r7, #12]
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
90010af6:	687b      	ldr	r3, [r7, #4]
90010af8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90010afa:	2b01      	cmp	r3, #1
90010afc:	d031      	beq.n	90010b62 <HAL_RCC_OscConfig+0x846>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
90010afe:	693b      	ldr	r3, [r7, #16]
90010b00:	f003 0203 	and.w	r2, r3, #3
90010b04:	687b      	ldr	r3, [r7, #4]
90010b06:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
90010b08:	429a      	cmp	r2, r3
90010b0a:	d12a      	bne.n	90010b62 <HAL_RCC_OscConfig+0x846>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
90010b0c:	693b      	ldr	r3, [r7, #16]
90010b0e:	091b      	lsrs	r3, r3, #4
90010b10:	f003 023f 	and.w	r2, r3, #63	; 0x3f
90010b14:	687b      	ldr	r3, [r7, #4]
90010b16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
90010b18:	429a      	cmp	r2, r3
90010b1a:	d122      	bne.n	90010b62 <HAL_RCC_OscConfig+0x846>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
90010b1c:	68fb      	ldr	r3, [r7, #12]
90010b1e:	f3c3 0208 	ubfx	r2, r3, #0, #9
90010b22:	687b      	ldr	r3, [r7, #4]
90010b24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90010b26:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
90010b28:	429a      	cmp	r2, r3
90010b2a:	d11a      	bne.n	90010b62 <HAL_RCC_OscConfig+0x846>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
90010b2c:	68fb      	ldr	r3, [r7, #12]
90010b2e:	0a5b      	lsrs	r3, r3, #9
90010b30:	f003 027f 	and.w	r2, r3, #127	; 0x7f
90010b34:	687b      	ldr	r3, [r7, #4]
90010b36:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90010b38:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
90010b3a:	429a      	cmp	r2, r3
90010b3c:	d111      	bne.n	90010b62 <HAL_RCC_OscConfig+0x846>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
90010b3e:	68fb      	ldr	r3, [r7, #12]
90010b40:	0c1b      	lsrs	r3, r3, #16
90010b42:	f003 027f 	and.w	r2, r3, #127	; 0x7f
90010b46:	687b      	ldr	r3, [r7, #4]
90010b48:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90010b4a:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
90010b4c:	429a      	cmp	r2, r3
90010b4e:	d108      	bne.n	90010b62 <HAL_RCC_OscConfig+0x846>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
90010b50:	68fb      	ldr	r3, [r7, #12]
90010b52:	0e1b      	lsrs	r3, r3, #24
90010b54:	f003 027f 	and.w	r2, r3, #127	; 0x7f
90010b58:	687b      	ldr	r3, [r7, #4]
90010b5a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
90010b5c:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
90010b5e:	429a      	cmp	r2, r3
90010b60:	d001      	beq.n	90010b66 <HAL_RCC_OscConfig+0x84a>
      {
        return HAL_ERROR;
90010b62:	2301      	movs	r3, #1
90010b64:	e000      	b.n	90010b68 <HAL_RCC_OscConfig+0x84c>
      }
    }
  }
  return HAL_OK;
90010b66:	2300      	movs	r3, #0
}
90010b68:	4618      	mov	r0, r3
90010b6a:	3730      	adds	r7, #48	; 0x30
90010b6c:	46bd      	mov	sp, r7
90010b6e:	bd80      	pop	{r7, pc}
90010b70:	58024400 	.word	0x58024400

90010b74 <HAL_RCC_ClockConfig>:
  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
90010b74:	b580      	push	{r7, lr}
90010b76:	b086      	sub	sp, #24
90010b78:	af00      	add	r7, sp, #0
90010b7a:	6078      	str	r0, [r7, #4]
90010b7c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;
  uint32_t common_system_clock;

   /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
90010b7e:	687b      	ldr	r3, [r7, #4]
90010b80:	2b00      	cmp	r3, #0
90010b82:	d101      	bne.n	90010b88 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
90010b84:	2301      	movs	r3, #1
90010b86:	e19c      	b.n	90010ec2 <HAL_RCC_ClockConfig+0x34e>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
90010b88:	4b8a      	ldr	r3, [pc, #552]	; (90010db4 <HAL_RCC_ClockConfig+0x240>)
90010b8a:	681b      	ldr	r3, [r3, #0]
90010b8c:	f003 030f 	and.w	r3, r3, #15
90010b90:	683a      	ldr	r2, [r7, #0]
90010b92:	429a      	cmp	r2, r3
90010b94:	d910      	bls.n	90010bb8 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
90010b96:	4b87      	ldr	r3, [pc, #540]	; (90010db4 <HAL_RCC_ClockConfig+0x240>)
90010b98:	681b      	ldr	r3, [r3, #0]
90010b9a:	f023 020f 	bic.w	r2, r3, #15
90010b9e:	4985      	ldr	r1, [pc, #532]	; (90010db4 <HAL_RCC_ClockConfig+0x240>)
90010ba0:	683b      	ldr	r3, [r7, #0]
90010ba2:	4313      	orrs	r3, r2
90010ba4:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
90010ba6:	4b83      	ldr	r3, [pc, #524]	; (90010db4 <HAL_RCC_ClockConfig+0x240>)
90010ba8:	681b      	ldr	r3, [r3, #0]
90010baa:	f003 030f 	and.w	r3, r3, #15
90010bae:	683a      	ldr	r2, [r7, #0]
90010bb0:	429a      	cmp	r2, r3
90010bb2:	d001      	beq.n	90010bb8 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
90010bb4:	2301      	movs	r3, #1
90010bb6:	e184      	b.n	90010ec2 <HAL_RCC_ClockConfig+0x34e>

  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
90010bb8:	687b      	ldr	r3, [r7, #4]
90010bba:	681b      	ldr	r3, [r3, #0]
90010bbc:	f003 0304 	and.w	r3, r3, #4
90010bc0:	2b00      	cmp	r3, #0
90010bc2:	d010      	beq.n	90010be6 <HAL_RCC_ClockConfig+0x72>
  {
#if defined (RCC_D1CFGR_D1PPRE)
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
90010bc4:	687b      	ldr	r3, [r7, #4]
90010bc6:	691a      	ldr	r2, [r3, #16]
90010bc8:	4b7b      	ldr	r3, [pc, #492]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010bca:	699b      	ldr	r3, [r3, #24]
90010bcc:	f003 0370 	and.w	r3, r3, #112	; 0x70
90010bd0:	429a      	cmp	r2, r3
90010bd2:	d908      	bls.n	90010be6 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
90010bd4:	4b78      	ldr	r3, [pc, #480]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010bd6:	699b      	ldr	r3, [r3, #24]
90010bd8:	f023 0270 	bic.w	r2, r3, #112	; 0x70
90010bdc:	687b      	ldr	r3, [r7, #4]
90010bde:	691b      	ldr	r3, [r3, #16]
90010be0:	4975      	ldr	r1, [pc, #468]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010be2:	4313      	orrs	r3, r2
90010be4:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
90010be6:	687b      	ldr	r3, [r7, #4]
90010be8:	681b      	ldr	r3, [r3, #0]
90010bea:	f003 0308 	and.w	r3, r3, #8
90010bee:	2b00      	cmp	r3, #0
90010bf0:	d010      	beq.n	90010c14 <HAL_RCC_ClockConfig+0xa0>
  {
#if defined (RCC_D2CFGR_D2PPRE1)
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
90010bf2:	687b      	ldr	r3, [r7, #4]
90010bf4:	695a      	ldr	r2, [r3, #20]
90010bf6:	4b70      	ldr	r3, [pc, #448]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010bf8:	69db      	ldr	r3, [r3, #28]
90010bfa:	f003 0370 	and.w	r3, r3, #112	; 0x70
90010bfe:	429a      	cmp	r2, r3
90010c00:	d908      	bls.n	90010c14 <HAL_RCC_ClockConfig+0xa0>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
90010c02:	4b6d      	ldr	r3, [pc, #436]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c04:	69db      	ldr	r3, [r3, #28]
90010c06:	f023 0270 	bic.w	r2, r3, #112	; 0x70
90010c0a:	687b      	ldr	r3, [r7, #4]
90010c0c:	695b      	ldr	r3, [r3, #20]
90010c0e:	496a      	ldr	r1, [pc, #424]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c10:	4313      	orrs	r3, r2
90010c12:	61cb      	str	r3, [r1, #28]
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
  }
#endif
    }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
90010c14:	687b      	ldr	r3, [r7, #4]
90010c16:	681b      	ldr	r3, [r3, #0]
90010c18:	f003 0310 	and.w	r3, r3, #16
90010c1c:	2b00      	cmp	r3, #0
90010c1e:	d010      	beq.n	90010c42 <HAL_RCC_ClockConfig+0xce>
  {
#if defined(RCC_D2CFGR_D2PPRE2)
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
90010c20:	687b      	ldr	r3, [r7, #4]
90010c22:	699a      	ldr	r2, [r3, #24]
90010c24:	4b64      	ldr	r3, [pc, #400]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c26:	69db      	ldr	r3, [r3, #28]
90010c28:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
90010c2c:	429a      	cmp	r2, r3
90010c2e:	d908      	bls.n	90010c42 <HAL_RCC_ClockConfig+0xce>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
90010c30:	4b61      	ldr	r3, [pc, #388]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c32:	69db      	ldr	r3, [r3, #28]
90010c34:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
90010c38:	687b      	ldr	r3, [r7, #4]
90010c3a:	699b      	ldr	r3, [r3, #24]
90010c3c:	495e      	ldr	r1, [pc, #376]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c3e:	4313      	orrs	r3, r2
90010c40:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
90010c42:	687b      	ldr	r3, [r7, #4]
90010c44:	681b      	ldr	r3, [r3, #0]
90010c46:	f003 0320 	and.w	r3, r3, #32
90010c4a:	2b00      	cmp	r3, #0
90010c4c:	d010      	beq.n	90010c70 <HAL_RCC_ClockConfig+0xfc>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
90010c4e:	687b      	ldr	r3, [r7, #4]
90010c50:	69da      	ldr	r2, [r3, #28]
90010c52:	4b59      	ldr	r3, [pc, #356]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c54:	6a1b      	ldr	r3, [r3, #32]
90010c56:	f003 0370 	and.w	r3, r3, #112	; 0x70
90010c5a:	429a      	cmp	r2, r3
90010c5c:	d908      	bls.n	90010c70 <HAL_RCC_ClockConfig+0xfc>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
90010c5e:	4b56      	ldr	r3, [pc, #344]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c60:	6a1b      	ldr	r3, [r3, #32]
90010c62:	f023 0270 	bic.w	r2, r3, #112	; 0x70
90010c66:	687b      	ldr	r3, [r7, #4]
90010c68:	69db      	ldr	r3, [r3, #28]
90010c6a:	4953      	ldr	r1, [pc, #332]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c6c:	4313      	orrs	r3, r2
90010c6e:	620b      	str	r3, [r1, #32]
    }
#endif
  }

   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
90010c70:	687b      	ldr	r3, [r7, #4]
90010c72:	681b      	ldr	r3, [r3, #0]
90010c74:	f003 0302 	and.w	r3, r3, #2
90010c78:	2b00      	cmp	r3, #0
90010c7a:	d010      	beq.n	90010c9e <HAL_RCC_ClockConfig+0x12a>
  {
#if defined (RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
90010c7c:	687b      	ldr	r3, [r7, #4]
90010c7e:	68da      	ldr	r2, [r3, #12]
90010c80:	4b4d      	ldr	r3, [pc, #308]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c82:	699b      	ldr	r3, [r3, #24]
90010c84:	f003 030f 	and.w	r3, r3, #15
90010c88:	429a      	cmp	r2, r3
90010c8a:	d908      	bls.n	90010c9e <HAL_RCC_ClockConfig+0x12a>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
90010c8c:	4b4a      	ldr	r3, [pc, #296]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c8e:	699b      	ldr	r3, [r3, #24]
90010c90:	f023 020f 	bic.w	r2, r3, #15
90010c94:	687b      	ldr	r3, [r7, #4]
90010c96:	68db      	ldr	r3, [r3, #12]
90010c98:	4947      	ldr	r1, [pc, #284]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010c9a:	4313      	orrs	r3, r2
90010c9c:	618b      	str	r3, [r1, #24]
    }
#endif
  }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
90010c9e:	687b      	ldr	r3, [r7, #4]
90010ca0:	681b      	ldr	r3, [r3, #0]
90010ca2:	f003 0301 	and.w	r3, r3, #1
90010ca6:	2b00      	cmp	r3, #0
90010ca8:	d055      	beq.n	90010d56 <HAL_RCC_ClockConfig+0x1e2>
    {
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
#if defined(RCC_D1CFGR_D1CPRE)
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
90010caa:	4b43      	ldr	r3, [pc, #268]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010cac:	699b      	ldr	r3, [r3, #24]
90010cae:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
90010cb2:	687b      	ldr	r3, [r7, #4]
90010cb4:	689b      	ldr	r3, [r3, #8]
90010cb6:	4940      	ldr	r1, [pc, #256]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010cb8:	4313      	orrs	r3, r2
90010cba:	618b      	str	r3, [r1, #24]
#else
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
#endif
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
90010cbc:	687b      	ldr	r3, [r7, #4]
90010cbe:	685b      	ldr	r3, [r3, #4]
90010cc0:	2b02      	cmp	r3, #2
90010cc2:	d107      	bne.n	90010cd4 <HAL_RCC_ClockConfig+0x160>
      {
        /* Check the HSE ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
90010cc4:	4b3c      	ldr	r3, [pc, #240]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010cc6:	681b      	ldr	r3, [r3, #0]
90010cc8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90010ccc:	2b00      	cmp	r3, #0
90010cce:	d121      	bne.n	90010d14 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
90010cd0:	2301      	movs	r3, #1
90010cd2:	e0f6      	b.n	90010ec2 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
90010cd4:	687b      	ldr	r3, [r7, #4]
90010cd6:	685b      	ldr	r3, [r3, #4]
90010cd8:	2b03      	cmp	r3, #3
90010cda:	d107      	bne.n	90010cec <HAL_RCC_ClockConfig+0x178>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
90010cdc:	4b36      	ldr	r3, [pc, #216]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010cde:	681b      	ldr	r3, [r3, #0]
90010ce0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90010ce4:	2b00      	cmp	r3, #0
90010ce6:	d115      	bne.n	90010d14 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
90010ce8:	2301      	movs	r3, #1
90010cea:	e0ea      	b.n	90010ec2 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* CSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
90010cec:	687b      	ldr	r3, [r7, #4]
90010cee:	685b      	ldr	r3, [r3, #4]
90010cf0:	2b01      	cmp	r3, #1
90010cf2:	d107      	bne.n	90010d04 <HAL_RCC_ClockConfig+0x190>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
90010cf4:	4b30      	ldr	r3, [pc, #192]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010cf6:	681b      	ldr	r3, [r3, #0]
90010cf8:	f403 7380 	and.w	r3, r3, #256	; 0x100
90010cfc:	2b00      	cmp	r3, #0
90010cfe:	d109      	bne.n	90010d14 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
90010d00:	2301      	movs	r3, #1
90010d02:	e0de      	b.n	90010ec2 <HAL_RCC_ClockConfig+0x34e>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
90010d04:	4b2c      	ldr	r3, [pc, #176]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010d06:	681b      	ldr	r3, [r3, #0]
90010d08:	f003 0304 	and.w	r3, r3, #4
90010d0c:	2b00      	cmp	r3, #0
90010d0e:	d101      	bne.n	90010d14 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
90010d10:	2301      	movs	r3, #1
90010d12:	e0d6      	b.n	90010ec2 <HAL_RCC_ClockConfig+0x34e>
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
90010d14:	4b28      	ldr	r3, [pc, #160]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010d16:	691b      	ldr	r3, [r3, #16]
90010d18:	f023 0207 	bic.w	r2, r3, #7
90010d1c:	687b      	ldr	r3, [r7, #4]
90010d1e:	685b      	ldr	r3, [r3, #4]
90010d20:	4925      	ldr	r1, [pc, #148]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010d22:	4313      	orrs	r3, r2
90010d24:	610b      	str	r3, [r1, #16]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
90010d26:	f7f8 fb4d 	bl	900093c4 <HAL_GetTick>
90010d2a:	6178      	str	r0, [r7, #20]

        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
90010d2c:	e00a      	b.n	90010d44 <HAL_RCC_ClockConfig+0x1d0>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
90010d2e:	f7f8 fb49 	bl	900093c4 <HAL_GetTick>
90010d32:	4602      	mov	r2, r0
90010d34:	697b      	ldr	r3, [r7, #20]
90010d36:	1ad3      	subs	r3, r2, r3
90010d38:	f241 3288 	movw	r2, #5000	; 0x1388
90010d3c:	4293      	cmp	r3, r2
90010d3e:	d901      	bls.n	90010d44 <HAL_RCC_ClockConfig+0x1d0>
          {
            return HAL_TIMEOUT;
90010d40:	2303      	movs	r3, #3
90010d42:	e0be      	b.n	90010ec2 <HAL_RCC_ClockConfig+0x34e>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
90010d44:	4b1c      	ldr	r3, [pc, #112]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010d46:	691b      	ldr	r3, [r3, #16]
90010d48:	f003 0238 	and.w	r2, r3, #56	; 0x38
90010d4c:	687b      	ldr	r3, [r7, #4]
90010d4e:	685b      	ldr	r3, [r3, #4]
90010d50:	00db      	lsls	r3, r3, #3
90010d52:	429a      	cmp	r2, r3
90010d54:	d1eb      	bne.n	90010d2e <HAL_RCC_ClockConfig+0x1ba>

    }

    /* Decreasing the BUS frequency divider */
   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
90010d56:	687b      	ldr	r3, [r7, #4]
90010d58:	681b      	ldr	r3, [r3, #0]
90010d5a:	f003 0302 	and.w	r3, r3, #2
90010d5e:	2b00      	cmp	r3, #0
90010d60:	d010      	beq.n	90010d84 <HAL_RCC_ClockConfig+0x210>
  {
#if defined(RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
90010d62:	687b      	ldr	r3, [r7, #4]
90010d64:	68da      	ldr	r2, [r3, #12]
90010d66:	4b14      	ldr	r3, [pc, #80]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010d68:	699b      	ldr	r3, [r3, #24]
90010d6a:	f003 030f 	and.w	r3, r3, #15
90010d6e:	429a      	cmp	r2, r3
90010d70:	d208      	bcs.n	90010d84 <HAL_RCC_ClockConfig+0x210>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
90010d72:	4b11      	ldr	r3, [pc, #68]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010d74:	699b      	ldr	r3, [r3, #24]
90010d76:	f023 020f 	bic.w	r2, r3, #15
90010d7a:	687b      	ldr	r3, [r7, #4]
90010d7c:	68db      	ldr	r3, [r3, #12]
90010d7e:	490e      	ldr	r1, [pc, #56]	; (90010db8 <HAL_RCC_ClockConfig+0x244>)
90010d80:	4313      	orrs	r3, r2
90010d82:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
90010d84:	4b0b      	ldr	r3, [pc, #44]	; (90010db4 <HAL_RCC_ClockConfig+0x240>)
90010d86:	681b      	ldr	r3, [r3, #0]
90010d88:	f003 030f 	and.w	r3, r3, #15
90010d8c:	683a      	ldr	r2, [r7, #0]
90010d8e:	429a      	cmp	r2, r3
90010d90:	d214      	bcs.n	90010dbc <HAL_RCC_ClockConfig+0x248>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
90010d92:	4b08      	ldr	r3, [pc, #32]	; (90010db4 <HAL_RCC_ClockConfig+0x240>)
90010d94:	681b      	ldr	r3, [r3, #0]
90010d96:	f023 020f 	bic.w	r2, r3, #15
90010d9a:	4906      	ldr	r1, [pc, #24]	; (90010db4 <HAL_RCC_ClockConfig+0x240>)
90010d9c:	683b      	ldr	r3, [r7, #0]
90010d9e:	4313      	orrs	r3, r2
90010da0:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
90010da2:	4b04      	ldr	r3, [pc, #16]	; (90010db4 <HAL_RCC_ClockConfig+0x240>)
90010da4:	681b      	ldr	r3, [r3, #0]
90010da6:	f003 030f 	and.w	r3, r3, #15
90010daa:	683a      	ldr	r2, [r7, #0]
90010dac:	429a      	cmp	r2, r3
90010dae:	d005      	beq.n	90010dbc <HAL_RCC_ClockConfig+0x248>
    {
      return HAL_ERROR;
90010db0:	2301      	movs	r3, #1
90010db2:	e086      	b.n	90010ec2 <HAL_RCC_ClockConfig+0x34e>
90010db4:	52002000 	.word	0x52002000
90010db8:	58024400 	.word	0x58024400
    }
 }

  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
90010dbc:	687b      	ldr	r3, [r7, #4]
90010dbe:	681b      	ldr	r3, [r3, #0]
90010dc0:	f003 0304 	and.w	r3, r3, #4
90010dc4:	2b00      	cmp	r3, #0
90010dc6:	d010      	beq.n	90010dea <HAL_RCC_ClockConfig+0x276>
 {
#if defined(RCC_D1CFGR_D1PPRE)
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
90010dc8:	687b      	ldr	r3, [r7, #4]
90010dca:	691a      	ldr	r2, [r3, #16]
90010dcc:	4b3f      	ldr	r3, [pc, #252]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010dce:	699b      	ldr	r3, [r3, #24]
90010dd0:	f003 0370 	and.w	r3, r3, #112	; 0x70
90010dd4:	429a      	cmp	r2, r3
90010dd6:	d208      	bcs.n	90010dea <HAL_RCC_ClockConfig+0x276>
   {
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
90010dd8:	4b3c      	ldr	r3, [pc, #240]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010dda:	699b      	ldr	r3, [r3, #24]
90010ddc:	f023 0270 	bic.w	r2, r3, #112	; 0x70
90010de0:	687b      	ldr	r3, [r7, #4]
90010de2:	691b      	ldr	r3, [r3, #16]
90010de4:	4939      	ldr	r1, [pc, #228]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010de6:	4313      	orrs	r3, r2
90010de8:	618b      	str	r3, [r1, #24]
   }
#endif
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
90010dea:	687b      	ldr	r3, [r7, #4]
90010dec:	681b      	ldr	r3, [r3, #0]
90010dee:	f003 0308 	and.w	r3, r3, #8
90010df2:	2b00      	cmp	r3, #0
90010df4:	d010      	beq.n	90010e18 <HAL_RCC_ClockConfig+0x2a4>
 {
#if defined(RCC_D2CFGR_D2PPRE1)
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
90010df6:	687b      	ldr	r3, [r7, #4]
90010df8:	695a      	ldr	r2, [r3, #20]
90010dfa:	4b34      	ldr	r3, [pc, #208]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010dfc:	69db      	ldr	r3, [r3, #28]
90010dfe:	f003 0370 	and.w	r3, r3, #112	; 0x70
90010e02:	429a      	cmp	r2, r3
90010e04:	d208      	bcs.n	90010e18 <HAL_RCC_ClockConfig+0x2a4>
   {
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
90010e06:	4b31      	ldr	r3, [pc, #196]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010e08:	69db      	ldr	r3, [r3, #28]
90010e0a:	f023 0270 	bic.w	r2, r3, #112	; 0x70
90010e0e:	687b      	ldr	r3, [r7, #4]
90010e10:	695b      	ldr	r3, [r3, #20]
90010e12:	492e      	ldr	r1, [pc, #184]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010e14:	4313      	orrs	r3, r2
90010e16:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
90010e18:	687b      	ldr	r3, [r7, #4]
90010e1a:	681b      	ldr	r3, [r3, #0]
90010e1c:	f003 0310 	and.w	r3, r3, #16
90010e20:	2b00      	cmp	r3, #0
90010e22:	d010      	beq.n	90010e46 <HAL_RCC_ClockConfig+0x2d2>
 {
#if defined (RCC_D2CFGR_D2PPRE2)
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
90010e24:	687b      	ldr	r3, [r7, #4]
90010e26:	699a      	ldr	r2, [r3, #24]
90010e28:	4b28      	ldr	r3, [pc, #160]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010e2a:	69db      	ldr	r3, [r3, #28]
90010e2c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
90010e30:	429a      	cmp	r2, r3
90010e32:	d208      	bcs.n	90010e46 <HAL_RCC_ClockConfig+0x2d2>
   {
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
90010e34:	4b25      	ldr	r3, [pc, #148]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010e36:	69db      	ldr	r3, [r3, #28]
90010e38:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
90010e3c:	687b      	ldr	r3, [r7, #4]
90010e3e:	699b      	ldr	r3, [r3, #24]
90010e40:	4922      	ldr	r1, [pc, #136]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010e42:	4313      	orrs	r3, r2
90010e44:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
90010e46:	687b      	ldr	r3, [r7, #4]
90010e48:	681b      	ldr	r3, [r3, #0]
90010e4a:	f003 0320 	and.w	r3, r3, #32
90010e4e:	2b00      	cmp	r3, #0
90010e50:	d010      	beq.n	90010e74 <HAL_RCC_ClockConfig+0x300>
 {
#if defined(RCC_D3CFGR_D3PPRE)
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
90010e52:	687b      	ldr	r3, [r7, #4]
90010e54:	69da      	ldr	r2, [r3, #28]
90010e56:	4b1d      	ldr	r3, [pc, #116]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010e58:	6a1b      	ldr	r3, [r3, #32]
90010e5a:	f003 0370 	and.w	r3, r3, #112	; 0x70
90010e5e:	429a      	cmp	r2, r3
90010e60:	d208      	bcs.n	90010e74 <HAL_RCC_ClockConfig+0x300>
   {
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
90010e62:	4b1a      	ldr	r3, [pc, #104]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010e64:	6a1b      	ldr	r3, [r3, #32]
90010e66:	f023 0270 	bic.w	r2, r3, #112	; 0x70
90010e6a:	687b      	ldr	r3, [r7, #4]
90010e6c:	69db      	ldr	r3, [r3, #28]
90010e6e:	4917      	ldr	r1, [pc, #92]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010e70:	4313      	orrs	r3, r2
90010e72:	620b      	str	r3, [r1, #32]
#endif
 }

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
90010e74:	f000 f834 	bl	90010ee0 <HAL_RCC_GetSysClockFreq>
90010e78:	4602      	mov	r2, r0
90010e7a:	4b14      	ldr	r3, [pc, #80]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010e7c:	699b      	ldr	r3, [r3, #24]
90010e7e:	0a1b      	lsrs	r3, r3, #8
90010e80:	f003 030f 	and.w	r3, r3, #15
90010e84:	4912      	ldr	r1, [pc, #72]	; (90010ed0 <HAL_RCC_ClockConfig+0x35c>)
90010e86:	5ccb      	ldrb	r3, [r1, r3]
90010e88:	f003 031f 	and.w	r3, r3, #31
90010e8c:	fa22 f303 	lsr.w	r3, r2, r3
90010e90:	613b      	str	r3, [r7, #16]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
90010e92:	4b0e      	ldr	r3, [pc, #56]	; (90010ecc <HAL_RCC_ClockConfig+0x358>)
90010e94:	699b      	ldr	r3, [r3, #24]
90010e96:	f003 030f 	and.w	r3, r3, #15
90010e9a:	4a0d      	ldr	r2, [pc, #52]	; (90010ed0 <HAL_RCC_ClockConfig+0x35c>)
90010e9c:	5cd3      	ldrb	r3, [r2, r3]
90010e9e:	f003 031f 	and.w	r3, r3, #31
90010ea2:	693a      	ldr	r2, [r7, #16]
90010ea4:	fa22 f303 	lsr.w	r3, r2, r3
90010ea8:	4a0a      	ldr	r2, [pc, #40]	; (90010ed4 <HAL_RCC_ClockConfig+0x360>)
90010eaa:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
90010eac:	4a0a      	ldr	r2, [pc, #40]	; (90010ed8 <HAL_RCC_ClockConfig+0x364>)
90010eae:	693b      	ldr	r3, [r7, #16]
90010eb0:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick (uwTickPrio);
90010eb2:	4b0a      	ldr	r3, [pc, #40]	; (90010edc <HAL_RCC_ClockConfig+0x368>)
90010eb4:	681b      	ldr	r3, [r3, #0]
90010eb6:	4618      	mov	r0, r3
90010eb8:	f7f8 fa3a 	bl	90009330 <HAL_InitTick>
90010ebc:	4603      	mov	r3, r0
90010ebe:	73fb      	strb	r3, [r7, #15]

  return halstatus;
90010ec0:	7bfb      	ldrb	r3, [r7, #15]
}
90010ec2:	4618      	mov	r0, r3
90010ec4:	3718      	adds	r7, #24
90010ec6:	46bd      	mov	sp, r7
90010ec8:	bd80      	pop	{r7, pc}
90010eca:	bf00      	nop
90010ecc:	58024400 	.word	0x58024400
90010ed0:	9001e8a8 	.word	0x9001e8a8
90010ed4:	24000094 	.word	0x24000094
90010ed8:	24000090 	.word	0x24000090
90010edc:	24000098 	.word	0x24000098

90010ee0 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
90010ee0:	b480      	push	{r7}
90010ee2:	b089      	sub	sp, #36	; 0x24
90010ee4:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
90010ee6:	4bb3      	ldr	r3, [pc, #716]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
90010ee8:	691b      	ldr	r3, [r3, #16]
90010eea:	f003 0338 	and.w	r3, r3, #56	; 0x38
90010eee:	2b18      	cmp	r3, #24
90010ef0:	f200 8155 	bhi.w	9001119e <HAL_RCC_GetSysClockFreq+0x2be>
90010ef4:	a201      	add	r2, pc, #4	; (adr r2, 90010efc <HAL_RCC_GetSysClockFreq+0x1c>)
90010ef6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90010efa:	bf00      	nop
90010efc:	90010f61 	.word	0x90010f61
90010f00:	9001119f 	.word	0x9001119f
90010f04:	9001119f 	.word	0x9001119f
90010f08:	9001119f 	.word	0x9001119f
90010f0c:	9001119f 	.word	0x9001119f
90010f10:	9001119f 	.word	0x9001119f
90010f14:	9001119f 	.word	0x9001119f
90010f18:	9001119f 	.word	0x9001119f
90010f1c:	90010f87 	.word	0x90010f87
90010f20:	9001119f 	.word	0x9001119f
90010f24:	9001119f 	.word	0x9001119f
90010f28:	9001119f 	.word	0x9001119f
90010f2c:	9001119f 	.word	0x9001119f
90010f30:	9001119f 	.word	0x9001119f
90010f34:	9001119f 	.word	0x9001119f
90010f38:	9001119f 	.word	0x9001119f
90010f3c:	90010f8d 	.word	0x90010f8d
90010f40:	9001119f 	.word	0x9001119f
90010f44:	9001119f 	.word	0x9001119f
90010f48:	9001119f 	.word	0x9001119f
90010f4c:	9001119f 	.word	0x9001119f
90010f50:	9001119f 	.word	0x9001119f
90010f54:	9001119f 	.word	0x9001119f
90010f58:	9001119f 	.word	0x9001119f
90010f5c:	90010f93 	.word	0x90010f93
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
90010f60:	4b94      	ldr	r3, [pc, #592]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
90010f62:	681b      	ldr	r3, [r3, #0]
90010f64:	f003 0320 	and.w	r3, r3, #32
90010f68:	2b00      	cmp	r3, #0
90010f6a:	d009      	beq.n	90010f80 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90010f6c:	4b91      	ldr	r3, [pc, #580]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
90010f6e:	681b      	ldr	r3, [r3, #0]
90010f70:	08db      	lsrs	r3, r3, #3
90010f72:	f003 0303 	and.w	r3, r3, #3
90010f76:	4a90      	ldr	r2, [pc, #576]	; (900111b8 <HAL_RCC_GetSysClockFreq+0x2d8>)
90010f78:	fa22 f303 	lsr.w	r3, r2, r3
90010f7c:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

    break;
90010f7e:	e111      	b.n	900111a4 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
90010f80:	4b8d      	ldr	r3, [pc, #564]	; (900111b8 <HAL_RCC_GetSysClockFreq+0x2d8>)
90010f82:	61bb      	str	r3, [r7, #24]
    break;
90010f84:	e10e      	b.n	900111a4 <HAL_RCC_GetSysClockFreq+0x2c4>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
90010f86:	4b8d      	ldr	r3, [pc, #564]	; (900111bc <HAL_RCC_GetSysClockFreq+0x2dc>)
90010f88:	61bb      	str	r3, [r7, #24]
    break;
90010f8a:	e10b      	b.n	900111a4 <HAL_RCC_GetSysClockFreq+0x2c4>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    sysclockfreq = HSE_VALUE;
90010f8c:	4b8c      	ldr	r3, [pc, #560]	; (900111c0 <HAL_RCC_GetSysClockFreq+0x2e0>)
90010f8e:	61bb      	str	r3, [r7, #24]
    break;
90010f90:	e108      	b.n	900111a4 <HAL_RCC_GetSysClockFreq+0x2c4>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90010f92:	4b88      	ldr	r3, [pc, #544]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
90010f94:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90010f96:	f003 0303 	and.w	r3, r3, #3
90010f9a:	617b      	str	r3, [r7, #20]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
90010f9c:	4b85      	ldr	r3, [pc, #532]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
90010f9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90010fa0:	091b      	lsrs	r3, r3, #4
90010fa2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
90010fa6:	613b      	str	r3, [r7, #16]
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
90010fa8:	4b82      	ldr	r3, [pc, #520]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
90010faa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90010fac:	f003 0301 	and.w	r3, r3, #1
90010fb0:	60fb      	str	r3, [r7, #12]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
90010fb2:	4b80      	ldr	r3, [pc, #512]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
90010fb4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90010fb6:	08db      	lsrs	r3, r3, #3
90010fb8:	f3c3 030c 	ubfx	r3, r3, #0, #13
90010fbc:	68fa      	ldr	r2, [r7, #12]
90010fbe:	fb02 f303 	mul.w	r3, r2, r3
90010fc2:	ee07 3a90 	vmov	s15, r3
90010fc6:	eef8 7a67 	vcvt.f32.u32	s15, s15
90010fca:	edc7 7a02 	vstr	s15, [r7, #8]

    if (pllm != 0U)
90010fce:	693b      	ldr	r3, [r7, #16]
90010fd0:	2b00      	cmp	r3, #0
90010fd2:	f000 80e1 	beq.w	90011198 <HAL_RCC_GetSysClockFreq+0x2b8>
90010fd6:	697b      	ldr	r3, [r7, #20]
90010fd8:	2b02      	cmp	r3, #2
90010fda:	f000 8083 	beq.w	900110e4 <HAL_RCC_GetSysClockFreq+0x204>
90010fde:	697b      	ldr	r3, [r7, #20]
90010fe0:	2b02      	cmp	r3, #2
90010fe2:	f200 80a1 	bhi.w	90011128 <HAL_RCC_GetSysClockFreq+0x248>
90010fe6:	697b      	ldr	r3, [r7, #20]
90010fe8:	2b00      	cmp	r3, #0
90010fea:	d003      	beq.n	90010ff4 <HAL_RCC_GetSysClockFreq+0x114>
90010fec:	697b      	ldr	r3, [r7, #20]
90010fee:	2b01      	cmp	r3, #1
90010ff0:	d056      	beq.n	900110a0 <HAL_RCC_GetSysClockFreq+0x1c0>
90010ff2:	e099      	b.n	90011128 <HAL_RCC_GetSysClockFreq+0x248>
    {
      switch (pllsource)
      {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
90010ff4:	4b6f      	ldr	r3, [pc, #444]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
90010ff6:	681b      	ldr	r3, [r3, #0]
90010ff8:	f003 0320 	and.w	r3, r3, #32
90010ffc:	2b00      	cmp	r3, #0
90010ffe:	d02d      	beq.n	9001105c <HAL_RCC_GetSysClockFreq+0x17c>
        {
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90011000:	4b6c      	ldr	r3, [pc, #432]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
90011002:	681b      	ldr	r3, [r3, #0]
90011004:	08db      	lsrs	r3, r3, #3
90011006:	f003 0303 	and.w	r3, r3, #3
9001100a:	4a6b      	ldr	r2, [pc, #428]	; (900111b8 <HAL_RCC_GetSysClockFreq+0x2d8>)
9001100c:	fa22 f303 	lsr.w	r3, r2, r3
90011010:	607b      	str	r3, [r7, #4]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90011012:	687b      	ldr	r3, [r7, #4]
90011014:	ee07 3a90 	vmov	s15, r3
90011018:	eef8 6a67 	vcvt.f32.u32	s13, s15
9001101c:	693b      	ldr	r3, [r7, #16]
9001101e:	ee07 3a90 	vmov	s15, r3
90011022:	eef8 7a67 	vcvt.f32.u32	s15, s15
90011026:	ee86 7aa7 	vdiv.f32	s14, s13, s15
9001102a:	4b62      	ldr	r3, [pc, #392]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
9001102c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9001102e:	f3c3 0308 	ubfx	r3, r3, #0, #9
90011032:	ee07 3a90 	vmov	s15, r3
90011036:	eef8 6a67 	vcvt.f32.u32	s13, s15
9001103a:	ed97 6a02 	vldr	s12, [r7, #8]
9001103e:	eddf 5a61 	vldr	s11, [pc, #388]	; 900111c4 <HAL_RCC_GetSysClockFreq+0x2e4>
90011042:	eec6 7a25 	vdiv.f32	s15, s12, s11
90011046:	ee76 7aa7 	vadd.f32	s15, s13, s15
9001104a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
9001104e:	ee77 7aa6 	vadd.f32	s15, s15, s13
90011052:	ee67 7a27 	vmul.f32	s15, s14, s15
90011056:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        }
        break;
9001105a:	e087      	b.n	9001116c <HAL_RCC_GetSysClockFreq+0x28c>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
9001105c:	693b      	ldr	r3, [r7, #16]
9001105e:	ee07 3a90 	vmov	s15, r3
90011062:	eef8 7a67 	vcvt.f32.u32	s15, s15
90011066:	eddf 6a58 	vldr	s13, [pc, #352]	; 900111c8 <HAL_RCC_GetSysClockFreq+0x2e8>
9001106a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
9001106e:	4b51      	ldr	r3, [pc, #324]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
90011070:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90011072:	f3c3 0308 	ubfx	r3, r3, #0, #9
90011076:	ee07 3a90 	vmov	s15, r3
9001107a:	eef8 6a67 	vcvt.f32.u32	s13, s15
9001107e:	ed97 6a02 	vldr	s12, [r7, #8]
90011082:	eddf 5a50 	vldr	s11, [pc, #320]	; 900111c4 <HAL_RCC_GetSysClockFreq+0x2e4>
90011086:	eec6 7a25 	vdiv.f32	s15, s12, s11
9001108a:	ee76 7aa7 	vadd.f32	s15, s13, s15
9001108e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
90011092:	ee77 7aa6 	vadd.f32	s15, s15, s13
90011096:	ee67 7a27 	vmul.f32	s15, s14, s15
9001109a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
9001109e:	e065      	b.n	9001116c <HAL_RCC_GetSysClockFreq+0x28c>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
900110a0:	693b      	ldr	r3, [r7, #16]
900110a2:	ee07 3a90 	vmov	s15, r3
900110a6:	eef8 7a67 	vcvt.f32.u32	s15, s15
900110aa:	eddf 6a48 	vldr	s13, [pc, #288]	; 900111cc <HAL_RCC_GetSysClockFreq+0x2ec>
900110ae:	ee86 7aa7 	vdiv.f32	s14, s13, s15
900110b2:	4b40      	ldr	r3, [pc, #256]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
900110b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900110b6:	f3c3 0308 	ubfx	r3, r3, #0, #9
900110ba:	ee07 3a90 	vmov	s15, r3
900110be:	eef8 6a67 	vcvt.f32.u32	s13, s15
900110c2:	ed97 6a02 	vldr	s12, [r7, #8]
900110c6:	eddf 5a3f 	vldr	s11, [pc, #252]	; 900111c4 <HAL_RCC_GetSysClockFreq+0x2e4>
900110ca:	eec6 7a25 	vdiv.f32	s15, s12, s11
900110ce:	ee76 7aa7 	vadd.f32	s15, s13, s15
900110d2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
900110d6:	ee77 7aa6 	vadd.f32	s15, s15, s13
900110da:	ee67 7a27 	vmul.f32	s15, s14, s15
900110de:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
900110e2:	e043      	b.n	9001116c <HAL_RCC_GetSysClockFreq+0x28c>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
900110e4:	693b      	ldr	r3, [r7, #16]
900110e6:	ee07 3a90 	vmov	s15, r3
900110ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
900110ee:	eddf 6a38 	vldr	s13, [pc, #224]	; 900111d0 <HAL_RCC_GetSysClockFreq+0x2f0>
900110f2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
900110f6:	4b2f      	ldr	r3, [pc, #188]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
900110f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900110fa:	f3c3 0308 	ubfx	r3, r3, #0, #9
900110fe:	ee07 3a90 	vmov	s15, r3
90011102:	eef8 6a67 	vcvt.f32.u32	s13, s15
90011106:	ed97 6a02 	vldr	s12, [r7, #8]
9001110a:	eddf 5a2e 	vldr	s11, [pc, #184]	; 900111c4 <HAL_RCC_GetSysClockFreq+0x2e4>
9001110e:	eec6 7a25 	vdiv.f32	s15, s12, s11
90011112:	ee76 7aa7 	vadd.f32	s15, s13, s15
90011116:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
9001111a:	ee77 7aa6 	vadd.f32	s15, s15, s13
9001111e:	ee67 7a27 	vmul.f32	s15, s14, s15
90011122:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
90011126:	e021      	b.n	9001116c <HAL_RCC_GetSysClockFreq+0x28c>

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90011128:	693b      	ldr	r3, [r7, #16]
9001112a:	ee07 3a90 	vmov	s15, r3
9001112e:	eef8 7a67 	vcvt.f32.u32	s15, s15
90011132:	eddf 6a26 	vldr	s13, [pc, #152]	; 900111cc <HAL_RCC_GetSysClockFreq+0x2ec>
90011136:	ee86 7aa7 	vdiv.f32	s14, s13, s15
9001113a:	4b1e      	ldr	r3, [pc, #120]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
9001113c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9001113e:	f3c3 0308 	ubfx	r3, r3, #0, #9
90011142:	ee07 3a90 	vmov	s15, r3
90011146:	eef8 6a67 	vcvt.f32.u32	s13, s15
9001114a:	ed97 6a02 	vldr	s12, [r7, #8]
9001114e:	eddf 5a1d 	vldr	s11, [pc, #116]	; 900111c4 <HAL_RCC_GetSysClockFreq+0x2e4>
90011152:	eec6 7a25 	vdiv.f32	s15, s12, s11
90011156:	ee76 7aa7 	vadd.f32	s15, s13, s15
9001115a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
9001115e:	ee77 7aa6 	vadd.f32	s15, s15, s13
90011162:	ee67 7a27 	vmul.f32	s15, s14, s15
90011166:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
9001116a:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
9001116c:	4b11      	ldr	r3, [pc, #68]	; (900111b4 <HAL_RCC_GetSysClockFreq+0x2d4>)
9001116e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90011170:	0a5b      	lsrs	r3, r3, #9
90011172:	f003 037f 	and.w	r3, r3, #127	; 0x7f
90011176:	3301      	adds	r3, #1
90011178:	603b      	str	r3, [r7, #0]
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
9001117a:	683b      	ldr	r3, [r7, #0]
9001117c:	ee07 3a90 	vmov	s15, r3
90011180:	eeb8 7a67 	vcvt.f32.u32	s14, s15
90011184:	edd7 6a07 	vldr	s13, [r7, #28]
90011188:	eec6 7a87 	vdiv.f32	s15, s13, s14
9001118c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90011190:	ee17 3a90 	vmov	r3, s15
90011194:	61bb      	str	r3, [r7, #24]
    }
    else
    {
      sysclockfreq = 0U;
    }
    break;
90011196:	e005      	b.n	900111a4 <HAL_RCC_GetSysClockFreq+0x2c4>
      sysclockfreq = 0U;
90011198:	2300      	movs	r3, #0
9001119a:	61bb      	str	r3, [r7, #24]
    break;
9001119c:	e002      	b.n	900111a4 <HAL_RCC_GetSysClockFreq+0x2c4>

  default:
    sysclockfreq = CSI_VALUE;
9001119e:	4b07      	ldr	r3, [pc, #28]	; (900111bc <HAL_RCC_GetSysClockFreq+0x2dc>)
900111a0:	61bb      	str	r3, [r7, #24]
    break;
900111a2:	bf00      	nop
  }

  return sysclockfreq;
900111a4:	69bb      	ldr	r3, [r7, #24]
}
900111a6:	4618      	mov	r0, r3
900111a8:	3724      	adds	r7, #36	; 0x24
900111aa:	46bd      	mov	sp, r7
900111ac:	f85d 7b04 	ldr.w	r7, [sp], #4
900111b0:	4770      	bx	lr
900111b2:	bf00      	nop
900111b4:	58024400 	.word	0x58024400
900111b8:	03d09000 	.word	0x03d09000
900111bc:	003d0900 	.word	0x003d0900
900111c0:	017d7840 	.word	0x017d7840
900111c4:	46000000 	.word	0x46000000
900111c8:	4c742400 	.word	0x4c742400
900111cc:	4a742400 	.word	0x4a742400
900111d0:	4bbebc20 	.word	0x4bbebc20

900111d4 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
900111d4:	b580      	push	{r7, lr}
900111d6:	b082      	sub	sp, #8
900111d8:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
900111da:	f7ff fe81 	bl	90010ee0 <HAL_RCC_GetSysClockFreq>
900111de:	4602      	mov	r2, r0
900111e0:	4b10      	ldr	r3, [pc, #64]	; (90011224 <HAL_RCC_GetHCLKFreq+0x50>)
900111e2:	699b      	ldr	r3, [r3, #24]
900111e4:	0a1b      	lsrs	r3, r3, #8
900111e6:	f003 030f 	and.w	r3, r3, #15
900111ea:	490f      	ldr	r1, [pc, #60]	; (90011228 <HAL_RCC_GetHCLKFreq+0x54>)
900111ec:	5ccb      	ldrb	r3, [r1, r3]
900111ee:	f003 031f 	and.w	r3, r3, #31
900111f2:	fa22 f303 	lsr.w	r3, r2, r3
900111f6:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
900111f8:	4b0a      	ldr	r3, [pc, #40]	; (90011224 <HAL_RCC_GetHCLKFreq+0x50>)
900111fa:	699b      	ldr	r3, [r3, #24]
900111fc:	f003 030f 	and.w	r3, r3, #15
90011200:	4a09      	ldr	r2, [pc, #36]	; (90011228 <HAL_RCC_GetHCLKFreq+0x54>)
90011202:	5cd3      	ldrb	r3, [r2, r3]
90011204:	f003 031f 	and.w	r3, r3, #31
90011208:	687a      	ldr	r2, [r7, #4]
9001120a:	fa22 f303 	lsr.w	r3, r2, r3
9001120e:	4a07      	ldr	r2, [pc, #28]	; (9001122c <HAL_RCC_GetHCLKFreq+0x58>)
90011210:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
90011212:	4a07      	ldr	r2, [pc, #28]	; (90011230 <HAL_RCC_GetHCLKFreq+0x5c>)
90011214:	687b      	ldr	r3, [r7, #4]
90011216:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
90011218:	4b04      	ldr	r3, [pc, #16]	; (9001122c <HAL_RCC_GetHCLKFreq+0x58>)
9001121a:	681b      	ldr	r3, [r3, #0]
}
9001121c:	4618      	mov	r0, r3
9001121e:	3708      	adds	r7, #8
90011220:	46bd      	mov	sp, r7
90011222:	bd80      	pop	{r7, pc}
90011224:	58024400 	.word	0x58024400
90011228:	9001e8a8 	.word	0x9001e8a8
9001122c:	24000094 	.word	0x24000094
90011230:	24000090 	.word	0x24000090

90011234 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
90011234:	b580      	push	{r7, lr}
90011236:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
90011238:	f7ff ffcc 	bl	900111d4 <HAL_RCC_GetHCLKFreq>
9001123c:	4602      	mov	r2, r0
9001123e:	4b06      	ldr	r3, [pc, #24]	; (90011258 <HAL_RCC_GetPCLK2Freq+0x24>)
90011240:	69db      	ldr	r3, [r3, #28]
90011242:	0a1b      	lsrs	r3, r3, #8
90011244:	f003 0307 	and.w	r3, r3, #7
90011248:	4904      	ldr	r1, [pc, #16]	; (9001125c <HAL_RCC_GetPCLK2Freq+0x28>)
9001124a:	5ccb      	ldrb	r3, [r1, r3]
9001124c:	f003 031f 	and.w	r3, r3, #31
90011250:	fa22 f303 	lsr.w	r3, r2, r3
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
90011254:	4618      	mov	r0, r3
90011256:	bd80      	pop	{r7, pc}
90011258:	58024400 	.word	0x58024400
9001125c:	9001e8a8 	.word	0x9001e8a8

90011260 <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
90011260:	b580      	push	{r7, lr}
90011262:	b086      	sub	sp, #24
90011264:	af00      	add	r7, sp, #0
90011266:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
90011268:	2300      	movs	r3, #0
9001126a:	75fb      	strb	r3, [r7, #23]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
9001126c:	2300      	movs	r3, #0
9001126e:	75bb      	strb	r3, [r7, #22]

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
90011270:	687b      	ldr	r3, [r7, #4]
90011272:	681b      	ldr	r3, [r3, #0]
90011274:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90011278:	2b00      	cmp	r3, #0
9001127a:	d03f      	beq.n	900112fc <HAL_RCCEx_PeriphCLKConfig+0x9c>
  {

    switch(PeriphClkInit->SpdifrxClockSelection)
9001127c:	687b      	ldr	r3, [r7, #4]
9001127e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
90011280:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
90011284:	d02a      	beq.n	900112dc <HAL_RCCEx_PeriphCLKConfig+0x7c>
90011286:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
9001128a:	d824      	bhi.n	900112d6 <HAL_RCCEx_PeriphCLKConfig+0x76>
9001128c:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
90011290:	d018      	beq.n	900112c4 <HAL_RCCEx_PeriphCLKConfig+0x64>
90011292:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
90011296:	d81e      	bhi.n	900112d6 <HAL_RCCEx_PeriphCLKConfig+0x76>
90011298:	2b00      	cmp	r3, #0
9001129a:	d003      	beq.n	900112a4 <HAL_RCCEx_PeriphCLKConfig+0x44>
9001129c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
900112a0:	d007      	beq.n	900112b2 <HAL_RCCEx_PeriphCLKConfig+0x52>
900112a2:	e018      	b.n	900112d6 <HAL_RCCEx_PeriphCLKConfig+0x76>
    {
    case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
      /* Enable PLL1Q Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
900112a4:	4bab      	ldr	r3, [pc, #684]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
900112a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900112a8:	4aaa      	ldr	r2, [pc, #680]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
900112aa:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
900112ae:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
900112b0:	e015      	b.n	900112de <HAL_RCCEx_PeriphCLKConfig+0x7e>

    case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
900112b2:	687b      	ldr	r3, [r7, #4]
900112b4:	3304      	adds	r3, #4
900112b6:	2102      	movs	r1, #2
900112b8:	4618      	mov	r0, r3
900112ba:	f002 f95f 	bl	9001357c <RCCEx_PLL2_Config>
900112be:	4603      	mov	r3, r0
900112c0:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
900112c2:	e00c      	b.n	900112de <HAL_RCCEx_PeriphCLKConfig+0x7e>

    case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
900112c4:	687b      	ldr	r3, [r7, #4]
900112c6:	3324      	adds	r3, #36	; 0x24
900112c8:	2102      	movs	r1, #2
900112ca:	4618      	mov	r0, r3
900112cc:	f002 fa08 	bl	900136e0 <RCCEx_PLL3_Config>
900112d0:	4603      	mov	r3, r0
900112d2:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
900112d4:	e003      	b.n	900112de <HAL_RCCEx_PeriphCLKConfig+0x7e>
      /* Internal OSC clock is used as source of SPDIFRX clock*/
      /* SPDIFRX clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
900112d6:	2301      	movs	r3, #1
900112d8:	75fb      	strb	r3, [r7, #23]
      break;
900112da:	e000      	b.n	900112de <HAL_RCCEx_PeriphCLKConfig+0x7e>
      break;
900112dc:	bf00      	nop
    }

    if(ret == HAL_OK)
900112de:	7dfb      	ldrb	r3, [r7, #23]
900112e0:	2b00      	cmp	r3, #0
900112e2:	d109      	bne.n	900112f8 <HAL_RCCEx_PeriphCLKConfig+0x98>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
900112e4:	4b9b      	ldr	r3, [pc, #620]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
900112e6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
900112e8:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
900112ec:	687b      	ldr	r3, [r7, #4]
900112ee:	6e5b      	ldr	r3, [r3, #100]	; 0x64
900112f0:	4998      	ldr	r1, [pc, #608]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
900112f2:	4313      	orrs	r3, r2
900112f4:	650b      	str	r3, [r1, #80]	; 0x50
900112f6:	e001      	b.n	900112fc <HAL_RCCEx_PeriphCLKConfig+0x9c>
    }
    else
    {
      /* set overall return value */
      status = ret;
900112f8:	7dfb      	ldrb	r3, [r7, #23]
900112fa:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
900112fc:	687b      	ldr	r3, [r7, #4]
900112fe:	681b      	ldr	r3, [r3, #0]
90011300:	f403 7380 	and.w	r3, r3, #256	; 0x100
90011304:	2b00      	cmp	r3, #0
90011306:	d03d      	beq.n	90011384 <HAL_RCCEx_PeriphCLKConfig+0x124>
  {
    switch(PeriphClkInit->Sai1ClockSelection)
90011308:	687b      	ldr	r3, [r7, #4]
9001130a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9001130c:	2b04      	cmp	r3, #4
9001130e:	d826      	bhi.n	9001135e <HAL_RCCEx_PeriphCLKConfig+0xfe>
90011310:	a201      	add	r2, pc, #4	; (adr r2, 90011318 <HAL_RCCEx_PeriphCLKConfig+0xb8>)
90011312:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90011316:	bf00      	nop
90011318:	9001132d 	.word	0x9001132d
9001131c:	9001133b 	.word	0x9001133b
90011320:	9001134d 	.word	0x9001134d
90011324:	90011365 	.word	0x90011365
90011328:	90011365 	.word	0x90011365
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
9001132c:	4b89      	ldr	r3, [pc, #548]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
9001132e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90011330:	4a88      	ldr	r2, [pc, #544]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
90011332:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90011336:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
90011338:	e015      	b.n	90011366 <HAL_RCCEx_PeriphCLKConfig+0x106>

    case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
9001133a:	687b      	ldr	r3, [r7, #4]
9001133c:	3304      	adds	r3, #4
9001133e:	2100      	movs	r1, #0
90011340:	4618      	mov	r0, r3
90011342:	f002 f91b 	bl	9001357c <RCCEx_PLL2_Config>
90011346:	4603      	mov	r3, r0
90011348:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
9001134a:	e00c      	b.n	90011366 <HAL_RCCEx_PeriphCLKConfig+0x106>

    case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
9001134c:	687b      	ldr	r3, [r7, #4]
9001134e:	3324      	adds	r3, #36	; 0x24
90011350:	2100      	movs	r1, #0
90011352:	4618      	mov	r0, r3
90011354:	f002 f9c4 	bl	900136e0 <RCCEx_PLL3_Config>
90011358:	4603      	mov	r3, r0
9001135a:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
9001135c:	e003      	b.n	90011366 <HAL_RCCEx_PeriphCLKConfig+0x106>
      /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
9001135e:	2301      	movs	r3, #1
90011360:	75fb      	strb	r3, [r7, #23]
      break;
90011362:	e000      	b.n	90011366 <HAL_RCCEx_PeriphCLKConfig+0x106>
      break;
90011364:	bf00      	nop
    }

    if(ret == HAL_OK)
90011366:	7dfb      	ldrb	r3, [r7, #23]
90011368:	2b00      	cmp	r3, #0
9001136a:	d109      	bne.n	90011380 <HAL_RCCEx_PeriphCLKConfig+0x120>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
9001136c:	4b79      	ldr	r3, [pc, #484]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
9001136e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90011370:	f023 0207 	bic.w	r2, r3, #7
90011374:	687b      	ldr	r3, [r7, #4]
90011376:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90011378:	4976      	ldr	r1, [pc, #472]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
9001137a:	4313      	orrs	r3, r2
9001137c:	650b      	str	r3, [r1, #80]	; 0x50
9001137e:	e001      	b.n	90011384 <HAL_RCCEx_PeriphCLKConfig+0x124>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011380:	7dfb      	ldrb	r3, [r7, #23]
90011382:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
90011384:	687b      	ldr	r3, [r7, #4]
90011386:	681b      	ldr	r3, [r3, #0]
90011388:	f403 7300 	and.w	r3, r3, #512	; 0x200
9001138c:	2b00      	cmp	r3, #0
9001138e:	d042      	beq.n	90011416 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
  {
    switch(PeriphClkInit->Sai23ClockSelection)
90011390:	687b      	ldr	r3, [r7, #4]
90011392:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90011394:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90011398:	d02b      	beq.n	900113f2 <HAL_RCCEx_PeriphCLKConfig+0x192>
9001139a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
9001139e:	d825      	bhi.n	900113ec <HAL_RCCEx_PeriphCLKConfig+0x18c>
900113a0:	2bc0      	cmp	r3, #192	; 0xc0
900113a2:	d028      	beq.n	900113f6 <HAL_RCCEx_PeriphCLKConfig+0x196>
900113a4:	2bc0      	cmp	r3, #192	; 0xc0
900113a6:	d821      	bhi.n	900113ec <HAL_RCCEx_PeriphCLKConfig+0x18c>
900113a8:	2b80      	cmp	r3, #128	; 0x80
900113aa:	d016      	beq.n	900113da <HAL_RCCEx_PeriphCLKConfig+0x17a>
900113ac:	2b80      	cmp	r3, #128	; 0x80
900113ae:	d81d      	bhi.n	900113ec <HAL_RCCEx_PeriphCLKConfig+0x18c>
900113b0:	2b00      	cmp	r3, #0
900113b2:	d002      	beq.n	900113ba <HAL_RCCEx_PeriphCLKConfig+0x15a>
900113b4:	2b40      	cmp	r3, #64	; 0x40
900113b6:	d007      	beq.n	900113c8 <HAL_RCCEx_PeriphCLKConfig+0x168>
900113b8:	e018      	b.n	900113ec <HAL_RCCEx_PeriphCLKConfig+0x18c>
    {
    case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
900113ba:	4b66      	ldr	r3, [pc, #408]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
900113bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900113be:	4a65      	ldr	r2, [pc, #404]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
900113c0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
900113c4:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
900113c6:	e017      	b.n	900113f8 <HAL_RCCEx_PeriphCLKConfig+0x198>

    case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
900113c8:	687b      	ldr	r3, [r7, #4]
900113ca:	3304      	adds	r3, #4
900113cc:	2100      	movs	r1, #0
900113ce:	4618      	mov	r0, r3
900113d0:	f002 f8d4 	bl	9001357c <RCCEx_PLL2_Config>
900113d4:	4603      	mov	r3, r0
900113d6:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
900113d8:	e00e      	b.n	900113f8 <HAL_RCCEx_PeriphCLKConfig+0x198>

    case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
900113da:	687b      	ldr	r3, [r7, #4]
900113dc:	3324      	adds	r3, #36	; 0x24
900113de:	2100      	movs	r1, #0
900113e0:	4618      	mov	r0, r3
900113e2:	f002 f97d 	bl	900136e0 <RCCEx_PLL3_Config>
900113e6:	4603      	mov	r3, r0
900113e8:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
900113ea:	e005      	b.n	900113f8 <HAL_RCCEx_PeriphCLKConfig+0x198>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
      /* SAI2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
900113ec:	2301      	movs	r3, #1
900113ee:	75fb      	strb	r3, [r7, #23]
      break;
900113f0:	e002      	b.n	900113f8 <HAL_RCCEx_PeriphCLKConfig+0x198>
      break;
900113f2:	bf00      	nop
900113f4:	e000      	b.n	900113f8 <HAL_RCCEx_PeriphCLKConfig+0x198>
      break;
900113f6:	bf00      	nop
    }

    if(ret == HAL_OK)
900113f8:	7dfb      	ldrb	r3, [r7, #23]
900113fa:	2b00      	cmp	r3, #0
900113fc:	d109      	bne.n	90011412 <HAL_RCCEx_PeriphCLKConfig+0x1b2>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
900113fe:	4b55      	ldr	r3, [pc, #340]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
90011400:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90011402:	f423 72e0 	bic.w	r2, r3, #448	; 0x1c0
90011406:	687b      	ldr	r3, [r7, #4]
90011408:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9001140a:	4952      	ldr	r1, [pc, #328]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
9001140c:	4313      	orrs	r3, r2
9001140e:	650b      	str	r3, [r1, #80]	; 0x50
90011410:	e001      	b.n	90011416 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011412:	7dfb      	ldrb	r3, [r7, #23]
90011414:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
90011416:	687b      	ldr	r3, [r7, #4]
90011418:	681b      	ldr	r3, [r3, #0]
9001141a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
9001141e:	2b00      	cmp	r3, #0
90011420:	d049      	beq.n	900114b6 <HAL_RCCEx_PeriphCLKConfig+0x256>
  {
    switch(PeriphClkInit->Sai4AClockSelection)
90011422:	687b      	ldr	r3, [r7, #4]
90011424:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
90011428:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
9001142c:	d030      	beq.n	90011490 <HAL_RCCEx_PeriphCLKConfig+0x230>
9001142e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
90011432:	d82a      	bhi.n	9001148a <HAL_RCCEx_PeriphCLKConfig+0x22a>
90011434:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
90011438:	d02c      	beq.n	90011494 <HAL_RCCEx_PeriphCLKConfig+0x234>
9001143a:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
9001143e:	d824      	bhi.n	9001148a <HAL_RCCEx_PeriphCLKConfig+0x22a>
90011440:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
90011444:	d018      	beq.n	90011478 <HAL_RCCEx_PeriphCLKConfig+0x218>
90011446:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
9001144a:	d81e      	bhi.n	9001148a <HAL_RCCEx_PeriphCLKConfig+0x22a>
9001144c:	2b00      	cmp	r3, #0
9001144e:	d003      	beq.n	90011458 <HAL_RCCEx_PeriphCLKConfig+0x1f8>
90011450:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
90011454:	d007      	beq.n	90011466 <HAL_RCCEx_PeriphCLKConfig+0x206>
90011456:	e018      	b.n	9001148a <HAL_RCCEx_PeriphCLKConfig+0x22a>
    {
    case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90011458:	4b3e      	ldr	r3, [pc, #248]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
9001145a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9001145c:	4a3d      	ldr	r2, [pc, #244]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
9001145e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90011462:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
90011464:	e017      	b.n	90011496 <HAL_RCCEx_PeriphCLKConfig+0x236>

    case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
90011466:	687b      	ldr	r3, [r7, #4]
90011468:	3304      	adds	r3, #4
9001146a:	2100      	movs	r1, #0
9001146c:	4618      	mov	r0, r3
9001146e:	f002 f885 	bl	9001357c <RCCEx_PLL2_Config>
90011472:	4603      	mov	r3, r0
90011474:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
90011476:	e00e      	b.n	90011496 <HAL_RCCEx_PeriphCLKConfig+0x236>

    case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
90011478:	687b      	ldr	r3, [r7, #4]
9001147a:	3324      	adds	r3, #36	; 0x24
9001147c:	2100      	movs	r1, #0
9001147e:	4618      	mov	r0, r3
90011480:	f002 f92e 	bl	900136e0 <RCCEx_PLL3_Config>
90011484:	4603      	mov	r3, r0
90011486:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
90011488:	e005      	b.n	90011496 <HAL_RCCEx_PeriphCLKConfig+0x236>
      /* SAI4A clock source configuration done later after clock selection check */
      break;
#endif /* RCC_VER_3_0 */

    default:
      ret = HAL_ERROR;
9001148a:	2301      	movs	r3, #1
9001148c:	75fb      	strb	r3, [r7, #23]
      break;
9001148e:	e002      	b.n	90011496 <HAL_RCCEx_PeriphCLKConfig+0x236>
      break;
90011490:	bf00      	nop
90011492:	e000      	b.n	90011496 <HAL_RCCEx_PeriphCLKConfig+0x236>
      break;
90011494:	bf00      	nop
    }

    if(ret == HAL_OK)
90011496:	7dfb      	ldrb	r3, [r7, #23]
90011498:	2b00      	cmp	r3, #0
9001149a:	d10a      	bne.n	900114b2 <HAL_RCCEx_PeriphCLKConfig+0x252>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
9001149c:	4b2d      	ldr	r3, [pc, #180]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
9001149e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
900114a0:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
900114a4:	687b      	ldr	r3, [r7, #4]
900114a6:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
900114aa:	492a      	ldr	r1, [pc, #168]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
900114ac:	4313      	orrs	r3, r2
900114ae:	658b      	str	r3, [r1, #88]	; 0x58
900114b0:	e001      	b.n	900114b6 <HAL_RCCEx_PeriphCLKConfig+0x256>
    }
    else
    {
      /* set overall return value */
      status = ret;
900114b2:	7dfb      	ldrb	r3, [r7, #23]
900114b4:	75bb      	strb	r3, [r7, #22]
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
900114b6:	687b      	ldr	r3, [r7, #4]
900114b8:	681b      	ldr	r3, [r3, #0]
900114ba:	f403 6300 	and.w	r3, r3, #2048	; 0x800
900114be:	2b00      	cmp	r3, #0
900114c0:	d04c      	beq.n	9001155c <HAL_RCCEx_PeriphCLKConfig+0x2fc>
  {
    switch(PeriphClkInit->Sai4BClockSelection)
900114c2:	687b      	ldr	r3, [r7, #4]
900114c4:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
900114c8:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
900114cc:	d030      	beq.n	90011530 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
900114ce:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
900114d2:	d82a      	bhi.n	9001152a <HAL_RCCEx_PeriphCLKConfig+0x2ca>
900114d4:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
900114d8:	d02c      	beq.n	90011534 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
900114da:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
900114de:	d824      	bhi.n	9001152a <HAL_RCCEx_PeriphCLKConfig+0x2ca>
900114e0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
900114e4:	d018      	beq.n	90011518 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
900114e6:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
900114ea:	d81e      	bhi.n	9001152a <HAL_RCCEx_PeriphCLKConfig+0x2ca>
900114ec:	2b00      	cmp	r3, #0
900114ee:	d003      	beq.n	900114f8 <HAL_RCCEx_PeriphCLKConfig+0x298>
900114f0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
900114f4:	d007      	beq.n	90011506 <HAL_RCCEx_PeriphCLKConfig+0x2a6>
900114f6:	e018      	b.n	9001152a <HAL_RCCEx_PeriphCLKConfig+0x2ca>
    {
    case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
900114f8:	4b16      	ldr	r3, [pc, #88]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
900114fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900114fc:	4a15      	ldr	r2, [pc, #84]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
900114fe:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90011502:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
90011504:	e017      	b.n	90011536 <HAL_RCCEx_PeriphCLKConfig+0x2d6>

    case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
90011506:	687b      	ldr	r3, [r7, #4]
90011508:	3304      	adds	r3, #4
9001150a:	2100      	movs	r1, #0
9001150c:	4618      	mov	r0, r3
9001150e:	f002 f835 	bl	9001357c <RCCEx_PLL2_Config>
90011512:	4603      	mov	r3, r0
90011514:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
90011516:	e00e      	b.n	90011536 <HAL_RCCEx_PeriphCLKConfig+0x2d6>

    case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
90011518:	687b      	ldr	r3, [r7, #4]
9001151a:	3324      	adds	r3, #36	; 0x24
9001151c:	2100      	movs	r1, #0
9001151e:	4618      	mov	r0, r3
90011520:	f002 f8de 	bl	900136e0 <RCCEx_PLL3_Config>
90011524:	4603      	mov	r3, r0
90011526:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
90011528:	e005      	b.n	90011536 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
      /* SAI4B clock source configuration done later after clock selection check */
      break;
#endif /* RCC_VER_3_0 */

    default:
      ret = HAL_ERROR;
9001152a:	2301      	movs	r3, #1
9001152c:	75fb      	strb	r3, [r7, #23]
      break;
9001152e:	e002      	b.n	90011536 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
      break;
90011530:	bf00      	nop
90011532:	e000      	b.n	90011536 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
      break;
90011534:	bf00      	nop
    }

    if(ret == HAL_OK)
90011536:	7dfb      	ldrb	r3, [r7, #23]
90011538:	2b00      	cmp	r3, #0
9001153a:	d10d      	bne.n	90011558 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
9001153c:	4b05      	ldr	r3, [pc, #20]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
9001153e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90011540:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
90011544:	687b      	ldr	r3, [r7, #4]
90011546:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
9001154a:	4902      	ldr	r1, [pc, #8]	; (90011554 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
9001154c:	4313      	orrs	r3, r2
9001154e:	658b      	str	r3, [r1, #88]	; 0x58
90011550:	e004      	b.n	9001155c <HAL_RCCEx_PeriphCLKConfig+0x2fc>
90011552:	bf00      	nop
90011554:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
90011558:	7dfb      	ldrb	r3, [r7, #23]
9001155a:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
9001155c:	687b      	ldr	r3, [r7, #4]
9001155e:	681b      	ldr	r3, [r3, #0]
90011560:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90011564:	2b00      	cmp	r3, #0
90011566:	d032      	beq.n	900115ce <HAL_RCCEx_PeriphCLKConfig+0x36e>
  {
    switch(PeriphClkInit->QspiClockSelection)
90011568:	687b      	ldr	r3, [r7, #4]
9001156a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
9001156c:	2b30      	cmp	r3, #48	; 0x30
9001156e:	d01c      	beq.n	900115aa <HAL_RCCEx_PeriphCLKConfig+0x34a>
90011570:	2b30      	cmp	r3, #48	; 0x30
90011572:	d817      	bhi.n	900115a4 <HAL_RCCEx_PeriphCLKConfig+0x344>
90011574:	2b20      	cmp	r3, #32
90011576:	d00c      	beq.n	90011592 <HAL_RCCEx_PeriphCLKConfig+0x332>
90011578:	2b20      	cmp	r3, #32
9001157a:	d813      	bhi.n	900115a4 <HAL_RCCEx_PeriphCLKConfig+0x344>
9001157c:	2b00      	cmp	r3, #0
9001157e:	d016      	beq.n	900115ae <HAL_RCCEx_PeriphCLKConfig+0x34e>
90011580:	2b10      	cmp	r3, #16
90011582:	d10f      	bne.n	900115a4 <HAL_RCCEx_PeriphCLKConfig+0x344>
    {
    case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
      /* Enable QSPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90011584:	4baf      	ldr	r3, [pc, #700]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
90011586:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90011588:	4aae      	ldr	r2, [pc, #696]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
9001158a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
9001158e:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* QSPI clock source configuration done later after clock selection check */
      break;
90011590:	e00e      	b.n	900115b0 <HAL_RCCEx_PeriphCLKConfig+0x350>

    case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
90011592:	687b      	ldr	r3, [r7, #4]
90011594:	3304      	adds	r3, #4
90011596:	2102      	movs	r1, #2
90011598:	4618      	mov	r0, r3
9001159a:	f001 ffef 	bl	9001357c <RCCEx_PLL2_Config>
9001159e:	4603      	mov	r3, r0
900115a0:	75fb      	strb	r3, [r7, #23]

      /* QSPI clock source configuration done later after clock selection check */
      break;
900115a2:	e005      	b.n	900115b0 <HAL_RCCEx_PeriphCLKConfig+0x350>
    case RCC_QSPICLKSOURCE_D1HCLK:
      /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
900115a4:	2301      	movs	r3, #1
900115a6:	75fb      	strb	r3, [r7, #23]
      break;
900115a8:	e002      	b.n	900115b0 <HAL_RCCEx_PeriphCLKConfig+0x350>
      break;
900115aa:	bf00      	nop
900115ac:	e000      	b.n	900115b0 <HAL_RCCEx_PeriphCLKConfig+0x350>
      break;
900115ae:	bf00      	nop
    }

    if(ret == HAL_OK)
900115b0:	7dfb      	ldrb	r3, [r7, #23]
900115b2:	2b00      	cmp	r3, #0
900115b4:	d109      	bne.n	900115ca <HAL_RCCEx_PeriphCLKConfig+0x36a>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
900115b6:	4ba3      	ldr	r3, [pc, #652]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
900115b8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
900115ba:	f023 0230 	bic.w	r2, r3, #48	; 0x30
900115be:	687b      	ldr	r3, [r7, #4]
900115c0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
900115c2:	49a0      	ldr	r1, [pc, #640]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
900115c4:	4313      	orrs	r3, r2
900115c6:	64cb      	str	r3, [r1, #76]	; 0x4c
900115c8:	e001      	b.n	900115ce <HAL_RCCEx_PeriphCLKConfig+0x36e>
    }
    else
    {
      /* set overall return value */
      status = ret;
900115ca:	7dfb      	ldrb	r3, [r7, #23]
900115cc:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
900115ce:	687b      	ldr	r3, [r7, #4]
900115d0:	681b      	ldr	r3, [r3, #0]
900115d2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
900115d6:	2b00      	cmp	r3, #0
900115d8:	d047      	beq.n	9001166a <HAL_RCCEx_PeriphCLKConfig+0x40a>
  {
    switch(PeriphClkInit->Spi123ClockSelection)
900115da:	687b      	ldr	r3, [r7, #4]
900115dc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
900115de:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
900115e2:	d030      	beq.n	90011646 <HAL_RCCEx_PeriphCLKConfig+0x3e6>
900115e4:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
900115e8:	d82a      	bhi.n	90011640 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
900115ea:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
900115ee:	d02c      	beq.n	9001164a <HAL_RCCEx_PeriphCLKConfig+0x3ea>
900115f0:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
900115f4:	d824      	bhi.n	90011640 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
900115f6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
900115fa:	d018      	beq.n	9001162e <HAL_RCCEx_PeriphCLKConfig+0x3ce>
900115fc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
90011600:	d81e      	bhi.n	90011640 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
90011602:	2b00      	cmp	r3, #0
90011604:	d003      	beq.n	9001160e <HAL_RCCEx_PeriphCLKConfig+0x3ae>
90011606:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
9001160a:	d007      	beq.n	9001161c <HAL_RCCEx_PeriphCLKConfig+0x3bc>
9001160c:	e018      	b.n	90011640 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    {
    case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
      /* Enable SPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
9001160e:	4b8d      	ldr	r3, [pc, #564]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
90011610:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90011612:	4a8c      	ldr	r2, [pc, #560]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
90011614:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90011618:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
9001161a:	e017      	b.n	9001164c <HAL_RCCEx_PeriphCLKConfig+0x3ec>

    case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
9001161c:	687b      	ldr	r3, [r7, #4]
9001161e:	3304      	adds	r3, #4
90011620:	2100      	movs	r1, #0
90011622:	4618      	mov	r0, r3
90011624:	f001 ffaa 	bl	9001357c <RCCEx_PLL2_Config>
90011628:	4603      	mov	r3, r0
9001162a:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
9001162c:	e00e      	b.n	9001164c <HAL_RCCEx_PeriphCLKConfig+0x3ec>

    case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
9001162e:	687b      	ldr	r3, [r7, #4]
90011630:	3324      	adds	r3, #36	; 0x24
90011632:	2100      	movs	r1, #0
90011634:	4618      	mov	r0, r3
90011636:	f002 f853 	bl	900136e0 <RCCEx_PLL3_Config>
9001163a:	4603      	mov	r3, r0
9001163c:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
9001163e:	e005      	b.n	9001164c <HAL_RCCEx_PeriphCLKConfig+0x3ec>
      /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
90011640:	2301      	movs	r3, #1
90011642:	75fb      	strb	r3, [r7, #23]
      break;
90011644:	e002      	b.n	9001164c <HAL_RCCEx_PeriphCLKConfig+0x3ec>
      break;
90011646:	bf00      	nop
90011648:	e000      	b.n	9001164c <HAL_RCCEx_PeriphCLKConfig+0x3ec>
      break;
9001164a:	bf00      	nop
    }

    if(ret == HAL_OK)
9001164c:	7dfb      	ldrb	r3, [r7, #23]
9001164e:	2b00      	cmp	r3, #0
90011650:	d109      	bne.n	90011666 <HAL_RCCEx_PeriphCLKConfig+0x406>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
90011652:	4b7c      	ldr	r3, [pc, #496]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
90011654:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90011656:	f423 42e0 	bic.w	r2, r3, #28672	; 0x7000
9001165a:	687b      	ldr	r3, [r7, #4]
9001165c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
9001165e:	4979      	ldr	r1, [pc, #484]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
90011660:	4313      	orrs	r3, r2
90011662:	650b      	str	r3, [r1, #80]	; 0x50
90011664:	e001      	b.n	9001166a <HAL_RCCEx_PeriphCLKConfig+0x40a>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011666:	7dfb      	ldrb	r3, [r7, #23]
90011668:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
9001166a:	687b      	ldr	r3, [r7, #4]
9001166c:	681b      	ldr	r3, [r3, #0]
9001166e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
90011672:	2b00      	cmp	r3, #0
90011674:	d049      	beq.n	9001170a <HAL_RCCEx_PeriphCLKConfig+0x4aa>
  {
    switch(PeriphClkInit->Spi45ClockSelection)
90011676:	687b      	ldr	r3, [r7, #4]
90011678:	6e1b      	ldr	r3, [r3, #96]	; 0x60
9001167a:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
9001167e:	d02e      	beq.n	900116de <HAL_RCCEx_PeriphCLKConfig+0x47e>
90011680:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
90011684:	d828      	bhi.n	900116d8 <HAL_RCCEx_PeriphCLKConfig+0x478>
90011686:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
9001168a:	d02a      	beq.n	900116e2 <HAL_RCCEx_PeriphCLKConfig+0x482>
9001168c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
90011690:	d822      	bhi.n	900116d8 <HAL_RCCEx_PeriphCLKConfig+0x478>
90011692:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
90011696:	d026      	beq.n	900116e6 <HAL_RCCEx_PeriphCLKConfig+0x486>
90011698:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
9001169c:	d81c      	bhi.n	900116d8 <HAL_RCCEx_PeriphCLKConfig+0x478>
9001169e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
900116a2:	d010      	beq.n	900116c6 <HAL_RCCEx_PeriphCLKConfig+0x466>
900116a4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
900116a8:	d816      	bhi.n	900116d8 <HAL_RCCEx_PeriphCLKConfig+0x478>
900116aa:	2b00      	cmp	r3, #0
900116ac:	d01d      	beq.n	900116ea <HAL_RCCEx_PeriphCLKConfig+0x48a>
900116ae:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
900116b2:	d111      	bne.n	900116d8 <HAL_RCCEx_PeriphCLKConfig+0x478>
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
900116b4:	687b      	ldr	r3, [r7, #4]
900116b6:	3304      	adds	r3, #4
900116b8:	2101      	movs	r1, #1
900116ba:	4618      	mov	r0, r3
900116bc:	f001 ff5e 	bl	9001357c <RCCEx_PLL2_Config>
900116c0:	4603      	mov	r3, r0
900116c2:	75fb      	strb	r3, [r7, #23]

      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
900116c4:	e012      	b.n	900116ec <HAL_RCCEx_PeriphCLKConfig+0x48c>
    case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
900116c6:	687b      	ldr	r3, [r7, #4]
900116c8:	3324      	adds	r3, #36	; 0x24
900116ca:	2101      	movs	r1, #1
900116cc:	4618      	mov	r0, r3
900116ce:	f002 f807 	bl	900136e0 <RCCEx_PLL3_Config>
900116d2:	4603      	mov	r3, r0
900116d4:	75fb      	strb	r3, [r7, #23]
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
900116d6:	e009      	b.n	900116ec <HAL_RCCEx_PeriphCLKConfig+0x48c>
      /* HSE,  oscillator is used as source of SPI4/5 clock */
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
900116d8:	2301      	movs	r3, #1
900116da:	75fb      	strb	r3, [r7, #23]
      break;
900116dc:	e006      	b.n	900116ec <HAL_RCCEx_PeriphCLKConfig+0x48c>
      break;
900116de:	bf00      	nop
900116e0:	e004      	b.n	900116ec <HAL_RCCEx_PeriphCLKConfig+0x48c>
      break;
900116e2:	bf00      	nop
900116e4:	e002      	b.n	900116ec <HAL_RCCEx_PeriphCLKConfig+0x48c>
      break;
900116e6:	bf00      	nop
900116e8:	e000      	b.n	900116ec <HAL_RCCEx_PeriphCLKConfig+0x48c>
      break;
900116ea:	bf00      	nop
    }

    if(ret == HAL_OK)
900116ec:	7dfb      	ldrb	r3, [r7, #23]
900116ee:	2b00      	cmp	r3, #0
900116f0:	d109      	bne.n	90011706 <HAL_RCCEx_PeriphCLKConfig+0x4a6>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
900116f2:	4b54      	ldr	r3, [pc, #336]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
900116f4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
900116f6:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
900116fa:	687b      	ldr	r3, [r7, #4]
900116fc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
900116fe:	4951      	ldr	r1, [pc, #324]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
90011700:	4313      	orrs	r3, r2
90011702:	650b      	str	r3, [r1, #80]	; 0x50
90011704:	e001      	b.n	9001170a <HAL_RCCEx_PeriphCLKConfig+0x4aa>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011706:	7dfb      	ldrb	r3, [r7, #23]
90011708:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
9001170a:	687b      	ldr	r3, [r7, #4]
9001170c:	681b      	ldr	r3, [r3, #0]
9001170e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
90011712:	2b00      	cmp	r3, #0
90011714:	d04b      	beq.n	900117ae <HAL_RCCEx_PeriphCLKConfig+0x54e>
  {
    switch(PeriphClkInit->Spi6ClockSelection)
90011716:	687b      	ldr	r3, [r7, #4]
90011718:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
9001171c:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
90011720:	d02e      	beq.n	90011780 <HAL_RCCEx_PeriphCLKConfig+0x520>
90011722:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
90011726:	d828      	bhi.n	9001177a <HAL_RCCEx_PeriphCLKConfig+0x51a>
90011728:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
9001172c:	d02a      	beq.n	90011784 <HAL_RCCEx_PeriphCLKConfig+0x524>
9001172e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
90011732:	d822      	bhi.n	9001177a <HAL_RCCEx_PeriphCLKConfig+0x51a>
90011734:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
90011738:	d026      	beq.n	90011788 <HAL_RCCEx_PeriphCLKConfig+0x528>
9001173a:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
9001173e:	d81c      	bhi.n	9001177a <HAL_RCCEx_PeriphCLKConfig+0x51a>
90011740:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90011744:	d010      	beq.n	90011768 <HAL_RCCEx_PeriphCLKConfig+0x508>
90011746:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
9001174a:	d816      	bhi.n	9001177a <HAL_RCCEx_PeriphCLKConfig+0x51a>
9001174c:	2b00      	cmp	r3, #0
9001174e:	d01d      	beq.n	9001178c <HAL_RCCEx_PeriphCLKConfig+0x52c>
90011750:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
90011754:	d111      	bne.n	9001177a <HAL_RCCEx_PeriphCLKConfig+0x51a>
      /* SPI6 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
90011756:	687b      	ldr	r3, [r7, #4]
90011758:	3304      	adds	r3, #4
9001175a:	2101      	movs	r1, #1
9001175c:	4618      	mov	r0, r3
9001175e:	f001 ff0d 	bl	9001357c <RCCEx_PLL2_Config>
90011762:	4603      	mov	r3, r0
90011764:	75fb      	strb	r3, [r7, #23]

      /* SPI6 clock source configuration done later after clock selection check */
      break;
90011766:	e012      	b.n	9001178e <HAL_RCCEx_PeriphCLKConfig+0x52e>
    case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
90011768:	687b      	ldr	r3, [r7, #4]
9001176a:	3324      	adds	r3, #36	; 0x24
9001176c:	2101      	movs	r1, #1
9001176e:	4618      	mov	r0, r3
90011770:	f001 ffb6 	bl	900136e0 <RCCEx_PLL3_Config>
90011774:	4603      	mov	r3, r0
90011776:	75fb      	strb	r3, [r7, #23]
      /* SPI6 clock source configuration done later after clock selection check */
      break;
90011778:	e009      	b.n	9001178e <HAL_RCCEx_PeriphCLKConfig+0x52e>
      /* SPI6 clock source configuration done later after clock selection check */
      break;
#endif

    default:
      ret = HAL_ERROR;
9001177a:	2301      	movs	r3, #1
9001177c:	75fb      	strb	r3, [r7, #23]
      break;
9001177e:	e006      	b.n	9001178e <HAL_RCCEx_PeriphCLKConfig+0x52e>
      break;
90011780:	bf00      	nop
90011782:	e004      	b.n	9001178e <HAL_RCCEx_PeriphCLKConfig+0x52e>
      break;
90011784:	bf00      	nop
90011786:	e002      	b.n	9001178e <HAL_RCCEx_PeriphCLKConfig+0x52e>
      break;
90011788:	bf00      	nop
9001178a:	e000      	b.n	9001178e <HAL_RCCEx_PeriphCLKConfig+0x52e>
      break;
9001178c:	bf00      	nop
    }

    if(ret == HAL_OK)
9001178e:	7dfb      	ldrb	r3, [r7, #23]
90011790:	2b00      	cmp	r3, #0
90011792:	d10a      	bne.n	900117aa <HAL_RCCEx_PeriphCLKConfig+0x54a>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
90011794:	4b2b      	ldr	r3, [pc, #172]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
90011796:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90011798:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
9001179c:	687b      	ldr	r3, [r7, #4]
9001179e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
900117a2:	4928      	ldr	r1, [pc, #160]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
900117a4:	4313      	orrs	r3, r2
900117a6:	658b      	str	r3, [r1, #88]	; 0x58
900117a8:	e001      	b.n	900117ae <HAL_RCCEx_PeriphCLKConfig+0x54e>
    }
    else
    {
      /* set overall return value */
      status = ret;
900117aa:	7dfb      	ldrb	r3, [r7, #23]
900117ac:	75bb      	strb	r3, [r7, #22]
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
900117ae:	687b      	ldr	r3, [r7, #4]
900117b0:	681b      	ldr	r3, [r3, #0]
900117b2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
900117b6:	2b00      	cmp	r3, #0
900117b8:	d02f      	beq.n	9001181a <HAL_RCCEx_PeriphCLKConfig+0x5ba>
  {
    switch(PeriphClkInit->FdcanClockSelection)
900117ba:	687b      	ldr	r3, [r7, #4]
900117bc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
900117be:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
900117c2:	d00e      	beq.n	900117e2 <HAL_RCCEx_PeriphCLKConfig+0x582>
900117c4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
900117c8:	d814      	bhi.n	900117f4 <HAL_RCCEx_PeriphCLKConfig+0x594>
900117ca:	2b00      	cmp	r3, #0
900117cc:	d015      	beq.n	900117fa <HAL_RCCEx_PeriphCLKConfig+0x59a>
900117ce:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
900117d2:	d10f      	bne.n	900117f4 <HAL_RCCEx_PeriphCLKConfig+0x594>
    {
    case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
      /* Enable FDCAN Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
900117d4:	4b1b      	ldr	r3, [pc, #108]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
900117d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900117d8:	4a1a      	ldr	r2, [pc, #104]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
900117da:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
900117de:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FDCAN clock source configuration done later after clock selection check */
      break;
900117e0:	e00c      	b.n	900117fc <HAL_RCCEx_PeriphCLKConfig+0x59c>

    case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
900117e2:	687b      	ldr	r3, [r7, #4]
900117e4:	3304      	adds	r3, #4
900117e6:	2101      	movs	r1, #1
900117e8:	4618      	mov	r0, r3
900117ea:	f001 fec7 	bl	9001357c <RCCEx_PLL2_Config>
900117ee:	4603      	mov	r3, r0
900117f0:	75fb      	strb	r3, [r7, #23]

      /* FDCAN clock source configuration done later after clock selection check */
      break;
900117f2:	e003      	b.n	900117fc <HAL_RCCEx_PeriphCLKConfig+0x59c>
      /* HSE is used as clock source for FDCAN*/
      /* FDCAN clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
900117f4:	2301      	movs	r3, #1
900117f6:	75fb      	strb	r3, [r7, #23]
      break;
900117f8:	e000      	b.n	900117fc <HAL_RCCEx_PeriphCLKConfig+0x59c>
      break;
900117fa:	bf00      	nop
    }

    if(ret == HAL_OK)
900117fc:	7dfb      	ldrb	r3, [r7, #23]
900117fe:	2b00      	cmp	r3, #0
90011800:	d109      	bne.n	90011816 <HAL_RCCEx_PeriphCLKConfig+0x5b6>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
90011802:	4b10      	ldr	r3, [pc, #64]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
90011804:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90011806:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
9001180a:	687b      	ldr	r3, [r7, #4]
9001180c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
9001180e:	490d      	ldr	r1, [pc, #52]	; (90011844 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
90011810:	4313      	orrs	r3, r2
90011812:	650b      	str	r3, [r1, #80]	; 0x50
90011814:	e001      	b.n	9001181a <HAL_RCCEx_PeriphCLKConfig+0x5ba>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011816:	7dfb      	ldrb	r3, [r7, #23]
90011818:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
9001181a:	687b      	ldr	r3, [r7, #4]
9001181c:	681b      	ldr	r3, [r3, #0]
9001181e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
90011822:	2b00      	cmp	r3, #0
90011824:	d033      	beq.n	9001188e <HAL_RCCEx_PeriphCLKConfig+0x62e>
  {
    switch(PeriphClkInit->FmcClockSelection)
90011826:	687b      	ldr	r3, [r7, #4]
90011828:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9001182a:	2b03      	cmp	r3, #3
9001182c:	d81c      	bhi.n	90011868 <HAL_RCCEx_PeriphCLKConfig+0x608>
9001182e:	a201      	add	r2, pc, #4	; (adr r2, 90011834 <HAL_RCCEx_PeriphCLKConfig+0x5d4>)
90011830:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90011834:	9001186f 	.word	0x9001186f
90011838:	90011849 	.word	0x90011849
9001183c:	90011857 	.word	0x90011857
90011840:	9001186f 	.word	0x9001186f
90011844:	58024400 	.word	0x58024400
    {
    case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
      /* Enable FMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90011848:	4bb8      	ldr	r3, [pc, #736]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
9001184a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9001184c:	4ab7      	ldr	r2, [pc, #732]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
9001184e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90011852:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FMC clock source configuration done later after clock selection check */
      break;
90011854:	e00c      	b.n	90011870 <HAL_RCCEx_PeriphCLKConfig+0x610>

    case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
90011856:	687b      	ldr	r3, [r7, #4]
90011858:	3304      	adds	r3, #4
9001185a:	2102      	movs	r1, #2
9001185c:	4618      	mov	r0, r3
9001185e:	f001 fe8d 	bl	9001357c <RCCEx_PLL2_Config>
90011862:	4603      	mov	r3, r0
90011864:	75fb      	strb	r3, [r7, #23]

      /* FMC clock source configuration done later after clock selection check */
      break;
90011866:	e003      	b.n	90011870 <HAL_RCCEx_PeriphCLKConfig+0x610>
    case RCC_FMCCLKSOURCE_HCLK:
      /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
90011868:	2301      	movs	r3, #1
9001186a:	75fb      	strb	r3, [r7, #23]
      break;
9001186c:	e000      	b.n	90011870 <HAL_RCCEx_PeriphCLKConfig+0x610>
      break;
9001186e:	bf00      	nop
    }

    if(ret == HAL_OK)
90011870:	7dfb      	ldrb	r3, [r7, #23]
90011872:	2b00      	cmp	r3, #0
90011874:	d109      	bne.n	9001188a <HAL_RCCEx_PeriphCLKConfig+0x62a>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
90011876:	4bad      	ldr	r3, [pc, #692]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011878:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9001187a:	f023 0203 	bic.w	r2, r3, #3
9001187e:	687b      	ldr	r3, [r7, #4]
90011880:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90011882:	49aa      	ldr	r1, [pc, #680]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011884:	4313      	orrs	r3, r2
90011886:	64cb      	str	r3, [r1, #76]	; 0x4c
90011888:	e001      	b.n	9001188e <HAL_RCCEx_PeriphCLKConfig+0x62e>
    }
    else
    {
      /* set overall return value */
      status = ret;
9001188a:	7dfb      	ldrb	r3, [r7, #23]
9001188c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
9001188e:	687b      	ldr	r3, [r7, #4]
90011890:	681b      	ldr	r3, [r3, #0]
90011892:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
90011896:	2b00      	cmp	r3, #0
90011898:	f000 8086 	beq.w	900119a8 <HAL_RCCEx_PeriphCLKConfig+0x748>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
9001189c:	4ba4      	ldr	r3, [pc, #656]	; (90011b30 <HAL_RCCEx_PeriphCLKConfig+0x8d0>)
9001189e:	681b      	ldr	r3, [r3, #0]
900118a0:	4aa3      	ldr	r2, [pc, #652]	; (90011b30 <HAL_RCCEx_PeriphCLKConfig+0x8d0>)
900118a2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
900118a6:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
900118a8:	f7f7 fd8c 	bl	900093c4 <HAL_GetTick>
900118ac:	6138      	str	r0, [r7, #16]

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
900118ae:	e009      	b.n	900118c4 <HAL_RCCEx_PeriphCLKConfig+0x664>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
900118b0:	f7f7 fd88 	bl	900093c4 <HAL_GetTick>
900118b4:	4602      	mov	r2, r0
900118b6:	693b      	ldr	r3, [r7, #16]
900118b8:	1ad3      	subs	r3, r2, r3
900118ba:	2b64      	cmp	r3, #100	; 0x64
900118bc:	d902      	bls.n	900118c4 <HAL_RCCEx_PeriphCLKConfig+0x664>
      {
        ret = HAL_TIMEOUT;
900118be:	2303      	movs	r3, #3
900118c0:	75fb      	strb	r3, [r7, #23]
        break;
900118c2:	e005      	b.n	900118d0 <HAL_RCCEx_PeriphCLKConfig+0x670>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
900118c4:	4b9a      	ldr	r3, [pc, #616]	; (90011b30 <HAL_RCCEx_PeriphCLKConfig+0x8d0>)
900118c6:	681b      	ldr	r3, [r3, #0]
900118c8:	f403 7380 	and.w	r3, r3, #256	; 0x100
900118cc:	2b00      	cmp	r3, #0
900118ce:	d0ef      	beq.n	900118b0 <HAL_RCCEx_PeriphCLKConfig+0x650>
      }
    }

    if(ret == HAL_OK)
900118d0:	7dfb      	ldrb	r3, [r7, #23]
900118d2:	2b00      	cmp	r3, #0
900118d4:	d166      	bne.n	900119a4 <HAL_RCCEx_PeriphCLKConfig+0x744>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
900118d6:	4b95      	ldr	r3, [pc, #596]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
900118d8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
900118da:	687b      	ldr	r3, [r7, #4]
900118dc:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
900118e0:	4053      	eors	r3, r2
900118e2:	f403 7340 	and.w	r3, r3, #768	; 0x300
900118e6:	2b00      	cmp	r3, #0
900118e8:	d013      	beq.n	90011912 <HAL_RCCEx_PeriphCLKConfig+0x6b2>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
900118ea:	4b90      	ldr	r3, [pc, #576]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
900118ec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900118ee:	f423 7340 	bic.w	r3, r3, #768	; 0x300
900118f2:	60fb      	str	r3, [r7, #12]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
900118f4:	4b8d      	ldr	r3, [pc, #564]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
900118f6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900118f8:	4a8c      	ldr	r2, [pc, #560]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
900118fa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
900118fe:	6713      	str	r3, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
90011900:	4b8a      	ldr	r3, [pc, #552]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011902:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90011904:	4a89      	ldr	r2, [pc, #548]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011906:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
9001190a:	6713      	str	r3, [r2, #112]	; 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
9001190c:	4a87      	ldr	r2, [pc, #540]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
9001190e:	68fb      	ldr	r3, [r7, #12]
90011910:	6713      	str	r3, [r2, #112]	; 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
90011912:	687b      	ldr	r3, [r7, #4]
90011914:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
90011918:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
9001191c:	d115      	bne.n	9001194a <HAL_RCCEx_PeriphCLKConfig+0x6ea>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
9001191e:	f7f7 fd51 	bl	900093c4 <HAL_GetTick>
90011922:	6138      	str	r0, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
90011924:	e00b      	b.n	9001193e <HAL_RCCEx_PeriphCLKConfig+0x6de>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
90011926:	f7f7 fd4d 	bl	900093c4 <HAL_GetTick>
9001192a:	4602      	mov	r2, r0
9001192c:	693b      	ldr	r3, [r7, #16]
9001192e:	1ad3      	subs	r3, r2, r3
90011930:	f241 3288 	movw	r2, #5000	; 0x1388
90011934:	4293      	cmp	r3, r2
90011936:	d902      	bls.n	9001193e <HAL_RCCEx_PeriphCLKConfig+0x6de>
          {
            ret = HAL_TIMEOUT;
90011938:	2303      	movs	r3, #3
9001193a:	75fb      	strb	r3, [r7, #23]
            break;
9001193c:	e005      	b.n	9001194a <HAL_RCCEx_PeriphCLKConfig+0x6ea>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
9001193e:	4b7b      	ldr	r3, [pc, #492]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011940:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90011942:	f003 0302 	and.w	r3, r3, #2
90011946:	2b00      	cmp	r3, #0
90011948:	d0ed      	beq.n	90011926 <HAL_RCCEx_PeriphCLKConfig+0x6c6>
          }
        }
      }

      if(ret == HAL_OK)
9001194a:	7dfb      	ldrb	r3, [r7, #23]
9001194c:	2b00      	cmp	r3, #0
9001194e:	d126      	bne.n	9001199e <HAL_RCCEx_PeriphCLKConfig+0x73e>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
90011950:	687b      	ldr	r3, [r7, #4]
90011952:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
90011956:	f403 7340 	and.w	r3, r3, #768	; 0x300
9001195a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
9001195e:	d10d      	bne.n	9001197c <HAL_RCCEx_PeriphCLKConfig+0x71c>
90011960:	4b72      	ldr	r3, [pc, #456]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011962:	691b      	ldr	r3, [r3, #16]
90011964:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
90011968:	687b      	ldr	r3, [r7, #4]
9001196a:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
9001196e:	0919      	lsrs	r1, r3, #4
90011970:	4b70      	ldr	r3, [pc, #448]	; (90011b34 <HAL_RCCEx_PeriphCLKConfig+0x8d4>)
90011972:	400b      	ands	r3, r1
90011974:	496d      	ldr	r1, [pc, #436]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011976:	4313      	orrs	r3, r2
90011978:	610b      	str	r3, [r1, #16]
9001197a:	e005      	b.n	90011988 <HAL_RCCEx_PeriphCLKConfig+0x728>
9001197c:	4b6b      	ldr	r3, [pc, #428]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
9001197e:	691b      	ldr	r3, [r3, #16]
90011980:	4a6a      	ldr	r2, [pc, #424]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011982:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
90011986:	6113      	str	r3, [r2, #16]
90011988:	4b68      	ldr	r3, [pc, #416]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
9001198a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
9001198c:	687b      	ldr	r3, [r7, #4]
9001198e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
90011992:	f3c3 030b 	ubfx	r3, r3, #0, #12
90011996:	4965      	ldr	r1, [pc, #404]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011998:	4313      	orrs	r3, r2
9001199a:	670b      	str	r3, [r1, #112]	; 0x70
9001199c:	e004      	b.n	900119a8 <HAL_RCCEx_PeriphCLKConfig+0x748>
      }
      else
      {
        /* set overall return value */
        status = ret;
9001199e:	7dfb      	ldrb	r3, [r7, #23]
900119a0:	75bb      	strb	r3, [r7, #22]
900119a2:	e001      	b.n	900119a8 <HAL_RCCEx_PeriphCLKConfig+0x748>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
900119a4:	7dfb      	ldrb	r3, [r7, #23]
900119a6:	75bb      	strb	r3, [r7, #22]
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
900119a8:	687b      	ldr	r3, [r7, #4]
900119aa:	681b      	ldr	r3, [r3, #0]
900119ac:	f003 0301 	and.w	r3, r3, #1
900119b0:	2b00      	cmp	r3, #0
900119b2:	d07e      	beq.n	90011ab2 <HAL_RCCEx_PeriphCLKConfig+0x852>
  {
    switch(PeriphClkInit->Usart16ClockSelection)
900119b4:	687b      	ldr	r3, [r7, #4]
900119b6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
900119b8:	2b28      	cmp	r3, #40	; 0x28
900119ba:	d867      	bhi.n	90011a8c <HAL_RCCEx_PeriphCLKConfig+0x82c>
900119bc:	a201      	add	r2, pc, #4	; (adr r2, 900119c4 <HAL_RCCEx_PeriphCLKConfig+0x764>)
900119be:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
900119c2:	bf00      	nop
900119c4:	90011a93 	.word	0x90011a93
900119c8:	90011a8d 	.word	0x90011a8d
900119cc:	90011a8d 	.word	0x90011a8d
900119d0:	90011a8d 	.word	0x90011a8d
900119d4:	90011a8d 	.word	0x90011a8d
900119d8:	90011a8d 	.word	0x90011a8d
900119dc:	90011a8d 	.word	0x90011a8d
900119e0:	90011a8d 	.word	0x90011a8d
900119e4:	90011a69 	.word	0x90011a69
900119e8:	90011a8d 	.word	0x90011a8d
900119ec:	90011a8d 	.word	0x90011a8d
900119f0:	90011a8d 	.word	0x90011a8d
900119f4:	90011a8d 	.word	0x90011a8d
900119f8:	90011a8d 	.word	0x90011a8d
900119fc:	90011a8d 	.word	0x90011a8d
90011a00:	90011a8d 	.word	0x90011a8d
90011a04:	90011a7b 	.word	0x90011a7b
90011a08:	90011a8d 	.word	0x90011a8d
90011a0c:	90011a8d 	.word	0x90011a8d
90011a10:	90011a8d 	.word	0x90011a8d
90011a14:	90011a8d 	.word	0x90011a8d
90011a18:	90011a8d 	.word	0x90011a8d
90011a1c:	90011a8d 	.word	0x90011a8d
90011a20:	90011a8d 	.word	0x90011a8d
90011a24:	90011a93 	.word	0x90011a93
90011a28:	90011a8d 	.word	0x90011a8d
90011a2c:	90011a8d 	.word	0x90011a8d
90011a30:	90011a8d 	.word	0x90011a8d
90011a34:	90011a8d 	.word	0x90011a8d
90011a38:	90011a8d 	.word	0x90011a8d
90011a3c:	90011a8d 	.word	0x90011a8d
90011a40:	90011a8d 	.word	0x90011a8d
90011a44:	90011a93 	.word	0x90011a93
90011a48:	90011a8d 	.word	0x90011a8d
90011a4c:	90011a8d 	.word	0x90011a8d
90011a50:	90011a8d 	.word	0x90011a8d
90011a54:	90011a8d 	.word	0x90011a8d
90011a58:	90011a8d 	.word	0x90011a8d
90011a5c:	90011a8d 	.word	0x90011a8d
90011a60:	90011a8d 	.word	0x90011a8d
90011a64:	90011a93 	.word	0x90011a93
    case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
90011a68:	687b      	ldr	r3, [r7, #4]
90011a6a:	3304      	adds	r3, #4
90011a6c:	2101      	movs	r1, #1
90011a6e:	4618      	mov	r0, r3
90011a70:	f001 fd84 	bl	9001357c <RCCEx_PLL2_Config>
90011a74:	4603      	mov	r3, r0
90011a76:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
90011a78:	e00c      	b.n	90011a94 <HAL_RCCEx_PeriphCLKConfig+0x834>

    case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
90011a7a:	687b      	ldr	r3, [r7, #4]
90011a7c:	3324      	adds	r3, #36	; 0x24
90011a7e:	2101      	movs	r1, #1
90011a80:	4618      	mov	r0, r3
90011a82:	f001 fe2d 	bl	900136e0 <RCCEx_PLL3_Config>
90011a86:	4603      	mov	r3, r0
90011a88:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
90011a8a:	e003      	b.n	90011a94 <HAL_RCCEx_PeriphCLKConfig+0x834>
      /* LSE,  oscillator is used as source of USART1/6 clock */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
90011a8c:	2301      	movs	r3, #1
90011a8e:	75fb      	strb	r3, [r7, #23]
      break;
90011a90:	e000      	b.n	90011a94 <HAL_RCCEx_PeriphCLKConfig+0x834>
      break;
90011a92:	bf00      	nop
    }

    if(ret == HAL_OK)
90011a94:	7dfb      	ldrb	r3, [r7, #23]
90011a96:	2b00      	cmp	r3, #0
90011a98:	d109      	bne.n	90011aae <HAL_RCCEx_PeriphCLKConfig+0x84e>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
90011a9a:	4b24      	ldr	r3, [pc, #144]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011a9c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90011a9e:	f023 0238 	bic.w	r2, r3, #56	; 0x38
90011aa2:	687b      	ldr	r3, [r7, #4]
90011aa4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
90011aa6:	4921      	ldr	r1, [pc, #132]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011aa8:	4313      	orrs	r3, r2
90011aaa:	654b      	str	r3, [r1, #84]	; 0x54
90011aac:	e001      	b.n	90011ab2 <HAL_RCCEx_PeriphCLKConfig+0x852>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011aae:	7dfb      	ldrb	r3, [r7, #23]
90011ab0:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
90011ab2:	687b      	ldr	r3, [r7, #4]
90011ab4:	681b      	ldr	r3, [r3, #0]
90011ab6:	f003 0302 	and.w	r3, r3, #2
90011aba:	2b00      	cmp	r3, #0
90011abc:	d03e      	beq.n	90011b3c <HAL_RCCEx_PeriphCLKConfig+0x8dc>
  {
    switch(PeriphClkInit->Usart234578ClockSelection)
90011abe:	687b      	ldr	r3, [r7, #4]
90011ac0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
90011ac2:	2b05      	cmp	r3, #5
90011ac4:	d820      	bhi.n	90011b08 <HAL_RCCEx_PeriphCLKConfig+0x8a8>
90011ac6:	a201      	add	r2, pc, #4	; (adr r2, 90011acc <HAL_RCCEx_PeriphCLKConfig+0x86c>)
90011ac8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90011acc:	90011b0f 	.word	0x90011b0f
90011ad0:	90011ae5 	.word	0x90011ae5
90011ad4:	90011af7 	.word	0x90011af7
90011ad8:	90011b0f 	.word	0x90011b0f
90011adc:	90011b0f 	.word	0x90011b0f
90011ae0:	90011b0f 	.word	0x90011b0f
    case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
90011ae4:	687b      	ldr	r3, [r7, #4]
90011ae6:	3304      	adds	r3, #4
90011ae8:	2101      	movs	r1, #1
90011aea:	4618      	mov	r0, r3
90011aec:	f001 fd46 	bl	9001357c <RCCEx_PLL2_Config>
90011af0:	4603      	mov	r3, r0
90011af2:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
90011af4:	e00c      	b.n	90011b10 <HAL_RCCEx_PeriphCLKConfig+0x8b0>

    case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
90011af6:	687b      	ldr	r3, [r7, #4]
90011af8:	3324      	adds	r3, #36	; 0x24
90011afa:	2101      	movs	r1, #1
90011afc:	4618      	mov	r0, r3
90011afe:	f001 fdef 	bl	900136e0 <RCCEx_PLL3_Config>
90011b02:	4603      	mov	r3, r0
90011b04:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
90011b06:	e003      	b.n	90011b10 <HAL_RCCEx_PeriphCLKConfig+0x8b0>
      /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
90011b08:	2301      	movs	r3, #1
90011b0a:	75fb      	strb	r3, [r7, #23]
      break;
90011b0c:	e000      	b.n	90011b10 <HAL_RCCEx_PeriphCLKConfig+0x8b0>
      break;
90011b0e:	bf00      	nop
    }

    if(ret == HAL_OK)
90011b10:	7dfb      	ldrb	r3, [r7, #23]
90011b12:	2b00      	cmp	r3, #0
90011b14:	d110      	bne.n	90011b38 <HAL_RCCEx_PeriphCLKConfig+0x8d8>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
90011b16:	4b05      	ldr	r3, [pc, #20]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011b18:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90011b1a:	f023 0207 	bic.w	r2, r3, #7
90011b1e:	687b      	ldr	r3, [r7, #4]
90011b20:	6f5b      	ldr	r3, [r3, #116]	; 0x74
90011b22:	4902      	ldr	r1, [pc, #8]	; (90011b2c <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
90011b24:	4313      	orrs	r3, r2
90011b26:	654b      	str	r3, [r1, #84]	; 0x54
90011b28:	e008      	b.n	90011b3c <HAL_RCCEx_PeriphCLKConfig+0x8dc>
90011b2a:	bf00      	nop
90011b2c:	58024400 	.word	0x58024400
90011b30:	58024800 	.word	0x58024800
90011b34:	00ffffcf 	.word	0x00ffffcf
    }
    else
    {
      /* set overall return value */
      status = ret;
90011b38:	7dfb      	ldrb	r3, [r7, #23]
90011b3a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
90011b3c:	687b      	ldr	r3, [r7, #4]
90011b3e:	681b      	ldr	r3, [r3, #0]
90011b40:	f003 0304 	and.w	r3, r3, #4
90011b44:	2b00      	cmp	r3, #0
90011b46:	d039      	beq.n	90011bbc <HAL_RCCEx_PeriphCLKConfig+0x95c>
  {
    switch(PeriphClkInit->Lpuart1ClockSelection)
90011b48:	687b      	ldr	r3, [r7, #4]
90011b4a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90011b4e:	2b05      	cmp	r3, #5
90011b50:	d820      	bhi.n	90011b94 <HAL_RCCEx_PeriphCLKConfig+0x934>
90011b52:	a201      	add	r2, pc, #4	; (adr r2, 90011b58 <HAL_RCCEx_PeriphCLKConfig+0x8f8>)
90011b54:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90011b58:	90011b9b 	.word	0x90011b9b
90011b5c:	90011b71 	.word	0x90011b71
90011b60:	90011b83 	.word	0x90011b83
90011b64:	90011b9b 	.word	0x90011b9b
90011b68:	90011b9b 	.word	0x90011b9b
90011b6c:	90011b9b 	.word	0x90011b9b
    case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
90011b70:	687b      	ldr	r3, [r7, #4]
90011b72:	3304      	adds	r3, #4
90011b74:	2101      	movs	r1, #1
90011b76:	4618      	mov	r0, r3
90011b78:	f001 fd00 	bl	9001357c <RCCEx_PLL2_Config>
90011b7c:	4603      	mov	r3, r0
90011b7e:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
90011b80:	e00c      	b.n	90011b9c <HAL_RCCEx_PeriphCLKConfig+0x93c>

    case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
90011b82:	687b      	ldr	r3, [r7, #4]
90011b84:	3324      	adds	r3, #36	; 0x24
90011b86:	2101      	movs	r1, #1
90011b88:	4618      	mov	r0, r3
90011b8a:	f001 fda9 	bl	900136e0 <RCCEx_PLL3_Config>
90011b8e:	4603      	mov	r3, r0
90011b90:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
90011b92:	e003      	b.n	90011b9c <HAL_RCCEx_PeriphCLKConfig+0x93c>
      /* LSE,  oscillator is used as source of LPUART1 clock */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
90011b94:	2301      	movs	r3, #1
90011b96:	75fb      	strb	r3, [r7, #23]
      break;
90011b98:	e000      	b.n	90011b9c <HAL_RCCEx_PeriphCLKConfig+0x93c>
      break;
90011b9a:	bf00      	nop
    }

    if(ret == HAL_OK)
90011b9c:	7dfb      	ldrb	r3, [r7, #23]
90011b9e:	2b00      	cmp	r3, #0
90011ba0:	d10a      	bne.n	90011bb8 <HAL_RCCEx_PeriphCLKConfig+0x958>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
90011ba2:	4bb7      	ldr	r3, [pc, #732]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011ba4:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90011ba6:	f023 0207 	bic.w	r2, r3, #7
90011baa:	687b      	ldr	r3, [r7, #4]
90011bac:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
90011bb0:	49b3      	ldr	r1, [pc, #716]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011bb2:	4313      	orrs	r3, r2
90011bb4:	658b      	str	r3, [r1, #88]	; 0x58
90011bb6:	e001      	b.n	90011bbc <HAL_RCCEx_PeriphCLKConfig+0x95c>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011bb8:	7dfb      	ldrb	r3, [r7, #23]
90011bba:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
90011bbc:	687b      	ldr	r3, [r7, #4]
90011bbe:	681b      	ldr	r3, [r3, #0]
90011bc0:	f003 0320 	and.w	r3, r3, #32
90011bc4:	2b00      	cmp	r3, #0
90011bc6:	d04b      	beq.n	90011c60 <HAL_RCCEx_PeriphCLKConfig+0xa00>
  {
    switch(PeriphClkInit->Lptim1ClockSelection)
90011bc8:	687b      	ldr	r3, [r7, #4]
90011bca:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90011bce:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
90011bd2:	d02e      	beq.n	90011c32 <HAL_RCCEx_PeriphCLKConfig+0x9d2>
90011bd4:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
90011bd8:	d828      	bhi.n	90011c2c <HAL_RCCEx_PeriphCLKConfig+0x9cc>
90011bda:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
90011bde:	d02a      	beq.n	90011c36 <HAL_RCCEx_PeriphCLKConfig+0x9d6>
90011be0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
90011be4:	d822      	bhi.n	90011c2c <HAL_RCCEx_PeriphCLKConfig+0x9cc>
90011be6:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
90011bea:	d026      	beq.n	90011c3a <HAL_RCCEx_PeriphCLKConfig+0x9da>
90011bec:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
90011bf0:	d81c      	bhi.n	90011c2c <HAL_RCCEx_PeriphCLKConfig+0x9cc>
90011bf2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90011bf6:	d010      	beq.n	90011c1a <HAL_RCCEx_PeriphCLKConfig+0x9ba>
90011bf8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90011bfc:	d816      	bhi.n	90011c2c <HAL_RCCEx_PeriphCLKConfig+0x9cc>
90011bfe:	2b00      	cmp	r3, #0
90011c00:	d01d      	beq.n	90011c3e <HAL_RCCEx_PeriphCLKConfig+0x9de>
90011c02:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
90011c06:	d111      	bne.n	90011c2c <HAL_RCCEx_PeriphCLKConfig+0x9cc>
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
90011c08:	687b      	ldr	r3, [r7, #4]
90011c0a:	3304      	adds	r3, #4
90011c0c:	2100      	movs	r1, #0
90011c0e:	4618      	mov	r0, r3
90011c10:	f001 fcb4 	bl	9001357c <RCCEx_PLL2_Config>
90011c14:	4603      	mov	r3, r0
90011c16:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
90011c18:	e012      	b.n	90011c40 <HAL_RCCEx_PeriphCLKConfig+0x9e0>

    case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
90011c1a:	687b      	ldr	r3, [r7, #4]
90011c1c:	3324      	adds	r3, #36	; 0x24
90011c1e:	2102      	movs	r1, #2
90011c20:	4618      	mov	r0, r3
90011c22:	f001 fd5d 	bl	900136e0 <RCCEx_PLL3_Config>
90011c26:	4603      	mov	r3, r0
90011c28:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
90011c2a:	e009      	b.n	90011c40 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
90011c2c:	2301      	movs	r3, #1
90011c2e:	75fb      	strb	r3, [r7, #23]
      break;
90011c30:	e006      	b.n	90011c40 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      break;
90011c32:	bf00      	nop
90011c34:	e004      	b.n	90011c40 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      break;
90011c36:	bf00      	nop
90011c38:	e002      	b.n	90011c40 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      break;
90011c3a:	bf00      	nop
90011c3c:	e000      	b.n	90011c40 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      break;
90011c3e:	bf00      	nop
    }

    if(ret == HAL_OK)
90011c40:	7dfb      	ldrb	r3, [r7, #23]
90011c42:	2b00      	cmp	r3, #0
90011c44:	d10a      	bne.n	90011c5c <HAL_RCCEx_PeriphCLKConfig+0x9fc>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
90011c46:	4b8e      	ldr	r3, [pc, #568]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011c48:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90011c4a:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
90011c4e:	687b      	ldr	r3, [r7, #4]
90011c50:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
90011c54:	498a      	ldr	r1, [pc, #552]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011c56:	4313      	orrs	r3, r2
90011c58:	654b      	str	r3, [r1, #84]	; 0x54
90011c5a:	e001      	b.n	90011c60 <HAL_RCCEx_PeriphCLKConfig+0xa00>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011c5c:	7dfb      	ldrb	r3, [r7, #23]
90011c5e:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
90011c60:	687b      	ldr	r3, [r7, #4]
90011c62:	681b      	ldr	r3, [r3, #0]
90011c64:	f003 0340 	and.w	r3, r3, #64	; 0x40
90011c68:	2b00      	cmp	r3, #0
90011c6a:	d04b      	beq.n	90011d04 <HAL_RCCEx_PeriphCLKConfig+0xaa4>
  {
    switch(PeriphClkInit->Lptim2ClockSelection)
90011c6c:	687b      	ldr	r3, [r7, #4]
90011c6e:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
90011c72:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
90011c76:	d02e      	beq.n	90011cd6 <HAL_RCCEx_PeriphCLKConfig+0xa76>
90011c78:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
90011c7c:	d828      	bhi.n	90011cd0 <HAL_RCCEx_PeriphCLKConfig+0xa70>
90011c7e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
90011c82:	d02a      	beq.n	90011cda <HAL_RCCEx_PeriphCLKConfig+0xa7a>
90011c84:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
90011c88:	d822      	bhi.n	90011cd0 <HAL_RCCEx_PeriphCLKConfig+0xa70>
90011c8a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
90011c8e:	d026      	beq.n	90011cde <HAL_RCCEx_PeriphCLKConfig+0xa7e>
90011c90:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
90011c94:	d81c      	bhi.n	90011cd0 <HAL_RCCEx_PeriphCLKConfig+0xa70>
90011c96:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
90011c9a:	d010      	beq.n	90011cbe <HAL_RCCEx_PeriphCLKConfig+0xa5e>
90011c9c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
90011ca0:	d816      	bhi.n	90011cd0 <HAL_RCCEx_PeriphCLKConfig+0xa70>
90011ca2:	2b00      	cmp	r3, #0
90011ca4:	d01d      	beq.n	90011ce2 <HAL_RCCEx_PeriphCLKConfig+0xa82>
90011ca6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
90011caa:	d111      	bne.n	90011cd0 <HAL_RCCEx_PeriphCLKConfig+0xa70>
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
90011cac:	687b      	ldr	r3, [r7, #4]
90011cae:	3304      	adds	r3, #4
90011cb0:	2100      	movs	r1, #0
90011cb2:	4618      	mov	r0, r3
90011cb4:	f001 fc62 	bl	9001357c <RCCEx_PLL2_Config>
90011cb8:	4603      	mov	r3, r0
90011cba:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
90011cbc:	e012      	b.n	90011ce4 <HAL_RCCEx_PeriphCLKConfig+0xa84>

    case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
90011cbe:	687b      	ldr	r3, [r7, #4]
90011cc0:	3324      	adds	r3, #36	; 0x24
90011cc2:	2102      	movs	r1, #2
90011cc4:	4618      	mov	r0, r3
90011cc6:	f001 fd0b 	bl	900136e0 <RCCEx_PLL3_Config>
90011cca:	4603      	mov	r3, r0
90011ccc:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
90011cce:	e009      	b.n	90011ce4 <HAL_RCCEx_PeriphCLKConfig+0xa84>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
90011cd0:	2301      	movs	r3, #1
90011cd2:	75fb      	strb	r3, [r7, #23]
      break;
90011cd4:	e006      	b.n	90011ce4 <HAL_RCCEx_PeriphCLKConfig+0xa84>
      break;
90011cd6:	bf00      	nop
90011cd8:	e004      	b.n	90011ce4 <HAL_RCCEx_PeriphCLKConfig+0xa84>
      break;
90011cda:	bf00      	nop
90011cdc:	e002      	b.n	90011ce4 <HAL_RCCEx_PeriphCLKConfig+0xa84>
      break;
90011cde:	bf00      	nop
90011ce0:	e000      	b.n	90011ce4 <HAL_RCCEx_PeriphCLKConfig+0xa84>
      break;
90011ce2:	bf00      	nop
    }

    if(ret == HAL_OK)
90011ce4:	7dfb      	ldrb	r3, [r7, #23]
90011ce6:	2b00      	cmp	r3, #0
90011ce8:	d10a      	bne.n	90011d00 <HAL_RCCEx_PeriphCLKConfig+0xaa0>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
90011cea:	4b65      	ldr	r3, [pc, #404]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011cec:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90011cee:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
90011cf2:	687b      	ldr	r3, [r7, #4]
90011cf4:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
90011cf8:	4961      	ldr	r1, [pc, #388]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011cfa:	4313      	orrs	r3, r2
90011cfc:	658b      	str	r3, [r1, #88]	; 0x58
90011cfe:	e001      	b.n	90011d04 <HAL_RCCEx_PeriphCLKConfig+0xaa4>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011d00:	7dfb      	ldrb	r3, [r7, #23]
90011d02:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
90011d04:	687b      	ldr	r3, [r7, #4]
90011d06:	681b      	ldr	r3, [r3, #0]
90011d08:	f003 0380 	and.w	r3, r3, #128	; 0x80
90011d0c:	2b00      	cmp	r3, #0
90011d0e:	d04b      	beq.n	90011da8 <HAL_RCCEx_PeriphCLKConfig+0xb48>
  {
    switch(PeriphClkInit->Lptim345ClockSelection)
90011d10:	687b      	ldr	r3, [r7, #4]
90011d12:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
90011d16:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
90011d1a:	d02e      	beq.n	90011d7a <HAL_RCCEx_PeriphCLKConfig+0xb1a>
90011d1c:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
90011d20:	d828      	bhi.n	90011d74 <HAL_RCCEx_PeriphCLKConfig+0xb14>
90011d22:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
90011d26:	d02a      	beq.n	90011d7e <HAL_RCCEx_PeriphCLKConfig+0xb1e>
90011d28:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
90011d2c:	d822      	bhi.n	90011d74 <HAL_RCCEx_PeriphCLKConfig+0xb14>
90011d2e:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
90011d32:	d026      	beq.n	90011d82 <HAL_RCCEx_PeriphCLKConfig+0xb22>
90011d34:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
90011d38:	d81c      	bhi.n	90011d74 <HAL_RCCEx_PeriphCLKConfig+0xb14>
90011d3a:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
90011d3e:	d010      	beq.n	90011d62 <HAL_RCCEx_PeriphCLKConfig+0xb02>
90011d40:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
90011d44:	d816      	bhi.n	90011d74 <HAL_RCCEx_PeriphCLKConfig+0xb14>
90011d46:	2b00      	cmp	r3, #0
90011d48:	d01d      	beq.n	90011d86 <HAL_RCCEx_PeriphCLKConfig+0xb26>
90011d4a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
90011d4e:	d111      	bne.n	90011d74 <HAL_RCCEx_PeriphCLKConfig+0xb14>
    case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
90011d50:	687b      	ldr	r3, [r7, #4]
90011d52:	3304      	adds	r3, #4
90011d54:	2100      	movs	r1, #0
90011d56:	4618      	mov	r0, r3
90011d58:	f001 fc10 	bl	9001357c <RCCEx_PLL2_Config>
90011d5c:	4603      	mov	r3, r0
90011d5e:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
90011d60:	e012      	b.n	90011d88 <HAL_RCCEx_PeriphCLKConfig+0xb28>

    case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
90011d62:	687b      	ldr	r3, [r7, #4]
90011d64:	3324      	adds	r3, #36	; 0x24
90011d66:	2102      	movs	r1, #2
90011d68:	4618      	mov	r0, r3
90011d6a:	f001 fcb9 	bl	900136e0 <RCCEx_PLL3_Config>
90011d6e:	4603      	mov	r3, r0
90011d70:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
90011d72:	e009      	b.n	90011d88 <HAL_RCCEx_PeriphCLKConfig+0xb28>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
90011d74:	2301      	movs	r3, #1
90011d76:	75fb      	strb	r3, [r7, #23]
      break;
90011d78:	e006      	b.n	90011d88 <HAL_RCCEx_PeriphCLKConfig+0xb28>
      break;
90011d7a:	bf00      	nop
90011d7c:	e004      	b.n	90011d88 <HAL_RCCEx_PeriphCLKConfig+0xb28>
      break;
90011d7e:	bf00      	nop
90011d80:	e002      	b.n	90011d88 <HAL_RCCEx_PeriphCLKConfig+0xb28>
      break;
90011d82:	bf00      	nop
90011d84:	e000      	b.n	90011d88 <HAL_RCCEx_PeriphCLKConfig+0xb28>
      break;
90011d86:	bf00      	nop
    }

    if(ret == HAL_OK)
90011d88:	7dfb      	ldrb	r3, [r7, #23]
90011d8a:	2b00      	cmp	r3, #0
90011d8c:	d10a      	bne.n	90011da4 <HAL_RCCEx_PeriphCLKConfig+0xb44>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
90011d8e:	4b3c      	ldr	r3, [pc, #240]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011d90:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90011d92:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
90011d96:	687b      	ldr	r3, [r7, #4]
90011d98:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
90011d9c:	4938      	ldr	r1, [pc, #224]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011d9e:	4313      	orrs	r3, r2
90011da0:	658b      	str	r3, [r1, #88]	; 0x58
90011da2:	e001      	b.n	90011da8 <HAL_RCCEx_PeriphCLKConfig+0xb48>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011da4:	7dfb      	ldrb	r3, [r7, #23]
90011da6:	75bb      	strb	r3, [r7, #22]

      __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);

  }
#else
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
90011da8:	687b      	ldr	r3, [r7, #4]
90011daa:	681b      	ldr	r3, [r3, #0]
90011dac:	f003 0308 	and.w	r3, r3, #8
90011db0:	2b00      	cmp	r3, #0
90011db2:	d01a      	beq.n	90011dea <HAL_RCCEx_PeriphCLKConfig+0xb8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
90011db4:	687b      	ldr	r3, [r7, #4]
90011db6:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
90011dba:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
90011dbe:	d10a      	bne.n	90011dd6 <HAL_RCCEx_PeriphCLKConfig+0xb76>
    {
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
90011dc0:	687b      	ldr	r3, [r7, #4]
90011dc2:	3324      	adds	r3, #36	; 0x24
90011dc4:	2102      	movs	r1, #2
90011dc6:	4618      	mov	r0, r3
90011dc8:	f001 fc8a 	bl	900136e0 <RCCEx_PLL3_Config>
90011dcc:	4603      	mov	r3, r0
90011dce:	2b00      	cmp	r3, #0
90011dd0:	d001      	beq.n	90011dd6 <HAL_RCCEx_PeriphCLKConfig+0xb76>
        {
          status = HAL_ERROR;
90011dd2:	2301      	movs	r3, #1
90011dd4:	75bb      	strb	r3, [r7, #22]
        }
    }

      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
90011dd6:	4b2a      	ldr	r3, [pc, #168]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011dd8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90011dda:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
90011dde:	687b      	ldr	r3, [r7, #4]
90011de0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
90011de4:	4926      	ldr	r1, [pc, #152]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011de6:	4313      	orrs	r3, r2
90011de8:	654b      	str	r3, [r1, #84]	; 0x54

  }
#endif /* I2C5 */

  /*------------------------------ I2C4 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
90011dea:	687b      	ldr	r3, [r7, #4]
90011dec:	681b      	ldr	r3, [r3, #0]
90011dee:	f003 0310 	and.w	r3, r3, #16
90011df2:	2b00      	cmp	r3, #0
90011df4:	d01a      	beq.n	90011e2c <HAL_RCCEx_PeriphCLKConfig+0xbcc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
90011df6:	687b      	ldr	r3, [r7, #4]
90011df8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
90011dfc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90011e00:	d10a      	bne.n	90011e18 <HAL_RCCEx_PeriphCLKConfig+0xbb8>
    {
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
90011e02:	687b      	ldr	r3, [r7, #4]
90011e04:	3324      	adds	r3, #36	; 0x24
90011e06:	2102      	movs	r1, #2
90011e08:	4618      	mov	r0, r3
90011e0a:	f001 fc69 	bl	900136e0 <RCCEx_PLL3_Config>
90011e0e:	4603      	mov	r3, r0
90011e10:	2b00      	cmp	r3, #0
90011e12:	d001      	beq.n	90011e18 <HAL_RCCEx_PeriphCLKConfig+0xbb8>
      {
        status = HAL_ERROR;
90011e14:	2301      	movs	r3, #1
90011e16:	75bb      	strb	r3, [r7, #22]
      }
    }

      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
90011e18:	4b19      	ldr	r3, [pc, #100]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011e1a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90011e1c:	f423 7240 	bic.w	r2, r3, #768	; 0x300
90011e20:	687b      	ldr	r3, [r7, #4]
90011e22:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
90011e26:	4916      	ldr	r1, [pc, #88]	; (90011e80 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
90011e28:	4313      	orrs	r3, r2
90011e2a:	658b      	str	r3, [r1, #88]	; 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
90011e2c:	687b      	ldr	r3, [r7, #4]
90011e2e:	681b      	ldr	r3, [r3, #0]
90011e30:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
90011e34:	2b00      	cmp	r3, #0
90011e36:	d036      	beq.n	90011ea6 <HAL_RCCEx_PeriphCLKConfig+0xc46>
  {
    switch(PeriphClkInit->AdcClockSelection)
90011e38:	687b      	ldr	r3, [r7, #4]
90011e3a:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
90011e3e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90011e42:	d01f      	beq.n	90011e84 <HAL_RCCEx_PeriphCLKConfig+0xc24>
90011e44:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90011e48:	d817      	bhi.n	90011e7a <HAL_RCCEx_PeriphCLKConfig+0xc1a>
90011e4a:	2b00      	cmp	r3, #0
90011e4c:	d003      	beq.n	90011e56 <HAL_RCCEx_PeriphCLKConfig+0xbf6>
90011e4e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
90011e52:	d009      	beq.n	90011e68 <HAL_RCCEx_PeriphCLKConfig+0xc08>
90011e54:	e011      	b.n	90011e7a <HAL_RCCEx_PeriphCLKConfig+0xc1a>
    {

    case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
90011e56:	687b      	ldr	r3, [r7, #4]
90011e58:	3304      	adds	r3, #4
90011e5a:	2100      	movs	r1, #0
90011e5c:	4618      	mov	r0, r3
90011e5e:	f001 fb8d 	bl	9001357c <RCCEx_PLL2_Config>
90011e62:	4603      	mov	r3, r0
90011e64:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
90011e66:	e00e      	b.n	90011e86 <HAL_RCCEx_PeriphCLKConfig+0xc26>

    case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
90011e68:	687b      	ldr	r3, [r7, #4]
90011e6a:	3324      	adds	r3, #36	; 0x24
90011e6c:	2102      	movs	r1, #2
90011e6e:	4618      	mov	r0, r3
90011e70:	f001 fc36 	bl	900136e0 <RCCEx_PLL3_Config>
90011e74:	4603      	mov	r3, r0
90011e76:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
90011e78:	e005      	b.n	90011e86 <HAL_RCCEx_PeriphCLKConfig+0xc26>
      /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
      /* ADC clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
90011e7a:	2301      	movs	r3, #1
90011e7c:	75fb      	strb	r3, [r7, #23]
      break;
90011e7e:	e002      	b.n	90011e86 <HAL_RCCEx_PeriphCLKConfig+0xc26>
90011e80:	58024400 	.word	0x58024400
      break;
90011e84:	bf00      	nop
    }

    if(ret == HAL_OK)
90011e86:	7dfb      	ldrb	r3, [r7, #23]
90011e88:	2b00      	cmp	r3, #0
90011e8a:	d10a      	bne.n	90011ea2 <HAL_RCCEx_PeriphCLKConfig+0xc42>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
90011e8c:	4b93      	ldr	r3, [pc, #588]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011e8e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90011e90:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
90011e94:	687b      	ldr	r3, [r7, #4]
90011e96:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
90011e9a:	4990      	ldr	r1, [pc, #576]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011e9c:	4313      	orrs	r3, r2
90011e9e:	658b      	str	r3, [r1, #88]	; 0x58
90011ea0:	e001      	b.n	90011ea6 <HAL_RCCEx_PeriphCLKConfig+0xc46>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011ea2:	7dfb      	ldrb	r3, [r7, #23]
90011ea4:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
90011ea6:	687b      	ldr	r3, [r7, #4]
90011ea8:	681b      	ldr	r3, [r3, #0]
90011eaa:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
90011eae:	2b00      	cmp	r3, #0
90011eb0:	d033      	beq.n	90011f1a <HAL_RCCEx_PeriphCLKConfig+0xcba>
  {

    switch(PeriphClkInit->UsbClockSelection)
90011eb2:	687b      	ldr	r3, [r7, #4]
90011eb4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90011eb8:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
90011ebc:	d01c      	beq.n	90011ef8 <HAL_RCCEx_PeriphCLKConfig+0xc98>
90011ebe:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
90011ec2:	d816      	bhi.n	90011ef2 <HAL_RCCEx_PeriphCLKConfig+0xc92>
90011ec4:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
90011ec8:	d003      	beq.n	90011ed2 <HAL_RCCEx_PeriphCLKConfig+0xc72>
90011eca:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
90011ece:	d007      	beq.n	90011ee0 <HAL_RCCEx_PeriphCLKConfig+0xc80>
90011ed0:	e00f      	b.n	90011ef2 <HAL_RCCEx_PeriphCLKConfig+0xc92>
    {
    case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
      /* Enable USB Clock output generated form System USB . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90011ed2:	4b82      	ldr	r3, [pc, #520]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011ed4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90011ed6:	4a81      	ldr	r2, [pc, #516]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011ed8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90011edc:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* USB clock source configuration done later after clock selection check */
      break;
90011ede:	e00c      	b.n	90011efa <HAL_RCCEx_PeriphCLKConfig+0xc9a>

    case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
90011ee0:	687b      	ldr	r3, [r7, #4]
90011ee2:	3324      	adds	r3, #36	; 0x24
90011ee4:	2101      	movs	r1, #1
90011ee6:	4618      	mov	r0, r3
90011ee8:	f001 fbfa 	bl	900136e0 <RCCEx_PLL3_Config>
90011eec:	4603      	mov	r3, r0
90011eee:	75fb      	strb	r3, [r7, #23]

      /* USB clock source configuration done later after clock selection check */
      break;
90011ef0:	e003      	b.n	90011efa <HAL_RCCEx_PeriphCLKConfig+0xc9a>
      /* HSI48 oscillator is used as source of USB clock */
      /* USB clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
90011ef2:	2301      	movs	r3, #1
90011ef4:	75fb      	strb	r3, [r7, #23]
      break;
90011ef6:	e000      	b.n	90011efa <HAL_RCCEx_PeriphCLKConfig+0xc9a>
      break;
90011ef8:	bf00      	nop
    }

    if(ret == HAL_OK)
90011efa:	7dfb      	ldrb	r3, [r7, #23]
90011efc:	2b00      	cmp	r3, #0
90011efe:	d10a      	bne.n	90011f16 <HAL_RCCEx_PeriphCLKConfig+0xcb6>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
90011f00:	4b76      	ldr	r3, [pc, #472]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011f02:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90011f04:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
90011f08:	687b      	ldr	r3, [r7, #4]
90011f0a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90011f0e:	4973      	ldr	r1, [pc, #460]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011f10:	4313      	orrs	r3, r2
90011f12:	654b      	str	r3, [r1, #84]	; 0x54
90011f14:	e001      	b.n	90011f1a <HAL_RCCEx_PeriphCLKConfig+0xcba>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011f16:	7dfb      	ldrb	r3, [r7, #23]
90011f18:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
90011f1a:	687b      	ldr	r3, [r7, #4]
90011f1c:	681b      	ldr	r3, [r3, #0]
90011f1e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
90011f22:	2b00      	cmp	r3, #0
90011f24:	d029      	beq.n	90011f7a <HAL_RCCEx_PeriphCLKConfig+0xd1a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch(PeriphClkInit->SdmmcClockSelection)
90011f26:	687b      	ldr	r3, [r7, #4]
90011f28:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90011f2a:	2b00      	cmp	r3, #0
90011f2c:	d003      	beq.n	90011f36 <HAL_RCCEx_PeriphCLKConfig+0xcd6>
90011f2e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
90011f32:	d007      	beq.n	90011f44 <HAL_RCCEx_PeriphCLKConfig+0xce4>
90011f34:	e00f      	b.n	90011f56 <HAL_RCCEx_PeriphCLKConfig+0xcf6>
    {
    case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
      /* Enable SDMMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90011f36:	4b69      	ldr	r3, [pc, #420]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011f38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90011f3a:	4a68      	ldr	r2, [pc, #416]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011f3c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90011f40:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SDMMC clock source configuration done later after clock selection check */
      break;
90011f42:	e00b      	b.n	90011f5c <HAL_RCCEx_PeriphCLKConfig+0xcfc>

    case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
90011f44:	687b      	ldr	r3, [r7, #4]
90011f46:	3304      	adds	r3, #4
90011f48:	2102      	movs	r1, #2
90011f4a:	4618      	mov	r0, r3
90011f4c:	f001 fb16 	bl	9001357c <RCCEx_PLL2_Config>
90011f50:	4603      	mov	r3, r0
90011f52:	75fb      	strb	r3, [r7, #23]

      /* SDMMC clock source configuration done later after clock selection check */
      break;
90011f54:	e002      	b.n	90011f5c <HAL_RCCEx_PeriphCLKConfig+0xcfc>

    default:
      ret = HAL_ERROR;
90011f56:	2301      	movs	r3, #1
90011f58:	75fb      	strb	r3, [r7, #23]
      break;
90011f5a:	bf00      	nop
    }

    if(ret == HAL_OK)
90011f5c:	7dfb      	ldrb	r3, [r7, #23]
90011f5e:	2b00      	cmp	r3, #0
90011f60:	d109      	bne.n	90011f76 <HAL_RCCEx_PeriphCLKConfig+0xd16>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
90011f62:	4b5e      	ldr	r3, [pc, #376]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011f64:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90011f66:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
90011f6a:	687b      	ldr	r3, [r7, #4]
90011f6c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90011f6e:	495b      	ldr	r1, [pc, #364]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011f70:	4313      	orrs	r3, r2
90011f72:	64cb      	str	r3, [r1, #76]	; 0x4c
90011f74:	e001      	b.n	90011f7a <HAL_RCCEx_PeriphCLKConfig+0xd1a>
    }
    else
    {
      /* set overall return value */
      status = ret;
90011f76:	7dfb      	ldrb	r3, [r7, #23]
90011f78:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
90011f7a:	687b      	ldr	r3, [r7, #4]
90011f7c:	681b      	ldr	r3, [r3, #0]
90011f7e:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
90011f82:	2b00      	cmp	r3, #0
90011f84:	d00a      	beq.n	90011f9c <HAL_RCCEx_PeriphCLKConfig+0xd3c>
  {
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
90011f86:	687b      	ldr	r3, [r7, #4]
90011f88:	3324      	adds	r3, #36	; 0x24
90011f8a:	2102      	movs	r1, #2
90011f8c:	4618      	mov	r0, r3
90011f8e:	f001 fba7 	bl	900136e0 <RCCEx_PLL3_Config>
90011f92:	4603      	mov	r3, r0
90011f94:	2b00      	cmp	r3, #0
90011f96:	d001      	beq.n	90011f9c <HAL_RCCEx_PeriphCLKConfig+0xd3c>
    {
      status=HAL_ERROR;
90011f98:	2301      	movs	r3, #1
90011f9a:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
90011f9c:	687b      	ldr	r3, [r7, #4]
90011f9e:	681b      	ldr	r3, [r3, #0]
90011fa0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90011fa4:	2b00      	cmp	r3, #0
90011fa6:	d030      	beq.n	9001200a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
  {

    switch(PeriphClkInit->RngClockSelection)
90011fa8:	687b      	ldr	r3, [r7, #4]
90011faa:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
90011fac:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
90011fb0:	d017      	beq.n	90011fe2 <HAL_RCCEx_PeriphCLKConfig+0xd82>
90011fb2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
90011fb6:	d811      	bhi.n	90011fdc <HAL_RCCEx_PeriphCLKConfig+0xd7c>
90011fb8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
90011fbc:	d013      	beq.n	90011fe6 <HAL_RCCEx_PeriphCLKConfig+0xd86>
90011fbe:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
90011fc2:	d80b      	bhi.n	90011fdc <HAL_RCCEx_PeriphCLKConfig+0xd7c>
90011fc4:	2b00      	cmp	r3, #0
90011fc6:	d010      	beq.n	90011fea <HAL_RCCEx_PeriphCLKConfig+0xd8a>
90011fc8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90011fcc:	d106      	bne.n	90011fdc <HAL_RCCEx_PeriphCLKConfig+0xd7c>
    {
    case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
      /* Enable RNG Clock output generated form System RNG . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
90011fce:	4b43      	ldr	r3, [pc, #268]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011fd0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90011fd2:	4a42      	ldr	r2, [pc, #264]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011fd4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
90011fd8:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* RNG clock source configuration done later after clock selection check */
      break;
90011fda:	e007      	b.n	90011fec <HAL_RCCEx_PeriphCLKConfig+0xd8c>
      /* HSI48 oscillator is used as source of RNG clock */
      /* RNG clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
90011fdc:	2301      	movs	r3, #1
90011fde:	75fb      	strb	r3, [r7, #23]
      break;
90011fe0:	e004      	b.n	90011fec <HAL_RCCEx_PeriphCLKConfig+0xd8c>
      break;
90011fe2:	bf00      	nop
90011fe4:	e002      	b.n	90011fec <HAL_RCCEx_PeriphCLKConfig+0xd8c>
      break;
90011fe6:	bf00      	nop
90011fe8:	e000      	b.n	90011fec <HAL_RCCEx_PeriphCLKConfig+0xd8c>
      break;
90011fea:	bf00      	nop
    }

    if(ret == HAL_OK)
90011fec:	7dfb      	ldrb	r3, [r7, #23]
90011fee:	2b00      	cmp	r3, #0
90011ff0:	d109      	bne.n	90012006 <HAL_RCCEx_PeriphCLKConfig+0xda6>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
90011ff2:	4b3a      	ldr	r3, [pc, #232]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90011ff4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90011ff6:	f423 7240 	bic.w	r2, r3, #768	; 0x300
90011ffa:	687b      	ldr	r3, [r7, #4]
90011ffc:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
90011ffe:	4937      	ldr	r1, [pc, #220]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012000:	4313      	orrs	r3, r2
90012002:	654b      	str	r3, [r1, #84]	; 0x54
90012004:	e001      	b.n	9001200a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    }
    else
    {
      /* set overall return value */
      status = ret;
90012006:	7dfb      	ldrb	r3, [r7, #23]
90012008:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
9001200a:	687b      	ldr	r3, [r7, #4]
9001200c:	681b      	ldr	r3, [r3, #0]
9001200e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
90012012:	2b00      	cmp	r3, #0
90012014:	d008      	beq.n	90012028 <HAL_RCCEx_PeriphCLKConfig+0xdc8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
90012016:	4b31      	ldr	r3, [pc, #196]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012018:	6d1b      	ldr	r3, [r3, #80]	; 0x50
9001201a:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
9001201e:	687b      	ldr	r3, [r7, #4]
90012020:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90012022:	492e      	ldr	r1, [pc, #184]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012024:	4313      	orrs	r3, r2
90012026:	650b      	str	r3, [r1, #80]	; 0x50
  }
#if defined(HRTIM1)
  /*------------------------------ HRTIM1 clock Configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
90012028:	687b      	ldr	r3, [r7, #4]
9001202a:	681b      	ldr	r3, [r3, #0]
9001202c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
90012030:	2b00      	cmp	r3, #0
90012032:	d009      	beq.n	90012048 <HAL_RCCEx_PeriphCLKConfig+0xde8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));

    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
90012034:	4b29      	ldr	r3, [pc, #164]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012036:	691b      	ldr	r3, [r3, #16]
90012038:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
9001203c:	687b      	ldr	r3, [r7, #4]
9001203e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
90012042:	4926      	ldr	r1, [pc, #152]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012044:	4313      	orrs	r3, r2
90012046:	610b      	str	r3, [r1, #16]
  }
#endif  /*HRTIM1*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
90012048:	687b      	ldr	r3, [r7, #4]
9001204a:	681b      	ldr	r3, [r3, #0]
9001204c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
90012050:	2b00      	cmp	r3, #0
90012052:	d008      	beq.n	90012066 <HAL_RCCEx_PeriphCLKConfig+0xe06>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
90012054:	4b21      	ldr	r3, [pc, #132]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012056:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90012058:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
9001205c:	687b      	ldr	r3, [r7, #4]
9001205e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
90012060:	491e      	ldr	r1, [pc, #120]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012062:	4313      	orrs	r3, r2
90012064:	650b      	str	r3, [r1, #80]	; 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
90012066:	687b      	ldr	r3, [r7, #4]
90012068:	681b      	ldr	r3, [r3, #0]
9001206a:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
9001206e:	2b00      	cmp	r3, #0
90012070:	d00d      	beq.n	9001208e <HAL_RCCEx_PeriphCLKConfig+0xe2e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
90012072:	4b1a      	ldr	r3, [pc, #104]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012074:	691b      	ldr	r3, [r3, #16]
90012076:	4a19      	ldr	r2, [pc, #100]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012078:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
9001207c:	6113      	str	r3, [r2, #16]
9001207e:	4b17      	ldr	r3, [pc, #92]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012080:	691a      	ldr	r2, [r3, #16]
90012082:	687b      	ldr	r3, [r7, #4]
90012084:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
90012088:	4914      	ldr	r1, [pc, #80]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
9001208a:	4313      	orrs	r3, r2
9001208c:	610b      	str	r3, [r1, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
9001208e:	687b      	ldr	r3, [r7, #4]
90012090:	681b      	ldr	r3, [r3, #0]
90012092:	2b00      	cmp	r3, #0
90012094:	da08      	bge.n	900120a8 <HAL_RCCEx_PeriphCLKConfig+0xe48>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
90012096:	4b11      	ldr	r3, [pc, #68]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
90012098:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9001209a:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
9001209e:	687b      	ldr	r3, [r7, #4]
900120a0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
900120a2:	490e      	ldr	r1, [pc, #56]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
900120a4:	4313      	orrs	r3, r2
900120a6:	64cb      	str	r3, [r1, #76]	; 0x4c
  }

  /*------------------------------ CEC Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
900120a8:	687b      	ldr	r3, [r7, #4]
900120aa:	681b      	ldr	r3, [r3, #0]
900120ac:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
900120b0:	2b00      	cmp	r3, #0
900120b2:	d009      	beq.n	900120c8 <HAL_RCCEx_PeriphCLKConfig+0xe68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC interface clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
900120b4:	4b09      	ldr	r3, [pc, #36]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
900120b6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
900120b8:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
900120bc:	687b      	ldr	r3, [r7, #4]
900120be:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
900120c2:	4906      	ldr	r1, [pc, #24]	; (900120dc <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
900120c4:	4313      	orrs	r3, r2
900120c6:	654b      	str	r3, [r1, #84]	; 0x54
  }

  if (status == HAL_OK)
900120c8:	7dbb      	ldrb	r3, [r7, #22]
900120ca:	2b00      	cmp	r3, #0
900120cc:	d101      	bne.n	900120d2 <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    return HAL_OK;
900120ce:	2300      	movs	r3, #0
900120d0:	e000      	b.n	900120d4 <HAL_RCCEx_PeriphCLKConfig+0xe74>
  }
  return HAL_ERROR;
900120d2:	2301      	movs	r3, #1
}
900120d4:	4618      	mov	r0, r3
900120d6:	3718      	adds	r7, #24
900120d8:	46bd      	mov	sp, r7
900120da:	bd80      	pop	{r7, pc}
900120dc:	58024400 	.word	0x58024400

900120e0 <HAL_RCCEx_GetPeriphCLKConfig>:
  * @retval None
  *
  *   (*) : Available on some STM32H7 lines only.
  */
void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
900120e0:	b480      	push	{r7}
900120e2:	b083      	sub	sp, #12
900120e4:	af00      	add	r7, sp, #0
900120e6:	6078      	str	r0, [r7, #4]
  /* Set all possible values for the extended clock type parameter------------*/
  PeriphClkInit->PeriphClockSelection =
900120e8:	687b      	ldr	r3, [r7, #4]
900120ea:	4aa3      	ldr	r2, [pc, #652]	; (90012378 <HAL_RCCEx_GetPeriphCLKConfig+0x298>)
900120ec:	601a      	str	r2, [r3, #0]
	         RCC_PERIPHCLK_CKPER;

#if defined(I2C5)
PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C1235;
#else
PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_I2C123;
900120ee:	687b      	ldr	r3, [r7, #4]
900120f0:	681b      	ldr	r3, [r3, #0]
900120f2:	f043 0208 	orr.w	r2, r3, #8
900120f6:	687b      	ldr	r3, [r7, #4]
900120f8:	601a      	str	r2, [r3, #0]
#endif /* RCC_CDCCIP1R_SAI2ASEL */
#if defined(RCC_CDCCIP1R_SAI2BSEL)		 
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI2B;
#endif /* RCC_CDCCIP1R_SAI2BSEL */
#if defined(SAI3)	 
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI23;
900120fa:	687b      	ldr	r3, [r7, #4]
900120fc:	681b      	ldr	r3, [r3, #0]
900120fe:	f443 7200 	orr.w	r2, r3, #512	; 0x200
90012102:	687b      	ldr	r3, [r7, #4]
90012104:	601a      	str	r2, [r3, #0]
#endif /* SAI3 */
#if defined(SAI4)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4A;
90012106:	687b      	ldr	r3, [r7, #4]
90012108:	681b      	ldr	r3, [r3, #0]
9001210a:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
9001210e:	687b      	ldr	r3, [r7, #4]
90012110:	601a      	str	r2, [r3, #0]
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_SAI4B;
90012112:	687b      	ldr	r3, [r7, #4]
90012114:	681b      	ldr	r3, [r3, #0]
90012116:	f443 6200 	orr.w	r2, r3, #2048	; 0x800
9001211a:	687b      	ldr	r3, [r7, #4]
9001211c:	601a      	str	r2, [r3, #0]
#endif /* SAI4 */
#if defined(DFSDM2_BASE)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DFSDM2;
#endif /* DFSDM2 */
#if defined(QUADSPI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_QSPI;
9001211e:	687b      	ldr	r3, [r7, #4]
90012120:	681b      	ldr	r3, [r3, #0]
90012122:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
90012126:	687b      	ldr	r3, [r7, #4]
90012128:	601a      	str	r2, [r3, #0]
#endif /* QUADSPI */
#if defined(OCTOSPI1) || defined(OCTOSPI2)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_OSPI;
#endif /* OCTOSPI1 || OCTOSPI2 */
#if defined(HRTIM1)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_HRTIM1;
9001212a:	687b      	ldr	r3, [r7, #4]
9001212c:	681b      	ldr	r3, [r3, #0]
9001212e:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
90012132:	687b      	ldr	r3, [r7, #4]
90012134:	601a      	str	r2, [r3, #0]
#endif /* HRTIM1 */
#if defined(LTDC)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_LTDC;
90012136:	687b      	ldr	r3, [r7, #4]
90012138:	681b      	ldr	r3, [r3, #0]
9001213a:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
9001213e:	687b      	ldr	r3, [r7, #4]
90012140:	601a      	str	r2, [r3, #0]
#if defined(DSI)
  PeriphClkInit->PeriphClockSelection |= RCC_PERIPHCLK_DSI;
#endif /* DSI */

  /* Get the PLL3 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL3.PLL3M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> RCC_PLLCKSELR_DIVM3_Pos);
90012142:	4b8e      	ldr	r3, [pc, #568]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012144:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90012146:	0d1b      	lsrs	r3, r3, #20
90012148:	f003 023f 	and.w	r2, r3, #63	; 0x3f
9001214c:	687b      	ldr	r3, [r7, #4]
9001214e:	625a      	str	r2, [r3, #36]	; 0x24
  PeriphClkInit->PLL3.PLL3N = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_N3) >> RCC_PLL3DIVR_N3_Pos)+ 1U;
90012150:	4b8a      	ldr	r3, [pc, #552]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012152:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90012154:	f3c3 0308 	ubfx	r3, r3, #0, #9
90012158:	1c5a      	adds	r2, r3, #1
9001215a:	687b      	ldr	r3, [r7, #4]
9001215c:	629a      	str	r2, [r3, #40]	; 0x28
  PeriphClkInit->PLL3.PLL3R = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> RCC_PLL3DIVR_R3_Pos)+ 1U;
9001215e:	4b87      	ldr	r3, [pc, #540]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012160:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90012162:	0e1b      	lsrs	r3, r3, #24
90012164:	f003 037f 	and.w	r3, r3, #127	; 0x7f
90012168:	1c5a      	adds	r2, r3, #1
9001216a:	687b      	ldr	r3, [r7, #4]
9001216c:	635a      	str	r2, [r3, #52]	; 0x34
  PeriphClkInit->PLL3.PLL3P = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> RCC_PLL3DIVR_P3_Pos)+ 1U;
9001216e:	4b83      	ldr	r3, [pc, #524]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012170:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90012172:	0a5b      	lsrs	r3, r3, #9
90012174:	f003 037f 	and.w	r3, r3, #127	; 0x7f
90012178:	1c5a      	adds	r2, r3, #1
9001217a:	687b      	ldr	r3, [r7, #4]
9001217c:	62da      	str	r2, [r3, #44]	; 0x2c
  PeriphClkInit->PLL3.PLL3Q = (uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> RCC_PLL3DIVR_Q3_Pos)+ 1U;
9001217e:	4b7f      	ldr	r3, [pc, #508]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012180:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90012182:	0c1b      	lsrs	r3, r3, #16
90012184:	f003 037f 	and.w	r3, r3, #127	; 0x7f
90012188:	1c5a      	adds	r2, r3, #1
9001218a:	687b      	ldr	r3, [r7, #4]
9001218c:	631a      	str	r2, [r3, #48]	; 0x30
  PeriphClkInit->PLL3.PLL3RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3RGE) >> RCC_PLLCFGR_PLL3RGE_Pos);
9001218e:	4b7b      	ldr	r3, [pc, #492]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012190:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90012192:	0a9b      	lsrs	r3, r3, #10
90012194:	f003 0203 	and.w	r2, r3, #3
90012198:	687b      	ldr	r3, [r7, #4]
9001219a:	639a      	str	r2, [r3, #56]	; 0x38
  PeriphClkInit->PLL3.PLL3VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL3VCOSEL) >> RCC_PLLCFGR_PLL3VCOSEL_Pos);
9001219c:	4b77      	ldr	r3, [pc, #476]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
9001219e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900121a0:	0a5b      	lsrs	r3, r3, #9
900121a2:	f003 0201 	and.w	r2, r3, #1
900121a6:	687b      	ldr	r3, [r7, #4]
900121a8:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Get the PLL2 Clock configuration -----------------------------------------------*/
  PeriphClkInit->PLL2.PLL2M = (uint32_t)((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> RCC_PLLCKSELR_DIVM2_Pos);
900121aa:	4b74      	ldr	r3, [pc, #464]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900121ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
900121ae:	0b1b      	lsrs	r3, r3, #12
900121b0:	f003 023f 	and.w	r2, r3, #63	; 0x3f
900121b4:	687b      	ldr	r3, [r7, #4]
900121b6:	605a      	str	r2, [r3, #4]
  PeriphClkInit->PLL2.PLL2N = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_N2) >> RCC_PLL2DIVR_N2_Pos)+ 1U;
900121b8:	4b70      	ldr	r3, [pc, #448]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900121ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
900121bc:	f3c3 0308 	ubfx	r3, r3, #0, #9
900121c0:	1c5a      	adds	r2, r3, #1
900121c2:	687b      	ldr	r3, [r7, #4]
900121c4:	609a      	str	r2, [r3, #8]
  PeriphClkInit->PLL2.PLL2R = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> RCC_PLL2DIVR_R2_Pos)+ 1U;
900121c6:	4b6d      	ldr	r3, [pc, #436]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900121c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
900121ca:	0e1b      	lsrs	r3, r3, #24
900121cc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
900121d0:	1c5a      	adds	r2, r3, #1
900121d2:	687b      	ldr	r3, [r7, #4]
900121d4:	615a      	str	r2, [r3, #20]
  PeriphClkInit->PLL2.PLL2P = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> RCC_PLL2DIVR_P2_Pos)+ 1U;
900121d6:	4b69      	ldr	r3, [pc, #420]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900121d8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
900121da:	0a5b      	lsrs	r3, r3, #9
900121dc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
900121e0:	1c5a      	adds	r2, r3, #1
900121e2:	687b      	ldr	r3, [r7, #4]
900121e4:	60da      	str	r2, [r3, #12]
  PeriphClkInit->PLL2.PLL2Q = (uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> RCC_PLL2DIVR_Q2_Pos)+ 1U;
900121e6:	4b65      	ldr	r3, [pc, #404]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900121e8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
900121ea:	0c1b      	lsrs	r3, r3, #16
900121ec:	f003 037f 	and.w	r3, r3, #127	; 0x7f
900121f0:	1c5a      	adds	r2, r3, #1
900121f2:	687b      	ldr	r3, [r7, #4]
900121f4:	611a      	str	r2, [r3, #16]
  PeriphClkInit->PLL2.PLL2RGE = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2RGE) >> RCC_PLLCFGR_PLL2RGE_Pos);
900121f6:	4b61      	ldr	r3, [pc, #388]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900121f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900121fa:	099b      	lsrs	r3, r3, #6
900121fc:	f003 0203 	and.w	r2, r3, #3
90012200:	687b      	ldr	r3, [r7, #4]
90012202:	619a      	str	r2, [r3, #24]
  PeriphClkInit->PLL2.PLL2VCOSEL = (uint32_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLL2VCOSEL) >> RCC_PLLCFGR_PLL2VCOSEL_Pos);
90012204:	4b5d      	ldr	r3, [pc, #372]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012206:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90012208:	095b      	lsrs	r3, r3, #5
9001220a:	f003 0201 	and.w	r2, r3, #1
9001220e:	687b      	ldr	r3, [r7, #4]
90012210:	61da      	str	r2, [r3, #28]

  /* Get the USART1 configuration --------------------------------------------*/
  PeriphClkInit->Usart16ClockSelection      = __HAL_RCC_GET_USART16_SOURCE();
90012212:	4b5a      	ldr	r3, [pc, #360]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012214:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90012216:	f003 0238 	and.w	r2, r3, #56	; 0x38
9001221a:	687b      	ldr	r3, [r7, #4]
9001221c:	679a      	str	r2, [r3, #120]	; 0x78
  /* Get the USART2/3/4/5/7/8 clock source -----------------------------------*/
  PeriphClkInit->Usart234578ClockSelection  = __HAL_RCC_GET_USART234578_SOURCE();
9001221e:	4b57      	ldr	r3, [pc, #348]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012220:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90012222:	f003 0207 	and.w	r2, r3, #7
90012226:	687b      	ldr	r3, [r7, #4]
90012228:	675a      	str	r2, [r3, #116]	; 0x74
  /* Get the LPUART1 clock source --------------------------------------------*/
  PeriphClkInit->Lpuart1ClockSelection      = __HAL_RCC_GET_LPUART1_SOURCE();
9001222a:	4b54      	ldr	r3, [pc, #336]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
9001222c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9001222e:	f003 0207 	and.w	r2, r3, #7
90012232:	687b      	ldr	r3, [r7, #4]
90012234:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#if defined(I2C5)
  /* Get the I2C1/2/3/5 clock source -----------------------------------------*/
  PeriphClkInit->I2c1235ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();
#else
  /* Get the I2C1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->I2c123ClockSelection       = __HAL_RCC_GET_I2C1_SOURCE();
90012238:	4b50      	ldr	r3, [pc, #320]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
9001223a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9001223c:	f403 5240 	and.w	r2, r3, #12288	; 0x3000
90012240:	687b      	ldr	r3, [r7, #4]
90012242:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#endif /*I2C5*/
  /* Get the LPTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim1ClockSelection       = __HAL_RCC_GET_LPTIM1_SOURCE();
90012246:	4b4d      	ldr	r3, [pc, #308]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012248:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9001224a:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
9001224e:	687b      	ldr	r3, [r7, #4]
90012250:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  /* Get the LPTIM2 clock source ---------------------------------------------*/
  PeriphClkInit->Lptim2ClockSelection       = __HAL_RCC_GET_LPTIM2_SOURCE();
90012254:	4b49      	ldr	r3, [pc, #292]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012256:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90012258:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
9001225c:	687b      	ldr	r3, [r7, #4]
9001225e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  /* Get the LPTIM3/4/5 clock source -----------------------------------------*/
  PeriphClkInit->Lptim345ClockSelection     = __HAL_RCC_GET_LPTIM345_SOURCE();
90012262:	4b46      	ldr	r3, [pc, #280]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012264:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90012266:	f403 4260 	and.w	r2, r3, #57344	; 0xe000
9001226a:	687b      	ldr	r3, [r7, #4]
9001226c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  /* Get the SAI1 clock source -----------------------------------------------*/
  PeriphClkInit->Sai1ClockSelection         = __HAL_RCC_GET_SAI1_SOURCE();
90012270:	4b42      	ldr	r3, [pc, #264]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012272:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90012274:	f003 0207 	and.w	r2, r3, #7
90012278:	687b      	ldr	r3, [r7, #4]
9001227a:	655a      	str	r2, [r3, #84]	; 0x54
#if defined(SAI3)
  /* Get the SAI2/3 clock source ---------------------------------------------*/
  PeriphClkInit->Sai23ClockSelection        = __HAL_RCC_GET_SAI23_SOURCE();
9001227c:	4b3f      	ldr	r3, [pc, #252]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
9001227e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90012280:	f403 72e0 	and.w	r2, r3, #448	; 0x1c0
90012284:	687b      	ldr	r3, [r7, #4]
90012286:	659a      	str	r2, [r3, #88]	; 0x58
  /* Get the SAI2B clock source ---------------------------------------------*/
  PeriphClkInit->Sai2BClockSelection        = __HAL_RCC_GET_SAI2B_SOURCE();
#endif  /*SAI2B*/
#if defined(SAI4)
  /* Get the SAI4A clock source ----------------------------------------------*/
  PeriphClkInit->Sai4AClockSelection        = __HAL_RCC_GET_SAI4A_SOURCE();
90012288:	4b3c      	ldr	r3, [pc, #240]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
9001228a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9001228c:	f403 0260 	and.w	r2, r3, #14680064	; 0xe00000
90012290:	687b      	ldr	r3, [r7, #4]
90012292:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  /* Get the SAI4B clock source ----------------------------------------------*/
  PeriphClkInit->Sai4BClockSelection        = __HAL_RCC_GET_SAI4B_SOURCE();
90012296:	4b39      	ldr	r3, [pc, #228]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012298:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9001229a:	f003 62e0 	and.w	r2, r3, #117440512	; 0x7000000
9001229e:	687b      	ldr	r3, [r7, #4]
900122a0:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
#endif  /*SAI4*/
  /* Get the RTC clock source ------------------------------------------------*/
  PeriphClkInit->RTCClockSelection          = __HAL_RCC_GET_RTC_SOURCE();
900122a4:	4b35      	ldr	r3, [pc, #212]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900122a6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
900122a8:	f403 7240 	and.w	r2, r3, #768	; 0x300
900122ac:	687b      	ldr	r3, [r7, #4]
900122ae:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  /* Get the USB clock source ------------------------------------------------*/
  PeriphClkInit->UsbClockSelection          = __HAL_RCC_GET_USB_SOURCE();
900122b2:	4b32      	ldr	r3, [pc, #200]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900122b4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
900122b6:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
900122ba:	687b      	ldr	r3, [r7, #4]
900122bc:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  /* Get the SDMMC clock source ----------------------------------------------*/
  PeriphClkInit->SdmmcClockSelection        = __HAL_RCC_GET_SDMMC_SOURCE();
900122c0:	4b2e      	ldr	r3, [pc, #184]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900122c2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
900122c4:	f403 3280 	and.w	r2, r3, #65536	; 0x10000
900122c8:	687b      	ldr	r3, [r7, #4]
900122ca:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Get the RNG clock source ------------------------------------------------*/
  PeriphClkInit->RngClockSelection          = __HAL_RCC_GET_RNG_SOURCE();
900122cc:	4b2b      	ldr	r3, [pc, #172]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900122ce:	6d5b      	ldr	r3, [r3, #84]	; 0x54
900122d0:	f403 7240 	and.w	r2, r3, #768	; 0x300
900122d4:	687b      	ldr	r3, [r7, #4]
900122d6:	67da      	str	r2, [r3, #124]	; 0x7c
#if defined(HRTIM1)
  /* Get the HRTIM1 clock source ---------------------------------------------*/
  PeriphClkInit->Hrtim1ClockSelection       = __HAL_RCC_GET_HRTIM1_SOURCE();
900122d8:	4b28      	ldr	r3, [pc, #160]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900122da:	691b      	ldr	r3, [r3, #16]
900122dc:	f403 4280 	and.w	r2, r3, #16384	; 0x4000
900122e0:	687b      	ldr	r3, [r7, #4]
900122e2:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
#endif /* HRTIM1 */
  /* Get the ADC clock source ------------------------------------------------*/
  PeriphClkInit->AdcClockSelection          = __HAL_RCC_GET_ADC_SOURCE();
900122e6:	4b25      	ldr	r3, [pc, #148]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900122e8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
900122ea:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
900122ee:	687b      	ldr	r3, [r7, #4]
900122f0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  /* Get the SWPMI1 clock source ---------------------------------------------*/
  PeriphClkInit->Swpmi1ClockSelection       = __HAL_RCC_GET_SWPMI1_SOURCE();
900122f4:	4b21      	ldr	r3, [pc, #132]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
900122f6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
900122f8:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
900122fc:	687b      	ldr	r3, [r7, #4]
900122fe:	671a      	str	r2, [r3, #112]	; 0x70
  /* Get the DFSDM1 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm1ClockSelection       = __HAL_RCC_GET_DFSDM1_SOURCE();
90012300:	4b1e      	ldr	r3, [pc, #120]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012302:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90012304:	f003 7280 	and.w	r2, r3, #16777216	; 0x1000000
90012308:	687b      	ldr	r3, [r7, #4]
9001230a:	669a      	str	r2, [r3, #104]	; 0x68
#if defined(DFSDM2_BASE)
  /* Get the DFSDM2 clock source ---------------------------------------------*/
  PeriphClkInit->Dfsdm2ClockSelection       = __HAL_RCC_GET_DFSDM2_SOURCE();
#endif /* DFSDM2 */
  /* Get the SPDIFRX clock source --------------------------------------------*/
  PeriphClkInit->SpdifrxClockSelection      = __HAL_RCC_GET_SPDIFRX_SOURCE();
9001230c:	4b1b      	ldr	r3, [pc, #108]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
9001230e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90012310:	f403 1240 	and.w	r2, r3, #3145728	; 0x300000
90012314:	687b      	ldr	r3, [r7, #4]
90012316:	665a      	str	r2, [r3, #100]	; 0x64
  /* Get the SPI1/2/3 clock source -------------------------------------------*/
  PeriphClkInit->Spi123ClockSelection       = __HAL_RCC_GET_SPI123_SOURCE();
90012318:	4b18      	ldr	r3, [pc, #96]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
9001231a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
9001231c:	f403 42e0 	and.w	r2, r3, #28672	; 0x7000
90012320:	687b      	ldr	r3, [r7, #4]
90012322:	65da      	str	r2, [r3, #92]	; 0x5c
  /* Get the SPI4/5 clock source ---------------------------------------------*/
  PeriphClkInit->Spi45ClockSelection        = __HAL_RCC_GET_SPI45_SOURCE();
90012324:	4b15      	ldr	r3, [pc, #84]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012326:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90012328:	f403 22e0 	and.w	r2, r3, #458752	; 0x70000
9001232c:	687b      	ldr	r3, [r7, #4]
9001232e:	661a      	str	r2, [r3, #96]	; 0x60
  /* Get the SPI6 clock source -----------------------------------------------*/
  PeriphClkInit->Spi6ClockSelection         = __HAL_RCC_GET_SPI6_SOURCE();
90012330:	4b12      	ldr	r3, [pc, #72]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012332:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90012334:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
90012338:	687b      	ldr	r3, [r7, #4]
9001233a:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  /* Get the FDCAN clock source ----------------------------------------------*/
  PeriphClkInit->FdcanClockSelection        = __HAL_RCC_GET_FDCAN_SOURCE();
9001233e:	4b0f      	ldr	r3, [pc, #60]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012340:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90012342:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
90012346:	687b      	ldr	r3, [r7, #4]
90012348:	66da      	str	r2, [r3, #108]	; 0x6c
  /* Get the CEC clock source ------------------------------------------------*/
  PeriphClkInit->CecClockSelection          = __HAL_RCC_GET_CEC_SOURCE();
9001234a:	4b0c      	ldr	r3, [pc, #48]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
9001234c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
9001234e:	f403 0240 	and.w	r2, r3, #12582912	; 0xc00000
90012352:	687b      	ldr	r3, [r7, #4]
90012354:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  /* Get the FMC clock source ------------------------------------------------*/
  PeriphClkInit->FmcClockSelection          = __HAL_RCC_GET_FMC_SOURCE();
90012358:	4b08      	ldr	r3, [pc, #32]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
9001235a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9001235c:	f003 0203 	and.w	r2, r3, #3
90012360:	687b      	ldr	r3, [r7, #4]
90012362:	645a      	str	r2, [r3, #68]	; 0x44
#if defined(QUADSPI)
  /* Get the QSPI clock source -----------------------------------------------*/
  PeriphClkInit->QspiClockSelection         = __HAL_RCC_GET_QSPI_SOURCE();
90012364:	4b05      	ldr	r3, [pc, #20]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012366:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90012368:	f003 0230 	and.w	r2, r3, #48	; 0x30
9001236c:	687b      	ldr	r3, [r7, #4]
9001236e:	649a      	str	r2, [r3, #72]	; 0x48
  /* Get the DSI clock source ------------------------------------------------*/
  PeriphClkInit->DsiClockSelection          = __HAL_RCC_GET_DSI_SOURCE();
#endif /*DSI*/

  /* Get the CKPER clock source ----------------------------------------------*/
  PeriphClkInit->CkperClockSelection        = __HAL_RCC_GET_CLKP_SOURCE();
90012370:	4b02      	ldr	r3, [pc, #8]	; (9001237c <HAL_RCCEx_GetPeriphCLKConfig+0x29c>)
90012372:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90012374:	e004      	b.n	90012380 <HAL_RCCEx_GetPeriphCLKConfig+0x2a0>
90012376:	bf00      	nop
90012378:	c9fff1f7 	.word	0xc9fff1f7
9001237c:	58024400 	.word	0x58024400
90012380:	f003 5240 	and.w	r2, r3, #805306368	; 0x30000000
90012384:	687b      	ldr	r3, [r7, #4]
90012386:	651a      	str	r2, [r3, #80]	; 0x50

  /* Get the TIM Prescaler configuration -------------------------------------*/
  if ((RCC->CFGR & RCC_CFGR_TIMPRE) == 0U)
90012388:	4b0a      	ldr	r3, [pc, #40]	; (900123b4 <HAL_RCCEx_GetPeriphCLKConfig+0x2d4>)
9001238a:	691b      	ldr	r3, [r3, #16]
9001238c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
90012390:	2b00      	cmp	r3, #0
90012392:	d104      	bne.n	9001239e <HAL_RCCEx_GetPeriphCLKConfig+0x2be>
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
90012394:	687b      	ldr	r3, [r7, #4]
90012396:	2200      	movs	r2, #0
90012398:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
  }
  else
  {
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
  }
}
9001239c:	e004      	b.n	900123a8 <HAL_RCCEx_GetPeriphCLKConfig+0x2c8>
    PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
9001239e:	687b      	ldr	r3, [r7, #4]
900123a0:	f44f 4200 	mov.w	r2, #32768	; 0x8000
900123a4:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
900123a8:	bf00      	nop
900123aa:	370c      	adds	r7, #12
900123ac:	46bd      	mov	sp, r7
900123ae:	f85d 7b04 	ldr.w	r7, [sp], #4
900123b2:	4770      	bx	lr
900123b4:	58024400 	.word	0x58024400

900123b8 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in KHz
  *
  *  (*) : Available on some STM32H7 lines only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
900123b8:	b580      	push	{r7, lr}
900123ba:	b090      	sub	sp, #64	; 0x40
900123bc:	af00      	add	r7, sp, #0
900123be:	6078      	str	r0, [r7, #4]
  /* This variable is used to store the SAI and CKP clock source */
  uint32_t saiclocksource;
  uint32_t ckpclocksource;
  uint32_t srcclk;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
900123c0:	687b      	ldr	r3, [r7, #4]
900123c2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
900123c6:	f040 8095 	bne.w	900124f4 <HAL_RCCEx_GetPeriphCLKFreq+0x13c>
    {

      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
900123ca:	4bae      	ldr	r3, [pc, #696]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
900123cc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
900123ce:	f003 0307 	and.w	r3, r3, #7
900123d2:	633b      	str	r3, [r7, #48]	; 0x30
900123d4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
900123d6:	2b04      	cmp	r3, #4
900123d8:	f200 8088 	bhi.w	900124ec <HAL_RCCEx_GetPeriphCLKFreq+0x134>
900123dc:	a201      	add	r2, pc, #4	; (adr r2, 900123e4 <HAL_RCCEx_GetPeriphCLKFreq+0x2c>)
900123de:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
900123e2:	bf00      	nop
900123e4:	900123f9 	.word	0x900123f9
900123e8:	90012421 	.word	0x90012421
900123ec:	90012449 	.word	0x90012449
900123f0:	900124e5 	.word	0x900124e5
900123f4:	90012471 	.word	0x90012471

      switch (saiclocksource)
      {
      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
900123f8:	4ba2      	ldr	r3, [pc, #648]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
900123fa:	681b      	ldr	r3, [r3, #0]
900123fc:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90012400:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
90012404:	d108      	bne.n	90012418 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
         {
           HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
90012406:	f107 0324 	add.w	r3, r7, #36	; 0x24
9001240a:	4618      	mov	r0, r3
9001240c:	f000 ff64 	bl	900132d8 <HAL_RCCEx_GetPLL1ClockFreq>
           frequency = pll1_clocks.PLL1_Q_Frequency;
90012410:	6abb      	ldr	r3, [r7, #40]	; 0x28
90012412:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
90012414:	f000 bc95 	b.w	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
90012418:	2300      	movs	r3, #0
9001241a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
9001241c:	f000 bc91 	b.w	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
90012420:	4b98      	ldr	r3, [pc, #608]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
90012422:	681b      	ldr	r3, [r3, #0]
90012424:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90012428:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
9001242c:	d108      	bne.n	90012440 <HAL_RCCEx_GetPeriphCLKFreq+0x88>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
9001242e:	f107 0318 	add.w	r3, r7, #24
90012432:	4618      	mov	r0, r3
90012434:	f000 fca8 	bl	90012d88 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
90012438:	69bb      	ldr	r3, [r7, #24]
9001243a:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
9001243c:	f000 bc81 	b.w	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
90012440:	2300      	movs	r3, #0
90012442:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012444:	f000 bc7d 	b.w	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
90012448:	4b8e      	ldr	r3, [pc, #568]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
9001244a:	681b      	ldr	r3, [r3, #0]
9001244c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
90012450:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012454:	d108      	bne.n	90012468 <HAL_RCCEx_GetPeriphCLKFreq+0xb0>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
90012456:	f107 030c 	add.w	r3, r7, #12
9001245a:	4618      	mov	r0, r3
9001245c:	f000 fde8 	bl	90013030 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
90012460:	68fb      	ldr	r3, [r7, #12]
90012462:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
90012464:	f000 bc6d 	b.w	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
90012468:	2300      	movs	r3, #0
9001246a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
9001246c:	f000 bc69 	b.w	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
90012470:	4b84      	ldr	r3, [pc, #528]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
90012472:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90012474:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
90012478:	637b      	str	r3, [r7, #52]	; 0x34

          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
9001247a:	4b82      	ldr	r3, [pc, #520]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
9001247c:	681b      	ldr	r3, [r3, #0]
9001247e:	f003 0304 	and.w	r3, r3, #4
90012482:	2b04      	cmp	r3, #4
90012484:	d10c      	bne.n	900124a0 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
90012486:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90012488:	2b00      	cmp	r3, #0
9001248a:	d109      	bne.n	900124a0 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
9001248c:	4b7d      	ldr	r3, [pc, #500]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
9001248e:	681b      	ldr	r3, [r3, #0]
90012490:	08db      	lsrs	r3, r3, #3
90012492:	f003 0303 	and.w	r3, r3, #3
90012496:	4a7c      	ldr	r2, [pc, #496]	; (90012688 <HAL_RCCEx_GetPeriphCLKFreq+0x2d0>)
90012498:	fa22 f303 	lsr.w	r3, r2, r3
9001249c:	63fb      	str	r3, [r7, #60]	; 0x3c
9001249e:	e01f      	b.n	900124e0 <HAL_RCCEx_GetPeriphCLKFreq+0x128>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
900124a0:	4b78      	ldr	r3, [pc, #480]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
900124a2:	681b      	ldr	r3, [r3, #0]
900124a4:	f403 7380 	and.w	r3, r3, #256	; 0x100
900124a8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
900124ac:	d106      	bne.n	900124bc <HAL_RCCEx_GetPeriphCLKFreq+0x104>
900124ae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
900124b0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
900124b4:	d102      	bne.n	900124bc <HAL_RCCEx_GetPeriphCLKFreq+0x104>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
900124b6:	4b75      	ldr	r3, [pc, #468]	; (9001268c <HAL_RCCEx_GetPeriphCLKFreq+0x2d4>)
900124b8:	63fb      	str	r3, [r7, #60]	; 0x3c
900124ba:	e011      	b.n	900124e0 <HAL_RCCEx_GetPeriphCLKFreq+0x128>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
900124bc:	4b71      	ldr	r3, [pc, #452]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
900124be:	681b      	ldr	r3, [r3, #0]
900124c0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
900124c4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
900124c8:	d106      	bne.n	900124d8 <HAL_RCCEx_GetPeriphCLKFreq+0x120>
900124ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
900124cc:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
900124d0:	d102      	bne.n	900124d8 <HAL_RCCEx_GetPeriphCLKFreq+0x120>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
900124d2:	4b6f      	ldr	r3, [pc, #444]	; (90012690 <HAL_RCCEx_GetPeriphCLKFreq+0x2d8>)
900124d4:	63fb      	str	r3, [r7, #60]	; 0x3c
900124d6:	e003      	b.n	900124e0 <HAL_RCCEx_GetPeriphCLKFreq+0x128>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
900124d8:	2300      	movs	r3, #0
900124da:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
900124dc:	f000 bc31 	b.w	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
900124e0:	f000 bc2f 	b.w	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
900124e4:	4b6b      	ldr	r3, [pc, #428]	; (90012694 <HAL_RCCEx_GetPeriphCLKFreq+0x2dc>)
900124e6:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
900124e8:	f000 bc2b 	b.w	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      default :
        {
          frequency = 0;
900124ec:	2300      	movs	r3, #0
900124ee:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
900124f0:	f000 bc27 	b.w	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      }
    }

#if defined(SAI3)
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
900124f4:	687b      	ldr	r3, [r7, #4]
900124f6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
900124fa:	f040 8095 	bne.w	90012628 <HAL_RCCEx_GetPeriphCLKFreq+0x270>
    {

      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
900124fe:	4b61      	ldr	r3, [pc, #388]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
90012500:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90012502:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
90012506:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
90012508:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9001250a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
9001250e:	d04d      	beq.n	900125ac <HAL_RCCEx_GetPeriphCLKFreq+0x1f4>
90012510:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90012512:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90012516:	f200 8084 	bhi.w	90012622 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
9001251a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9001251c:	2bc0      	cmp	r3, #192	; 0xc0
9001251e:	d07d      	beq.n	9001261c <HAL_RCCEx_GetPeriphCLKFreq+0x264>
90012520:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90012522:	2bc0      	cmp	r3, #192	; 0xc0
90012524:	d87d      	bhi.n	90012622 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
90012526:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90012528:	2b80      	cmp	r3, #128	; 0x80
9001252a:	d02d      	beq.n	90012588 <HAL_RCCEx_GetPeriphCLKFreq+0x1d0>
9001252c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9001252e:	2b80      	cmp	r3, #128	; 0x80
90012530:	d877      	bhi.n	90012622 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
90012532:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90012534:	2b00      	cmp	r3, #0
90012536:	d003      	beq.n	90012540 <HAL_RCCEx_GetPeriphCLKFreq+0x188>
90012538:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9001253a:	2b40      	cmp	r3, #64	; 0x40
9001253c:	d012      	beq.n	90012564 <HAL_RCCEx_GetPeriphCLKFreq+0x1ac>
9001253e:	e070      	b.n	90012622 <HAL_RCCEx_GetPeriphCLKFreq+0x26a>
      {
      case RCC_SAI23CLKSOURCE_PLL: /* PLL1 is the clock source for SAI2/3 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
90012540:	4b50      	ldr	r3, [pc, #320]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
90012542:	681b      	ldr	r3, [r3, #0]
90012544:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90012548:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
9001254c:	d107      	bne.n	9001255e <HAL_RCCEx_GetPeriphCLKFreq+0x1a6>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
9001254e:	f107 0324 	add.w	r3, r7, #36	; 0x24
90012552:	4618      	mov	r0, r3
90012554:	f000 fec0 	bl	900132d8 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
90012558:	6abb      	ldr	r3, [r7, #40]	; 0x28
9001255a:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
9001255c:	e3f1      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
9001255e:	2300      	movs	r3, #0
90012560:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012562:	e3ee      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI2/3 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
90012564:	4b47      	ldr	r3, [pc, #284]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
90012566:	681b      	ldr	r3, [r3, #0]
90012568:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
9001256c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
90012570:	d107      	bne.n	90012582 <HAL_RCCEx_GetPeriphCLKFreq+0x1ca>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
90012572:	f107 0318 	add.w	r3, r7, #24
90012576:	4618      	mov	r0, r3
90012578:	f000 fc06 	bl	90012d88 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
9001257c:	69bb      	ldr	r3, [r7, #24]
9001257e:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
90012580:	e3df      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
90012582:	2300      	movs	r3, #0
90012584:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012586:	e3dc      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SAI23CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI2/3 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
90012588:	4b3e      	ldr	r3, [pc, #248]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
9001258a:	681b      	ldr	r3, [r3, #0]
9001258c:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
90012590:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012594:	d107      	bne.n	900125a6 <HAL_RCCEx_GetPeriphCLKFreq+0x1ee>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
90012596:	f107 030c 	add.w	r3, r7, #12
9001259a:	4618      	mov	r0, r3
9001259c:	f000 fd48 	bl	90013030 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
900125a0:	68fb      	ldr	r3, [r7, #12]
900125a2:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
900125a4:	e3cd      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
900125a6:	2300      	movs	r3, #0
900125a8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
900125aa:	e3ca      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SAI23CLKSOURCE_CLKP: /* CKPER is the clock source for SAI2/3 */
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
900125ac:	4b35      	ldr	r3, [pc, #212]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
900125ae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
900125b0:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
900125b4:	637b      	str	r3, [r7, #52]	; 0x34

          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
900125b6:	4b33      	ldr	r3, [pc, #204]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
900125b8:	681b      	ldr	r3, [r3, #0]
900125ba:	f003 0304 	and.w	r3, r3, #4
900125be:	2b04      	cmp	r3, #4
900125c0:	d10c      	bne.n	900125dc <HAL_RCCEx_GetPeriphCLKFreq+0x224>
900125c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
900125c4:	2b00      	cmp	r3, #0
900125c6:	d109      	bne.n	900125dc <HAL_RCCEx_GetPeriphCLKFreq+0x224>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
900125c8:	4b2e      	ldr	r3, [pc, #184]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
900125ca:	681b      	ldr	r3, [r3, #0]
900125cc:	08db      	lsrs	r3, r3, #3
900125ce:	f003 0303 	and.w	r3, r3, #3
900125d2:	4a2d      	ldr	r2, [pc, #180]	; (90012688 <HAL_RCCEx_GetPeriphCLKFreq+0x2d0>)
900125d4:	fa22 f303 	lsr.w	r3, r2, r3
900125d8:	63fb      	str	r3, [r7, #60]	; 0x3c
900125da:	e01e      	b.n	9001261a <HAL_RCCEx_GetPeriphCLKFreq+0x262>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
900125dc:	4b29      	ldr	r3, [pc, #164]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
900125de:	681b      	ldr	r3, [r3, #0]
900125e0:	f403 7380 	and.w	r3, r3, #256	; 0x100
900125e4:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
900125e8:	d106      	bne.n	900125f8 <HAL_RCCEx_GetPeriphCLKFreq+0x240>
900125ea:	6b7b      	ldr	r3, [r7, #52]	; 0x34
900125ec:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
900125f0:	d102      	bne.n	900125f8 <HAL_RCCEx_GetPeriphCLKFreq+0x240>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
900125f2:	4b26      	ldr	r3, [pc, #152]	; (9001268c <HAL_RCCEx_GetPeriphCLKFreq+0x2d4>)
900125f4:	63fb      	str	r3, [r7, #60]	; 0x3c
900125f6:	e010      	b.n	9001261a <HAL_RCCEx_GetPeriphCLKFreq+0x262>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
900125f8:	4b22      	ldr	r3, [pc, #136]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
900125fa:	681b      	ldr	r3, [r3, #0]
900125fc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90012600:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90012604:	d106      	bne.n	90012614 <HAL_RCCEx_GetPeriphCLKFreq+0x25c>
90012606:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90012608:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
9001260c:	d102      	bne.n	90012614 <HAL_RCCEx_GetPeriphCLKFreq+0x25c>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
9001260e:	4b20      	ldr	r3, [pc, #128]	; (90012690 <HAL_RCCEx_GetPeriphCLKFreq+0x2d8>)
90012610:	63fb      	str	r3, [r7, #60]	; 0x3c
90012612:	e002      	b.n	9001261a <HAL_RCCEx_GetPeriphCLKFreq+0x262>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
90012614:	2300      	movs	r3, #0
90012616:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
90012618:	e393      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
9001261a:	e392      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case (RCC_SAI23CLKSOURCE_PIN): /* External clock is the clock source for SAI2/3 */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
9001261c:	4b1d      	ldr	r3, [pc, #116]	; (90012694 <HAL_RCCEx_GetPeriphCLKFreq+0x2dc>)
9001261e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012620:	e38f      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      default :
        {
          frequency = 0;
90012622:	2300      	movs	r3, #0
90012624:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012626:	e38c      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
      }
    }
#endif

#if defined(SAI4)
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
90012628:	687b      	ldr	r3, [r7, #4]
9001262a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
9001262e:	f040 80a7 	bne.w	90012780 <HAL_RCCEx_GetPeriphCLKFreq+0x3c8>
    {

      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
90012632:	4b14      	ldr	r3, [pc, #80]	; (90012684 <HAL_RCCEx_GetPeriphCLKFreq+0x2cc>)
90012634:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90012636:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
9001263a:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
9001263c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9001263e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
90012642:	d05f      	beq.n	90012704 <HAL_RCCEx_GetPeriphCLKFreq+0x34c>
90012644:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90012646:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
9001264a:	f200 8096 	bhi.w	9001277a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
9001264e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90012650:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
90012654:	f000 808e 	beq.w	90012774 <HAL_RCCEx_GetPeriphCLKFreq+0x3bc>
90012658:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9001265a:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
9001265e:	f200 808c 	bhi.w	9001277a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
90012662:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90012664:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
90012668:	d03a      	beq.n	900126e0 <HAL_RCCEx_GetPeriphCLKFreq+0x328>
9001266a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9001266c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
90012670:	f200 8083 	bhi.w	9001277a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
90012674:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90012676:	2b00      	cmp	r3, #0
90012678:	d00e      	beq.n	90012698 <HAL_RCCEx_GetPeriphCLKFreq+0x2e0>
9001267a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9001267c:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
90012680:	d01c      	beq.n	900126bc <HAL_RCCEx_GetPeriphCLKFreq+0x304>
90012682:	e07a      	b.n	9001277a <HAL_RCCEx_GetPeriphCLKFreq+0x3c2>
90012684:	58024400 	.word	0x58024400
90012688:	03d09000 	.word	0x03d09000
9001268c:	003d0900 	.word	0x003d0900
90012690:	017d7840 	.word	0x017d7840
90012694:	00bb8000 	.word	0x00bb8000
      {
      case RCC_SAI4ACLKSOURCE_PLL: /* PLL1 is the clock source for SAI4A */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
90012698:	4baa      	ldr	r3, [pc, #680]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
9001269a:	681b      	ldr	r3, [r3, #0]
9001269c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
900126a0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
900126a4:	d107      	bne.n	900126b6 <HAL_RCCEx_GetPeriphCLKFreq+0x2fe>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
900126a6:	f107 0324 	add.w	r3, r7, #36	; 0x24
900126aa:	4618      	mov	r0, r3
900126ac:	f000 fe14 	bl	900132d8 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
900126b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
900126b2:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
900126b4:	e345      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
900126b6:	2300      	movs	r3, #0
900126b8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
900126ba:	e342      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_SAI4ACLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4A */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
900126bc:	4ba1      	ldr	r3, [pc, #644]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
900126be:	681b      	ldr	r3, [r3, #0]
900126c0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
900126c4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
900126c8:	d107      	bne.n	900126da <HAL_RCCEx_GetPeriphCLKFreq+0x322>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
900126ca:	f107 0318 	add.w	r3, r7, #24
900126ce:	4618      	mov	r0, r3
900126d0:	f000 fb5a 	bl	90012d88 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
900126d4:	69bb      	ldr	r3, [r7, #24]
900126d6:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
900126d8:	e333      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
900126da:	2300      	movs	r3, #0
900126dc:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
900126de:	e330      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SAI4ACLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4A */
        {
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
900126e0:	4b98      	ldr	r3, [pc, #608]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
900126e2:	681b      	ldr	r3, [r3, #0]
900126e4:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
900126e8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
900126ec:	d107      	bne.n	900126fe <HAL_RCCEx_GetPeriphCLKFreq+0x346>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
900126ee:	f107 030c 	add.w	r3, r7, #12
900126f2:	4618      	mov	r0, r3
900126f4:	f000 fc9c 	bl	90013030 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
900126f8:	68fb      	ldr	r3, [r7, #12]
900126fa:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
900126fc:	e321      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
900126fe:	2300      	movs	r3, #0
90012700:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012702:	e31e      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SAI4ACLKSOURCE_CLKP: /* CKPER is the clock source for SAI4A*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
90012704:	4b8f      	ldr	r3, [pc, #572]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012706:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90012708:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
9001270c:	637b      	str	r3, [r7, #52]	; 0x34

          if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
9001270e:	4b8d      	ldr	r3, [pc, #564]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012710:	681b      	ldr	r3, [r3, #0]
90012712:	f003 0304 	and.w	r3, r3, #4
90012716:	2b04      	cmp	r3, #4
90012718:	d10c      	bne.n	90012734 <HAL_RCCEx_GetPeriphCLKFreq+0x37c>
9001271a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9001271c:	2b00      	cmp	r3, #0
9001271e:	d109      	bne.n	90012734 <HAL_RCCEx_GetPeriphCLKFreq+0x37c>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90012720:	4b88      	ldr	r3, [pc, #544]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012722:	681b      	ldr	r3, [r3, #0]
90012724:	08db      	lsrs	r3, r3, #3
90012726:	f003 0303 	and.w	r3, r3, #3
9001272a:	4a87      	ldr	r2, [pc, #540]	; (90012948 <HAL_RCCEx_GetPeriphCLKFreq+0x590>)
9001272c:	fa22 f303 	lsr.w	r3, r2, r3
90012730:	63fb      	str	r3, [r7, #60]	; 0x3c
90012732:	e01e      	b.n	90012772 <HAL_RCCEx_GetPeriphCLKFreq+0x3ba>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
90012734:	4b83      	ldr	r3, [pc, #524]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012736:	681b      	ldr	r3, [r3, #0]
90012738:	f403 7380 	and.w	r3, r3, #256	; 0x100
9001273c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90012740:	d106      	bne.n	90012750 <HAL_RCCEx_GetPeriphCLKFreq+0x398>
90012742:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90012744:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
90012748:	d102      	bne.n	90012750 <HAL_RCCEx_GetPeriphCLKFreq+0x398>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
9001274a:	4b80      	ldr	r3, [pc, #512]	; (9001294c <HAL_RCCEx_GetPeriphCLKFreq+0x594>)
9001274c:	63fb      	str	r3, [r7, #60]	; 0x3c
9001274e:	e010      	b.n	90012772 <HAL_RCCEx_GetPeriphCLKFreq+0x3ba>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
90012750:	4b7c      	ldr	r3, [pc, #496]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012752:	681b      	ldr	r3, [r3, #0]
90012754:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90012758:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
9001275c:	d106      	bne.n	9001276c <HAL_RCCEx_GetPeriphCLKFreq+0x3b4>
9001275e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90012760:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012764:	d102      	bne.n	9001276c <HAL_RCCEx_GetPeriphCLKFreq+0x3b4>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
90012766:	4b7a      	ldr	r3, [pc, #488]	; (90012950 <HAL_RCCEx_GetPeriphCLKFreq+0x598>)
90012768:	63fb      	str	r3, [r7, #60]	; 0x3c
9001276a:	e002      	b.n	90012772 <HAL_RCCEx_GetPeriphCLKFreq+0x3ba>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
9001276c:	2300      	movs	r3, #0
9001276e:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
90012770:	e2e7      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
90012772:	e2e6      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SAI4ACLKSOURCE_PIN: /* External clock is the clock source for SAI4A */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
90012774:	4b77      	ldr	r3, [pc, #476]	; (90012954 <HAL_RCCEx_GetPeriphCLKFreq+0x59c>)
90012776:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012778:	e2e3      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      default :
        {
          frequency = 0;
9001277a:	2300      	movs	r3, #0
9001277c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
9001277e:	e2e0      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      }
    }

  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
90012780:	687b      	ldr	r3, [r7, #4]
90012782:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
90012786:	f040 809c 	bne.w	900128c2 <HAL_RCCEx_GetPeriphCLKFreq+0x50a>
    {

      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
9001278a:	4b6e      	ldr	r3, [pc, #440]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
9001278c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
9001278e:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
90012792:	633b      	str	r3, [r7, #48]	; 0x30

      switch (saiclocksource)
90012794:	6b3b      	ldr	r3, [r7, #48]	; 0x30
90012796:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
9001279a:	d054      	beq.n	90012846 <HAL_RCCEx_GetPeriphCLKFreq+0x48e>
9001279c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
9001279e:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
900127a2:	f200 808b 	bhi.w	900128bc <HAL_RCCEx_GetPeriphCLKFreq+0x504>
900127a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
900127a8:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
900127ac:	f000 8083 	beq.w	900128b6 <HAL_RCCEx_GetPeriphCLKFreq+0x4fe>
900127b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
900127b2:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
900127b6:	f200 8081 	bhi.w	900128bc <HAL_RCCEx_GetPeriphCLKFreq+0x504>
900127ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
900127bc:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
900127c0:	d02f      	beq.n	90012822 <HAL_RCCEx_GetPeriphCLKFreq+0x46a>
900127c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
900127c4:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
900127c8:	d878      	bhi.n	900128bc <HAL_RCCEx_GetPeriphCLKFreq+0x504>
900127ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
900127cc:	2b00      	cmp	r3, #0
900127ce:	d004      	beq.n	900127da <HAL_RCCEx_GetPeriphCLKFreq+0x422>
900127d0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
900127d2:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
900127d6:	d012      	beq.n	900127fe <HAL_RCCEx_GetPeriphCLKFreq+0x446>
900127d8:	e070      	b.n	900128bc <HAL_RCCEx_GetPeriphCLKFreq+0x504>
      {
      case RCC_SAI4BCLKSOURCE_PLL: /* PLL1 is the clock source for SAI4B */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
900127da:	4b5a      	ldr	r3, [pc, #360]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
900127dc:	681b      	ldr	r3, [r3, #0]
900127de:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
900127e2:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
900127e6:	d107      	bne.n	900127f8 <HAL_RCCEx_GetPeriphCLKFreq+0x440>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
900127e8:	f107 0324 	add.w	r3, r7, #36	; 0x24
900127ec:	4618      	mov	r0, r3
900127ee:	f000 fd73 	bl	900132d8 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
900127f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
900127f4:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
900127f6:	e2a4      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
900127f8:	2300      	movs	r3, #0
900127fa:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
900127fc:	e2a1      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_SAI4BCLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4B */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
900127fe:	4b51      	ldr	r3, [pc, #324]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012800:	681b      	ldr	r3, [r3, #0]
90012802:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90012806:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
9001280a:	d107      	bne.n	9001281c <HAL_RCCEx_GetPeriphCLKFreq+0x464>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
9001280c:	f107 0318 	add.w	r3, r7, #24
90012810:	4618      	mov	r0, r3
90012812:	f000 fab9 	bl	90012d88 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
90012816:	69bb      	ldr	r3, [r7, #24]
90012818:	63fb      	str	r3, [r7, #60]	; 0x3c
          }
         else
         {
           frequency = 0;
         }
          break;
9001281a:	e292      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
9001281c:	2300      	movs	r3, #0
9001281e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012820:	e28f      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SAI4BCLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4B */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
90012822:	4b48      	ldr	r3, [pc, #288]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012824:	681b      	ldr	r3, [r3, #0]
90012826:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
9001282a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
9001282e:	d107      	bne.n	90012840 <HAL_RCCEx_GetPeriphCLKFreq+0x488>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
90012830:	f107 030c 	add.w	r3, r7, #12
90012834:	4618      	mov	r0, r3
90012836:	f000 fbfb 	bl	90013030 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
9001283a:	68fb      	ldr	r3, [r7, #12]
9001283c:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
9001283e:	e280      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
90012840:	2300      	movs	r3, #0
90012842:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012844:	e27d      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SAI4BCLKSOURCE_CLKP: /* CKPER is the clock source for SAI4B*/
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
90012846:	4b3f      	ldr	r3, [pc, #252]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012848:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
9001284a:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
9001284e:	637b      	str	r3, [r7, #52]	; 0x34

         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
90012850:	4b3c      	ldr	r3, [pc, #240]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012852:	681b      	ldr	r3, [r3, #0]
90012854:	f003 0304 	and.w	r3, r3, #4
90012858:	2b04      	cmp	r3, #4
9001285a:	d10c      	bne.n	90012876 <HAL_RCCEx_GetPeriphCLKFreq+0x4be>
9001285c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
9001285e:	2b00      	cmp	r3, #0
90012860:	d109      	bne.n	90012876 <HAL_RCCEx_GetPeriphCLKFreq+0x4be>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90012862:	4b38      	ldr	r3, [pc, #224]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012864:	681b      	ldr	r3, [r3, #0]
90012866:	08db      	lsrs	r3, r3, #3
90012868:	f003 0303 	and.w	r3, r3, #3
9001286c:	4a36      	ldr	r2, [pc, #216]	; (90012948 <HAL_RCCEx_GetPeriphCLKFreq+0x590>)
9001286e:	fa22 f303 	lsr.w	r3, r2, r3
90012872:	63fb      	str	r3, [r7, #60]	; 0x3c
90012874:	e01e      	b.n	900128b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4fc>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
90012876:	4b33      	ldr	r3, [pc, #204]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012878:	681b      	ldr	r3, [r3, #0]
9001287a:	f403 7380 	and.w	r3, r3, #256	; 0x100
9001287e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90012882:	d106      	bne.n	90012892 <HAL_RCCEx_GetPeriphCLKFreq+0x4da>
90012884:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90012886:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
9001288a:	d102      	bne.n	90012892 <HAL_RCCEx_GetPeriphCLKFreq+0x4da>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
9001288c:	4b2f      	ldr	r3, [pc, #188]	; (9001294c <HAL_RCCEx_GetPeriphCLKFreq+0x594>)
9001288e:	63fb      	str	r3, [r7, #60]	; 0x3c
90012890:	e010      	b.n	900128b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4fc>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
90012892:	4b2c      	ldr	r3, [pc, #176]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012894:	681b      	ldr	r3, [r3, #0]
90012896:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
9001289a:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
9001289e:	d106      	bne.n	900128ae <HAL_RCCEx_GetPeriphCLKFreq+0x4f6>
900128a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
900128a2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
900128a6:	d102      	bne.n	900128ae <HAL_RCCEx_GetPeriphCLKFreq+0x4f6>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
900128a8:	4b29      	ldr	r3, [pc, #164]	; (90012950 <HAL_RCCEx_GetPeriphCLKFreq+0x598>)
900128aa:	63fb      	str	r3, [r7, #60]	; 0x3c
900128ac:	e002      	b.n	900128b4 <HAL_RCCEx_GetPeriphCLKFreq+0x4fc>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
900128ae:	2300      	movs	r3, #0
900128b0:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
900128b2:	e246      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
900128b4:	e245      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SAI4BCLKSOURCE_PIN: /* External clock is the clock source for SAI4B */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
900128b6:	4b27      	ldr	r3, [pc, #156]	; (90012954 <HAL_RCCEx_GetPeriphCLKFreq+0x59c>)
900128b8:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
900128ba:	e242      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      default :
        {
          frequency = 0;
900128bc:	2300      	movs	r3, #0
900128be:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
900128c0:	e23f      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      }
    }
#endif /*SAI4*/
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
900128c2:	687b      	ldr	r3, [r7, #4]
900128c4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
900128c8:	f040 80a8 	bne.w	90012a1c <HAL_RCCEx_GetPeriphCLKFreq+0x664>
    {
      /* Get SPI1/2/3 clock source */
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
900128cc:	4b1d      	ldr	r3, [pc, #116]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
900128ce:	6d1b      	ldr	r3, [r3, #80]	; 0x50
900128d0:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
900128d4:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
900128d6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
900128d8:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
900128dc:	d060      	beq.n	900129a0 <HAL_RCCEx_GetPeriphCLKFreq+0x5e8>
900128de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
900128e0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
900128e4:	f200 8097 	bhi.w	90012a16 <HAL_RCCEx_GetPeriphCLKFreq+0x65e>
900128e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
900128ea:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
900128ee:	f000 808f 	beq.w	90012a10 <HAL_RCCEx_GetPeriphCLKFreq+0x658>
900128f2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
900128f4:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
900128f8:	f200 808d 	bhi.w	90012a16 <HAL_RCCEx_GetPeriphCLKFreq+0x65e>
900128fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
900128fe:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
90012902:	d03b      	beq.n	9001297c <HAL_RCCEx_GetPeriphCLKFreq+0x5c4>
90012904:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012906:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
9001290a:	f200 8084 	bhi.w	90012a16 <HAL_RCCEx_GetPeriphCLKFreq+0x65e>
9001290e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012910:	2b00      	cmp	r3, #0
90012912:	d004      	beq.n	9001291e <HAL_RCCEx_GetPeriphCLKFreq+0x566>
90012914:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012916:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
9001291a:	d01d      	beq.n	90012958 <HAL_RCCEx_GetPeriphCLKFreq+0x5a0>
9001291c:	e07b      	b.n	90012a16 <HAL_RCCEx_GetPeriphCLKFreq+0x65e>
      {
      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for SPI123 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
9001291e:	4b09      	ldr	r3, [pc, #36]	; (90012944 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>)
90012920:	681b      	ldr	r3, [r3, #0]
90012922:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90012926:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
9001292a:	d107      	bne.n	9001293c <HAL_RCCEx_GetPeriphCLKFreq+0x584>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
9001292c:	f107 0324 	add.w	r3, r7, #36	; 0x24
90012930:	4618      	mov	r0, r3
90012932:	f000 fcd1 	bl	900132d8 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
90012936:	6abb      	ldr	r3, [r7, #40]	; 0x28
90012938:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
9001293a:	e202      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
9001293c:	2300      	movs	r3, #0
9001293e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012940:	e1ff      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
90012942:	bf00      	nop
90012944:	58024400 	.word	0x58024400
90012948:	03d09000 	.word	0x03d09000
9001294c:	003d0900 	.word	0x003d0900
90012950:	017d7840 	.word	0x017d7840
90012954:	00bb8000 	.word	0x00bb8000
        }
      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI123 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
90012958:	4ba3      	ldr	r3, [pc, #652]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
9001295a:	681b      	ldr	r3, [r3, #0]
9001295c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90012960:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
90012964:	d107      	bne.n	90012976 <HAL_RCCEx_GetPeriphCLKFreq+0x5be>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
90012966:	f107 0318 	add.w	r3, r7, #24
9001296a:	4618      	mov	r0, r3
9001296c:	f000 fa0c 	bl	90012d88 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
90012970:	69bb      	ldr	r3, [r7, #24]
90012972:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
90012974:	e1e5      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
90012976:	2300      	movs	r3, #0
90012978:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
9001297a:	e1e2      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI123 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
9001297c:	4b9a      	ldr	r3, [pc, #616]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
9001297e:	681b      	ldr	r3, [r3, #0]
90012980:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
90012984:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012988:	d107      	bne.n	9001299a <HAL_RCCEx_GetPeriphCLKFreq+0x5e2>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
9001298a:	f107 030c 	add.w	r3, r7, #12
9001298e:	4618      	mov	r0, r3
90012990:	f000 fb4e 	bl	90013030 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
90012994:	68fb      	ldr	r3, [r7, #12]
90012996:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
90012998:	e1d3      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
9001299a:	2300      	movs	r3, #0
9001299c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
9001299e:	e1d0      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for SPI123 */
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
900129a0:	4b91      	ldr	r3, [pc, #580]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
900129a2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
900129a4:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
900129a8:	637b      	str	r3, [r7, #52]	; 0x34

         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
900129aa:	4b8f      	ldr	r3, [pc, #572]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
900129ac:	681b      	ldr	r3, [r3, #0]
900129ae:	f003 0304 	and.w	r3, r3, #4
900129b2:	2b04      	cmp	r3, #4
900129b4:	d10c      	bne.n	900129d0 <HAL_RCCEx_GetPeriphCLKFreq+0x618>
900129b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
900129b8:	2b00      	cmp	r3, #0
900129ba:	d109      	bne.n	900129d0 <HAL_RCCEx_GetPeriphCLKFreq+0x618>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
900129bc:	4b8a      	ldr	r3, [pc, #552]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
900129be:	681b      	ldr	r3, [r3, #0]
900129c0:	08db      	lsrs	r3, r3, #3
900129c2:	f003 0303 	and.w	r3, r3, #3
900129c6:	4a89      	ldr	r2, [pc, #548]	; (90012bec <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
900129c8:	fa22 f303 	lsr.w	r3, r2, r3
900129cc:	63fb      	str	r3, [r7, #60]	; 0x3c
900129ce:	e01e      	b.n	90012a0e <HAL_RCCEx_GetPeriphCLKFreq+0x656>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
900129d0:	4b85      	ldr	r3, [pc, #532]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
900129d2:	681b      	ldr	r3, [r3, #0]
900129d4:	f403 7380 	and.w	r3, r3, #256	; 0x100
900129d8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
900129dc:	d106      	bne.n	900129ec <HAL_RCCEx_GetPeriphCLKFreq+0x634>
900129de:	6b7b      	ldr	r3, [r7, #52]	; 0x34
900129e0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
900129e4:	d102      	bne.n	900129ec <HAL_RCCEx_GetPeriphCLKFreq+0x634>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
900129e6:	4b82      	ldr	r3, [pc, #520]	; (90012bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x838>)
900129e8:	63fb      	str	r3, [r7, #60]	; 0x3c
900129ea:	e010      	b.n	90012a0e <HAL_RCCEx_GetPeriphCLKFreq+0x656>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
900129ec:	4b7e      	ldr	r3, [pc, #504]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
900129ee:	681b      	ldr	r3, [r3, #0]
900129f0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
900129f4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
900129f8:	d106      	bne.n	90012a08 <HAL_RCCEx_GetPeriphCLKFreq+0x650>
900129fa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
900129fc:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012a00:	d102      	bne.n	90012a08 <HAL_RCCEx_GetPeriphCLKFreq+0x650>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
90012a02:	4b7c      	ldr	r3, [pc, #496]	; (90012bf4 <HAL_RCCEx_GetPeriphCLKFreq+0x83c>)
90012a04:	63fb      	str	r3, [r7, #60]	; 0x3c
90012a06:	e002      	b.n	90012a0e <HAL_RCCEx_GetPeriphCLKFreq+0x656>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
90012a08:	2300      	movs	r3, #0
90012a0a:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
90012a0c:	e199      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
90012a0e:	e198      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */
        {
          frequency = EXTERNAL_CLOCK_VALUE;
90012a10:	4b79      	ldr	r3, [pc, #484]	; (90012bf8 <HAL_RCCEx_GetPeriphCLKFreq+0x840>)
90012a12:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012a14:	e195      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      default :
        {
          frequency = 0;
90012a16:	2300      	movs	r3, #0
90012a18:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012a1a:	e192      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
90012a1c:	687b      	ldr	r3, [r7, #4]
90012a1e:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
90012a22:	d173      	bne.n	90012b0c <HAL_RCCEx_GetPeriphCLKFreq+0x754>
    {
      /* Get ADC clock source */
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
90012a24:	4b70      	ldr	r3, [pc, #448]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012a26:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90012a28:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
90012a2c:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
90012a2e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012a30:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90012a34:	d02f      	beq.n	90012a96 <HAL_RCCEx_GetPeriphCLKFreq+0x6de>
90012a36:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012a38:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90012a3c:	d863      	bhi.n	90012b06 <HAL_RCCEx_GetPeriphCLKFreq+0x74e>
90012a3e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012a40:	2b00      	cmp	r3, #0
90012a42:	d004      	beq.n	90012a4e <HAL_RCCEx_GetPeriphCLKFreq+0x696>
90012a44:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012a46:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
90012a4a:	d012      	beq.n	90012a72 <HAL_RCCEx_GetPeriphCLKFreq+0x6ba>
90012a4c:	e05b      	b.n	90012b06 <HAL_RCCEx_GetPeriphCLKFreq+0x74e>
      {
      case RCC_ADCCLKSOURCE_PLL2:
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
90012a4e:	4b66      	ldr	r3, [pc, #408]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012a50:	681b      	ldr	r3, [r3, #0]
90012a52:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90012a56:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
90012a5a:	d107      	bne.n	90012a6c <HAL_RCCEx_GetPeriphCLKFreq+0x6b4>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
90012a5c:	f107 0318 	add.w	r3, r7, #24
90012a60:	4618      	mov	r0, r3
90012a62:	f000 f991 	bl	90012d88 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
90012a66:	69bb      	ldr	r3, [r7, #24]
90012a68:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
90012a6a:	e16a      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
90012a6c:	2300      	movs	r3, #0
90012a6e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012a70:	e167      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_ADCCLKSOURCE_PLL3:
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
90012a72:	4b5d      	ldr	r3, [pc, #372]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012a74:	681b      	ldr	r3, [r3, #0]
90012a76:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
90012a7a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012a7e:	d107      	bne.n	90012a90 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
90012a80:	f107 030c 	add.w	r3, r7, #12
90012a84:	4618      	mov	r0, r3
90012a86:	f000 fad3 	bl	90013030 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
90012a8a:	697b      	ldr	r3, [r7, #20]
90012a8c:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
90012a8e:	e158      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
90012a90:	2300      	movs	r3, #0
90012a92:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012a94:	e155      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      case RCC_ADCCLKSOURCE_CLKP:
        {

          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
90012a96:	4b54      	ldr	r3, [pc, #336]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012a98:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90012a9a:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
90012a9e:	637b      	str	r3, [r7, #52]	; 0x34

         if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
90012aa0:	4b51      	ldr	r3, [pc, #324]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012aa2:	681b      	ldr	r3, [r3, #0]
90012aa4:	f003 0304 	and.w	r3, r3, #4
90012aa8:	2b04      	cmp	r3, #4
90012aaa:	d10c      	bne.n	90012ac6 <HAL_RCCEx_GetPeriphCLKFreq+0x70e>
90012aac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90012aae:	2b00      	cmp	r3, #0
90012ab0:	d109      	bne.n	90012ac6 <HAL_RCCEx_GetPeriphCLKFreq+0x70e>
          {
            /* In Case the CKPER Source is HSI */
            frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90012ab2:	4b4d      	ldr	r3, [pc, #308]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012ab4:	681b      	ldr	r3, [r3, #0]
90012ab6:	08db      	lsrs	r3, r3, #3
90012ab8:	f003 0303 	and.w	r3, r3, #3
90012abc:	4a4b      	ldr	r2, [pc, #300]	; (90012bec <HAL_RCCEx_GetPeriphCLKFreq+0x834>)
90012abe:	fa22 f303 	lsr.w	r3, r2, r3
90012ac2:	63fb      	str	r3, [r7, #60]	; 0x3c
90012ac4:	e01e      	b.n	90012b04 <HAL_RCCEx_GetPeriphCLKFreq+0x74c>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
90012ac6:	4b48      	ldr	r3, [pc, #288]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012ac8:	681b      	ldr	r3, [r3, #0]
90012aca:	f403 7380 	and.w	r3, r3, #256	; 0x100
90012ace:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90012ad2:	d106      	bne.n	90012ae2 <HAL_RCCEx_GetPeriphCLKFreq+0x72a>
90012ad4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90012ad6:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
90012ada:	d102      	bne.n	90012ae2 <HAL_RCCEx_GetPeriphCLKFreq+0x72a>
          {
            /* In Case the CKPER Source is CSI */
            frequency = CSI_VALUE;
90012adc:	4b44      	ldr	r3, [pc, #272]	; (90012bf0 <HAL_RCCEx_GetPeriphCLKFreq+0x838>)
90012ade:	63fb      	str	r3, [r7, #60]	; 0x3c
90012ae0:	e010      	b.n	90012b04 <HAL_RCCEx_GetPeriphCLKFreq+0x74c>
          }

          else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
90012ae2:	4b41      	ldr	r3, [pc, #260]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012ae4:	681b      	ldr	r3, [r3, #0]
90012ae6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90012aea:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90012aee:	d106      	bne.n	90012afe <HAL_RCCEx_GetPeriphCLKFreq+0x746>
90012af0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
90012af2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012af6:	d102      	bne.n	90012afe <HAL_RCCEx_GetPeriphCLKFreq+0x746>
          {
            /* In Case the CKPER Source is HSE */
            frequency = HSE_VALUE;
90012af8:	4b3e      	ldr	r3, [pc, #248]	; (90012bf4 <HAL_RCCEx_GetPeriphCLKFreq+0x83c>)
90012afa:	63fb      	str	r3, [r7, #60]	; 0x3c
90012afc:	e002      	b.n	90012b04 <HAL_RCCEx_GetPeriphCLKFreq+0x74c>
          }

          else
          {
            /* In Case the CKPER is disabled*/
            frequency = 0;
90012afe:	2300      	movs	r3, #0
90012b00:	63fb      	str	r3, [r7, #60]	; 0x3c
          }

          break;
90012b02:	e11e      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
90012b04:	e11d      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      default :
        {
          frequency = 0;
90012b06:	2300      	movs	r3, #0
90012b08:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012b0a:	e11a      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
90012b0c:	687b      	ldr	r3, [r7, #4]
90012b0e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
90012b12:	d133      	bne.n	90012b7c <HAL_RCCEx_GetPeriphCLKFreq+0x7c4>
    {
      /* Get SDMMC clock source */
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
90012b14:	4b34      	ldr	r3, [pc, #208]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012b16:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90012b18:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
90012b1c:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
90012b1e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012b20:	2b00      	cmp	r3, #0
90012b22:	d004      	beq.n	90012b2e <HAL_RCCEx_GetPeriphCLKFreq+0x776>
90012b24:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012b26:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
90012b2a:	d012      	beq.n	90012b52 <HAL_RCCEx_GetPeriphCLKFreq+0x79a>
90012b2c:	e023      	b.n	90012b76 <HAL_RCCEx_GetPeriphCLKFreq+0x7be>
      {
      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
90012b2e:	4b2e      	ldr	r3, [pc, #184]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012b30:	681b      	ldr	r3, [r3, #0]
90012b32:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90012b36:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
90012b3a:	d107      	bne.n	90012b4c <HAL_RCCEx_GetPeriphCLKFreq+0x794>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
90012b3c:	f107 0324 	add.w	r3, r7, #36	; 0x24
90012b40:	4618      	mov	r0, r3
90012b42:	f000 fbc9 	bl	900132d8 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
90012b46:	6abb      	ldr	r3, [r7, #40]	; 0x28
90012b48:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
90012b4a:	e0fa      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
          frequency = 0;
90012b4c:	2300      	movs	r3, #0
90012b4e:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012b50:	e0f7      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */
        {
          if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
90012b52:	4b25      	ldr	r3, [pc, #148]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012b54:	681b      	ldr	r3, [r3, #0]
90012b56:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90012b5a:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
90012b5e:	d107      	bne.n	90012b70 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
90012b60:	f107 0318 	add.w	r3, r7, #24
90012b64:	4618      	mov	r0, r3
90012b66:	f000 f90f 	bl	90012d88 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
90012b6a:	6a3b      	ldr	r3, [r7, #32]
90012b6c:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
90012b6e:	e0e8      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
          frequency = 0;
90012b70:	2300      	movs	r3, #0
90012b72:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012b74:	e0e5      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }

      default :
        {
          frequency = 0;
90012b76:	2300      	movs	r3, #0
90012b78:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012b7a:	e0e2      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
90012b7c:	687b      	ldr	r3, [r7, #4]
90012b7e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
90012b82:	f040 808f 	bne.w	90012ca4 <HAL_RCCEx_GetPeriphCLKFreq+0x8ec>
    {
      /* Get SPI6 clock source */
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
90012b86:	4b18      	ldr	r3, [pc, #96]	; (90012be8 <HAL_RCCEx_GetPeriphCLKFreq+0x830>)
90012b88:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90012b8a:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
90012b8e:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
90012b90:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012b92:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
90012b96:	d075      	beq.n	90012c84 <HAL_RCCEx_GetPeriphCLKFreq+0x8cc>
90012b98:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012b9a:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
90012b9e:	d87e      	bhi.n	90012c9e <HAL_RCCEx_GetPeriphCLKFreq+0x8e6>
90012ba0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012ba2:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
90012ba6:	d060      	beq.n	90012c6a <HAL_RCCEx_GetPeriphCLKFreq+0x8b2>
90012ba8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012baa:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
90012bae:	d876      	bhi.n	90012c9e <HAL_RCCEx_GetPeriphCLKFreq+0x8e6>
90012bb0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012bb2:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
90012bb6:	d045      	beq.n	90012c44 <HAL_RCCEx_GetPeriphCLKFreq+0x88c>
90012bb8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012bba:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
90012bbe:	d86e      	bhi.n	90012c9e <HAL_RCCEx_GetPeriphCLKFreq+0x8e6>
90012bc0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012bc2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012bc6:	d02b      	beq.n	90012c20 <HAL_RCCEx_GetPeriphCLKFreq+0x868>
90012bc8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012bca:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012bce:	d866      	bhi.n	90012c9e <HAL_RCCEx_GetPeriphCLKFreq+0x8e6>
90012bd0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012bd2:	2b00      	cmp	r3, #0
90012bd4:	d004      	beq.n	90012be0 <HAL_RCCEx_GetPeriphCLKFreq+0x828>
90012bd6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012bd8:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
90012bdc:	d00e      	beq.n	90012bfc <HAL_RCCEx_GetPeriphCLKFreq+0x844>
90012bde:	e05e      	b.n	90012c9e <HAL_RCCEx_GetPeriphCLKFreq+0x8e6>
      {
      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */
        {
          frequency = HAL_RCCEx_GetD3PCLK1Freq();
90012be0:	f000 f8bc 	bl	90012d5c <HAL_RCCEx_GetD3PCLK1Freq>
90012be4:	63f8      	str	r0, [r7, #60]	; 0x3c
          break;
90012be6:	e0ac      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
90012be8:	58024400 	.word	0x58024400
90012bec:	03d09000 	.word	0x03d09000
90012bf0:	003d0900 	.word	0x003d0900
90012bf4:	017d7840 	.word	0x017d7840
90012bf8:	00bb8000 	.word	0x00bb8000
        }
      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
90012bfc:	4b53      	ldr	r3, [pc, #332]	; (90012d4c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
90012bfe:	681b      	ldr	r3, [r3, #0]
90012c00:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90012c04:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
90012c08:	d107      	bne.n	90012c1a <HAL_RCCEx_GetPeriphCLKFreq+0x862>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
90012c0a:	f107 0318 	add.w	r3, r7, #24
90012c0e:	4618      	mov	r0, r3
90012c10:	f000 f8ba 	bl	90012d88 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
90012c14:	69fb      	ldr	r3, [r7, #28]
90012c16:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
90012c18:	e093      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
          frequency = 0;
90012c1a:	2300      	movs	r3, #0
90012c1c:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012c1e:	e090      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
90012c20:	4b4a      	ldr	r3, [pc, #296]	; (90012d4c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
90012c22:	681b      	ldr	r3, [r3, #0]
90012c24:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
90012c28:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012c2c:	d107      	bne.n	90012c3e <HAL_RCCEx_GetPeriphCLKFreq+0x886>
         {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
90012c2e:	f107 030c 	add.w	r3, r7, #12
90012c32:	4618      	mov	r0, r3
90012c34:	f000 f9fc 	bl	90013030 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
90012c38:	693b      	ldr	r3, [r7, #16]
90012c3a:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
90012c3c:	e081      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
          frequency = 0;
90012c3e:	2300      	movs	r3, #0
90012c40:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012c42:	e07e      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
90012c44:	4b41      	ldr	r3, [pc, #260]	; (90012d4c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
90012c46:	681b      	ldr	r3, [r3, #0]
90012c48:	f003 0304 	and.w	r3, r3, #4
90012c4c:	2b04      	cmp	r3, #4
90012c4e:	d109      	bne.n	90012c64 <HAL_RCCEx_GetPeriphCLKFreq+0x8ac>
         {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90012c50:	4b3e      	ldr	r3, [pc, #248]	; (90012d4c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
90012c52:	681b      	ldr	r3, [r3, #0]
90012c54:	08db      	lsrs	r3, r3, #3
90012c56:	f003 0303 	and.w	r3, r3, #3
90012c5a:	4a3d      	ldr	r2, [pc, #244]	; (90012d50 <HAL_RCCEx_GetPeriphCLKFreq+0x998>)
90012c5c:	fa22 f303 	lsr.w	r3, r2, r3
90012c60:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
90012c62:	e06e      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
          frequency = 0;
90012c64:	2300      	movs	r3, #0
90012c66:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012c68:	e06b      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
90012c6a:	4b38      	ldr	r3, [pc, #224]	; (90012d4c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
90012c6c:	681b      	ldr	r3, [r3, #0]
90012c6e:	f403 7380 	and.w	r3, r3, #256	; 0x100
90012c72:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90012c76:	d102      	bne.n	90012c7e <HAL_RCCEx_GetPeriphCLKFreq+0x8c6>
         {
          frequency = CSI_VALUE;
90012c78:	4b36      	ldr	r3, [pc, #216]	; (90012d54 <HAL_RCCEx_GetPeriphCLKFreq+0x99c>)
90012c7a:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
           frequency = 0;
         }
          break;
90012c7c:	e061      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
           frequency = 0;
90012c7e:	2300      	movs	r3, #0
90012c80:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012c82:	e05e      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
90012c84:	4b31      	ldr	r3, [pc, #196]	; (90012d4c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
90012c86:	681b      	ldr	r3, [r3, #0]
90012c88:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90012c8c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90012c90:	d102      	bne.n	90012c98 <HAL_RCCEx_GetPeriphCLKFreq+0x8e0>
         {
          frequency = HSE_VALUE;
90012c92:	4b31      	ldr	r3, [pc, #196]	; (90012d58 <HAL_RCCEx_GetPeriphCLKFreq+0x9a0>)
90012c94:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
90012c96:	e054      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
          frequency = 0;
90012c98:	2300      	movs	r3, #0
90012c9a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012c9c:	e051      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
          break;
        }
#endif /* RCC_SPI6CLKSOURCE_PIN */
      default :
        {
          frequency = 0;
90012c9e:	2300      	movs	r3, #0
90012ca0:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012ca2:	e04e      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      }
    }
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN)
90012ca4:	687b      	ldr	r3, [r7, #4]
90012ca6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
90012caa:	d148      	bne.n	90012d3e <HAL_RCCEx_GetPeriphCLKFreq+0x986>
    {
      /* Get FDCAN clock source */
      srcclk= __HAL_RCC_GET_FDCAN_SOURCE();
90012cac:	4b27      	ldr	r3, [pc, #156]	; (90012d4c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
90012cae:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90012cb0:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
90012cb4:	63bb      	str	r3, [r7, #56]	; 0x38

      switch (srcclk)
90012cb6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012cb8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012cbc:	d02a      	beq.n	90012d14 <HAL_RCCEx_GetPeriphCLKFreq+0x95c>
90012cbe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012cc0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
90012cc4:	d838      	bhi.n	90012d38 <HAL_RCCEx_GetPeriphCLKFreq+0x980>
90012cc6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012cc8:	2b00      	cmp	r3, #0
90012cca:	d004      	beq.n	90012cd6 <HAL_RCCEx_GetPeriphCLKFreq+0x91e>
90012ccc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90012cce:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
90012cd2:	d00d      	beq.n	90012cf0 <HAL_RCCEx_GetPeriphCLKFreq+0x938>
90012cd4:	e030      	b.n	90012d38 <HAL_RCCEx_GetPeriphCLKFreq+0x980>
      {
      case RCC_FDCANCLKSOURCE_HSE: /* HSE is the clock source for FDCAN */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
90012cd6:	4b1d      	ldr	r3, [pc, #116]	; (90012d4c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
90012cd8:	681b      	ldr	r3, [r3, #0]
90012cda:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
90012cde:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
90012ce2:	d102      	bne.n	90012cea <HAL_RCCEx_GetPeriphCLKFreq+0x932>
         {
          frequency = HSE_VALUE;
90012ce4:	4b1c      	ldr	r3, [pc, #112]	; (90012d58 <HAL_RCCEx_GetPeriphCLKFreq+0x9a0>)
90012ce6:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
90012ce8:	e02b      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
          frequency = 0;
90012cea:	2300      	movs	r3, #0
90012cec:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012cee:	e028      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_FDCANCLKSOURCE_PLL: /* PLL is the clock source for FDCAN */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
90012cf0:	4b16      	ldr	r3, [pc, #88]	; (90012d4c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
90012cf2:	681b      	ldr	r3, [r3, #0]
90012cf4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
90012cf8:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
90012cfc:	d107      	bne.n	90012d0e <HAL_RCCEx_GetPeriphCLKFreq+0x956>
         {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
90012cfe:	f107 0324 	add.w	r3, r7, #36	; 0x24
90012d02:	4618      	mov	r0, r3
90012d04:	f000 fae8 	bl	900132d8 <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
90012d08:	6abb      	ldr	r3, [r7, #40]	; 0x28
90012d0a:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
90012d0c:	e019      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
          frequency = 0;
90012d0e:	2300      	movs	r3, #0
90012d10:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012d12:	e016      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is the clock source for FDCAN */
        {
         if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
90012d14:	4b0d      	ldr	r3, [pc, #52]	; (90012d4c <HAL_RCCEx_GetPeriphCLKFreq+0x994>)
90012d16:	681b      	ldr	r3, [r3, #0]
90012d18:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90012d1c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
90012d20:	d107      	bne.n	90012d32 <HAL_RCCEx_GetPeriphCLKFreq+0x97a>
         {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
90012d22:	f107 0318 	add.w	r3, r7, #24
90012d26:	4618      	mov	r0, r3
90012d28:	f000 f82e 	bl	90012d88 <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
90012d2c:	69fb      	ldr	r3, [r7, #28]
90012d2e:	63fb      	str	r3, [r7, #60]	; 0x3c
         }
         else
         {
          frequency = 0;
         }
          break;
90012d30:	e007      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
          frequency = 0;
90012d32:	2300      	movs	r3, #0
90012d34:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012d36:	e004      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      default :
        {
          frequency = 0;
90012d38:	2300      	movs	r3, #0
90012d3a:	63fb      	str	r3, [r7, #60]	; 0x3c
          break;
90012d3c:	e001      	b.n	90012d42 <HAL_RCCEx_GetPeriphCLKFreq+0x98a>
        }
      }
    }
  else
    {
      frequency = 0;
90012d3e:	2300      	movs	r3, #0
90012d40:	63fb      	str	r3, [r7, #60]	; 0x3c
    }

  return frequency;
90012d42:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
90012d44:	4618      	mov	r0, r3
90012d46:	3740      	adds	r7, #64	; 0x40
90012d48:	46bd      	mov	sp, r7
90012d4a:	bd80      	pop	{r7, pc}
90012d4c:	58024400 	.word	0x58024400
90012d50:	03d09000 	.word	0x03d09000
90012d54:	003d0900 	.word	0x003d0900
90012d58:	017d7840 	.word	0x017d7840

90012d5c <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
90012d5c:	b580      	push	{r7, lr}
90012d5e:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
90012d60:	f7fe fa38 	bl	900111d4 <HAL_RCC_GetHCLKFreq>
90012d64:	4602      	mov	r2, r0
90012d66:	4b06      	ldr	r3, [pc, #24]	; (90012d80 <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
90012d68:	6a1b      	ldr	r3, [r3, #32]
90012d6a:	091b      	lsrs	r3, r3, #4
90012d6c:	f003 0307 	and.w	r3, r3, #7
90012d70:	4904      	ldr	r1, [pc, #16]	; (90012d84 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
90012d72:	5ccb      	ldrb	r3, [r1, r3]
90012d74:	f003 031f 	and.w	r3, r3, #31
90012d78:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE)>> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
90012d7c:	4618      	mov	r0, r3
90012d7e:	bd80      	pop	{r7, pc}
90012d80:	58024400 	.word	0x58024400
90012d84:	9001e8a8 	.word	0x9001e8a8

90012d88 <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef* PLL2_Clocks)
{
90012d88:	b480      	push	{r7}
90012d8a:	b089      	sub	sp, #36	; 0x24
90012d8c:	af00      	add	r7, sp, #0
90012d8e:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90012d90:	4ba1      	ldr	r3, [pc, #644]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012d92:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90012d94:	f003 0303 	and.w	r3, r3, #3
90012d98:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
90012d9a:	4b9f      	ldr	r3, [pc, #636]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012d9c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90012d9e:	0b1b      	lsrs	r3, r3, #12
90012da0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
90012da4:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
90012da6:	4b9c      	ldr	r3, [pc, #624]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012da8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90012daa:	091b      	lsrs	r3, r3, #4
90012dac:	f003 0301 	and.w	r3, r3, #1
90012db0:	613b      	str	r3, [r7, #16]
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
90012db2:	4b99      	ldr	r3, [pc, #612]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012db4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
90012db6:	08db      	lsrs	r3, r3, #3
90012db8:	f3c3 030c 	ubfx	r3, r3, #0, #13
90012dbc:	693a      	ldr	r2, [r7, #16]
90012dbe:	fb02 f303 	mul.w	r3, r2, r3
90012dc2:	ee07 3a90 	vmov	s15, r3
90012dc6:	eef8 7a67 	vcvt.f32.u32	s15, s15
90012dca:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
90012dce:	697b      	ldr	r3, [r7, #20]
90012dd0:	2b00      	cmp	r3, #0
90012dd2:	f000 8111 	beq.w	90012ff8 <HAL_RCCEx_GetPLL2ClockFreq+0x270>
  {
    switch (pllsource)
90012dd6:	69bb      	ldr	r3, [r7, #24]
90012dd8:	2b02      	cmp	r3, #2
90012dda:	f000 8083 	beq.w	90012ee4 <HAL_RCCEx_GetPLL2ClockFreq+0x15c>
90012dde:	69bb      	ldr	r3, [r7, #24]
90012de0:	2b02      	cmp	r3, #2
90012de2:	f200 80a1 	bhi.w	90012f28 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
90012de6:	69bb      	ldr	r3, [r7, #24]
90012de8:	2b00      	cmp	r3, #0
90012dea:	d003      	beq.n	90012df4 <HAL_RCCEx_GetPLL2ClockFreq+0x6c>
90012dec:	69bb      	ldr	r3, [r7, #24]
90012dee:	2b01      	cmp	r3, #1
90012df0:	d056      	beq.n	90012ea0 <HAL_RCCEx_GetPLL2ClockFreq+0x118>
90012df2:	e099      	b.n	90012f28 <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
90012df4:	4b88      	ldr	r3, [pc, #544]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012df6:	681b      	ldr	r3, [r3, #0]
90012df8:	f003 0320 	and.w	r3, r3, #32
90012dfc:	2b00      	cmp	r3, #0
90012dfe:	d02d      	beq.n	90012e5c <HAL_RCCEx_GetPLL2ClockFreq+0xd4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
90012e00:	4b85      	ldr	r3, [pc, #532]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012e02:	681b      	ldr	r3, [r3, #0]
90012e04:	08db      	lsrs	r3, r3, #3
90012e06:	f003 0303 	and.w	r3, r3, #3
90012e0a:	4a84      	ldr	r2, [pc, #528]	; (9001301c <HAL_RCCEx_GetPLL2ClockFreq+0x294>)
90012e0c:	fa22 f303 	lsr.w	r3, r2, r3
90012e10:	60bb      	str	r3, [r7, #8]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90012e12:	68bb      	ldr	r3, [r7, #8]
90012e14:	ee07 3a90 	vmov	s15, r3
90012e18:	eef8 6a67 	vcvt.f32.u32	s13, s15
90012e1c:	697b      	ldr	r3, [r7, #20]
90012e1e:	ee07 3a90 	vmov	s15, r3
90012e22:	eef8 7a67 	vcvt.f32.u32	s15, s15
90012e26:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90012e2a:	4b7b      	ldr	r3, [pc, #492]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012e2c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90012e2e:	f3c3 0308 	ubfx	r3, r3, #0, #9
90012e32:	ee07 3a90 	vmov	s15, r3
90012e36:	eef8 6a67 	vcvt.f32.u32	s13, s15
90012e3a:	ed97 6a03 	vldr	s12, [r7, #12]
90012e3e:	eddf 5a78 	vldr	s11, [pc, #480]	; 90013020 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
90012e42:	eec6 7a25 	vdiv.f32	s15, s12, s11
90012e46:	ee76 7aa7 	vadd.f32	s15, s13, s15
90012e4a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
90012e4e:	ee77 7aa6 	vadd.f32	s15, s15, s13
90012e52:	ee67 7a27 	vmul.f32	s15, s14, s15
90012e56:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
      }
      break;
90012e5a:	e087      	b.n	90012f6c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90012e5c:	697b      	ldr	r3, [r7, #20]
90012e5e:	ee07 3a90 	vmov	s15, r3
90012e62:	eef8 7a67 	vcvt.f32.u32	s15, s15
90012e66:	eddf 6a6f 	vldr	s13, [pc, #444]	; 90013024 <HAL_RCCEx_GetPLL2ClockFreq+0x29c>
90012e6a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90012e6e:	4b6a      	ldr	r3, [pc, #424]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012e70:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90012e72:	f3c3 0308 	ubfx	r3, r3, #0, #9
90012e76:	ee07 3a90 	vmov	s15, r3
90012e7a:	eef8 6a67 	vcvt.f32.u32	s13, s15
90012e7e:	ed97 6a03 	vldr	s12, [r7, #12]
90012e82:	eddf 5a67 	vldr	s11, [pc, #412]	; 90013020 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
90012e86:	eec6 7a25 	vdiv.f32	s15, s12, s11
90012e8a:	ee76 7aa7 	vadd.f32	s15, s13, s15
90012e8e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
90012e92:	ee77 7aa6 	vadd.f32	s15, s15, s13
90012e96:	ee67 7a27 	vmul.f32	s15, s14, s15
90012e9a:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
90012e9e:	e065      	b.n	90012f6c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90012ea0:	697b      	ldr	r3, [r7, #20]
90012ea2:	ee07 3a90 	vmov	s15, r3
90012ea6:	eef8 7a67 	vcvt.f32.u32	s15, s15
90012eaa:	eddf 6a5f 	vldr	s13, [pc, #380]	; 90013028 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
90012eae:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90012eb2:	4b59      	ldr	r3, [pc, #356]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012eb4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90012eb6:	f3c3 0308 	ubfx	r3, r3, #0, #9
90012eba:	ee07 3a90 	vmov	s15, r3
90012ebe:	eef8 6a67 	vcvt.f32.u32	s13, s15
90012ec2:	ed97 6a03 	vldr	s12, [r7, #12]
90012ec6:	eddf 5a56 	vldr	s11, [pc, #344]	; 90013020 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
90012eca:	eec6 7a25 	vdiv.f32	s15, s12, s11
90012ece:	ee76 7aa7 	vadd.f32	s15, s13, s15
90012ed2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
90012ed6:	ee77 7aa6 	vadd.f32	s15, s15, s13
90012eda:	ee67 7a27 	vmul.f32	s15, s14, s15
90012ede:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
90012ee2:	e043      	b.n	90012f6c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90012ee4:	697b      	ldr	r3, [r7, #20]
90012ee6:	ee07 3a90 	vmov	s15, r3
90012eea:	eef8 7a67 	vcvt.f32.u32	s15, s15
90012eee:	eddf 6a4f 	vldr	s13, [pc, #316]	; 9001302c <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>
90012ef2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90012ef6:	4b48      	ldr	r3, [pc, #288]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012ef8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90012efa:	f3c3 0308 	ubfx	r3, r3, #0, #9
90012efe:	ee07 3a90 	vmov	s15, r3
90012f02:	eef8 6a67 	vcvt.f32.u32	s13, s15
90012f06:	ed97 6a03 	vldr	s12, [r7, #12]
90012f0a:	eddf 5a45 	vldr	s11, [pc, #276]	; 90013020 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
90012f0e:	eec6 7a25 	vdiv.f32	s15, s12, s11
90012f12:	ee76 7aa7 	vadd.f32	s15, s13, s15
90012f16:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
90012f1a:	ee77 7aa6 	vadd.f32	s15, s15, s13
90012f1e:	ee67 7a27 	vmul.f32	s15, s14, s15
90012f22:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
90012f26:	e021      	b.n	90012f6c <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    default:
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
90012f28:	697b      	ldr	r3, [r7, #20]
90012f2a:	ee07 3a90 	vmov	s15, r3
90012f2e:	eef8 7a67 	vcvt.f32.u32	s15, s15
90012f32:	eddf 6a3d 	vldr	s13, [pc, #244]	; 90013028 <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
90012f36:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90012f3a:	4b37      	ldr	r3, [pc, #220]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012f3c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90012f3e:	f3c3 0308 	ubfx	r3, r3, #0, #9
90012f42:	ee07 3a90 	vmov	s15, r3
90012f46:	eef8 6a67 	vcvt.f32.u32	s13, s15
90012f4a:	ed97 6a03 	vldr	s12, [r7, #12]
90012f4e:	eddf 5a34 	vldr	s11, [pc, #208]	; 90013020 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
90012f52:	eec6 7a25 	vdiv.f32	s15, s12, s11
90012f56:	ee76 7aa7 	vadd.f32	s15, s13, s15
90012f5a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
90012f5e:	ee77 7aa6 	vadd.f32	s15, s15, s13
90012f62:	ee67 7a27 	vmul.f32	s15, s14, s15
90012f66:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
90012f6a:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
90012f6c:	4b2a      	ldr	r3, [pc, #168]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012f6e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90012f70:	0a5b      	lsrs	r3, r3, #9
90012f72:	f003 037f 	and.w	r3, r3, #127	; 0x7f
90012f76:	ee07 3a90 	vmov	s15, r3
90012f7a:	eef8 7a67 	vcvt.f32.u32	s15, s15
90012f7e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
90012f82:	ee37 7a87 	vadd.f32	s14, s15, s14
90012f86:	edd7 6a07 	vldr	s13, [r7, #28]
90012f8a:	eec6 7a87 	vdiv.f32	s15, s13, s14
90012f8e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90012f92:	ee17 2a90 	vmov	r2, s15
90012f96:	687b      	ldr	r3, [r7, #4]
90012f98:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
90012f9a:	4b1f      	ldr	r3, [pc, #124]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012f9c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90012f9e:	0c1b      	lsrs	r3, r3, #16
90012fa0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
90012fa4:	ee07 3a90 	vmov	s15, r3
90012fa8:	eef8 7a67 	vcvt.f32.u32	s15, s15
90012fac:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
90012fb0:	ee37 7a87 	vadd.f32	s14, s15, s14
90012fb4:	edd7 6a07 	vldr	s13, [r7, #28]
90012fb8:	eec6 7a87 	vdiv.f32	s15, s13, s14
90012fbc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90012fc0:	ee17 2a90 	vmov	r2, s15
90012fc4:	687b      	ldr	r3, [r7, #4]
90012fc6:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
90012fc8:	4b13      	ldr	r3, [pc, #76]	; (90013018 <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
90012fca:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90012fcc:	0e1b      	lsrs	r3, r3, #24
90012fce:	f003 037f 	and.w	r3, r3, #127	; 0x7f
90012fd2:	ee07 3a90 	vmov	s15, r3
90012fd6:	eef8 7a67 	vcvt.f32.u32	s15, s15
90012fda:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
90012fde:	ee37 7a87 	vadd.f32	s14, s15, s14
90012fe2:	edd7 6a07 	vldr	s13, [r7, #28]
90012fe6:	eec6 7a87 	vdiv.f32	s15, s13, s14
90012fea:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90012fee:	ee17 2a90 	vmov	r2, s15
90012ff2:	687b      	ldr	r3, [r7, #4]
90012ff4:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
90012ff6:	e008      	b.n	9001300a <HAL_RCCEx_GetPLL2ClockFreq+0x282>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
90012ff8:	687b      	ldr	r3, [r7, #4]
90012ffa:	2200      	movs	r2, #0
90012ffc:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
90012ffe:	687b      	ldr	r3, [r7, #4]
90013000:	2200      	movs	r2, #0
90013002:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
90013004:	687b      	ldr	r3, [r7, #4]
90013006:	2200      	movs	r2, #0
90013008:	609a      	str	r2, [r3, #8]
}
9001300a:	bf00      	nop
9001300c:	3724      	adds	r7, #36	; 0x24
9001300e:	46bd      	mov	sp, r7
90013010:	f85d 7b04 	ldr.w	r7, [sp], #4
90013014:	4770      	bx	lr
90013016:	bf00      	nop
90013018:	58024400 	.word	0x58024400
9001301c:	03d09000 	.word	0x03d09000
90013020:	46000000 	.word	0x46000000
90013024:	4c742400 	.word	0x4c742400
90013028:	4a742400 	.word	0x4a742400
9001302c:	4bbebc20 	.word	0x4bbebc20

90013030 <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef* PLL3_Clocks)
{
90013030:	b480      	push	{r7}
90013032:	b089      	sub	sp, #36	; 0x24
90013034:	af00      	add	r7, sp, #0
90013036:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
90013038:	4ba1      	ldr	r3, [pc, #644]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
9001303a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9001303c:	f003 0303 	and.w	r3, r3, #3
90013040:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
90013042:	4b9f      	ldr	r3, [pc, #636]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
90013044:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90013046:	0d1b      	lsrs	r3, r3, #20
90013048:	f003 033f 	and.w	r3, r3, #63	; 0x3f
9001304c:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
9001304e:	4b9c      	ldr	r3, [pc, #624]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
90013050:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90013052:	0a1b      	lsrs	r3, r3, #8
90013054:	f003 0301 	and.w	r3, r3, #1
90013058:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
9001305a:	4b99      	ldr	r3, [pc, #612]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
9001305c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
9001305e:	08db      	lsrs	r3, r3, #3
90013060:	f3c3 030c 	ubfx	r3, r3, #0, #13
90013064:	693a      	ldr	r2, [r7, #16]
90013066:	fb02 f303 	mul.w	r3, r2, r3
9001306a:	ee07 3a90 	vmov	s15, r3
9001306e:	eef8 7a67 	vcvt.f32.u32	s15, s15
90013072:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
90013076:	697b      	ldr	r3, [r7, #20]
90013078:	2b00      	cmp	r3, #0
9001307a:	f000 8111 	beq.w	900132a0 <HAL_RCCEx_GetPLL3ClockFreq+0x270>
  {
    switch (pllsource)
9001307e:	69bb      	ldr	r3, [r7, #24]
90013080:	2b02      	cmp	r3, #2
90013082:	f000 8083 	beq.w	9001318c <HAL_RCCEx_GetPLL3ClockFreq+0x15c>
90013086:	69bb      	ldr	r3, [r7, #24]
90013088:	2b02      	cmp	r3, #2
9001308a:	f200 80a1 	bhi.w	900131d0 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
9001308e:	69bb      	ldr	r3, [r7, #24]
90013090:	2b00      	cmp	r3, #0
90013092:	d003      	beq.n	9001309c <HAL_RCCEx_GetPLL3ClockFreq+0x6c>
90013094:	69bb      	ldr	r3, [r7, #24]
90013096:	2b01      	cmp	r3, #1
90013098:	d056      	beq.n	90013148 <HAL_RCCEx_GetPLL3ClockFreq+0x118>
9001309a:	e099      	b.n	900131d0 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
9001309c:	4b88      	ldr	r3, [pc, #544]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
9001309e:	681b      	ldr	r3, [r3, #0]
900130a0:	f003 0320 	and.w	r3, r3, #32
900130a4:	2b00      	cmp	r3, #0
900130a6:	d02d      	beq.n	90013104 <HAL_RCCEx_GetPLL3ClockFreq+0xd4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
900130a8:	4b85      	ldr	r3, [pc, #532]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
900130aa:	681b      	ldr	r3, [r3, #0]
900130ac:	08db      	lsrs	r3, r3, #3
900130ae:	f003 0303 	and.w	r3, r3, #3
900130b2:	4a84      	ldr	r2, [pc, #528]	; (900132c4 <HAL_RCCEx_GetPLL3ClockFreq+0x294>)
900130b4:	fa22 f303 	lsr.w	r3, r2, r3
900130b8:	60bb      	str	r3, [r7, #8]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
900130ba:	68bb      	ldr	r3, [r7, #8]
900130bc:	ee07 3a90 	vmov	s15, r3
900130c0:	eef8 6a67 	vcvt.f32.u32	s13, s15
900130c4:	697b      	ldr	r3, [r7, #20]
900130c6:	ee07 3a90 	vmov	s15, r3
900130ca:	eef8 7a67 	vcvt.f32.u32	s15, s15
900130ce:	ee86 7aa7 	vdiv.f32	s14, s13, s15
900130d2:	4b7b      	ldr	r3, [pc, #492]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
900130d4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900130d6:	f3c3 0308 	ubfx	r3, r3, #0, #9
900130da:	ee07 3a90 	vmov	s15, r3
900130de:	eef8 6a67 	vcvt.f32.u32	s13, s15
900130e2:	ed97 6a03 	vldr	s12, [r7, #12]
900130e6:	eddf 5a78 	vldr	s11, [pc, #480]	; 900132c8 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
900130ea:	eec6 7a25 	vdiv.f32	s15, s12, s11
900130ee:	ee76 7aa7 	vadd.f32	s15, s13, s15
900130f2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
900130f6:	ee77 7aa6 	vadd.f32	s15, s15, s13
900130fa:	ee67 7a27 	vmul.f32	s15, s14, s15
900130fe:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
      }
      break;
90013102:	e087      	b.n	90013214 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90013104:	697b      	ldr	r3, [r7, #20]
90013106:	ee07 3a90 	vmov	s15, r3
9001310a:	eef8 7a67 	vcvt.f32.u32	s15, s15
9001310e:	eddf 6a6f 	vldr	s13, [pc, #444]	; 900132cc <HAL_RCCEx_GetPLL3ClockFreq+0x29c>
90013112:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90013116:	4b6a      	ldr	r3, [pc, #424]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
90013118:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9001311a:	f3c3 0308 	ubfx	r3, r3, #0, #9
9001311e:	ee07 3a90 	vmov	s15, r3
90013122:	eef8 6a67 	vcvt.f32.u32	s13, s15
90013126:	ed97 6a03 	vldr	s12, [r7, #12]
9001312a:	eddf 5a67 	vldr	s11, [pc, #412]	; 900132c8 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
9001312e:	eec6 7a25 	vdiv.f32	s15, s12, s11
90013132:	ee76 7aa7 	vadd.f32	s15, s13, s15
90013136:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
9001313a:	ee77 7aa6 	vadd.f32	s15, s15, s13
9001313e:	ee67 7a27 	vmul.f32	s15, s14, s15
90013142:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
90013146:	e065      	b.n	90013214 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
90013148:	697b      	ldr	r3, [r7, #20]
9001314a:	ee07 3a90 	vmov	s15, r3
9001314e:	eef8 7a67 	vcvt.f32.u32	s15, s15
90013152:	eddf 6a5f 	vldr	s13, [pc, #380]	; 900132d0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
90013156:	ee86 7aa7 	vdiv.f32	s14, s13, s15
9001315a:	4b59      	ldr	r3, [pc, #356]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
9001315c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9001315e:	f3c3 0308 	ubfx	r3, r3, #0, #9
90013162:	ee07 3a90 	vmov	s15, r3
90013166:	eef8 6a67 	vcvt.f32.u32	s13, s15
9001316a:	ed97 6a03 	vldr	s12, [r7, #12]
9001316e:	eddf 5a56 	vldr	s11, [pc, #344]	; 900132c8 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
90013172:	eec6 7a25 	vdiv.f32	s15, s12, s11
90013176:	ee76 7aa7 	vadd.f32	s15, s13, s15
9001317a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
9001317e:	ee77 7aa6 	vadd.f32	s15, s15, s13
90013182:	ee67 7a27 	vmul.f32	s15, s14, s15
90013186:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
9001318a:	e043      	b.n	90013214 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
9001318c:	697b      	ldr	r3, [r7, #20]
9001318e:	ee07 3a90 	vmov	s15, r3
90013192:	eef8 7a67 	vcvt.f32.u32	s15, s15
90013196:	eddf 6a4f 	vldr	s13, [pc, #316]	; 900132d4 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>
9001319a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
9001319e:	4b48      	ldr	r3, [pc, #288]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
900131a0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900131a2:	f3c3 0308 	ubfx	r3, r3, #0, #9
900131a6:	ee07 3a90 	vmov	s15, r3
900131aa:	eef8 6a67 	vcvt.f32.u32	s13, s15
900131ae:	ed97 6a03 	vldr	s12, [r7, #12]
900131b2:	eddf 5a45 	vldr	s11, [pc, #276]	; 900132c8 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
900131b6:	eec6 7a25 	vdiv.f32	s15, s12, s11
900131ba:	ee76 7aa7 	vadd.f32	s15, s13, s15
900131be:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
900131c2:	ee77 7aa6 	vadd.f32	s15, s15, s13
900131c6:	ee67 7a27 	vmul.f32	s15, s14, s15
900131ca:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
900131ce:	e021      	b.n	90013214 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

    default:
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
900131d0:	697b      	ldr	r3, [r7, #20]
900131d2:	ee07 3a90 	vmov	s15, r3
900131d6:	eef8 7a67 	vcvt.f32.u32	s15, s15
900131da:	eddf 6a3d 	vldr	s13, [pc, #244]	; 900132d0 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
900131de:	ee86 7aa7 	vdiv.f32	s14, s13, s15
900131e2:	4b37      	ldr	r3, [pc, #220]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
900131e4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900131e6:	f3c3 0308 	ubfx	r3, r3, #0, #9
900131ea:	ee07 3a90 	vmov	s15, r3
900131ee:	eef8 6a67 	vcvt.f32.u32	s13, s15
900131f2:	ed97 6a03 	vldr	s12, [r7, #12]
900131f6:	eddf 5a34 	vldr	s11, [pc, #208]	; 900132c8 <HAL_RCCEx_GetPLL3ClockFreq+0x298>
900131fa:	eec6 7a25 	vdiv.f32	s15, s12, s11
900131fe:	ee76 7aa7 	vadd.f32	s15, s13, s15
90013202:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
90013206:	ee77 7aa6 	vadd.f32	s15, s15, s13
9001320a:	ee67 7a27 	vmul.f32	s15, s14, s15
9001320e:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
90013212:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
90013214:	4b2a      	ldr	r3, [pc, #168]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
90013216:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90013218:	0a5b      	lsrs	r3, r3, #9
9001321a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
9001321e:	ee07 3a90 	vmov	s15, r3
90013222:	eef8 7a67 	vcvt.f32.u32	s15, s15
90013226:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
9001322a:	ee37 7a87 	vadd.f32	s14, s15, s14
9001322e:	edd7 6a07 	vldr	s13, [r7, #28]
90013232:	eec6 7a87 	vdiv.f32	s15, s13, s14
90013236:	eefc 7ae7 	vcvt.u32.f32	s15, s15
9001323a:	ee17 2a90 	vmov	r2, s15
9001323e:	687b      	ldr	r3, [r7, #4]
90013240:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
90013242:	4b1f      	ldr	r3, [pc, #124]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
90013244:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90013246:	0c1b      	lsrs	r3, r3, #16
90013248:	f003 037f 	and.w	r3, r3, #127	; 0x7f
9001324c:	ee07 3a90 	vmov	s15, r3
90013250:	eef8 7a67 	vcvt.f32.u32	s15, s15
90013254:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
90013258:	ee37 7a87 	vadd.f32	s14, s15, s14
9001325c:	edd7 6a07 	vldr	s13, [r7, #28]
90013260:	eec6 7a87 	vdiv.f32	s15, s13, s14
90013264:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90013268:	ee17 2a90 	vmov	r2, s15
9001326c:	687b      	ldr	r3, [r7, #4]
9001326e:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
90013270:	4b13      	ldr	r3, [pc, #76]	; (900132c0 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
90013272:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90013274:	0e1b      	lsrs	r3, r3, #24
90013276:	f003 037f 	and.w	r3, r3, #127	; 0x7f
9001327a:	ee07 3a90 	vmov	s15, r3
9001327e:	eef8 7a67 	vcvt.f32.u32	s15, s15
90013282:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
90013286:	ee37 7a87 	vadd.f32	s14, s15, s14
9001328a:	edd7 6a07 	vldr	s13, [r7, #28]
9001328e:	eec6 7a87 	vdiv.f32	s15, s13, s14
90013292:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90013296:	ee17 2a90 	vmov	r2, s15
9001329a:	687b      	ldr	r3, [r7, #4]
9001329c:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
9001329e:	e008      	b.n	900132b2 <HAL_RCCEx_GetPLL3ClockFreq+0x282>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
900132a0:	687b      	ldr	r3, [r7, #4]
900132a2:	2200      	movs	r2, #0
900132a4:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
900132a6:	687b      	ldr	r3, [r7, #4]
900132a8:	2200      	movs	r2, #0
900132aa:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
900132ac:	687b      	ldr	r3, [r7, #4]
900132ae:	2200      	movs	r2, #0
900132b0:	609a      	str	r2, [r3, #8]
}
900132b2:	bf00      	nop
900132b4:	3724      	adds	r7, #36	; 0x24
900132b6:	46bd      	mov	sp, r7
900132b8:	f85d 7b04 	ldr.w	r7, [sp], #4
900132bc:	4770      	bx	lr
900132be:	bf00      	nop
900132c0:	58024400 	.word	0x58024400
900132c4:	03d09000 	.word	0x03d09000
900132c8:	46000000 	.word	0x46000000
900132cc:	4c742400 	.word	0x4c742400
900132d0:	4a742400 	.word	0x4a742400
900132d4:	4bbebc20 	.word	0x4bbebc20

900132d8 <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef* PLL1_Clocks)
{
900132d8:	b480      	push	{r7}
900132da:	b089      	sub	sp, #36	; 0x24
900132dc:	af00      	add	r7, sp, #0
900132de:	6078      	str	r0, [r7, #4]
  uint32_t pllsource, pll1m, pll1fracen, hsivalue;
  float_t fracn1, pll1vco;

  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
900132e0:	4ba0      	ldr	r3, [pc, #640]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
900132e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
900132e4:	f003 0303 	and.w	r3, r3, #3
900132e8:	61bb      	str	r3, [r7, #24]
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
900132ea:	4b9e      	ldr	r3, [pc, #632]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
900132ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
900132ee:	091b      	lsrs	r3, r3, #4
900132f0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
900132f4:	617b      	str	r3, [r7, #20]
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
900132f6:	4b9b      	ldr	r3, [pc, #620]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
900132f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900132fa:	f003 0301 	and.w	r3, r3, #1
900132fe:	613b      	str	r3, [r7, #16]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
90013300:	4b98      	ldr	r3, [pc, #608]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
90013302:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90013304:	08db      	lsrs	r3, r3, #3
90013306:	f3c3 030c 	ubfx	r3, r3, #0, #13
9001330a:	693a      	ldr	r2, [r7, #16]
9001330c:	fb02 f303 	mul.w	r3, r2, r3
90013310:	ee07 3a90 	vmov	s15, r3
90013314:	eef8 7a67 	vcvt.f32.u32	s15, s15
90013318:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll1m != 0U)
9001331c:	697b      	ldr	r3, [r7, #20]
9001331e:	2b00      	cmp	r3, #0
90013320:	f000 8111 	beq.w	90013546 <HAL_RCCEx_GetPLL1ClockFreq+0x26e>
  {
    switch (pllsource)
90013324:	69bb      	ldr	r3, [r7, #24]
90013326:	2b02      	cmp	r3, #2
90013328:	f000 8083 	beq.w	90013432 <HAL_RCCEx_GetPLL1ClockFreq+0x15a>
9001332c:	69bb      	ldr	r3, [r7, #24]
9001332e:	2b02      	cmp	r3, #2
90013330:	f200 80a1 	bhi.w	90013476 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
90013334:	69bb      	ldr	r3, [r7, #24]
90013336:	2b00      	cmp	r3, #0
90013338:	d003      	beq.n	90013342 <HAL_RCCEx_GetPLL1ClockFreq+0x6a>
9001333a:	69bb      	ldr	r3, [r7, #24]
9001333c:	2b01      	cmp	r3, #1
9001333e:	d056      	beq.n	900133ee <HAL_RCCEx_GetPLL1ClockFreq+0x116>
90013340:	e099      	b.n	90013476 <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
90013342:	4b88      	ldr	r3, [pc, #544]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
90013344:	681b      	ldr	r3, [r3, #0]
90013346:	f003 0320 	and.w	r3, r3, #32
9001334a:	2b00      	cmp	r3, #0
9001334c:	d02d      	beq.n	900133aa <HAL_RCCEx_GetPLL1ClockFreq+0xd2>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
9001334e:	4b85      	ldr	r3, [pc, #532]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
90013350:	681b      	ldr	r3, [r3, #0]
90013352:	08db      	lsrs	r3, r3, #3
90013354:	f003 0303 	and.w	r3, r3, #3
90013358:	4a83      	ldr	r2, [pc, #524]	; (90013568 <HAL_RCCEx_GetPLL1ClockFreq+0x290>)
9001335a:	fa22 f303 	lsr.w	r3, r2, r3
9001335e:	60bb      	str	r3, [r7, #8]
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90013360:	68bb      	ldr	r3, [r7, #8]
90013362:	ee07 3a90 	vmov	s15, r3
90013366:	eef8 6a67 	vcvt.f32.u32	s13, s15
9001336a:	697b      	ldr	r3, [r7, #20]
9001336c:	ee07 3a90 	vmov	s15, r3
90013370:	eef8 7a67 	vcvt.f32.u32	s15, s15
90013374:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90013378:	4b7a      	ldr	r3, [pc, #488]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
9001337a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9001337c:	f3c3 0308 	ubfx	r3, r3, #0, #9
90013380:	ee07 3a90 	vmov	s15, r3
90013384:	eef8 6a67 	vcvt.f32.u32	s13, s15
90013388:	ed97 6a03 	vldr	s12, [r7, #12]
9001338c:	eddf 5a77 	vldr	s11, [pc, #476]	; 9001356c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
90013390:	eec6 7a25 	vdiv.f32	s15, s12, s11
90013394:	ee76 7aa7 	vadd.f32	s15, s13, s15
90013398:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
9001339c:	ee77 7aa6 	vadd.f32	s15, s15, s13
900133a0:	ee67 7a27 	vmul.f32	s15, s14, s15
900133a4:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
      }
      break;
900133a8:	e087      	b.n	900134ba <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
900133aa:	697b      	ldr	r3, [r7, #20]
900133ac:	ee07 3a90 	vmov	s15, r3
900133b0:	eef8 7a67 	vcvt.f32.u32	s15, s15
900133b4:	eddf 6a6e 	vldr	s13, [pc, #440]	; 90013570 <HAL_RCCEx_GetPLL1ClockFreq+0x298>
900133b8:	ee86 7aa7 	vdiv.f32	s14, s13, s15
900133bc:	4b69      	ldr	r3, [pc, #420]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
900133be:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900133c0:	f3c3 0308 	ubfx	r3, r3, #0, #9
900133c4:	ee07 3a90 	vmov	s15, r3
900133c8:	eef8 6a67 	vcvt.f32.u32	s13, s15
900133cc:	ed97 6a03 	vldr	s12, [r7, #12]
900133d0:	eddf 5a66 	vldr	s11, [pc, #408]	; 9001356c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
900133d4:	eec6 7a25 	vdiv.f32	s15, s12, s11
900133d8:	ee76 7aa7 	vadd.f32	s15, s13, s15
900133dc:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
900133e0:	ee77 7aa6 	vadd.f32	s15, s15, s13
900133e4:	ee67 7a27 	vmul.f32	s15, s14, s15
900133e8:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
900133ec:	e065      	b.n	900134ba <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
900133ee:	697b      	ldr	r3, [r7, #20]
900133f0:	ee07 3a90 	vmov	s15, r3
900133f4:	eef8 7a67 	vcvt.f32.u32	s15, s15
900133f8:	eddf 6a5e 	vldr	s13, [pc, #376]	; 90013574 <HAL_RCCEx_GetPLL1ClockFreq+0x29c>
900133fc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90013400:	4b58      	ldr	r3, [pc, #352]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
90013402:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90013404:	f3c3 0308 	ubfx	r3, r3, #0, #9
90013408:	ee07 3a90 	vmov	s15, r3
9001340c:	eef8 6a67 	vcvt.f32.u32	s13, s15
90013410:	ed97 6a03 	vldr	s12, [r7, #12]
90013414:	eddf 5a55 	vldr	s11, [pc, #340]	; 9001356c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
90013418:	eec6 7a25 	vdiv.f32	s15, s12, s11
9001341c:	ee76 7aa7 	vadd.f32	s15, s13, s15
90013420:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
90013424:	ee77 7aa6 	vadd.f32	s15, s15, s13
90013428:	ee67 7a27 	vmul.f32	s15, s14, s15
9001342c:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
90013430:	e043      	b.n	900134ba <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90013432:	697b      	ldr	r3, [r7, #20]
90013434:	ee07 3a90 	vmov	s15, r3
90013438:	eef8 7a67 	vcvt.f32.u32	s15, s15
9001343c:	eddf 6a4e 	vldr	s13, [pc, #312]	; 90013578 <HAL_RCCEx_GetPLL1ClockFreq+0x2a0>
90013440:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90013444:	4b47      	ldr	r3, [pc, #284]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
90013446:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90013448:	f3c3 0308 	ubfx	r3, r3, #0, #9
9001344c:	ee07 3a90 	vmov	s15, r3
90013450:	eef8 6a67 	vcvt.f32.u32	s13, s15
90013454:	ed97 6a03 	vldr	s12, [r7, #12]
90013458:	eddf 5a44 	vldr	s11, [pc, #272]	; 9001356c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
9001345c:	eec6 7a25 	vdiv.f32	s15, s12, s11
90013460:	ee76 7aa7 	vadd.f32	s15, s13, s15
90013464:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
90013468:	ee77 7aa6 	vadd.f32	s15, s15, s13
9001346c:	ee67 7a27 	vmul.f32	s15, s14, s15
90013470:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
90013474:	e021      	b.n	900134ba <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

    default:
      pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
90013476:	697b      	ldr	r3, [r7, #20]
90013478:	ee07 3a90 	vmov	s15, r3
9001347c:	eef8 7a67 	vcvt.f32.u32	s15, s15
90013480:	eddf 6a3b 	vldr	s13, [pc, #236]	; 90013570 <HAL_RCCEx_GetPLL1ClockFreq+0x298>
90013484:	ee86 7aa7 	vdiv.f32	s14, s13, s15
90013488:	4b36      	ldr	r3, [pc, #216]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
9001348a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9001348c:	f3c3 0308 	ubfx	r3, r3, #0, #9
90013490:	ee07 3a90 	vmov	s15, r3
90013494:	eef8 6a67 	vcvt.f32.u32	s13, s15
90013498:	ed97 6a03 	vldr	s12, [r7, #12]
9001349c:	eddf 5a33 	vldr	s11, [pc, #204]	; 9001356c <HAL_RCCEx_GetPLL1ClockFreq+0x294>
900134a0:	eec6 7a25 	vdiv.f32	s15, s12, s11
900134a4:	ee76 7aa7 	vadd.f32	s15, s13, s15
900134a8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
900134ac:	ee77 7aa6 	vadd.f32	s15, s15, s13
900134b0:	ee67 7a27 	vmul.f32	s15, s14, s15
900134b4:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
900134b8:	bf00      	nop
    }

    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
900134ba:	4b2a      	ldr	r3, [pc, #168]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
900134bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900134be:	0a5b      	lsrs	r3, r3, #9
900134c0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
900134c4:	ee07 3a90 	vmov	s15, r3
900134c8:	eef8 7a67 	vcvt.f32.u32	s15, s15
900134cc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
900134d0:	ee37 7a87 	vadd.f32	s14, s15, s14
900134d4:	edd7 6a07 	vldr	s13, [r7, #28]
900134d8:	eec6 7a87 	vdiv.f32	s15, s13, s14
900134dc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
900134e0:	ee17 2a90 	vmov	r2, s15
900134e4:	687b      	ldr	r3, [r7, #4]
900134e6:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
900134e8:	4b1e      	ldr	r3, [pc, #120]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
900134ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
900134ec:	0c1b      	lsrs	r3, r3, #16
900134ee:	f003 037f 	and.w	r3, r3, #127	; 0x7f
900134f2:	ee07 3a90 	vmov	s15, r3
900134f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
900134fa:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
900134fe:	ee37 7a87 	vadd.f32	s14, s15, s14
90013502:	edd7 6a07 	vldr	s13, [r7, #28]
90013506:	eec6 7a87 	vdiv.f32	s15, s13, s14
9001350a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
9001350e:	ee17 2a90 	vmov	r2, s15
90013512:	687b      	ldr	r3, [r7, #4]
90013514:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
90013516:	4b13      	ldr	r3, [pc, #76]	; (90013564 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
90013518:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9001351a:	0e1b      	lsrs	r3, r3, #24
9001351c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
90013520:	ee07 3a90 	vmov	s15, r3
90013524:	eef8 7a67 	vcvt.f32.u32	s15, s15
90013528:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
9001352c:	ee37 7a87 	vadd.f32	s14, s15, s14
90013530:	edd7 6a07 	vldr	s13, [r7, #28]
90013534:	eec6 7a87 	vdiv.f32	s15, s13, s14
90013538:	eefc 7ae7 	vcvt.u32.f32	s15, s15
9001353c:	ee17 2a90 	vmov	r2, s15
90013540:	687b      	ldr	r3, [r7, #4]
90013542:	609a      	str	r2, [r3, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
90013544:	e008      	b.n	90013558 <HAL_RCCEx_GetPLL1ClockFreq+0x280>
    PLL1_Clocks->PLL1_P_Frequency = 0U;
90013546:	687b      	ldr	r3, [r7, #4]
90013548:	2200      	movs	r2, #0
9001354a:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
9001354c:	687b      	ldr	r3, [r7, #4]
9001354e:	2200      	movs	r2, #0
90013550:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
90013552:	687b      	ldr	r3, [r7, #4]
90013554:	2200      	movs	r2, #0
90013556:	609a      	str	r2, [r3, #8]
}
90013558:	bf00      	nop
9001355a:	3724      	adds	r7, #36	; 0x24
9001355c:	46bd      	mov	sp, r7
9001355e:	f85d 7b04 	ldr.w	r7, [sp], #4
90013562:	4770      	bx	lr
90013564:	58024400 	.word	0x58024400
90013568:	03d09000 	.word	0x03d09000
9001356c:	46000000 	.word	0x46000000
90013570:	4c742400 	.word	0x4c742400
90013574:	4a742400 	.word	0x4a742400
90013578:	4bbebc20 	.word	0x4bbebc20

9001357c <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
9001357c:	b580      	push	{r7, lr}
9001357e:	b084      	sub	sp, #16
90013580:	af00      	add	r7, sp, #0
90013582:	6078      	str	r0, [r7, #4]
90013584:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
90013586:	2300      	movs	r3, #0
90013588:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
9001358a:	4b53      	ldr	r3, [pc, #332]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
9001358c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
9001358e:	f003 0303 	and.w	r3, r3, #3
90013592:	2b03      	cmp	r3, #3
90013594:	d101      	bne.n	9001359a <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
90013596:	2301      	movs	r3, #1
90013598:	e099      	b.n	900136ce <RCCEx_PLL2_Config+0x152>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
9001359a:	4b4f      	ldr	r3, [pc, #316]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
9001359c:	681b      	ldr	r3, [r3, #0]
9001359e:	4a4e      	ldr	r2, [pc, #312]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
900135a0:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
900135a4:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
900135a6:	f7f5 ff0d 	bl	900093c4 <HAL_GetTick>
900135aa:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
900135ac:	e008      	b.n	900135c0 <RCCEx_PLL2_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
900135ae:	f7f5 ff09 	bl	900093c4 <HAL_GetTick>
900135b2:	4602      	mov	r2, r0
900135b4:	68bb      	ldr	r3, [r7, #8]
900135b6:	1ad3      	subs	r3, r2, r3
900135b8:	2b02      	cmp	r3, #2
900135ba:	d901      	bls.n	900135c0 <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
900135bc:	2303      	movs	r3, #3
900135be:	e086      	b.n	900136ce <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
900135c0:	4b45      	ldr	r3, [pc, #276]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
900135c2:	681b      	ldr	r3, [r3, #0]
900135c4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
900135c8:	2b00      	cmp	r3, #0
900135ca:	d1f0      	bne.n	900135ae <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
900135cc:	4b42      	ldr	r3, [pc, #264]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
900135ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
900135d0:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
900135d4:	687b      	ldr	r3, [r7, #4]
900135d6:	681b      	ldr	r3, [r3, #0]
900135d8:	031b      	lsls	r3, r3, #12
900135da:	493f      	ldr	r1, [pc, #252]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
900135dc:	4313      	orrs	r3, r2
900135de:	628b      	str	r3, [r1, #40]	; 0x28
900135e0:	687b      	ldr	r3, [r7, #4]
900135e2:	685b      	ldr	r3, [r3, #4]
900135e4:	3b01      	subs	r3, #1
900135e6:	f3c3 0208 	ubfx	r2, r3, #0, #9
900135ea:	687b      	ldr	r3, [r7, #4]
900135ec:	689b      	ldr	r3, [r3, #8]
900135ee:	3b01      	subs	r3, #1
900135f0:	025b      	lsls	r3, r3, #9
900135f2:	b29b      	uxth	r3, r3
900135f4:	431a      	orrs	r2, r3
900135f6:	687b      	ldr	r3, [r7, #4]
900135f8:	68db      	ldr	r3, [r3, #12]
900135fa:	3b01      	subs	r3, #1
900135fc:	041b      	lsls	r3, r3, #16
900135fe:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
90013602:	431a      	orrs	r2, r3
90013604:	687b      	ldr	r3, [r7, #4]
90013606:	691b      	ldr	r3, [r3, #16]
90013608:	3b01      	subs	r3, #1
9001360a:	061b      	lsls	r3, r3, #24
9001360c:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
90013610:	4931      	ldr	r1, [pc, #196]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013612:	4313      	orrs	r3, r2
90013614:	638b      	str	r3, [r1, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
90013616:	4b30      	ldr	r3, [pc, #192]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013618:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9001361a:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
9001361e:	687b      	ldr	r3, [r7, #4]
90013620:	695b      	ldr	r3, [r3, #20]
90013622:	492d      	ldr	r1, [pc, #180]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013624:	4313      	orrs	r3, r2
90013626:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
90013628:	4b2b      	ldr	r3, [pc, #172]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
9001362a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9001362c:	f023 0220 	bic.w	r2, r3, #32
90013630:	687b      	ldr	r3, [r7, #4]
90013632:	699b      	ldr	r3, [r3, #24]
90013634:	4928      	ldr	r1, [pc, #160]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013636:	4313      	orrs	r3, r2
90013638:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
9001363a:	4b27      	ldr	r3, [pc, #156]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
9001363c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9001363e:	4a26      	ldr	r2, [pc, #152]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013640:	f023 0310 	bic.w	r3, r3, #16
90013644:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
90013646:	4b24      	ldr	r3, [pc, #144]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013648:	6bda      	ldr	r2, [r3, #60]	; 0x3c
9001364a:	4b24      	ldr	r3, [pc, #144]	; (900136dc <RCCEx_PLL2_Config+0x160>)
9001364c:	4013      	ands	r3, r2
9001364e:	687a      	ldr	r2, [r7, #4]
90013650:	69d2      	ldr	r2, [r2, #28]
90013652:	00d2      	lsls	r2, r2, #3
90013654:	4920      	ldr	r1, [pc, #128]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013656:	4313      	orrs	r3, r2
90013658:	63cb      	str	r3, [r1, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
9001365a:	4b1f      	ldr	r3, [pc, #124]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
9001365c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9001365e:	4a1e      	ldr	r2, [pc, #120]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013660:	f043 0310 	orr.w	r3, r3, #16
90013664:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
90013666:	683b      	ldr	r3, [r7, #0]
90013668:	2b00      	cmp	r3, #0
9001366a:	d106      	bne.n	9001367a <RCCEx_PLL2_Config+0xfe>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
9001366c:	4b1a      	ldr	r3, [pc, #104]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
9001366e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90013670:	4a19      	ldr	r2, [pc, #100]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013672:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
90013676:	62d3      	str	r3, [r2, #44]	; 0x2c
90013678:	e00f      	b.n	9001369a <RCCEx_PLL2_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
9001367a:	683b      	ldr	r3, [r7, #0]
9001367c:	2b01      	cmp	r3, #1
9001367e:	d106      	bne.n	9001368e <RCCEx_PLL2_Config+0x112>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
90013680:	4b15      	ldr	r3, [pc, #84]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013682:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90013684:	4a14      	ldr	r2, [pc, #80]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013686:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
9001368a:	62d3      	str	r3, [r2, #44]	; 0x2c
9001368c:	e005      	b.n	9001369a <RCCEx_PLL2_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
9001368e:	4b12      	ldr	r3, [pc, #72]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013690:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90013692:	4a11      	ldr	r2, [pc, #68]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
90013694:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
90013698:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
9001369a:	4b0f      	ldr	r3, [pc, #60]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
9001369c:	681b      	ldr	r3, [r3, #0]
9001369e:	4a0e      	ldr	r2, [pc, #56]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
900136a0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
900136a4:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
900136a6:	f7f5 fe8d 	bl	900093c4 <HAL_GetTick>
900136aa:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
900136ac:	e008      	b.n	900136c0 <RCCEx_PLL2_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
900136ae:	f7f5 fe89 	bl	900093c4 <HAL_GetTick>
900136b2:	4602      	mov	r2, r0
900136b4:	68bb      	ldr	r3, [r7, #8]
900136b6:	1ad3      	subs	r3, r2, r3
900136b8:	2b02      	cmp	r3, #2
900136ba:	d901      	bls.n	900136c0 <RCCEx_PLL2_Config+0x144>
      {
        return HAL_TIMEOUT;
900136bc:	2303      	movs	r3, #3
900136be:	e006      	b.n	900136ce <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
900136c0:	4b05      	ldr	r3, [pc, #20]	; (900136d8 <RCCEx_PLL2_Config+0x15c>)
900136c2:	681b      	ldr	r3, [r3, #0]
900136c4:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
900136c8:	2b00      	cmp	r3, #0
900136ca:	d0f0      	beq.n	900136ae <RCCEx_PLL2_Config+0x132>
    }

  }


  return status;
900136cc:	7bfb      	ldrb	r3, [r7, #15]
}
900136ce:	4618      	mov	r0, r3
900136d0:	3710      	adds	r7, #16
900136d2:	46bd      	mov	sp, r7
900136d4:	bd80      	pop	{r7, pc}
900136d6:	bf00      	nop
900136d8:	58024400 	.word	0x58024400
900136dc:	ffff0007 	.word	0xffff0007

900136e0 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
900136e0:	b580      	push	{r7, lr}
900136e2:	b084      	sub	sp, #16
900136e4:	af00      	add	r7, sp, #0
900136e6:	6078      	str	r0, [r7, #4]
900136e8:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
900136ea:	2300      	movs	r3, #0
900136ec:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
900136ee:	4b53      	ldr	r3, [pc, #332]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900136f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
900136f2:	f003 0303 	and.w	r3, r3, #3
900136f6:	2b03      	cmp	r3, #3
900136f8:	d101      	bne.n	900136fe <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
900136fa:	2301      	movs	r3, #1
900136fc:	e099      	b.n	90013832 <RCCEx_PLL3_Config+0x152>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
900136fe:	4b4f      	ldr	r3, [pc, #316]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
90013700:	681b      	ldr	r3, [r3, #0]
90013702:	4a4e      	ldr	r2, [pc, #312]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
90013704:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
90013708:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
9001370a:	f7f5 fe5b 	bl	900093c4 <HAL_GetTick>
9001370e:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
90013710:	e008      	b.n	90013724 <RCCEx_PLL3_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
90013712:	f7f5 fe57 	bl	900093c4 <HAL_GetTick>
90013716:	4602      	mov	r2, r0
90013718:	68bb      	ldr	r3, [r7, #8]
9001371a:	1ad3      	subs	r3, r2, r3
9001371c:	2b02      	cmp	r3, #2
9001371e:	d901      	bls.n	90013724 <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
90013720:	2303      	movs	r3, #3
90013722:	e086      	b.n	90013832 <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
90013724:	4b45      	ldr	r3, [pc, #276]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
90013726:	681b      	ldr	r3, [r3, #0]
90013728:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
9001372c:	2b00      	cmp	r3, #0
9001372e:	d1f0      	bne.n	90013712 <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
90013730:	4b42      	ldr	r3, [pc, #264]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
90013732:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90013734:	f023 727c 	bic.w	r2, r3, #66060288	; 0x3f00000
90013738:	687b      	ldr	r3, [r7, #4]
9001373a:	681b      	ldr	r3, [r3, #0]
9001373c:	051b      	lsls	r3, r3, #20
9001373e:	493f      	ldr	r1, [pc, #252]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
90013740:	4313      	orrs	r3, r2
90013742:	628b      	str	r3, [r1, #40]	; 0x28
90013744:	687b      	ldr	r3, [r7, #4]
90013746:	685b      	ldr	r3, [r3, #4]
90013748:	3b01      	subs	r3, #1
9001374a:	f3c3 0208 	ubfx	r2, r3, #0, #9
9001374e:	687b      	ldr	r3, [r7, #4]
90013750:	689b      	ldr	r3, [r3, #8]
90013752:	3b01      	subs	r3, #1
90013754:	025b      	lsls	r3, r3, #9
90013756:	b29b      	uxth	r3, r3
90013758:	431a      	orrs	r2, r3
9001375a:	687b      	ldr	r3, [r7, #4]
9001375c:	68db      	ldr	r3, [r3, #12]
9001375e:	3b01      	subs	r3, #1
90013760:	041b      	lsls	r3, r3, #16
90013762:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
90013766:	431a      	orrs	r2, r3
90013768:	687b      	ldr	r3, [r7, #4]
9001376a:	691b      	ldr	r3, [r3, #16]
9001376c:	3b01      	subs	r3, #1
9001376e:	061b      	lsls	r3, r3, #24
90013770:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
90013774:	4931      	ldr	r1, [pc, #196]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
90013776:	4313      	orrs	r3, r2
90013778:	640b      	str	r3, [r1, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
9001377a:	4b30      	ldr	r3, [pc, #192]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
9001377c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9001377e:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
90013782:	687b      	ldr	r3, [r7, #4]
90013784:	695b      	ldr	r3, [r3, #20]
90013786:	492d      	ldr	r1, [pc, #180]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
90013788:	4313      	orrs	r3, r2
9001378a:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
9001378c:	4b2b      	ldr	r3, [pc, #172]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
9001378e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90013790:	f423 7200 	bic.w	r2, r3, #512	; 0x200
90013794:	687b      	ldr	r3, [r7, #4]
90013796:	699b      	ldr	r3, [r3, #24]
90013798:	4928      	ldr	r1, [pc, #160]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
9001379a:	4313      	orrs	r3, r2
9001379c:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
9001379e:	4b27      	ldr	r3, [pc, #156]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900137a2:	4a26      	ldr	r2, [pc, #152]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137a4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
900137a8:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
900137aa:	4b24      	ldr	r3, [pc, #144]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137ac:	6c5a      	ldr	r2, [r3, #68]	; 0x44
900137ae:	4b24      	ldr	r3, [pc, #144]	; (90013840 <RCCEx_PLL3_Config+0x160>)
900137b0:	4013      	ands	r3, r2
900137b2:	687a      	ldr	r2, [r7, #4]
900137b4:	69d2      	ldr	r2, [r2, #28]
900137b6:	00d2      	lsls	r2, r2, #3
900137b8:	4920      	ldr	r1, [pc, #128]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137ba:	4313      	orrs	r3, r2
900137bc:	644b      	str	r3, [r1, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
900137be:	4b1f      	ldr	r3, [pc, #124]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900137c2:	4a1e      	ldr	r2, [pc, #120]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137c4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
900137c8:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
900137ca:	683b      	ldr	r3, [r7, #0]
900137cc:	2b00      	cmp	r3, #0
900137ce:	d106      	bne.n	900137de <RCCEx_PLL3_Config+0xfe>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
900137d0:	4b1a      	ldr	r3, [pc, #104]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900137d4:	4a19      	ldr	r2, [pc, #100]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137d6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
900137da:	62d3      	str	r3, [r2, #44]	; 0x2c
900137dc:	e00f      	b.n	900137fe <RCCEx_PLL3_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
900137de:	683b      	ldr	r3, [r7, #0]
900137e0:	2b01      	cmp	r3, #1
900137e2:	d106      	bne.n	900137f2 <RCCEx_PLL3_Config+0x112>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
900137e4:	4b15      	ldr	r3, [pc, #84]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900137e8:	4a14      	ldr	r2, [pc, #80]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137ea:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
900137ee:	62d3      	str	r3, [r2, #44]	; 0x2c
900137f0:	e005      	b.n	900137fe <RCCEx_PLL3_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
900137f2:	4b12      	ldr	r3, [pc, #72]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
900137f6:	4a11      	ldr	r2, [pc, #68]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
900137f8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
900137fc:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
900137fe:	4b0f      	ldr	r3, [pc, #60]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
90013800:	681b      	ldr	r3, [r3, #0]
90013802:	4a0e      	ldr	r2, [pc, #56]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
90013804:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
90013808:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
9001380a:	f7f5 fddb 	bl	900093c4 <HAL_GetTick>
9001380e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
90013810:	e008      	b.n	90013824 <RCCEx_PLL3_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
90013812:	f7f5 fdd7 	bl	900093c4 <HAL_GetTick>
90013816:	4602      	mov	r2, r0
90013818:	68bb      	ldr	r3, [r7, #8]
9001381a:	1ad3      	subs	r3, r2, r3
9001381c:	2b02      	cmp	r3, #2
9001381e:	d901      	bls.n	90013824 <RCCEx_PLL3_Config+0x144>
      {
        return HAL_TIMEOUT;
90013820:	2303      	movs	r3, #3
90013822:	e006      	b.n	90013832 <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
90013824:	4b05      	ldr	r3, [pc, #20]	; (9001383c <RCCEx_PLL3_Config+0x15c>)
90013826:	681b      	ldr	r3, [r3, #0]
90013828:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
9001382c:	2b00      	cmp	r3, #0
9001382e:	d0f0      	beq.n	90013812 <RCCEx_PLL3_Config+0x132>
    }

  }


  return status;
90013830:	7bfb      	ldrb	r3, [r7, #15]
}
90013832:	4618      	mov	r0, r3
90013834:	3710      	adds	r7, #16
90013836:	46bd      	mov	sp, r7
90013838:	bd80      	pop	{r7, pc}
9001383a:	bf00      	nop
9001383c:	58024400 	.word	0x58024400
90013840:	ffff0007 	.word	0xffff0007

90013844 <HAL_SAI_Init>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Init(SAI_HandleTypeDef *hsai)
{
90013844:	b580      	push	{r7, lr}
90013846:	b08a      	sub	sp, #40	; 0x28
90013848:	af00      	add	r7, sp, #0
9001384a:	6078      	str	r0, [r7, #4]
  uint32_t ckstr_bits;
  uint32_t syncen_bits;
  SAI_TypeDef *SaiBaseAddress;

  /* Check the SAI handle allocation */
  if (hsai == NULL)
9001384c:	687b      	ldr	r3, [r7, #4]
9001384e:	2b00      	cmp	r3, #0
90013850:	d101      	bne.n	90013856 <HAL_SAI_Init+0x12>
  {
    return HAL_ERROR;
90013852:	2301      	movs	r3, #1
90013854:	e283      	b.n	90013d5e <HAL_SAI_Init+0x51a>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
  assert_param(IS_SAI_BLOCK_CLOCK_STROBING(hsai->Init.ClockStrobing));
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
#if defined(SAI_VER_V2_X) 
  /* SAI Peripheral version depends on STM32H7 device revision ID */
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
90013856:	f7f5 fde5 	bl	90009424 <HAL_GetREVID>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));

  /* Check the SAI PDM parameters */
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
  if (hsai->Init.PdmInit.Activation == ENABLE)
9001385a:	687b      	ldr	r3, [r7, #4]
9001385c:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
90013860:	2b01      	cmp	r3, #1
90013862:	d113      	bne.n	9001388c <HAL_SAI_Init+0x48>
  {
    assert_param(IS_SAI_PDM_MIC_PAIRS_NUMBER(hsai->Init.PdmInit.MicPairsNbr));
    assert_param(IS_SAI_PDM_CLOCK_ENABLE(hsai->Init.PdmInit.ClockEnable));
    /* Check that SAI sub-block is SAI1 or SAI4 sub-block A, in master RX mode with free protocol */
#if defined(SAI4)
    if (((hsai->Instance != SAI1_Block_A) && (hsai->Instance != SAI4_Block_A)) ||
90013864:	687b      	ldr	r3, [r7, #4]
90013866:	681b      	ldr	r3, [r3, #0]
90013868:	4a94      	ldr	r2, [pc, #592]	; (90013abc <HAL_SAI_Init+0x278>)
9001386a:	4293      	cmp	r3, r2
9001386c:	d004      	beq.n	90013878 <HAL_SAI_Init+0x34>
9001386e:	687b      	ldr	r3, [r7, #4]
90013870:	681b      	ldr	r3, [r3, #0]
90013872:	4a93      	ldr	r2, [pc, #588]	; (90013ac0 <HAL_SAI_Init+0x27c>)
90013874:	4293      	cmp	r3, r2
90013876:	d107      	bne.n	90013888 <HAL_SAI_Init+0x44>
         (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
90013878:	687b      	ldr	r3, [r7, #4]
9001387a:	685b      	ldr	r3, [r3, #4]
    if (((hsai->Instance != SAI1_Block_A) && (hsai->Instance != SAI4_Block_A)) ||
9001387c:	2b01      	cmp	r3, #1
9001387e:	d103      	bne.n	90013888 <HAL_SAI_Init+0x44>
         (hsai->Init.Protocol != SAI_FREE_PROTOCOL))
90013880:	687b      	ldr	r3, [r7, #4]
90013882:	6c5b      	ldr	r3, [r3, #68]	; 0x44
         (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
90013884:	2b00      	cmp	r3, #0
90013886:	d001      	beq.n	9001388c <HAL_SAI_Init+0x48>
    {
      return HAL_ERROR;
90013888:	2301      	movs	r3, #1
9001388a:	e268      	b.n	90013d5e <HAL_SAI_Init+0x51a>
    }
#endif /* SAI4 */
  }

  /* Get the SAI base address according to the SAI handle */
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
9001388c:	687b      	ldr	r3, [r7, #4]
9001388e:	681b      	ldr	r3, [r3, #0]
90013890:	4a8a      	ldr	r2, [pc, #552]	; (90013abc <HAL_SAI_Init+0x278>)
90013892:	4293      	cmp	r3, r2
90013894:	d004      	beq.n	900138a0 <HAL_SAI_Init+0x5c>
90013896:	687b      	ldr	r3, [r7, #4]
90013898:	681b      	ldr	r3, [r3, #0]
9001389a:	4a8a      	ldr	r2, [pc, #552]	; (90013ac4 <HAL_SAI_Init+0x280>)
9001389c:	4293      	cmp	r3, r2
9001389e:	d102      	bne.n	900138a6 <HAL_SAI_Init+0x62>
  {
    SaiBaseAddress = SAI1;
900138a0:	4b89      	ldr	r3, [pc, #548]	; (90013ac8 <HAL_SAI_Init+0x284>)
900138a2:	61bb      	str	r3, [r7, #24]
900138a4:	e028      	b.n	900138f8 <HAL_SAI_Init+0xb4>
  }
#if defined(SAI2)
  else if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
900138a6:	687b      	ldr	r3, [r7, #4]
900138a8:	681b      	ldr	r3, [r3, #0]
900138aa:	4a88      	ldr	r2, [pc, #544]	; (90013acc <HAL_SAI_Init+0x288>)
900138ac:	4293      	cmp	r3, r2
900138ae:	d004      	beq.n	900138ba <HAL_SAI_Init+0x76>
900138b0:	687b      	ldr	r3, [r7, #4]
900138b2:	681b      	ldr	r3, [r3, #0]
900138b4:	4a86      	ldr	r2, [pc, #536]	; (90013ad0 <HAL_SAI_Init+0x28c>)
900138b6:	4293      	cmp	r3, r2
900138b8:	d102      	bne.n	900138c0 <HAL_SAI_Init+0x7c>
  {
    SaiBaseAddress = SAI2;
900138ba:	4b86      	ldr	r3, [pc, #536]	; (90013ad4 <HAL_SAI_Init+0x290>)
900138bc:	61bb      	str	r3, [r7, #24]
900138be:	e01b      	b.n	900138f8 <HAL_SAI_Init+0xb4>
  }
#endif /* SAI2 */
#if defined(SAI3)
  else if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
900138c0:	687b      	ldr	r3, [r7, #4]
900138c2:	681b      	ldr	r3, [r3, #0]
900138c4:	4a84      	ldr	r2, [pc, #528]	; (90013ad8 <HAL_SAI_Init+0x294>)
900138c6:	4293      	cmp	r3, r2
900138c8:	d004      	beq.n	900138d4 <HAL_SAI_Init+0x90>
900138ca:	687b      	ldr	r3, [r7, #4]
900138cc:	681b      	ldr	r3, [r3, #0]
900138ce:	4a83      	ldr	r2, [pc, #524]	; (90013adc <HAL_SAI_Init+0x298>)
900138d0:	4293      	cmp	r3, r2
900138d2:	d102      	bne.n	900138da <HAL_SAI_Init+0x96>
  {
    SaiBaseAddress = SAI3;
900138d4:	4b82      	ldr	r3, [pc, #520]	; (90013ae0 <HAL_SAI_Init+0x29c>)
900138d6:	61bb      	str	r3, [r7, #24]
900138d8:	e00e      	b.n	900138f8 <HAL_SAI_Init+0xb4>
  }
#endif /* SAI3 */
#if defined(SAI4)
  else if ((hsai->Instance == SAI4_Block_A) || (hsai->Instance == SAI4_Block_B))
900138da:	687b      	ldr	r3, [r7, #4]
900138dc:	681b      	ldr	r3, [r3, #0]
900138de:	4a78      	ldr	r2, [pc, #480]	; (90013ac0 <HAL_SAI_Init+0x27c>)
900138e0:	4293      	cmp	r3, r2
900138e2:	d004      	beq.n	900138ee <HAL_SAI_Init+0xaa>
900138e4:	687b      	ldr	r3, [r7, #4]
900138e6:	681b      	ldr	r3, [r3, #0]
900138e8:	4a7e      	ldr	r2, [pc, #504]	; (90013ae4 <HAL_SAI_Init+0x2a0>)
900138ea:	4293      	cmp	r3, r2
900138ec:	d102      	bne.n	900138f4 <HAL_SAI_Init+0xb0>
  {
    SaiBaseAddress = SAI4;
900138ee:	4b7e      	ldr	r3, [pc, #504]	; (90013ae8 <HAL_SAI_Init+0x2a4>)
900138f0:	61bb      	str	r3, [r7, #24]
900138f2:	e001      	b.n	900138f8 <HAL_SAI_Init+0xb4>
  }
#endif /* SAI4 */
  else
  {
    return HAL_ERROR;
900138f4:	2301      	movs	r3, #1
900138f6:	e232      	b.n	90013d5e <HAL_SAI_Init+0x51a>
  }

  if (hsai->State == HAL_SAI_STATE_RESET)
900138f8:	687b      	ldr	r3, [r7, #4]
900138fa:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
900138fe:	b2db      	uxtb	r3, r3
90013900:	2b00      	cmp	r3, #0
90013902:	d106      	bne.n	90013912 <HAL_SAI_Init+0xce>
  {
    /* Allocate lock resource and initialize it */
    hsai->Lock = HAL_UNLOCKED;
90013904:	687b      	ldr	r3, [r7, #4]
90013906:	2200      	movs	r2, #0
90013908:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
      hsai->MspInitCallback = HAL_SAI_MspInit;
    }
    hsai->MspInitCallback(hsai);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_SAI_MspInit(hsai);
9001390c:	6878      	ldr	r0, [r7, #4]
9001390e:	f000 fa9f 	bl	90013e50 <HAL_SAI_MspInit>
#endif
  }

  /* Disable the selected SAI peripheral */
  if(SAI_Disable(hsai) != HAL_OK)
90013912:	6878      	ldr	r0, [r7, #4]
90013914:	f000 fd04 	bl	90014320 <SAI_Disable>
90013918:	4603      	mov	r3, r0
9001391a:	2b00      	cmp	r3, #0
9001391c:	d001      	beq.n	90013922 <HAL_SAI_Init+0xde>
  {
    return HAL_ERROR;
9001391e:	2301      	movs	r3, #1
90013920:	e21d      	b.n	90013d5e <HAL_SAI_Init+0x51a>
  }

  hsai->State = HAL_SAI_STATE_BUSY;
90013922:	687b      	ldr	r3, [r7, #4]
90013924:	2202      	movs	r2, #2
90013926:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

  /* SAI Block Synchro Configuration -----------------------------------------*/
  /* This setting must be done with both audio block (A & B) disabled         */
  switch (hsai->Init.SynchroExt)
9001392a:	687b      	ldr	r3, [r7, #4]
9001392c:	68db      	ldr	r3, [r3, #12]
9001392e:	2b02      	cmp	r3, #2
90013930:	d00c      	beq.n	9001394c <HAL_SAI_Init+0x108>
90013932:	2b02      	cmp	r3, #2
90013934:	d80d      	bhi.n	90013952 <HAL_SAI_Init+0x10e>
90013936:	2b00      	cmp	r3, #0
90013938:	d002      	beq.n	90013940 <HAL_SAI_Init+0xfc>
9001393a:	2b01      	cmp	r3, #1
9001393c:	d003      	beq.n	90013946 <HAL_SAI_Init+0x102>
9001393e:	e008      	b.n	90013952 <HAL_SAI_Init+0x10e>
  {
    case SAI_SYNCEXT_DISABLE :
      tmpregisterGCR = 0;
90013940:	2300      	movs	r3, #0
90013942:	627b      	str	r3, [r7, #36]	; 0x24
      break;
90013944:	e008      	b.n	90013958 <HAL_SAI_Init+0x114>
    case SAI_SYNCEXT_OUTBLOCKA_ENABLE :
      tmpregisterGCR = SAI_GCR_SYNCOUT_0;
90013946:	2310      	movs	r3, #16
90013948:	627b      	str	r3, [r7, #36]	; 0x24
      break;
9001394a:	e005      	b.n	90013958 <HAL_SAI_Init+0x114>
    case SAI_SYNCEXT_OUTBLOCKB_ENABLE :
      tmpregisterGCR = SAI_GCR_SYNCOUT_1;
9001394c:	2320      	movs	r3, #32
9001394e:	627b      	str	r3, [r7, #36]	; 0x24
      break;
90013950:	e002      	b.n	90013958 <HAL_SAI_Init+0x114>
    default:
      tmpregisterGCR = 0;
90013952:	2300      	movs	r3, #0
90013954:	627b      	str	r3, [r7, #36]	; 0x24
      break;
90013956:	bf00      	nop
  }

  switch (hsai->Init.Synchro)
90013958:	687b      	ldr	r3, [r7, #4]
9001395a:	689b      	ldr	r3, [r3, #8]
9001395c:	2b05      	cmp	r3, #5
9001395e:	d832      	bhi.n	900139c6 <HAL_SAI_Init+0x182>
90013960:	a201      	add	r2, pc, #4	; (adr r2, 90013968 <HAL_SAI_Init+0x124>)
90013962:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90013966:	bf00      	nop
90013968:	90013981 	.word	0x90013981
9001396c:	90013987 	.word	0x90013987
90013970:	9001398f 	.word	0x9001398f
90013974:	90013997 	.word	0x90013997
90013978:	900139a7 	.word	0x900139a7
9001397c:	900139b7 	.word	0x900139b7
  {
    case SAI_ASYNCHRONOUS :
      syncen_bits = 0;
90013980:	2300      	movs	r3, #0
90013982:	61fb      	str	r3, [r7, #28]
      break;
90013984:	e022      	b.n	900139cc <HAL_SAI_Init+0x188>
    case SAI_SYNCHRONOUS :
      syncen_bits = SAI_xCR1_SYNCEN_0;
90013986:	f44f 6380 	mov.w	r3, #1024	; 0x400
9001398a:	61fb      	str	r3, [r7, #28]
      break;
9001398c:	e01e      	b.n	900139cc <HAL_SAI_Init+0x188>
    case SAI_SYNCHRONOUS_EXT_SAI1 :
      syncen_bits = SAI_xCR1_SYNCEN_1;
9001398e:	f44f 6300 	mov.w	r3, #2048	; 0x800
90013992:	61fb      	str	r3, [r7, #28]
      break;
90013994:	e01a      	b.n	900139cc <HAL_SAI_Init+0x188>
#if defined(SAI2)
    case SAI_SYNCHRONOUS_EXT_SAI2 :
      syncen_bits = SAI_xCR1_SYNCEN_1;
90013996:	f44f 6300 	mov.w	r3, #2048	; 0x800
9001399a:	61fb      	str	r3, [r7, #28]
      tmpregisterGCR |= SAI_GCR_SYNCIN_0;
9001399c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9001399e:	f043 0301 	orr.w	r3, r3, #1
900139a2:	627b      	str	r3, [r7, #36]	; 0x24
      break;
900139a4:	e012      	b.n	900139cc <HAL_SAI_Init+0x188>
#endif /* SAI2 */
#if defined(SAI3)
    case SAI_SYNCHRONOUS_EXT_SAI3 :
      syncen_bits = SAI_xCR1_SYNCEN_1;
900139a6:	f44f 6300 	mov.w	r3, #2048	; 0x800
900139aa:	61fb      	str	r3, [r7, #28]
      tmpregisterGCR |= SAI_GCR_SYNCIN_1;
900139ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
900139ae:	f043 0302 	orr.w	r3, r3, #2
900139b2:	627b      	str	r3, [r7, #36]	; 0x24
      break;
900139b4:	e00a      	b.n	900139cc <HAL_SAI_Init+0x188>
#endif /* SAI3 */
#if defined(SAI4)
    case SAI_SYNCHRONOUS_EXT_SAI4 :
      syncen_bits = SAI_xCR1_SYNCEN_1;
900139b6:	f44f 6300 	mov.w	r3, #2048	; 0x800
900139ba:	61fb      	str	r3, [r7, #28]
      tmpregisterGCR |= (SAI_GCR_SYNCIN_1 | SAI_GCR_SYNCIN_0);
900139bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
900139be:	f043 0303 	orr.w	r3, r3, #3
900139c2:	627b      	str	r3, [r7, #36]	; 0x24
      break;
900139c4:	e002      	b.n	900139cc <HAL_SAI_Init+0x188>
#endif /* SAI4 */
    default:
      syncen_bits = 0;
900139c6:	2300      	movs	r3, #0
900139c8:	61fb      	str	r3, [r7, #28]
      break;
900139ca:	bf00      	nop
  }

  /* Set the SAI Block Synchro Configuration */
  SaiBaseAddress->GCR = tmpregisterGCR;
900139cc:	69bb      	ldr	r3, [r7, #24]
900139ce:	6a7a      	ldr	r2, [r7, #36]	; 0x24
900139d0:	601a      	str	r2, [r3, #0]

  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
900139d2:	687b      	ldr	r3, [r7, #4]
900139d4:	6a1b      	ldr	r3, [r3, #32]
900139d6:	2b00      	cmp	r3, #0
900139d8:	f000 80ba 	beq.w	90013b50 <HAL_SAI_Init+0x30c>
  {
    uint32_t freq = 0;
900139dc:	2300      	movs	r3, #0
900139de:	617b      	str	r3, [r7, #20]
    uint32_t tmpval;

    /* In this case, the MCKDIV value is calculated to get AudioFrequency */
    if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
900139e0:	687b      	ldr	r3, [r7, #4]
900139e2:	681b      	ldr	r3, [r3, #0]
900139e4:	4a35      	ldr	r2, [pc, #212]	; (90013abc <HAL_SAI_Init+0x278>)
900139e6:	4293      	cmp	r3, r2
900139e8:	d004      	beq.n	900139f4 <HAL_SAI_Init+0x1b0>
900139ea:	687b      	ldr	r3, [r7, #4]
900139ec:	681b      	ldr	r3, [r3, #0]
900139ee:	4a35      	ldr	r2, [pc, #212]	; (90013ac4 <HAL_SAI_Init+0x280>)
900139f0:	4293      	cmp	r3, r2
900139f2:	d104      	bne.n	900139fe <HAL_SAI_Init+0x1ba>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
900139f4:	f44f 7080 	mov.w	r0, #256	; 0x100
900139f8:	f7fe fcde 	bl	900123b8 <HAL_RCCEx_GetPeriphCLKFreq>
900139fc:	6178      	str	r0, [r7, #20]
    }

#if defined(SAI2)
#if defined(RCC_PERIPHCLK_SAI2)
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
900139fe:	687b      	ldr	r3, [r7, #4]
90013a00:	681b      	ldr	r3, [r3, #0]
90013a02:	4a32      	ldr	r2, [pc, #200]	; (90013acc <HAL_SAI_Init+0x288>)
90013a04:	4293      	cmp	r3, r2
90013a06:	d004      	beq.n	90013a12 <HAL_SAI_Init+0x1ce>
90013a08:	687b      	ldr	r3, [r7, #4]
90013a0a:	681b      	ldr	r3, [r3, #0]
90013a0c:	4a30      	ldr	r2, [pc, #192]	; (90013ad0 <HAL_SAI_Init+0x28c>)
90013a0e:	4293      	cmp	r3, r2
90013a10:	d104      	bne.n	90013a1c <HAL_SAI_Init+0x1d8>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
90013a12:	f44f 7000 	mov.w	r0, #512	; 0x200
90013a16:	f7fe fccf 	bl	900123b8 <HAL_RCCEx_GetPeriphCLKFreq>
90013a1a:	6178      	str	r0, [r7, #20]
    }
#endif /* RCC_PERIPHCLK_SAI2 */
#endif /* SAI2 */

#if defined(SAI3)
    if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
90013a1c:	687b      	ldr	r3, [r7, #4]
90013a1e:	681b      	ldr	r3, [r3, #0]
90013a20:	4a2d      	ldr	r2, [pc, #180]	; (90013ad8 <HAL_SAI_Init+0x294>)
90013a22:	4293      	cmp	r3, r2
90013a24:	d004      	beq.n	90013a30 <HAL_SAI_Init+0x1ec>
90013a26:	687b      	ldr	r3, [r7, #4]
90013a28:	681b      	ldr	r3, [r3, #0]
90013a2a:	4a2c      	ldr	r2, [pc, #176]	; (90013adc <HAL_SAI_Init+0x298>)
90013a2c:	4293      	cmp	r3, r2
90013a2e:	d104      	bne.n	90013a3a <HAL_SAI_Init+0x1f6>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI3);
90013a30:	f44f 7000 	mov.w	r0, #512	; 0x200
90013a34:	f7fe fcc0 	bl	900123b8 <HAL_RCCEx_GetPeriphCLKFreq>
90013a38:	6178      	str	r0, [r7, #20]
    }
#endif /* SAI3 */
#if defined(SAI4)
    if (hsai->Instance == SAI4_Block_A)
90013a3a:	687b      	ldr	r3, [r7, #4]
90013a3c:	681b      	ldr	r3, [r3, #0]
90013a3e:	4a20      	ldr	r2, [pc, #128]	; (90013ac0 <HAL_SAI_Init+0x27c>)
90013a40:	4293      	cmp	r3, r2
90013a42:	d104      	bne.n	90013a4e <HAL_SAI_Init+0x20a>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4A);
90013a44:	f44f 6080 	mov.w	r0, #1024	; 0x400
90013a48:	f7fe fcb6 	bl	900123b8 <HAL_RCCEx_GetPeriphCLKFreq>
90013a4c:	6178      	str	r0, [r7, #20]
    }
    if (hsai->Instance == SAI4_Block_B)
90013a4e:	687b      	ldr	r3, [r7, #4]
90013a50:	681b      	ldr	r3, [r3, #0]
90013a52:	4a24      	ldr	r2, [pc, #144]	; (90013ae4 <HAL_SAI_Init+0x2a0>)
90013a54:	4293      	cmp	r3, r2
90013a56:	d104      	bne.n	90013a62 <HAL_SAI_Init+0x21e>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4B);
90013a58:	f44f 6000 	mov.w	r0, #2048	; 0x800
90013a5c:	f7fe fcac 	bl	900123b8 <HAL_RCCEx_GetPeriphCLKFreq>
90013a60:	6178      	str	r0, [r7, #20]
    /* Configure Master Clock Divider using the following formula :
       - If NODIV = 1 :
         MCKDIV[5:0] = SAI_CK_x / (FS * (FRL + 1))
       - If NODIV = 0 :
         MCKDIV[5:0] = SAI_CK_x / (FS * (OSR + 1) * 256) */
    if (hsai->Init.NoDivider == SAI_MASTERDIVIDER_DISABLE)
90013a62:	687b      	ldr	r3, [r7, #4]
90013a64:	699b      	ldr	r3, [r3, #24]
90013a66:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
90013a6a:	d120      	bne.n	90013aae <HAL_SAI_Init+0x26a>
    {
      /* NODIV = 1 */
      uint32_t tmpframelength;

      if (hsai->Init.Protocol == SAI_SPDIF_PROTOCOL)
90013a6c:	687b      	ldr	r3, [r7, #4]
90013a6e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90013a70:	2b04      	cmp	r3, #4
90013a72:	d102      	bne.n	90013a7a <HAL_SAI_Init+0x236>
      {
        /* For SPDIF protocol, frame length is set by hardware to 64 */
        tmpframelength = 64U;
90013a74:	2340      	movs	r3, #64	; 0x40
90013a76:	60fb      	str	r3, [r7, #12]
90013a78:	e00a      	b.n	90013a90 <HAL_SAI_Init+0x24c>
      }
      else if (hsai->Init.Protocol == SAI_AC97_PROTOCOL)
90013a7a:	687b      	ldr	r3, [r7, #4]
90013a7c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90013a7e:	2b08      	cmp	r3, #8
90013a80:	d103      	bne.n	90013a8a <HAL_SAI_Init+0x246>
      {
        /* For AC97 protocol, frame length is set by hardware to 256 */
        tmpframelength = 256U;
90013a82:	f44f 7380 	mov.w	r3, #256	; 0x100
90013a86:	60fb      	str	r3, [r7, #12]
90013a88:	e002      	b.n	90013a90 <HAL_SAI_Init+0x24c>
      }
      else
      {
        /* For free protocol, frame length is set by user */
        tmpframelength = hsai->FrameInit.FrameLength;
90013a8a:	687b      	ldr	r3, [r7, #4]
90013a8c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90013a8e:	60fb      	str	r3, [r7, #12]
      }

      /* (freq x 10) to keep Significant digits */
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmpframelength);
90013a90:	697a      	ldr	r2, [r7, #20]
90013a92:	4613      	mov	r3, r2
90013a94:	009b      	lsls	r3, r3, #2
90013a96:	4413      	add	r3, r2
90013a98:	005b      	lsls	r3, r3, #1
90013a9a:	4619      	mov	r1, r3
90013a9c:	687b      	ldr	r3, [r7, #4]
90013a9e:	6a1b      	ldr	r3, [r3, #32]
90013aa0:	68fa      	ldr	r2, [r7, #12]
90013aa2:	fb02 f303 	mul.w	r3, r2, r3
90013aa6:	fbb1 f3f3 	udiv	r3, r1, r3
90013aaa:	613b      	str	r3, [r7, #16]
90013aac:	e02f      	b.n	90013b0e <HAL_SAI_Init+0x2ca>
    }
    else
    {
      /* NODIV = 0 */
      uint32_t tmposr;
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
90013aae:	687b      	ldr	r3, [r7, #4]
90013ab0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90013ab2:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
90013ab6:	d119      	bne.n	90013aec <HAL_SAI_Init+0x2a8>
90013ab8:	2302      	movs	r3, #2
90013aba:	e018      	b.n	90013aee <HAL_SAI_Init+0x2aa>
90013abc:	40015804 	.word	0x40015804
90013ac0:	58005404 	.word	0x58005404
90013ac4:	40015824 	.word	0x40015824
90013ac8:	40015800 	.word	0x40015800
90013acc:	40015c04 	.word	0x40015c04
90013ad0:	40015c24 	.word	0x40015c24
90013ad4:	40015c00 	.word	0x40015c00
90013ad8:	40016004 	.word	0x40016004
90013adc:	40016024 	.word	0x40016024
90013ae0:	40016000 	.word	0x40016000
90013ae4:	58005424 	.word	0x58005424
90013ae8:	58005400 	.word	0x58005400
90013aec:	2301      	movs	r3, #1
90013aee:	60bb      	str	r3, [r7, #8]
      /* (freq x 10) to keep Significant digits */
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
90013af0:	697a      	ldr	r2, [r7, #20]
90013af2:	4613      	mov	r3, r2
90013af4:	009b      	lsls	r3, r3, #2
90013af6:	4413      	add	r3, r2
90013af8:	005b      	lsls	r3, r3, #1
90013afa:	4619      	mov	r1, r3
90013afc:	687b      	ldr	r3, [r7, #4]
90013afe:	6a1b      	ldr	r3, [r3, #32]
90013b00:	68ba      	ldr	r2, [r7, #8]
90013b02:	fb02 f303 	mul.w	r3, r2, r3
90013b06:	021b      	lsls	r3, r3, #8
90013b08:	fbb1 f3f3 	udiv	r3, r1, r3
90013b0c:	613b      	str	r3, [r7, #16]
    }
    hsai->Init.Mckdiv = tmpval / 10U;
90013b0e:	693b      	ldr	r3, [r7, #16]
90013b10:	4a95      	ldr	r2, [pc, #596]	; (90013d68 <HAL_SAI_Init+0x524>)
90013b12:	fba2 2303 	umull	r2, r3, r2, r3
90013b16:	08da      	lsrs	r2, r3, #3
90013b18:	687b      	ldr	r3, [r7, #4]
90013b1a:	625a      	str	r2, [r3, #36]	; 0x24

    /* Round result to the nearest integer */
    if ((tmpval % 10U) > 8U)
90013b1c:	6939      	ldr	r1, [r7, #16]
90013b1e:	4b92      	ldr	r3, [pc, #584]	; (90013d68 <HAL_SAI_Init+0x524>)
90013b20:	fba3 2301 	umull	r2, r3, r3, r1
90013b24:	08da      	lsrs	r2, r3, #3
90013b26:	4613      	mov	r3, r2
90013b28:	009b      	lsls	r3, r3, #2
90013b2a:	4413      	add	r3, r2
90013b2c:	005b      	lsls	r3, r3, #1
90013b2e:	1aca      	subs	r2, r1, r3
90013b30:	2a08      	cmp	r2, #8
90013b32:	d904      	bls.n	90013b3e <HAL_SAI_Init+0x2fa>
    {
      hsai->Init.Mckdiv += 1U;
90013b34:	687b      	ldr	r3, [r7, #4]
90013b36:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90013b38:	1c5a      	adds	r2, r3, #1
90013b3a:	687b      	ldr	r3, [r7, #4]
90013b3c:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /* For SPDIF protocol, SAI shall provide a bit clock twice faster the symbol-rate */
    if (hsai->Init.Protocol == SAI_SPDIF_PROTOCOL)
90013b3e:	687b      	ldr	r3, [r7, #4]
90013b40:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90013b42:	2b04      	cmp	r3, #4
90013b44:	d104      	bne.n	90013b50 <HAL_SAI_Init+0x30c>
    {
      hsai->Init.Mckdiv = hsai->Init.Mckdiv >> 1;
90013b46:	687b      	ldr	r3, [r7, #4]
90013b48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90013b4a:	085a      	lsrs	r2, r3, #1
90013b4c:	687b      	ldr	r3, [r7, #4]
90013b4e:	625a      	str	r2, [r3, #36]	; 0x24

  /* Check the SAI Block master clock divider parameter */
  assert_param(IS_SAI_BLOCK_MASTER_DIVIDER(hsai->Init.Mckdiv));

  /* Compute CKSTR bits of SAI CR1 according ClockStrobing and AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
90013b50:	687b      	ldr	r3, [r7, #4]
90013b52:	685b      	ldr	r3, [r3, #4]
90013b54:	2b00      	cmp	r3, #0
90013b56:	d003      	beq.n	90013b60 <HAL_SAI_Init+0x31c>
90013b58:	687b      	ldr	r3, [r7, #4]
90013b5a:	685b      	ldr	r3, [r3, #4]
90013b5c:	2b02      	cmp	r3, #2
90013b5e:	d109      	bne.n	90013b74 <HAL_SAI_Init+0x330>
  {
    /* Transmit */
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
90013b60:	687b      	ldr	r3, [r7, #4]
90013b62:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90013b64:	2b01      	cmp	r3, #1
90013b66:	d101      	bne.n	90013b6c <HAL_SAI_Init+0x328>
90013b68:	2300      	movs	r3, #0
90013b6a:	e001      	b.n	90013b70 <HAL_SAI_Init+0x32c>
90013b6c:	f44f 7300 	mov.w	r3, #512	; 0x200
90013b70:	623b      	str	r3, [r7, #32]
90013b72:	e008      	b.n	90013b86 <HAL_SAI_Init+0x342>
  }
  else
  {
    /* Receive */
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0U;
90013b74:	687b      	ldr	r3, [r7, #4]
90013b76:	6d1b      	ldr	r3, [r3, #80]	; 0x50
90013b78:	2b01      	cmp	r3, #1
90013b7a:	d102      	bne.n	90013b82 <HAL_SAI_Init+0x33e>
90013b7c:	f44f 7300 	mov.w	r3, #512	; 0x200
90013b80:	e000      	b.n	90013b84 <HAL_SAI_Init+0x340>
90013b82:	2300      	movs	r3, #0
90013b84:	623b      	str	r3, [r7, #32]

  /* SAI Block Configuration -------------------------------------------------*/
  /* SAI CR1 Configuration */
#if defined(SAI_VER_V2_X) /* SAI Peripheral version depends on STM32H7 device revision ID */

  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
90013b86:	f7f5 fc4d 	bl	90009424 <HAL_GetREVID>
90013b8a:	4603      	mov	r3, r0
90013b8c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
90013b90:	d331      	bcc.n	90013bf6 <HAL_SAI_Init+0x3b2>
  {
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
90013b92:	687b      	ldr	r3, [r7, #4]
90013b94:	681b      	ldr	r3, [r3, #0]
90013b96:	6819      	ldr	r1, [r3, #0]
90013b98:	687b      	ldr	r3, [r7, #4]
90013b9a:	681a      	ldr	r2, [r3, #0]
90013b9c:	4b73      	ldr	r3, [pc, #460]	; (90013d6c <HAL_SAI_Init+0x528>)
90013b9e:	400b      	ands	r3, r1
90013ba0:	6013      	str	r3, [r2, #0]
                             SAI_xCR1_LSBFIRST | SAI_xCR1_CKSTR | SAI_xCR1_SYNCEN | \
                             SAI_xCR1_MONO | SAI_xCR1_OUTDRIV  | SAI_xCR1_DMAEN |  \
                             SAI_xCR1_NODIV | SAI_xCR1_MCKDIV | SAI_xCR1_OSR |     \
                             SAI_xCR1_MCKEN);

    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
90013ba2:	687b      	ldr	r3, [r7, #4]
90013ba4:	681b      	ldr	r3, [r3, #0]
90013ba6:	6819      	ldr	r1, [r3, #0]
90013ba8:	687b      	ldr	r3, [r7, #4]
90013baa:	685a      	ldr	r2, [r3, #4]
90013bac:	687b      	ldr	r3, [r7, #4]
90013bae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90013bb0:	431a      	orrs	r2, r3
                            hsai->Init.DataSize | hsai->Init.FirstBit  |           \
90013bb2:	687b      	ldr	r3, [r7, #4]
90013bb4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
90013bb6:	431a      	orrs	r2, r3
                            hsai->Init.DataSize | hsai->Init.FirstBit  |           \
90013bb8:	687b      	ldr	r3, [r7, #4]
90013bba:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90013bbc:	431a      	orrs	r2, r3
90013bbe:	6a3b      	ldr	r3, [r7, #32]
90013bc0:	431a      	orrs	r2, r3
                            ckstr_bits | syncen_bits |                             \
90013bc2:	69fb      	ldr	r3, [r7, #28]
90013bc4:	431a      	orrs	r2, r3
                            hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
90013bc6:	687b      	ldr	r3, [r7, #4]
90013bc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                            ckstr_bits | syncen_bits |                             \
90013bca:	431a      	orrs	r2, r3
                            hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
90013bcc:	687b      	ldr	r3, [r7, #4]
90013bce:	695b      	ldr	r3, [r3, #20]
90013bd0:	431a      	orrs	r2, r3
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
90013bd2:	687b      	ldr	r3, [r7, #4]
90013bd4:	699b      	ldr	r3, [r3, #24]
                            hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
90013bd6:	431a      	orrs	r2, r3
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
90013bd8:	687b      	ldr	r3, [r7, #4]
90013bda:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90013bdc:	051b      	lsls	r3, r3, #20
90013bde:	431a      	orrs	r2, r3
                            hsai->Init.MckOverSampling | hsai->Init.MckOutput);
90013be0:	687b      	ldr	r3, [r7, #4]
90013be2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
90013be4:	431a      	orrs	r2, r3
                            hsai->Init.MckOverSampling | hsai->Init.MckOutput);
90013be6:	687b      	ldr	r3, [r7, #4]
90013be8:	691b      	ldr	r3, [r3, #16]
90013bea:	431a      	orrs	r2, r3
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
90013bec:	687b      	ldr	r3, [r7, #4]
90013bee:	681b      	ldr	r3, [r3, #0]
90013bf0:	430a      	orrs	r2, r1
90013bf2:	601a      	str	r2, [r3, #0]
90013bf4:	e02d      	b.n	90013c52 <HAL_SAI_Init+0x40e>
  }
  else /* STM32H7xx Rev.Y */
  {
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
90013bf6:	687b      	ldr	r3, [r7, #4]
90013bf8:	681b      	ldr	r3, [r3, #0]
90013bfa:	6819      	ldr	r1, [r3, #0]
90013bfc:	687b      	ldr	r3, [r7, #4]
90013bfe:	681a      	ldr	r2, [r3, #0]
90013c00:	4b5b      	ldr	r3, [pc, #364]	; (90013d70 <HAL_SAI_Init+0x52c>)
90013c02:	400b      	ands	r3, r1
90013c04:	6013      	str	r3, [r2, #0]
                             SAI_xCR1_LSBFIRST | SAI_xCR1_CKSTR | SAI_xCR1_SYNCEN | \
                             SAI_xCR1_MONO | SAI_xCR1_OUTDRIV  | SAI_xCR1_DMAEN |  \
                             SAI_xCR1_NODIV | SAI_xCR1_MCKDIV | SAI_xCR1_OSR);

    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
90013c06:	687b      	ldr	r3, [r7, #4]
90013c08:	681b      	ldr	r3, [r3, #0]
90013c0a:	6819      	ldr	r1, [r3, #0]
90013c0c:	687b      	ldr	r3, [r7, #4]
90013c0e:	685a      	ldr	r2, [r3, #4]
90013c10:	687b      	ldr	r3, [r7, #4]
90013c12:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90013c14:	431a      	orrs	r2, r3
                            hsai->Init.DataSize | hsai->Init.FirstBit  |           \
90013c16:	687b      	ldr	r3, [r7, #4]
90013c18:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
90013c1a:	431a      	orrs	r2, r3
                            hsai->Init.DataSize | hsai->Init.FirstBit  |           \
90013c1c:	687b      	ldr	r3, [r7, #4]
90013c1e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
90013c20:	431a      	orrs	r2, r3
90013c22:	6a3b      	ldr	r3, [r7, #32]
90013c24:	431a      	orrs	r2, r3
                            ckstr_bits | syncen_bits |                             \
90013c26:	69fb      	ldr	r3, [r7, #28]
90013c28:	431a      	orrs	r2, r3
                            hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
90013c2a:	687b      	ldr	r3, [r7, #4]
90013c2c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                            ckstr_bits | syncen_bits |                             \
90013c2e:	431a      	orrs	r2, r3
                            hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
90013c30:	687b      	ldr	r3, [r7, #4]
90013c32:	695b      	ldr	r3, [r3, #20]
90013c34:	431a      	orrs	r2, r3
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
90013c36:	687b      	ldr	r3, [r7, #4]
90013c38:	699b      	ldr	r3, [r3, #24]
                            hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
90013c3a:	431a      	orrs	r2, r3
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
90013c3c:	687b      	ldr	r3, [r7, #4]
90013c3e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90013c40:	051b      	lsls	r3, r3, #20
90013c42:	431a      	orrs	r2, r3
                            hsai->Init.MckOverSampling);
90013c44:	687b      	ldr	r3, [r7, #4]
90013c46:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
90013c48:	431a      	orrs	r2, r3
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
90013c4a:	687b      	ldr	r3, [r7, #4]
90013c4c:	681b      	ldr	r3, [r3, #0]
90013c4e:	430a      	orrs	r2, r1
90013c50:	601a      	str	r2, [r3, #0]
                          hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
                          hsai->Init.MckOverSampling | hsai->Init.MckOutput);
#endif /* SAI_VER_V2_X */

  /* SAI CR2 Configuration */
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
90013c52:	687b      	ldr	r3, [r7, #4]
90013c54:	681b      	ldr	r3, [r3, #0]
90013c56:	6859      	ldr	r1, [r3, #4]
90013c58:	687b      	ldr	r3, [r7, #4]
90013c5a:	681a      	ldr	r2, [r3, #0]
90013c5c:	4b45      	ldr	r3, [pc, #276]	; (90013d74 <HAL_SAI_Init+0x530>)
90013c5e:	400b      	ands	r3, r1
90013c60:	6053      	str	r3, [r2, #4]
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
90013c62:	687b      	ldr	r3, [r7, #4]
90013c64:	681b      	ldr	r3, [r3, #0]
90013c66:	6859      	ldr	r1, [r3, #4]
90013c68:	687b      	ldr	r3, [r7, #4]
90013c6a:	69da      	ldr	r2, [r3, #28]
90013c6c:	687b      	ldr	r3, [r7, #4]
90013c6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90013c70:	431a      	orrs	r2, r3
90013c72:	687b      	ldr	r3, [r7, #4]
90013c74:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90013c76:	431a      	orrs	r2, r3
90013c78:	687b      	ldr	r3, [r7, #4]
90013c7a:	681b      	ldr	r3, [r3, #0]
90013c7c:	430a      	orrs	r2, r1
90013c7e:	605a      	str	r2, [r3, #4]

  /* SAI Frame Configuration -----------------------------------------*/
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
90013c80:	687b      	ldr	r3, [r7, #4]
90013c82:	681b      	ldr	r3, [r3, #0]
90013c84:	6899      	ldr	r1, [r3, #8]
90013c86:	687b      	ldr	r3, [r7, #4]
90013c88:	681a      	ldr	r2, [r3, #0]
90013c8a:	4b3b      	ldr	r3, [pc, #236]	; (90013d78 <HAL_SAI_Init+0x534>)
90013c8c:	400b      	ands	r3, r1
90013c8e:	6093      	str	r3, [r2, #8]
                             SAI_xFRCR_FSPOL | SAI_xFRCR_FSOFF));
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
90013c90:	687b      	ldr	r3, [r7, #4]
90013c92:	681b      	ldr	r3, [r3, #0]
90013c94:	6899      	ldr	r1, [r3, #8]
90013c96:	687b      	ldr	r3, [r7, #4]
90013c98:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90013c9a:	1e5a      	subs	r2, r3, #1
                           hsai->FrameInit.FSOffset |
90013c9c:	687b      	ldr	r3, [r7, #4]
90013c9e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
90013ca0:	431a      	orrs	r2, r3
                           hsai->FrameInit.FSDefinition |
90013ca2:	687b      	ldr	r3, [r7, #4]
90013ca4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
                           hsai->FrameInit.FSOffset |
90013ca6:	431a      	orrs	r2, r3
                           hsai->FrameInit.FSPolarity   |
90013ca8:	687b      	ldr	r3, [r7, #4]
90013caa:	6e1b      	ldr	r3, [r3, #96]	; 0x60
                           hsai->FrameInit.FSDefinition |
90013cac:	431a      	orrs	r2, r3
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
90013cae:	687b      	ldr	r3, [r7, #4]
90013cb0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
90013cb2:	3b01      	subs	r3, #1
90013cb4:	021b      	lsls	r3, r3, #8
                           hsai->FrameInit.FSPolarity   |
90013cb6:	431a      	orrs	r2, r3
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
90013cb8:	687b      	ldr	r3, [r7, #4]
90013cba:	681b      	ldr	r3, [r3, #0]
90013cbc:	430a      	orrs	r2, r1
90013cbe:	609a      	str	r2, [r3, #8]

  /* SAI Block_x SLOT Configuration ------------------------------------------*/
  /* This register has no meaning in AC 97 and SPDIF audio protocol */
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
90013cc0:	687b      	ldr	r3, [r7, #4]
90013cc2:	681b      	ldr	r3, [r3, #0]
90013cc4:	68d9      	ldr	r1, [r3, #12]
90013cc6:	687b      	ldr	r3, [r7, #4]
90013cc8:	681a      	ldr	r2, [r3, #0]
90013cca:	f24f 0320 	movw	r3, #61472	; 0xf020
90013cce:	400b      	ands	r3, r1
90013cd0:	60d3      	str	r3, [r2, #12]
                              SAI_xSLOTR_NBSLOT | SAI_xSLOTR_SLOTEN));

  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
90013cd2:	687b      	ldr	r3, [r7, #4]
90013cd4:	681b      	ldr	r3, [r3, #0]
90013cd6:	68d9      	ldr	r1, [r3, #12]
90013cd8:	687b      	ldr	r3, [r7, #4]
90013cda:	6e9a      	ldr	r2, [r3, #104]	; 0x68
90013cdc:	687b      	ldr	r3, [r7, #4]
90013cde:	6edb      	ldr	r3, [r3, #108]	; 0x6c
90013ce0:	431a      	orrs	r2, r3
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
90013ce2:	687b      	ldr	r3, [r7, #4]
90013ce4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
90013ce6:	041b      	lsls	r3, r3, #16
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
90013ce8:	431a      	orrs	r2, r3
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
90013cea:	687b      	ldr	r3, [r7, #4]
90013cec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
90013cee:	3b01      	subs	r3, #1
90013cf0:	021b      	lsls	r3, r3, #8
90013cf2:	431a      	orrs	r2, r3
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
90013cf4:	687b      	ldr	r3, [r7, #4]
90013cf6:	681b      	ldr	r3, [r3, #0]
90013cf8:	430a      	orrs	r2, r1
90013cfa:	60da      	str	r2, [r3, #12]

  /* SAI PDM Configuration ---------------------------------------------------*/
#if defined(SAI4)
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
90013cfc:	687b      	ldr	r3, [r7, #4]
90013cfe:	681b      	ldr	r3, [r3, #0]
90013d00:	4a1e      	ldr	r2, [pc, #120]	; (90013d7c <HAL_SAI_Init+0x538>)
90013d02:	4293      	cmp	r3, r2
90013d04:	d004      	beq.n	90013d10 <HAL_SAI_Init+0x4cc>
90013d06:	687b      	ldr	r3, [r7, #4]
90013d08:	681b      	ldr	r3, [r3, #0]
90013d0a:	4a1d      	ldr	r2, [pc, #116]	; (90013d80 <HAL_SAI_Init+0x53c>)
90013d0c:	4293      	cmp	r3, r2
90013d0e:	d119      	bne.n	90013d44 <HAL_SAI_Init+0x500>
#else
  if (hsai->Instance == SAI1_Block_A)
#endif /* SAI4 */
  {
    /* Disable PDM interface */
    SaiBaseAddress->PDMCR &= ~(SAI_PDMCR_PDMEN);
90013d10:	69bb      	ldr	r3, [r7, #24]
90013d12:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90013d14:	f023 0201 	bic.w	r2, r3, #1
90013d18:	69bb      	ldr	r3, [r7, #24]
90013d1a:	645a      	str	r2, [r3, #68]	; 0x44
    if (hsai->Init.PdmInit.Activation == ENABLE)
90013d1c:	687b      	ldr	r3, [r7, #4]
90013d1e:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
90013d22:	2b01      	cmp	r3, #1
90013d24:	d10e      	bne.n	90013d44 <HAL_SAI_Init+0x500>
    {
      /* Configure and enable PDM interface */
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
90013d26:	687b      	ldr	r3, [r7, #4]
90013d28:	6c1a      	ldr	r2, [r3, #64]	; 0x40
                               ((hsai->Init.PdmInit.MicPairsNbr - 1U) << SAI_PDMCR_MICNBR_Pos));
90013d2a:	687b      	ldr	r3, [r7, #4]
90013d2c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
90013d2e:	3b01      	subs	r3, #1
90013d30:	011b      	lsls	r3, r3, #4
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
90013d32:	431a      	orrs	r2, r3
90013d34:	69bb      	ldr	r3, [r7, #24]
90013d36:	645a      	str	r2, [r3, #68]	; 0x44
      SaiBaseAddress->PDMCR |= SAI_PDMCR_PDMEN;
90013d38:	69bb      	ldr	r3, [r7, #24]
90013d3a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90013d3c:	f043 0201 	orr.w	r2, r3, #1
90013d40:	69bb      	ldr	r3, [r7, #24]
90013d42:	645a      	str	r2, [r3, #68]	; 0x44
    }
  }

  /* Initialize the error code */
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
90013d44:	687b      	ldr	r3, [r7, #4]
90013d46:	2200      	movs	r2, #0
90013d48:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

  /* Initialize the SAI state */
  hsai->State = HAL_SAI_STATE_READY;
90013d4c:	687b      	ldr	r3, [r7, #4]
90013d4e:	2201      	movs	r2, #1
90013d50:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

  /* Release Lock */
  __HAL_UNLOCK(hsai);
90013d54:	687b      	ldr	r3, [r7, #4]
90013d56:	2200      	movs	r2, #0
90013d58:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

  return HAL_OK;
90013d5c:	2300      	movs	r3, #0
}
90013d5e:	4618      	mov	r0, r3
90013d60:	3728      	adds	r7, #40	; 0x28
90013d62:	46bd      	mov	sp, r7
90013d64:	bd80      	pop	{r7, pc}
90013d66:	bf00      	nop
90013d68:	cccccccd 	.word	0xcccccccd
90013d6c:	f005c010 	.word	0xf005c010
90013d70:	f805c010 	.word	0xf805c010
90013d74:	ffff1ff0 	.word	0xffff1ff0
90013d78:	fff88000 	.word	0xfff88000
90013d7c:	40015804 	.word	0x40015804
90013d80:	58005404 	.word	0x58005404

90013d84 <HAL_SAI_DeInit>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_DeInit(SAI_HandleTypeDef *hsai)
{
90013d84:	b580      	push	{r7, lr}
90013d86:	b084      	sub	sp, #16
90013d88:	af00      	add	r7, sp, #0
90013d8a:	6078      	str	r0, [r7, #4]
  SAI_TypeDef *SaiBaseAddress;

  /* Check the SAI handle allocation */
  if (hsai == NULL)
90013d8c:	687b      	ldr	r3, [r7, #4]
90013d8e:	2b00      	cmp	r3, #0
90013d90:	d101      	bne.n	90013d96 <HAL_SAI_DeInit+0x12>
  {
    return HAL_ERROR;
90013d92:	2301      	movs	r3, #1
90013d94:	e050      	b.n	90013e38 <HAL_SAI_DeInit+0xb4>
  }

  hsai->State = HAL_SAI_STATE_BUSY;
90013d96:	687b      	ldr	r3, [r7, #4]
90013d98:	2202      	movs	r2, #2
90013d9a:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

  /* Disabled All interrupt and clear all the flag */
  hsai->Instance->IMR = 0;
90013d9e:	687b      	ldr	r3, [r7, #4]
90013da0:	681b      	ldr	r3, [r3, #0]
90013da2:	2200      	movs	r2, #0
90013da4:	611a      	str	r2, [r3, #16]
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
90013da6:	687b      	ldr	r3, [r7, #4]
90013da8:	681b      	ldr	r3, [r3, #0]
90013daa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
90013dae:	619a      	str	r2, [r3, #24]

  /* Disable the SAI */
  if (SAI_Disable(hsai) != HAL_OK)
90013db0:	6878      	ldr	r0, [r7, #4]
90013db2:	f000 fab5 	bl	90014320 <SAI_Disable>
90013db6:	4603      	mov	r3, r0
90013db8:	2b00      	cmp	r3, #0
90013dba:	d009      	beq.n	90013dd0 <HAL_SAI_DeInit+0x4c>
  {
    /* Reset SAI state to ready */
    hsai->State = HAL_SAI_STATE_READY;
90013dbc:	687b      	ldr	r3, [r7, #4]
90013dbe:	2201      	movs	r2, #1
90013dc0:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

    /* Release Lock */
    __HAL_UNLOCK(hsai);
90013dc4:	687b      	ldr	r3, [r7, #4]
90013dc6:	2200      	movs	r2, #0
90013dc8:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

    return HAL_ERROR;
90013dcc:	2301      	movs	r3, #1
90013dce:	e033      	b.n	90013e38 <HAL_SAI_DeInit+0xb4>
  }

  /* Flush the fifo */
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
90013dd0:	687b      	ldr	r3, [r7, #4]
90013dd2:	681b      	ldr	r3, [r3, #0]
90013dd4:	685a      	ldr	r2, [r3, #4]
90013dd6:	687b      	ldr	r3, [r7, #4]
90013dd8:	681b      	ldr	r3, [r3, #0]
90013dda:	f042 0208 	orr.w	r2, r2, #8
90013dde:	605a      	str	r2, [r3, #4]

  /* Disable SAI PDM interface */
#if defined(SAI4)
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
90013de0:	687b      	ldr	r3, [r7, #4]
90013de2:	681b      	ldr	r3, [r3, #0]
90013de4:	4a16      	ldr	r2, [pc, #88]	; (90013e40 <HAL_SAI_DeInit+0xbc>)
90013de6:	4293      	cmp	r3, r2
90013de8:	d004      	beq.n	90013df4 <HAL_SAI_DeInit+0x70>
90013dea:	687b      	ldr	r3, [r7, #4]
90013dec:	681b      	ldr	r3, [r3, #0]
90013dee:	4a15      	ldr	r2, [pc, #84]	; (90013e44 <HAL_SAI_DeInit+0xc0>)
90013df0:	4293      	cmp	r3, r2
90013df2:	d111      	bne.n	90013e18 <HAL_SAI_DeInit+0x94>
  if (hsai->Instance == SAI1_Block_A)
#endif /* SAI4 */
  {
    /* Get the SAI base address according to the SAI handle */
#if defined(SAI4)
    SaiBaseAddress = (hsai->Instance == SAI1_Block_A) ? SAI1 : SAI4;
90013df4:	687b      	ldr	r3, [r7, #4]
90013df6:	681b      	ldr	r3, [r3, #0]
90013df8:	4a11      	ldr	r2, [pc, #68]	; (90013e40 <HAL_SAI_DeInit+0xbc>)
90013dfa:	4293      	cmp	r3, r2
90013dfc:	d101      	bne.n	90013e02 <HAL_SAI_DeInit+0x7e>
90013dfe:	4b12      	ldr	r3, [pc, #72]	; (90013e48 <HAL_SAI_DeInit+0xc4>)
90013e00:	e000      	b.n	90013e04 <HAL_SAI_DeInit+0x80>
90013e02:	4b12      	ldr	r3, [pc, #72]	; (90013e4c <HAL_SAI_DeInit+0xc8>)
90013e04:	60fb      	str	r3, [r7, #12]
#else
    SaiBaseAddress = SAI1;
#endif /* SAI4 */

    /* Reset PDM delays */
    SaiBaseAddress->PDMDLY = 0U;
90013e06:	68fb      	ldr	r3, [r7, #12]
90013e08:	2200      	movs	r2, #0
90013e0a:	649a      	str	r2, [r3, #72]	; 0x48

    /* Disable PDM interface */
    SaiBaseAddress->PDMCR &= ~(SAI_PDMCR_PDMEN);
90013e0c:	68fb      	ldr	r3, [r7, #12]
90013e0e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
90013e10:	f023 0201 	bic.w	r2, r3, #1
90013e14:	68fb      	ldr	r3, [r7, #12]
90013e16:	645a      	str	r2, [r3, #68]	; 0x44
  {
    hsai->MspDeInitCallback = HAL_SAI_MspDeInit;
  }
  hsai->MspDeInitCallback(hsai);
#else
  HAL_SAI_MspDeInit(hsai);
90013e18:	6878      	ldr	r0, [r7, #4]
90013e1a:	f000 f823 	bl	90013e64 <HAL_SAI_MspDeInit>
#endif

  /* Initialize the error code */
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
90013e1e:	687b      	ldr	r3, [r7, #4]
90013e20:	2200      	movs	r2, #0
90013e22:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

  /* Initialize the SAI state */
  hsai->State = HAL_SAI_STATE_RESET;
90013e26:	687b      	ldr	r3, [r7, #4]
90013e28:	2200      	movs	r2, #0
90013e2a:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

  /* Release Lock */
  __HAL_UNLOCK(hsai);
90013e2e:	687b      	ldr	r3, [r7, #4]
90013e30:	2200      	movs	r2, #0
90013e32:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

  return HAL_OK;
90013e36:	2300      	movs	r3, #0
}
90013e38:	4618      	mov	r0, r3
90013e3a:	3710      	adds	r7, #16
90013e3c:	46bd      	mov	sp, r7
90013e3e:	bd80      	pop	{r7, pc}
90013e40:	40015804 	.word	0x40015804
90013e44:	58005404 	.word	0x58005404
90013e48:	40015800 	.word	0x40015800
90013e4c:	58005400 	.word	0x58005400

90013e50 <HAL_SAI_MspInit>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval None
  */
__weak void HAL_SAI_MspInit(SAI_HandleTypeDef *hsai)
{
90013e50:	b480      	push	{r7}
90013e52:	b083      	sub	sp, #12
90013e54:	af00      	add	r7, sp, #0
90013e56:	6078      	str	r0, [r7, #4]
  UNUSED(hsai);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SAI_MspInit could be implemented in the user file
   */
}
90013e58:	bf00      	nop
90013e5a:	370c      	adds	r7, #12
90013e5c:	46bd      	mov	sp, r7
90013e5e:	f85d 7b04 	ldr.w	r7, [sp], #4
90013e62:	4770      	bx	lr

90013e64 <HAL_SAI_MspDeInit>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval None
  */
__weak void HAL_SAI_MspDeInit(SAI_HandleTypeDef *hsai)
{
90013e64:	b480      	push	{r7}
90013e66:	b083      	sub	sp, #12
90013e68:	af00      	add	r7, sp, #0
90013e6a:	6078      	str	r0, [r7, #4]
  UNUSED(hsai);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SAI_MspDeInit could be implemented in the user file
   */
}
90013e6c:	bf00      	nop
90013e6e:	370c      	adds	r7, #12
90013e70:	46bd      	mov	sp, r7
90013e72:	f85d 7b04 	ldr.w	r7, [sp], #4
90013e76:	4770      	bx	lr

90013e78 <HAL_SAI_DMAPause>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_DMAPause(SAI_HandleTypeDef *hsai)
{
90013e78:	b480      	push	{r7}
90013e7a:	b083      	sub	sp, #12
90013e7c:	af00      	add	r7, sp, #0
90013e7e:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hsai);
90013e80:	687b      	ldr	r3, [r7, #4]
90013e82:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
90013e86:	2b01      	cmp	r3, #1
90013e88:	d101      	bne.n	90013e8e <HAL_SAI_DMAPause+0x16>
90013e8a:	2302      	movs	r3, #2
90013e8c:	e010      	b.n	90013eb0 <HAL_SAI_DMAPause+0x38>
90013e8e:	687b      	ldr	r3, [r7, #4]
90013e90:	2201      	movs	r2, #1
90013e92:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

  /* Pause the audio file playing by disabling the SAI DMA requests */
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
90013e96:	687b      	ldr	r3, [r7, #4]
90013e98:	681b      	ldr	r3, [r3, #0]
90013e9a:	681a      	ldr	r2, [r3, #0]
90013e9c:	687b      	ldr	r3, [r7, #4]
90013e9e:	681b      	ldr	r3, [r3, #0]
90013ea0:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
90013ea4:	601a      	str	r2, [r3, #0]

  /* Process Unlocked */
  __HAL_UNLOCK(hsai);
90013ea6:	687b      	ldr	r3, [r7, #4]
90013ea8:	2200      	movs	r2, #0
90013eaa:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

  return HAL_OK;
90013eae:	2300      	movs	r3, #0
}
90013eb0:	4618      	mov	r0, r3
90013eb2:	370c      	adds	r7, #12
90013eb4:	46bd      	mov	sp, r7
90013eb6:	f85d 7b04 	ldr.w	r7, [sp], #4
90013eba:	4770      	bx	lr

90013ebc <HAL_SAI_DMAResume>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_DMAResume(SAI_HandleTypeDef *hsai)
{
90013ebc:	b480      	push	{r7}
90013ebe:	b083      	sub	sp, #12
90013ec0:	af00      	add	r7, sp, #0
90013ec2:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK(hsai);
90013ec4:	687b      	ldr	r3, [r7, #4]
90013ec6:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
90013eca:	2b01      	cmp	r3, #1
90013ecc:	d101      	bne.n	90013ed2 <HAL_SAI_DMAResume+0x16>
90013ece:	2302      	movs	r3, #2
90013ed0:	e01f      	b.n	90013f12 <HAL_SAI_DMAResume+0x56>
90013ed2:	687b      	ldr	r3, [r7, #4]
90013ed4:	2201      	movs	r2, #1
90013ed6:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

  /* Enable the SAI DMA requests */
  hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
90013eda:	687b      	ldr	r3, [r7, #4]
90013edc:	681b      	ldr	r3, [r3, #0]
90013ede:	681a      	ldr	r2, [r3, #0]
90013ee0:	687b      	ldr	r3, [r7, #4]
90013ee2:	681b      	ldr	r3, [r3, #0]
90013ee4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
90013ee8:	601a      	str	r2, [r3, #0]

  /* If the SAI peripheral is still not enabled, enable it */
  if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
90013eea:	687b      	ldr	r3, [r7, #4]
90013eec:	681b      	ldr	r3, [r3, #0]
90013eee:	681b      	ldr	r3, [r3, #0]
90013ef0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
90013ef4:	2b00      	cmp	r3, #0
90013ef6:	d107      	bne.n	90013f08 <HAL_SAI_DMAResume+0x4c>
  {
    /* Enable SAI peripheral */
    __HAL_SAI_ENABLE(hsai);
90013ef8:	687b      	ldr	r3, [r7, #4]
90013efa:	681b      	ldr	r3, [r3, #0]
90013efc:	681a      	ldr	r2, [r3, #0]
90013efe:	687b      	ldr	r3, [r7, #4]
90013f00:	681b      	ldr	r3, [r3, #0]
90013f02:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90013f06:	601a      	str	r2, [r3, #0]
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hsai);
90013f08:	687b      	ldr	r3, [r7, #4]
90013f0a:	2200      	movs	r2, #0
90013f0c:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

  return HAL_OK;
90013f10:	2300      	movs	r3, #0
}
90013f12:	4618      	mov	r0, r3
90013f14:	370c      	adds	r7, #12
90013f16:	46bd      	mov	sp, r7
90013f18:	f85d 7b04 	ldr.w	r7, [sp], #4
90013f1c:	4770      	bx	lr

90013f1e <HAL_SAI_DMAStop>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_DMAStop(SAI_HandleTypeDef *hsai)
{
90013f1e:	b580      	push	{r7, lr}
90013f20:	b084      	sub	sp, #16
90013f22:	af00      	add	r7, sp, #0
90013f24:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
90013f26:	2300      	movs	r3, #0
90013f28:	73fb      	strb	r3, [r7, #15]

  /* Process Locked */
  __HAL_LOCK(hsai);
90013f2a:	687b      	ldr	r3, [r7, #4]
90013f2c:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
90013f30:	2b01      	cmp	r3, #1
90013f32:	d101      	bne.n	90013f38 <HAL_SAI_DMAStop+0x1a>
90013f34:	2302      	movs	r3, #2
90013f36:	e06c      	b.n	90014012 <HAL_SAI_DMAStop+0xf4>
90013f38:	687b      	ldr	r3, [r7, #4]
90013f3a:	2201      	movs	r2, #1
90013f3c:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

  /* Disable the SAI DMA request */
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
90013f40:	687b      	ldr	r3, [r7, #4]
90013f42:	681b      	ldr	r3, [r3, #0]
90013f44:	681a      	ldr	r2, [r3, #0]
90013f46:	687b      	ldr	r3, [r7, #4]
90013f48:	681b      	ldr	r3, [r3, #0]
90013f4a:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
90013f4e:	601a      	str	r2, [r3, #0]

  /* Abort the SAI Tx DMA Stream */
  if ((hsai->State == HAL_SAI_STATE_BUSY_TX) && (hsai->hdmatx != NULL))
90013f50:	687b      	ldr	r3, [r7, #4]
90013f52:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
90013f56:	b2db      	uxtb	r3, r3
90013f58:	2b12      	cmp	r3, #18
90013f5a:	d11d      	bne.n	90013f98 <HAL_SAI_DMAStop+0x7a>
90013f5c:	687b      	ldr	r3, [r7, #4]
90013f5e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
90013f62:	2b00      	cmp	r3, #0
90013f64:	d018      	beq.n	90013f98 <HAL_SAI_DMAStop+0x7a>
  {
    if (HAL_DMA_Abort(hsai->hdmatx) != HAL_OK)
90013f66:	687b      	ldr	r3, [r7, #4]
90013f68:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
90013f6c:	4618      	mov	r0, r3
90013f6e:	f7f6 fbaf 	bl	9000a6d0 <HAL_DMA_Abort>
90013f72:	4603      	mov	r3, r0
90013f74:	2b00      	cmp	r3, #0
90013f76:	d00f      	beq.n	90013f98 <HAL_SAI_DMAStop+0x7a>
    {
      /* If the DMA Tx errorCode is different from DMA No Transfer then return Error */
      if (hsai->hdmatx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
90013f78:	687b      	ldr	r3, [r7, #4]
90013f7a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
90013f7e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90013f80:	2b80      	cmp	r3, #128	; 0x80
90013f82:	d009      	beq.n	90013f98 <HAL_SAI_DMAStop+0x7a>
      {
        status = HAL_ERROR;
90013f84:	2301      	movs	r3, #1
90013f86:	73fb      	strb	r3, [r7, #15]
        hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
90013f88:	687b      	ldr	r3, [r7, #4]
90013f8a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
90013f8e:	f043 0280 	orr.w	r2, r3, #128	; 0x80
90013f92:	687b      	ldr	r3, [r7, #4]
90013f94:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
      }
    }
  }

  /* Abort the SAI Rx DMA Stream */
  if ((hsai->State == HAL_SAI_STATE_BUSY_RX) && (hsai->hdmarx != NULL))
90013f98:	687b      	ldr	r3, [r7, #4]
90013f9a:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
90013f9e:	b2db      	uxtb	r3, r3
90013fa0:	2b22      	cmp	r3, #34	; 0x22
90013fa2:	d11d      	bne.n	90013fe0 <HAL_SAI_DMAStop+0xc2>
90013fa4:	687b      	ldr	r3, [r7, #4]
90013fa6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90013faa:	2b00      	cmp	r3, #0
90013fac:	d018      	beq.n	90013fe0 <HAL_SAI_DMAStop+0xc2>
  {
    if (HAL_DMA_Abort(hsai->hdmarx) != HAL_OK)
90013fae:	687b      	ldr	r3, [r7, #4]
90013fb0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90013fb4:	4618      	mov	r0, r3
90013fb6:	f7f6 fb8b 	bl	9000a6d0 <HAL_DMA_Abort>
90013fba:	4603      	mov	r3, r0
90013fbc:	2b00      	cmp	r3, #0
90013fbe:	d00f      	beq.n	90013fe0 <HAL_SAI_DMAStop+0xc2>
    {
      /* If the DMA Rx errorCode is different from DMA No Transfer then return Error */
      if (hsai->hdmarx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
90013fc0:	687b      	ldr	r3, [r7, #4]
90013fc2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90013fc6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
90013fc8:	2b80      	cmp	r3, #128	; 0x80
90013fca:	d009      	beq.n	90013fe0 <HAL_SAI_DMAStop+0xc2>
      {
        status = HAL_ERROR;
90013fcc:	2301      	movs	r3, #1
90013fce:	73fb      	strb	r3, [r7, #15]
        hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
90013fd0:	687b      	ldr	r3, [r7, #4]
90013fd2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
90013fd6:	f043 0280 	orr.w	r2, r3, #128	; 0x80
90013fda:	687b      	ldr	r3, [r7, #4]
90013fdc:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
      }
    }
  }

  /* Disable SAI peripheral */
  if (SAI_Disable(hsai) != HAL_OK)
90013fe0:	6878      	ldr	r0, [r7, #4]
90013fe2:	f000 f99d 	bl	90014320 <SAI_Disable>
90013fe6:	4603      	mov	r3, r0
90013fe8:	2b00      	cmp	r3, #0
90013fea:	d001      	beq.n	90013ff0 <HAL_SAI_DMAStop+0xd2>
  {
    status = HAL_ERROR;
90013fec:	2301      	movs	r3, #1
90013fee:	73fb      	strb	r3, [r7, #15]
  }

  /* Flush the fifo */
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
90013ff0:	687b      	ldr	r3, [r7, #4]
90013ff2:	681b      	ldr	r3, [r3, #0]
90013ff4:	685a      	ldr	r2, [r3, #4]
90013ff6:	687b      	ldr	r3, [r7, #4]
90013ff8:	681b      	ldr	r3, [r3, #0]
90013ffa:	f042 0208 	orr.w	r2, r2, #8
90013ffe:	605a      	str	r2, [r3, #4]

  /* Set hsai state to ready */
  hsai->State = HAL_SAI_STATE_READY;
90014000:	687b      	ldr	r3, [r7, #4]
90014002:	2201      	movs	r2, #1
90014004:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

  /* Process Unlocked */
  __HAL_UNLOCK(hsai);
90014008:	687b      	ldr	r3, [r7, #4]
9001400a:	2200      	movs	r2, #0
9001400c:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

  return status;
90014010:	7bfb      	ldrb	r3, [r7, #15]
}
90014012:	4618      	mov	r0, r3
90014014:	3710      	adds	r7, #16
90014016:	46bd      	mov	sp, r7
90014018:	bd80      	pop	{r7, pc}
	...

9001401c <HAL_SAI_Transmit_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Transmit_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
{
9001401c:	b580      	push	{r7, lr}
9001401e:	b086      	sub	sp, #24
90014020:	af00      	add	r7, sp, #0
90014022:	60f8      	str	r0, [r7, #12]
90014024:	60b9      	str	r1, [r7, #8]
90014026:	4613      	mov	r3, r2
90014028:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart = HAL_GetTick();
9001402a:	f7f5 f9cb 	bl	900093c4 <HAL_GetTick>
9001402e:	6178      	str	r0, [r7, #20]

  if ((pData == NULL) || (Size == 0U))
90014030:	68bb      	ldr	r3, [r7, #8]
90014032:	2b00      	cmp	r3, #0
90014034:	d002      	beq.n	9001403c <HAL_SAI_Transmit_DMA+0x20>
90014036:	88fb      	ldrh	r3, [r7, #6]
90014038:	2b00      	cmp	r3, #0
9001403a:	d101      	bne.n	90014040 <HAL_SAI_Transmit_DMA+0x24>
  {
    return  HAL_ERROR;
9001403c:	2301      	movs	r3, #1
9001403e:	e098      	b.n	90014172 <HAL_SAI_Transmit_DMA+0x156>
  }

  if (hsai->State == HAL_SAI_STATE_READY)
90014040:	68fb      	ldr	r3, [r7, #12]
90014042:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
90014046:	b2db      	uxtb	r3, r3
90014048:	2b01      	cmp	r3, #1
9001404a:	f040 8091 	bne.w	90014170 <HAL_SAI_Transmit_DMA+0x154>
  {
    /* Process Locked */
    __HAL_LOCK(hsai);
9001404e:	68fb      	ldr	r3, [r7, #12]
90014050:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
90014054:	2b01      	cmp	r3, #1
90014056:	d101      	bne.n	9001405c <HAL_SAI_Transmit_DMA+0x40>
90014058:	2302      	movs	r3, #2
9001405a:	e08a      	b.n	90014172 <HAL_SAI_Transmit_DMA+0x156>
9001405c:	68fb      	ldr	r3, [r7, #12]
9001405e:	2201      	movs	r2, #1
90014060:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

    hsai->pBuffPtr = pData;
90014064:	68fb      	ldr	r3, [r7, #12]
90014066:	68ba      	ldr	r2, [r7, #8]
90014068:	679a      	str	r2, [r3, #120]	; 0x78
    hsai->XferSize = Size;
9001406a:	68fb      	ldr	r3, [r7, #12]
9001406c:	88fa      	ldrh	r2, [r7, #6]
9001406e:	f8a3 207c 	strh.w	r2, [r3, #124]	; 0x7c
    hsai->XferCount = Size;
90014072:	68fb      	ldr	r3, [r7, #12]
90014074:	88fa      	ldrh	r2, [r7, #6]
90014076:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
9001407a:	68fb      	ldr	r3, [r7, #12]
9001407c:	2200      	movs	r2, #0
9001407e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    hsai->State = HAL_SAI_STATE_BUSY_TX;
90014082:	68fb      	ldr	r3, [r7, #12]
90014084:	2212      	movs	r2, #18
90014086:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

    /* Set the SAI Tx DMA Half transfer complete callback */
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
9001408a:	68fb      	ldr	r3, [r7, #12]
9001408c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
90014090:	4a3a      	ldr	r2, [pc, #232]	; (9001417c <HAL_SAI_Transmit_DMA+0x160>)
90014092:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the SAI TxDMA transfer complete callback */
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
90014094:	68fb      	ldr	r3, [r7, #12]
90014096:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
9001409a:	4a39      	ldr	r2, [pc, #228]	; (90014180 <HAL_SAI_Transmit_DMA+0x164>)
9001409c:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the DMA error callback */
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
9001409e:	68fb      	ldr	r3, [r7, #12]
900140a0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
900140a4:	4a37      	ldr	r2, [pc, #220]	; (90014184 <HAL_SAI_Transmit_DMA+0x168>)
900140a6:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA Tx abort callback */
    hsai->hdmatx->XferAbortCallback = NULL;
900140a8:	68fb      	ldr	r3, [r7, #12]
900140aa:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
900140ae:	2200      	movs	r2, #0
900140b0:	651a      	str	r2, [r3, #80]	; 0x50

    /* Enable the Tx DMA Stream */
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
900140b2:	68fb      	ldr	r3, [r7, #12]
900140b4:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
900140b8:	68fb      	ldr	r3, [r7, #12]
900140ba:	6f9b      	ldr	r3, [r3, #120]	; 0x78
900140bc:	4619      	mov	r1, r3
900140be:	68fb      	ldr	r3, [r7, #12]
900140c0:	681b      	ldr	r3, [r3, #0]
900140c2:	331c      	adds	r3, #28
900140c4:	461a      	mov	r2, r3
900140c6:	68fb      	ldr	r3, [r7, #12]
900140c8:	f8b3 307c 	ldrh.w	r3, [r3, #124]	; 0x7c
900140cc:	f7f6 f896 	bl	9000a1fc <HAL_DMA_Start_IT>
900140d0:	4603      	mov	r3, r0
900140d2:	2b00      	cmp	r3, #0
900140d4:	d005      	beq.n	900140e2 <HAL_SAI_Transmit_DMA+0xc6>
    {
      __HAL_UNLOCK(hsai);
900140d6:	68fb      	ldr	r3, [r7, #12]
900140d8:	2200      	movs	r2, #0
900140da:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
      return  HAL_ERROR;
900140de:	2301      	movs	r3, #1
900140e0:	e047      	b.n	90014172 <HAL_SAI_Transmit_DMA+0x156>
    }

    /* Enable the interrupts for error handling */
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
900140e2:	2100      	movs	r1, #0
900140e4:	68f8      	ldr	r0, [r7, #12]
900140e6:	f000 f8e3 	bl	900142b0 <SAI_InterruptFlag>
900140ea:	4601      	mov	r1, r0
900140ec:	68fb      	ldr	r3, [r7, #12]
900140ee:	681b      	ldr	r3, [r3, #0]
900140f0:	691a      	ldr	r2, [r3, #16]
900140f2:	68fb      	ldr	r3, [r7, #12]
900140f4:	681b      	ldr	r3, [r3, #0]
900140f6:	430a      	orrs	r2, r1
900140f8:	611a      	str	r2, [r3, #16]

    /* Enable SAI Tx DMA Request */
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
900140fa:	68fb      	ldr	r3, [r7, #12]
900140fc:	681b      	ldr	r3, [r3, #0]
900140fe:	681a      	ldr	r2, [r3, #0]
90014100:	68fb      	ldr	r3, [r7, #12]
90014102:	681b      	ldr	r3, [r3, #0]
90014104:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
90014108:	601a      	str	r2, [r3, #0]

    /* Wait until FIFO is not empty */
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
9001410a:	e015      	b.n	90014138 <HAL_SAI_Transmit_DMA+0x11c>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > SAI_LONG_TIMEOUT)
9001410c:	f7f5 f95a 	bl	900093c4 <HAL_GetTick>
90014110:	4602      	mov	r2, r0
90014112:	697b      	ldr	r3, [r7, #20]
90014114:	1ad3      	subs	r3, r2, r3
90014116:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
9001411a:	d90d      	bls.n	90014138 <HAL_SAI_Transmit_DMA+0x11c>
      {
        /* Update error code */
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
9001411c:	68fb      	ldr	r3, [r7, #12]
9001411e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
90014122:	f043 0240 	orr.w	r2, r3, #64	; 0x40
90014126:	68fb      	ldr	r3, [r7, #12]
90014128:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

        /* Process Unlocked */
        __HAL_UNLOCK(hsai);
9001412c:	68fb      	ldr	r3, [r7, #12]
9001412e:	2200      	movs	r2, #0
90014130:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

        return HAL_TIMEOUT;
90014134:	2303      	movs	r3, #3
90014136:	e01c      	b.n	90014172 <HAL_SAI_Transmit_DMA+0x156>
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
90014138:	68fb      	ldr	r3, [r7, #12]
9001413a:	681b      	ldr	r3, [r3, #0]
9001413c:	695b      	ldr	r3, [r3, #20]
9001413e:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
90014142:	2b00      	cmp	r3, #0
90014144:	d0e2      	beq.n	9001410c <HAL_SAI_Transmit_DMA+0xf0>
      }
    }

    /* Check if the SAI is already enabled */
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
90014146:	68fb      	ldr	r3, [r7, #12]
90014148:	681b      	ldr	r3, [r3, #0]
9001414a:	681b      	ldr	r3, [r3, #0]
9001414c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
90014150:	2b00      	cmp	r3, #0
90014152:	d107      	bne.n	90014164 <HAL_SAI_Transmit_DMA+0x148>
    {
      /* Enable SAI peripheral */
      __HAL_SAI_ENABLE(hsai);
90014154:	68fb      	ldr	r3, [r7, #12]
90014156:	681b      	ldr	r3, [r3, #0]
90014158:	681a      	ldr	r2, [r3, #0]
9001415a:	68fb      	ldr	r3, [r7, #12]
9001415c:	681b      	ldr	r3, [r3, #0]
9001415e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90014162:	601a      	str	r2, [r3, #0]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hsai);
90014164:	68fb      	ldr	r3, [r7, #12]
90014166:	2200      	movs	r2, #0
90014168:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

    return HAL_OK;
9001416c:	2300      	movs	r3, #0
9001416e:	e000      	b.n	90014172 <HAL_SAI_Transmit_DMA+0x156>
  }
  else
  {
    return HAL_BUSY;
90014170:	2302      	movs	r3, #2
  }
}
90014172:	4618      	mov	r0, r3
90014174:	3718      	adds	r7, #24
90014176:	46bd      	mov	sp, r7
90014178:	bd80      	pop	{r7, pc}
9001417a:	bf00      	nop
9001417c:	900143f5 	.word	0x900143f5
90014180:	90014395 	.word	0x90014395
90014184:	9001448d 	.word	0x9001448d

90014188 <HAL_SAI_Receive_DMA>:
  * @param  pData Pointer to data buffer
  * @param  Size Amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Receive_DMA(SAI_HandleTypeDef *hsai, uint8_t *pData, uint16_t Size)
{
90014188:	b580      	push	{r7, lr}
9001418a:	b084      	sub	sp, #16
9001418c:	af00      	add	r7, sp, #0
9001418e:	60f8      	str	r0, [r7, #12]
90014190:	60b9      	str	r1, [r7, #8]
90014192:	4613      	mov	r3, r2
90014194:	80fb      	strh	r3, [r7, #6]

  if ((pData == NULL) || (Size == 0U))
90014196:	68bb      	ldr	r3, [r7, #8]
90014198:	2b00      	cmp	r3, #0
9001419a:	d002      	beq.n	900141a2 <HAL_SAI_Receive_DMA+0x1a>
9001419c:	88fb      	ldrh	r3, [r7, #6]
9001419e:	2b00      	cmp	r3, #0
900141a0:	d101      	bne.n	900141a6 <HAL_SAI_Receive_DMA+0x1e>
  {
    return  HAL_ERROR;
900141a2:	2301      	movs	r3, #1
900141a4:	e079      	b.n	9001429a <HAL_SAI_Receive_DMA+0x112>
  }

  if (hsai->State == HAL_SAI_STATE_READY)
900141a6:	68fb      	ldr	r3, [r7, #12]
900141a8:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
900141ac:	b2db      	uxtb	r3, r3
900141ae:	2b01      	cmp	r3, #1
900141b0:	d172      	bne.n	90014298 <HAL_SAI_Receive_DMA+0x110>
  {
    /* Process Locked */
    __HAL_LOCK(hsai);
900141b2:	68fb      	ldr	r3, [r7, #12]
900141b4:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
900141b8:	2b01      	cmp	r3, #1
900141ba:	d101      	bne.n	900141c0 <HAL_SAI_Receive_DMA+0x38>
900141bc:	2302      	movs	r3, #2
900141be:	e06c      	b.n	9001429a <HAL_SAI_Receive_DMA+0x112>
900141c0:	68fb      	ldr	r3, [r7, #12]
900141c2:	2201      	movs	r2, #1
900141c4:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

    hsai->pBuffPtr = pData;
900141c8:	68fb      	ldr	r3, [r7, #12]
900141ca:	68ba      	ldr	r2, [r7, #8]
900141cc:	679a      	str	r2, [r3, #120]	; 0x78
    hsai->XferSize = Size;
900141ce:	68fb      	ldr	r3, [r7, #12]
900141d0:	88fa      	ldrh	r2, [r7, #6]
900141d2:	f8a3 207c 	strh.w	r2, [r3, #124]	; 0x7c
    hsai->XferCount = Size;
900141d6:	68fb      	ldr	r3, [r7, #12]
900141d8:	88fa      	ldrh	r2, [r7, #6]
900141da:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
900141de:	68fb      	ldr	r3, [r7, #12]
900141e0:	2200      	movs	r2, #0
900141e2:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    hsai->State = HAL_SAI_STATE_BUSY_RX;
900141e6:	68fb      	ldr	r3, [r7, #12]
900141e8:	2222      	movs	r2, #34	; 0x22
900141ea:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

    /* Set the SAI Rx DMA Half transfer complete callback */
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
900141ee:	68fb      	ldr	r3, [r7, #12]
900141f0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
900141f4:	4a2b      	ldr	r2, [pc, #172]	; (900142a4 <HAL_SAI_Receive_DMA+0x11c>)
900141f6:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the SAI Rx DMA transfer complete callback */
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
900141f8:	68fb      	ldr	r3, [r7, #12]
900141fa:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
900141fe:	4a2a      	ldr	r2, [pc, #168]	; (900142a8 <HAL_SAI_Receive_DMA+0x120>)
90014200:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the DMA error callback */
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
90014202:	68fb      	ldr	r3, [r7, #12]
90014204:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90014208:	4a28      	ldr	r2, [pc, #160]	; (900142ac <HAL_SAI_Receive_DMA+0x124>)
9001420a:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA Rx abort callback */
    hsai->hdmarx->XferAbortCallback = NULL;
9001420c:	68fb      	ldr	r3, [r7, #12]
9001420e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90014212:	2200      	movs	r2, #0
90014214:	651a      	str	r2, [r3, #80]	; 0x50

    /* Enable the Rx DMA Stream */
    if (HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
90014216:	68fb      	ldr	r3, [r7, #12]
90014218:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
9001421c:	68fb      	ldr	r3, [r7, #12]
9001421e:	681b      	ldr	r3, [r3, #0]
90014220:	331c      	adds	r3, #28
90014222:	4619      	mov	r1, r3
90014224:	68fb      	ldr	r3, [r7, #12]
90014226:	6f9b      	ldr	r3, [r3, #120]	; 0x78
90014228:	461a      	mov	r2, r3
9001422a:	68fb      	ldr	r3, [r7, #12]
9001422c:	f8b3 307c 	ldrh.w	r3, [r3, #124]	; 0x7c
90014230:	f7f5 ffe4 	bl	9000a1fc <HAL_DMA_Start_IT>
90014234:	4603      	mov	r3, r0
90014236:	2b00      	cmp	r3, #0
90014238:	d005      	beq.n	90014246 <HAL_SAI_Receive_DMA+0xbe>
    {
      __HAL_UNLOCK(hsai);
9001423a:	68fb      	ldr	r3, [r7, #12]
9001423c:	2200      	movs	r2, #0
9001423e:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
      return  HAL_ERROR;
90014242:	2301      	movs	r3, #1
90014244:	e029      	b.n	9001429a <HAL_SAI_Receive_DMA+0x112>
    }

    /* Enable the interrupts for error handling */
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
90014246:	2100      	movs	r1, #0
90014248:	68f8      	ldr	r0, [r7, #12]
9001424a:	f000 f831 	bl	900142b0 <SAI_InterruptFlag>
9001424e:	4601      	mov	r1, r0
90014250:	68fb      	ldr	r3, [r7, #12]
90014252:	681b      	ldr	r3, [r3, #0]
90014254:	691a      	ldr	r2, [r3, #16]
90014256:	68fb      	ldr	r3, [r7, #12]
90014258:	681b      	ldr	r3, [r3, #0]
9001425a:	430a      	orrs	r2, r1
9001425c:	611a      	str	r2, [r3, #16]

    /* Enable SAI Rx DMA Request */
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
9001425e:	68fb      	ldr	r3, [r7, #12]
90014260:	681b      	ldr	r3, [r3, #0]
90014262:	681a      	ldr	r2, [r3, #0]
90014264:	68fb      	ldr	r3, [r7, #12]
90014266:	681b      	ldr	r3, [r3, #0]
90014268:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
9001426c:	601a      	str	r2, [r3, #0]

    /* Check if the SAI is already enabled */
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
9001426e:	68fb      	ldr	r3, [r7, #12]
90014270:	681b      	ldr	r3, [r3, #0]
90014272:	681b      	ldr	r3, [r3, #0]
90014274:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
90014278:	2b00      	cmp	r3, #0
9001427a:	d107      	bne.n	9001428c <HAL_SAI_Receive_DMA+0x104>
    {
      /* Enable SAI peripheral */
      __HAL_SAI_ENABLE(hsai);
9001427c:	68fb      	ldr	r3, [r7, #12]
9001427e:	681b      	ldr	r3, [r3, #0]
90014280:	681a      	ldr	r2, [r3, #0]
90014282:	68fb      	ldr	r3, [r7, #12]
90014284:	681b      	ldr	r3, [r3, #0]
90014286:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
9001428a:	601a      	str	r2, [r3, #0]
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hsai);
9001428c:	68fb      	ldr	r3, [r7, #12]
9001428e:	2200      	movs	r2, #0
90014290:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90

    return HAL_OK;
90014294:	2300      	movs	r3, #0
90014296:	e000      	b.n	9001429a <HAL_SAI_Receive_DMA+0x112>
  }
  else
  {
    return HAL_BUSY;
90014298:	2302      	movs	r3, #2
  }
}
9001429a:	4618      	mov	r0, r3
9001429c:	3710      	adds	r7, #16
9001429e:	46bd      	mov	sp, r7
900142a0:	bd80      	pop	{r7, pc}
900142a2:	bf00      	nop
900142a4:	90014471 	.word	0x90014471
900142a8:	90014411 	.word	0x90014411
900142ac:	9001448d 	.word	0x9001448d

900142b0 <SAI_InterruptFlag>:
  *              the configuration information for SAI module.
  * @param  mode SAI_MODE_DMA or SAI_MODE_IT
  * @retval the list of the IT flag to enable
  */
static uint32_t SAI_InterruptFlag(const SAI_HandleTypeDef *hsai, SAI_ModeTypedef mode)
{
900142b0:	b480      	push	{r7}
900142b2:	b085      	sub	sp, #20
900142b4:	af00      	add	r7, sp, #0
900142b6:	6078      	str	r0, [r7, #4]
900142b8:	460b      	mov	r3, r1
900142ba:	70fb      	strb	r3, [r7, #3]
  uint32_t tmpIT = SAI_IT_OVRUDR;
900142bc:	2301      	movs	r3, #1
900142be:	60fb      	str	r3, [r7, #12]

  if (mode == SAI_MODE_IT)
900142c0:	78fb      	ldrb	r3, [r7, #3]
900142c2:	2b01      	cmp	r3, #1
900142c4:	d103      	bne.n	900142ce <SAI_InterruptFlag+0x1e>
  {
    tmpIT |= SAI_IT_FREQ;
900142c6:	68fb      	ldr	r3, [r7, #12]
900142c8:	f043 0308 	orr.w	r3, r3, #8
900142cc:	60fb      	str	r3, [r7, #12]
  }

  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
900142ce:	687b      	ldr	r3, [r7, #4]
900142d0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
900142d2:	2b08      	cmp	r3, #8
900142d4:	d10b      	bne.n	900142ee <SAI_InterruptFlag+0x3e>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
900142d6:	687b      	ldr	r3, [r7, #4]
900142d8:	685b      	ldr	r3, [r3, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
900142da:	2b03      	cmp	r3, #3
900142dc:	d003      	beq.n	900142e6 <SAI_InterruptFlag+0x36>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
900142de:	687b      	ldr	r3, [r7, #4]
900142e0:	685b      	ldr	r3, [r3, #4]
900142e2:	2b01      	cmp	r3, #1
900142e4:	d103      	bne.n	900142ee <SAI_InterruptFlag+0x3e>
  {
    tmpIT |= SAI_IT_CNRDY;
900142e6:	68fb      	ldr	r3, [r7, #12]
900142e8:	f043 0310 	orr.w	r3, r3, #16
900142ec:	60fb      	str	r3, [r7, #12]
  }

  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
900142ee:	687b      	ldr	r3, [r7, #4]
900142f0:	685b      	ldr	r3, [r3, #4]
900142f2:	2b03      	cmp	r3, #3
900142f4:	d003      	beq.n	900142fe <SAI_InterruptFlag+0x4e>
900142f6:	687b      	ldr	r3, [r7, #4]
900142f8:	685b      	ldr	r3, [r3, #4]
900142fa:	2b02      	cmp	r3, #2
900142fc:	d104      	bne.n	90014308 <SAI_InterruptFlag+0x58>
  {
    tmpIT |= SAI_IT_AFSDET | SAI_IT_LFSDET;
900142fe:	68fb      	ldr	r3, [r7, #12]
90014300:	f043 0360 	orr.w	r3, r3, #96	; 0x60
90014304:	60fb      	str	r3, [r7, #12]
90014306:	e003      	b.n	90014310 <SAI_InterruptFlag+0x60>
  }
  else
  {
    /* hsai has been configured in master mode */
    tmpIT |= SAI_IT_WCKCFG;
90014308:	68fb      	ldr	r3, [r7, #12]
9001430a:	f043 0304 	orr.w	r3, r3, #4
9001430e:	60fb      	str	r3, [r7, #12]
  }
  return tmpIT;
90014310:	68fb      	ldr	r3, [r7, #12]
}
90014312:	4618      	mov	r0, r3
90014314:	3714      	adds	r7, #20
90014316:	46bd      	mov	sp, r7
90014318:	f85d 7b04 	ldr.w	r7, [sp], #4
9001431c:	4770      	bx	lr
	...

90014320 <SAI_Disable>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *              the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
90014320:	b480      	push	{r7}
90014322:	b085      	sub	sp, #20
90014324:	af00      	add	r7, sp, #0
90014326:	6078      	str	r0, [r7, #4]
  uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
90014328:	4b18      	ldr	r3, [pc, #96]	; (9001438c <SAI_Disable+0x6c>)
9001432a:	681b      	ldr	r3, [r3, #0]
9001432c:	4a18      	ldr	r2, [pc, #96]	; (90014390 <SAI_Disable+0x70>)
9001432e:	fba2 2303 	umull	r2, r3, r2, r3
90014332:	0b1b      	lsrs	r3, r3, #12
90014334:	009b      	lsls	r3, r3, #2
90014336:	60fb      	str	r3, [r7, #12]
  HAL_StatusTypeDef status = HAL_OK;
90014338:	2300      	movs	r3, #0
9001433a:	72fb      	strb	r3, [r7, #11]

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
9001433c:	687b      	ldr	r3, [r7, #4]
9001433e:	681b      	ldr	r3, [r3, #0]
90014340:	681a      	ldr	r2, [r3, #0]
90014342:	687b      	ldr	r3, [r7, #4]
90014344:	681b      	ldr	r3, [r3, #0]
90014346:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
9001434a:	601a      	str	r2, [r3, #0]

  do
  {
    /* Check for the Timeout */
    if (count == 0U)
9001434c:	68fb      	ldr	r3, [r7, #12]
9001434e:	2b00      	cmp	r3, #0
90014350:	d10a      	bne.n	90014368 <SAI_Disable+0x48>
    {
      /* Update error code */
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
90014352:	687b      	ldr	r3, [r7, #4]
90014354:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
90014358:	f043 0240 	orr.w	r2, r3, #64	; 0x40
9001435c:	687b      	ldr	r3, [r7, #4]
9001435e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
      status = HAL_TIMEOUT;
90014362:	2303      	movs	r3, #3
90014364:	72fb      	strb	r3, [r7, #11]
      break;
90014366:	e009      	b.n	9001437c <SAI_Disable+0x5c>
    }
    count--;
90014368:	68fb      	ldr	r3, [r7, #12]
9001436a:	3b01      	subs	r3, #1
9001436c:	60fb      	str	r3, [r7, #12]
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
9001436e:	687b      	ldr	r3, [r7, #4]
90014370:	681b      	ldr	r3, [r3, #0]
90014372:	681b      	ldr	r3, [r3, #0]
90014374:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
90014378:	2b00      	cmp	r3, #0
9001437a:	d1e7      	bne.n	9001434c <SAI_Disable+0x2c>

  return status;
9001437c:	7afb      	ldrb	r3, [r7, #11]
}
9001437e:	4618      	mov	r0, r3
90014380:	3714      	adds	r7, #20
90014382:	46bd      	mov	sp, r7
90014384:	f85d 7b04 	ldr.w	r7, [sp], #4
90014388:	4770      	bx	lr
9001438a:	bf00      	nop
9001438c:	24000090 	.word	0x24000090
90014390:	95cbec1b 	.word	0x95cbec1b

90014394 <SAI_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
90014394:	b580      	push	{r7, lr}
90014396:	b084      	sub	sp, #16
90014398:	af00      	add	r7, sp, #0
9001439a:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
9001439c:	687b      	ldr	r3, [r7, #4]
9001439e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
900143a0:	60fb      	str	r3, [r7, #12]

  if (hdma->Init.Mode != DMA_CIRCULAR)
900143a2:	687b      	ldr	r3, [r7, #4]
900143a4:	69db      	ldr	r3, [r3, #28]
900143a6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
900143aa:	d01c      	beq.n	900143e6 <SAI_DMATxCplt+0x52>
  {
    hsai->XferCount = 0;
900143ac:	68fb      	ldr	r3, [r7, #12]
900143ae:	2200      	movs	r2, #0
900143b0:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e

    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
900143b4:	68fb      	ldr	r3, [r7, #12]
900143b6:	681b      	ldr	r3, [r3, #0]
900143b8:	681a      	ldr	r2, [r3, #0]
900143ba:	68fb      	ldr	r3, [r7, #12]
900143bc:	681b      	ldr	r3, [r3, #0]
900143be:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
900143c2:	601a      	str	r2, [r3, #0]

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
900143c4:	2100      	movs	r1, #0
900143c6:	68f8      	ldr	r0, [r7, #12]
900143c8:	f7ff ff72 	bl	900142b0 <SAI_InterruptFlag>
900143cc:	4603      	mov	r3, r0
900143ce:	43d9      	mvns	r1, r3
900143d0:	68fb      	ldr	r3, [r7, #12]
900143d2:	681b      	ldr	r3, [r3, #0]
900143d4:	691a      	ldr	r2, [r3, #16]
900143d6:	68fb      	ldr	r3, [r7, #12]
900143d8:	681b      	ldr	r3, [r3, #0]
900143da:	400a      	ands	r2, r1
900143dc:	611a      	str	r2, [r3, #16]

    hsai->State = HAL_SAI_STATE_READY;
900143de:	68fb      	ldr	r3, [r7, #12]
900143e0:	2201      	movs	r2, #1
900143e2:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxCpltCallback(hsai);
#else
  HAL_SAI_TxCpltCallback(hsai);
900143e6:	68f8      	ldr	r0, [r7, #12]
900143e8:	f7f1 fa56 	bl	90005898 <HAL_SAI_TxCpltCallback>
#endif
}
900143ec:	bf00      	nop
900143ee:	3710      	adds	r7, #16
900143f0:	46bd      	mov	sp, r7
900143f2:	bd80      	pop	{r7, pc}

900143f4 <SAI_DMATxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
900143f4:	b580      	push	{r7, lr}
900143f6:	b084      	sub	sp, #16
900143f8:	af00      	add	r7, sp, #0
900143fa:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
900143fc:	687b      	ldr	r3, [r7, #4]
900143fe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90014400:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxHalfCpltCallback(hsai);
#else
  HAL_SAI_TxHalfCpltCallback(hsai);
90014402:	68f8      	ldr	r0, [r7, #12]
90014404:	f7f1 fa53 	bl	900058ae <HAL_SAI_TxHalfCpltCallback>
#endif
}
90014408:	bf00      	nop
9001440a:	3710      	adds	r7, #16
9001440c:	46bd      	mov	sp, r7
9001440e:	bd80      	pop	{r7, pc}

90014410 <SAI_DMARxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)
{
90014410:	b580      	push	{r7, lr}
90014412:	b084      	sub	sp, #16
90014414:	af00      	add	r7, sp, #0
90014416:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
90014418:	687b      	ldr	r3, [r7, #4]
9001441a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9001441c:	60fb      	str	r3, [r7, #12]

  if (hdma->Init.Mode != DMA_CIRCULAR)
9001441e:	687b      	ldr	r3, [r7, #4]
90014420:	69db      	ldr	r3, [r3, #28]
90014422:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
90014426:	d01c      	beq.n	90014462 <SAI_DMARxCplt+0x52>
  {
    /* Disable Rx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
90014428:	68fb      	ldr	r3, [r7, #12]
9001442a:	681b      	ldr	r3, [r3, #0]
9001442c:	681a      	ldr	r2, [r3, #0]
9001442e:	68fb      	ldr	r3, [r7, #12]
90014430:	681b      	ldr	r3, [r3, #0]
90014432:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
90014436:	601a      	str	r2, [r3, #0]
    hsai->XferCount = 0;
90014438:	68fb      	ldr	r3, [r7, #12]
9001443a:	2200      	movs	r2, #0
9001443c:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
90014440:	2100      	movs	r1, #0
90014442:	68f8      	ldr	r0, [r7, #12]
90014444:	f7ff ff34 	bl	900142b0 <SAI_InterruptFlag>
90014448:	4603      	mov	r3, r0
9001444a:	43d9      	mvns	r1, r3
9001444c:	68fb      	ldr	r3, [r7, #12]
9001444e:	681b      	ldr	r3, [r3, #0]
90014450:	691a      	ldr	r2, [r3, #16]
90014452:	68fb      	ldr	r3, [r7, #12]
90014454:	681b      	ldr	r3, [r3, #0]
90014456:	400a      	ands	r2, r1
90014458:	611a      	str	r2, [r3, #16]

    hsai->State = HAL_SAI_STATE_READY;
9001445a:	68fb      	ldr	r3, [r7, #12]
9001445c:	2201      	movs	r2, #1
9001445e:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxCpltCallback(hsai);
#else
  HAL_SAI_RxCpltCallback(hsai);
90014462:	68f8      	ldr	r0, [r7, #12]
90014464:	f7f1 feec 	bl	90006240 <HAL_SAI_RxCpltCallback>
#endif
}
90014468:	bf00      	nop
9001446a:	3710      	adds	r7, #16
9001446c:	46bd      	mov	sp, r7
9001446e:	bd80      	pop	{r7, pc}

90014470 <SAI_DMARxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
90014470:	b580      	push	{r7, lr}
90014472:	b084      	sub	sp, #16
90014474:	af00      	add	r7, sp, #0
90014476:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
90014478:	687b      	ldr	r3, [r7, #4]
9001447a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
9001447c:	60fb      	str	r3, [r7, #12]

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxHalfCpltCallback(hsai);
#else
  HAL_SAI_RxHalfCpltCallback(hsai);
9001447e:	68f8      	ldr	r0, [r7, #12]
90014480:	f7f1 fec8 	bl	90006214 <HAL_SAI_RxHalfCpltCallback>
#endif
}
90014484:	bf00      	nop
90014486:	3710      	adds	r7, #16
90014488:	46bd      	mov	sp, r7
9001448a:	bd80      	pop	{r7, pc}

9001448c <SAI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
9001448c:	b580      	push	{r7, lr}
9001448e:	b084      	sub	sp, #16
90014490:	af00      	add	r7, sp, #0
90014492:	6078      	str	r0, [r7, #4]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
90014494:	687b      	ldr	r3, [r7, #4]
90014496:	6b9b      	ldr	r3, [r3, #56]	; 0x38
90014498:	60fb      	str	r3, [r7, #12]

  /* Ignore DMA FIFO error */
  if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
9001449a:	6878      	ldr	r0, [r7, #4]
9001449c:	f7f7 fb60 	bl	9000bb60 <HAL_DMA_GetError>
900144a0:	4603      	mov	r3, r0
900144a2:	2b02      	cmp	r3, #2
900144a4:	d01d      	beq.n	900144e2 <SAI_DMAError+0x56>
  {
    /* Set SAI error code */
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
900144a6:	68fb      	ldr	r3, [r7, #12]
900144a8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
900144ac:	f043 0280 	orr.w	r2, r3, #128	; 0x80
900144b0:	68fb      	ldr	r3, [r7, #12]
900144b2:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

    /* Disable the SAI DMA request */
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
900144b6:	68fb      	ldr	r3, [r7, #12]
900144b8:	681b      	ldr	r3, [r3, #0]
900144ba:	681a      	ldr	r2, [r3, #0]
900144bc:	68fb      	ldr	r3, [r7, #12]
900144be:	681b      	ldr	r3, [r3, #0]
900144c0:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
900144c4:	601a      	str	r2, [r3, #0]

    /* Disable SAI peripheral */
    /* No need to check return value because state will be updated and HAL_SAI_ErrorCallback will be called later */
    (void) SAI_Disable(hsai);
900144c6:	68f8      	ldr	r0, [r7, #12]
900144c8:	f7ff ff2a 	bl	90014320 <SAI_Disable>

    /* Set the SAI state ready to be able to start again the process */
    hsai->State = HAL_SAI_STATE_READY;
900144cc:	68fb      	ldr	r3, [r7, #12]
900144ce:	2201      	movs	r2, #1
900144d0:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91

    /* Initialize XferCount */
    hsai->XferCount = 0U;
900144d4:	68fb      	ldr	r3, [r7, #12]
900144d6:	2200      	movs	r2, #0
900144d8:	f8a3 207e 	strh.w	r2, [r3, #126]	; 0x7e

    /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
    hsai->ErrorCallback(hsai);
#else
    HAL_SAI_ErrorCallback(hsai);
900144dc:	68f8      	ldr	r0, [r7, #12]
900144de:	f7f1 f9f1 	bl	900058c4 <HAL_SAI_ErrorCallback>
#endif
  }
}
900144e2:	bf00      	nop
900144e4:	3710      	adds	r7, #16
900144e6:	46bd      	mov	sp, r7
900144e8:	bd80      	pop	{r7, pc}
	...

900144ec <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing Pointer to SDRAM control timing structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{
900144ec:	b580      	push	{r7, lr}
900144ee:	b082      	sub	sp, #8
900144f0:	af00      	add	r7, sp, #0
900144f2:	6078      	str	r0, [r7, #4]
900144f4:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if (hsdram == NULL)
900144f6:	687b      	ldr	r3, [r7, #4]
900144f8:	2b00      	cmp	r3, #0
900144fa:	d101      	bne.n	90014500 <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
900144fc:	2301      	movs	r3, #1
900144fe:	e02b      	b.n	90014558 <HAL_SDRAM_Init+0x6c>
  }

  if (hsdram->State == HAL_SDRAM_STATE_RESET)
90014500:	687b      	ldr	r3, [r7, #4]
90014502:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
90014506:	b2db      	uxtb	r3, r3
90014508:	2b00      	cmp	r3, #0
9001450a:	d106      	bne.n	9001451a <HAL_SDRAM_Init+0x2e>
  {
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
9001450c:	687b      	ldr	r3, [r7, #4]
9001450e:	2200      	movs	r2, #0
90014510:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* Init the low level hardware */
    hsdram->MspInitCallback(hsdram);
#else
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
90014514:	6878      	ldr	r0, [r7, #4]
90014516:	f000 f841 	bl	9001459c <HAL_SDRAM_MspInit>
#endif /* USE_HAL_SDRAM_REGISTER_CALLBACKS */
  }

  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
9001451a:	687b      	ldr	r3, [r7, #4]
9001451c:	2202      	movs	r2, #2
9001451e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

  /* Initialize SDRAM control Interface */
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
90014522:	687b      	ldr	r3, [r7, #4]
90014524:	681a      	ldr	r2, [r3, #0]
90014526:	687b      	ldr	r3, [r7, #4]
90014528:	3304      	adds	r3, #4
9001452a:	4619      	mov	r1, r3
9001452c:	4610      	mov	r0, r2
9001452e:	f000 fba1 	bl	90014c74 <FMC_SDRAM_Init>

  /* Initialize SDRAM timing Interface */
  (void)FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
90014532:	687b      	ldr	r3, [r7, #4]
90014534:	6818      	ldr	r0, [r3, #0]
90014536:	687b      	ldr	r3, [r7, #4]
90014538:	685b      	ldr	r3, [r3, #4]
9001453a:	461a      	mov	r2, r3
9001453c:	6839      	ldr	r1, [r7, #0]
9001453e:	f000 fbf5 	bl	90014d2c <FMC_SDRAM_Timing_Init>

  /* Enable FMC Peripheral */
  __FMC_ENABLE();
90014542:	4b07      	ldr	r3, [pc, #28]	; (90014560 <HAL_SDRAM_Init+0x74>)
90014544:	681b      	ldr	r3, [r3, #0]
90014546:	4a06      	ldr	r2, [pc, #24]	; (90014560 <HAL_SDRAM_Init+0x74>)
90014548:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
9001454c:	6013      	str	r3, [r2, #0]
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
9001454e:	687b      	ldr	r3, [r7, #4]
90014550:	2201      	movs	r2, #1
90014552:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

  return HAL_OK;
90014556:	2300      	movs	r3, #0
}
90014558:	4618      	mov	r0, r3
9001455a:	3708      	adds	r7, #8
9001455c:	46bd      	mov	sp, r7
9001455e:	bd80      	pop	{r7, pc}
90014560:	52004000 	.word	0x52004000

90014564 <HAL_SDRAM_DeInit>:
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_DeInit(SDRAM_HandleTypeDef *hsdram)
{
90014564:	b580      	push	{r7, lr}
90014566:	b082      	sub	sp, #8
90014568:	af00      	add	r7, sp, #0
9001456a:	6078      	str	r0, [r7, #4]

  /* DeInit the low level hardware */
  hsdram->MspDeInitCallback(hsdram);
#else
  /* Initialize the low level hardware (MSP) */
  HAL_SDRAM_MspDeInit(hsdram);
9001456c:	6878      	ldr	r0, [r7, #4]
9001456e:	f000 f81f 	bl	900145b0 <HAL_SDRAM_MspDeInit>
#endif /* USE_HAL_SDRAM_REGISTER_CALLBACKS */

  /* Configure the SDRAM registers with their reset values */
  (void)FMC_SDRAM_DeInit(hsdram->Instance, hsdram->Init.SDBank);
90014572:	687b      	ldr	r3, [r7, #4]
90014574:	681a      	ldr	r2, [r3, #0]
90014576:	687b      	ldr	r3, [r7, #4]
90014578:	685b      	ldr	r3, [r3, #4]
9001457a:	4619      	mov	r1, r3
9001457c:	4610      	mov	r0, r2
9001457e:	f000 fc3f 	bl	90014e00 <FMC_SDRAM_DeInit>

  /* Reset the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_RESET;
90014582:	687b      	ldr	r3, [r7, #4]
90014584:	2200      	movs	r2, #0
90014586:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

  /* Release Lock */
  __HAL_UNLOCK(hsdram);
9001458a:	687b      	ldr	r3, [r7, #4]
9001458c:	2200      	movs	r2, #0
9001458e:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

  return HAL_OK;
90014592:	2300      	movs	r3, #0
}
90014594:	4618      	mov	r0, r3
90014596:	3708      	adds	r7, #8
90014598:	46bd      	mov	sp, r7
9001459a:	bd80      	pop	{r7, pc}

9001459c <HAL_SDRAM_MspInit>:
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  */
__weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
{
9001459c:	b480      	push	{r7}
9001459e:	b083      	sub	sp, #12
900145a0:	af00      	add	r7, sp, #0
900145a2:	6078      	str	r0, [r7, #4]
  UNUSED(hsdram);

  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */
}
900145a4:	bf00      	nop
900145a6:	370c      	adds	r7, #12
900145a8:	46bd      	mov	sp, r7
900145aa:	f85d 7b04 	ldr.w	r7, [sp], #4
900145ae:	4770      	bx	lr

900145b0 <HAL_SDRAM_MspDeInit>:
  * @param  hsdram pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  */
__weak void HAL_SDRAM_MspDeInit(SDRAM_HandleTypeDef *hsdram)
{
900145b0:	b480      	push	{r7}
900145b2:	b083      	sub	sp, #12
900145b4:	af00      	add	r7, sp, #0
900145b6:	6078      	str	r0, [r7, #4]
  UNUSED(hsdram);

  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspDeInit could be implemented in the user file
   */
}
900145b8:	bf00      	nop
900145ba:	370c      	adds	r7, #12
900145bc:	46bd      	mov	sp, r7
900145be:	f85d 7b04 	ldr.w	r7, [sp], #4
900145c2:	4770      	bx	lr

900145c4 <HAL_SDRAM_DMA_XferCpltCallback>:
  * @param  hmdma pointer to a DMA_HandleTypeDef structure that contains
  *                the configuration information for the specified DMA module.
  * @retval None
  */
__weak void HAL_SDRAM_DMA_XferCpltCallback(MDMA_HandleTypeDef *hmdma)
{
900145c4:	b480      	push	{r7}
900145c6:	b083      	sub	sp, #12
900145c8:	af00      	add	r7, sp, #0
900145ca:	6078      	str	r0, [r7, #4]
  UNUSED(hmdma);

  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_DMA_XferCpltCallback could be implemented in the user file
   */
}
900145cc:	bf00      	nop
900145ce:	370c      	adds	r7, #12
900145d0:	46bd      	mov	sp, r7
900145d2:	f85d 7b04 	ldr.w	r7, [sp], #4
900145d6:	4770      	bx	lr

900145d8 <HAL_SDRAM_DMA_XferErrorCallback>:
  * @brief  DMA transfer complete error callback.
  * @param  hmdma DMA handle
  * @retval None
  */
__weak void HAL_SDRAM_DMA_XferErrorCallback(MDMA_HandleTypeDef *hmdma)
{
900145d8:	b480      	push	{r7}
900145da:	b083      	sub	sp, #12
900145dc:	af00      	add	r7, sp, #0
900145de:	6078      	str	r0, [r7, #4]
  UNUSED(hmdma);

  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_DMA_XferErrorCallback could be implemented in the user file
   */
}
900145e0:	bf00      	nop
900145e2:	370c      	adds	r7, #12
900145e4:	46bd      	mov	sp, r7
900145e6:	f85d 7b04 	ldr.w	r7, [sp], #4
900145ea:	4770      	bx	lr

900145ec <HAL_SDRAM_Read_32b>:
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Read_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer,
                                     uint32_t BufferSize)
{
900145ec:	b480      	push	{r7}
900145ee:	b089      	sub	sp, #36	; 0x24
900145f0:	af00      	add	r7, sp, #0
900145f2:	60f8      	str	r0, [r7, #12]
900145f4:	60b9      	str	r1, [r7, #8]
900145f6:	607a      	str	r2, [r7, #4]
900145f8:	603b      	str	r3, [r7, #0]
  uint32_t size;
  __IO uint32_t *pSdramAddress = (uint32_t *)pAddress;
900145fa:	68bb      	ldr	r3, [r7, #8]
900145fc:	61bb      	str	r3, [r7, #24]
  uint32_t *pdestbuff = pDstBuffer;
900145fe:	687b      	ldr	r3, [r7, #4]
90014600:	617b      	str	r3, [r7, #20]
  HAL_SDRAM_StateTypeDef state = hsdram->State;
90014602:	68fb      	ldr	r3, [r7, #12]
90014604:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
90014608:	74fb      	strb	r3, [r7, #19]

  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
9001460a:	7cfb      	ldrb	r3, [r7, #19]
9001460c:	2b02      	cmp	r3, #2
9001460e:	d101      	bne.n	90014614 <HAL_SDRAM_Read_32b+0x28>
  {
    return HAL_BUSY;
90014610:	2302      	movs	r3, #2
90014612:	e032      	b.n	9001467a <HAL_SDRAM_Read_32b+0x8e>
  }
  else if ((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_WRITE_PROTECTED))
90014614:	7cfb      	ldrb	r3, [r7, #19]
90014616:	2b01      	cmp	r3, #1
90014618:	d002      	beq.n	90014620 <HAL_SDRAM_Read_32b+0x34>
9001461a:	7cfb      	ldrb	r3, [r7, #19]
9001461c:	2b04      	cmp	r3, #4
9001461e:	d12b      	bne.n	90014678 <HAL_SDRAM_Read_32b+0x8c>
  {
    /* Process Locked */
    __HAL_LOCK(hsdram);
90014620:	68fb      	ldr	r3, [r7, #12]
90014622:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
90014626:	2b01      	cmp	r3, #1
90014628:	d101      	bne.n	9001462e <HAL_SDRAM_Read_32b+0x42>
9001462a:	2302      	movs	r3, #2
9001462c:	e025      	b.n	9001467a <HAL_SDRAM_Read_32b+0x8e>
9001462e:	68fb      	ldr	r3, [r7, #12]
90014630:	2201      	movs	r2, #1
90014632:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* Update the SDRAM controller state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
90014636:	68fb      	ldr	r3, [r7, #12]
90014638:	2202      	movs	r2, #2
9001463a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* Read data from source */
    for (size = BufferSize; size != 0U; size--)
9001463e:	683b      	ldr	r3, [r7, #0]
90014640:	61fb      	str	r3, [r7, #28]
90014642:	e00c      	b.n	9001465e <HAL_SDRAM_Read_32b+0x72>
    {
      *pdestbuff = *(__IO uint32_t *)pSdramAddress;
90014644:	69bb      	ldr	r3, [r7, #24]
90014646:	681a      	ldr	r2, [r3, #0]
90014648:	697b      	ldr	r3, [r7, #20]
9001464a:	601a      	str	r2, [r3, #0]
      pdestbuff++;
9001464c:	697b      	ldr	r3, [r7, #20]
9001464e:	3304      	adds	r3, #4
90014650:	617b      	str	r3, [r7, #20]
      pSdramAddress++;
90014652:	69bb      	ldr	r3, [r7, #24]
90014654:	3304      	adds	r3, #4
90014656:	61bb      	str	r3, [r7, #24]
    for (size = BufferSize; size != 0U; size--)
90014658:	69fb      	ldr	r3, [r7, #28]
9001465a:	3b01      	subs	r3, #1
9001465c:	61fb      	str	r3, [r7, #28]
9001465e:	69fb      	ldr	r3, [r7, #28]
90014660:	2b00      	cmp	r3, #0
90014662:	d1ef      	bne.n	90014644 <HAL_SDRAM_Read_32b+0x58>
    }

    /* Update the SDRAM controller state */
    hsdram->State = state;
90014664:	68fb      	ldr	r3, [r7, #12]
90014666:	7cfa      	ldrb	r2, [r7, #19]
90014668:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* Process Unlocked */
    __HAL_UNLOCK(hsdram);
9001466c:	68fb      	ldr	r3, [r7, #12]
9001466e:	2200      	movs	r2, #0
90014670:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  else
  {
    return  HAL_ERROR;
  }

  return HAL_OK;
90014674:	2300      	movs	r3, #0
90014676:	e000      	b.n	9001467a <HAL_SDRAM_Read_32b+0x8e>
    return  HAL_ERROR;
90014678:	2301      	movs	r3, #1
}
9001467a:	4618      	mov	r0, r3
9001467c:	3724      	adds	r7, #36	; 0x24
9001467e:	46bd      	mov	sp, r7
90014680:	f85d 7b04 	ldr.w	r7, [sp], #4
90014684:	4770      	bx	lr

90014686 <HAL_SDRAM_Write_32b>:
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Write_32b(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer,
                                      uint32_t BufferSize)
{
90014686:	b480      	push	{r7}
90014688:	b089      	sub	sp, #36	; 0x24
9001468a:	af00      	add	r7, sp, #0
9001468c:	60f8      	str	r0, [r7, #12]
9001468e:	60b9      	str	r1, [r7, #8]
90014690:	607a      	str	r2, [r7, #4]
90014692:	603b      	str	r3, [r7, #0]
  uint32_t size;
  __IO uint32_t *pSdramAddress = pAddress;
90014694:	68bb      	ldr	r3, [r7, #8]
90014696:	61bb      	str	r3, [r7, #24]
  uint32_t *psrcbuff = pSrcBuffer;
90014698:	687b      	ldr	r3, [r7, #4]
9001469a:	617b      	str	r3, [r7, #20]

  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
9001469c:	68fb      	ldr	r3, [r7, #12]
9001469e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
900146a2:	b2db      	uxtb	r3, r3
900146a4:	2b02      	cmp	r3, #2
900146a6:	d101      	bne.n	900146ac <HAL_SDRAM_Write_32b+0x26>
  {
    return HAL_BUSY;
900146a8:	2302      	movs	r3, #2
900146aa:	e032      	b.n	90014712 <HAL_SDRAM_Write_32b+0x8c>
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
900146ac:	68fb      	ldr	r3, [r7, #12]
900146ae:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
900146b2:	b2db      	uxtb	r3, r3
900146b4:	2b01      	cmp	r3, #1
900146b6:	d12b      	bne.n	90014710 <HAL_SDRAM_Write_32b+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hsdram);
900146b8:	68fb      	ldr	r3, [r7, #12]
900146ba:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
900146be:	2b01      	cmp	r3, #1
900146c0:	d101      	bne.n	900146c6 <HAL_SDRAM_Write_32b+0x40>
900146c2:	2302      	movs	r3, #2
900146c4:	e025      	b.n	90014712 <HAL_SDRAM_Write_32b+0x8c>
900146c6:	68fb      	ldr	r3, [r7, #12]
900146c8:	2201      	movs	r2, #1
900146ca:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* Update the SDRAM controller state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
900146ce:	68fb      	ldr	r3, [r7, #12]
900146d0:	2202      	movs	r2, #2
900146d2:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* Write data to memory */
    for (size = BufferSize; size != 0U; size--)
900146d6:	683b      	ldr	r3, [r7, #0]
900146d8:	61fb      	str	r3, [r7, #28]
900146da:	e00c      	b.n	900146f6 <HAL_SDRAM_Write_32b+0x70>
    {
      *pSdramAddress = *psrcbuff;
900146dc:	697b      	ldr	r3, [r7, #20]
900146de:	681a      	ldr	r2, [r3, #0]
900146e0:	69bb      	ldr	r3, [r7, #24]
900146e2:	601a      	str	r2, [r3, #0]
      psrcbuff++;
900146e4:	697b      	ldr	r3, [r7, #20]
900146e6:	3304      	adds	r3, #4
900146e8:	617b      	str	r3, [r7, #20]
      pSdramAddress++;
900146ea:	69bb      	ldr	r3, [r7, #24]
900146ec:	3304      	adds	r3, #4
900146ee:	61bb      	str	r3, [r7, #24]
    for (size = BufferSize; size != 0U; size--)
900146f0:	69fb      	ldr	r3, [r7, #28]
900146f2:	3b01      	subs	r3, #1
900146f4:	61fb      	str	r3, [r7, #28]
900146f6:	69fb      	ldr	r3, [r7, #28]
900146f8:	2b00      	cmp	r3, #0
900146fa:	d1ef      	bne.n	900146dc <HAL_SDRAM_Write_32b+0x56>
    }

    /* Update the SDRAM controller state */
    hsdram->State = HAL_SDRAM_STATE_READY;
900146fc:	68fb      	ldr	r3, [r7, #12]
900146fe:	2201      	movs	r2, #1
90014700:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* Process Unlocked */
    __HAL_UNLOCK(hsdram);
90014704:	68fb      	ldr	r3, [r7, #12]
90014706:	2200      	movs	r2, #0
90014708:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
  else
  {
    return  HAL_ERROR;
  }

  return HAL_OK;
9001470c:	2300      	movs	r3, #0
9001470e:	e000      	b.n	90014712 <HAL_SDRAM_Write_32b+0x8c>
    return  HAL_ERROR;
90014710:	2301      	movs	r3, #1
}
90014712:	4618      	mov	r0, r3
90014714:	3724      	adds	r7, #36	; 0x24
90014716:	46bd      	mov	sp, r7
90014718:	f85d 7b04 	ldr.w	r7, [sp], #4
9001471c:	4770      	bx	lr
	...

90014720 <HAL_SDRAM_Read_DMA>:
  * @param  BufferSize Size of the buffer to read from memory
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Read_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pDstBuffer,
                                     uint32_t BufferSize)
{
90014720:	b590      	push	{r4, r7, lr}
90014722:	b089      	sub	sp, #36	; 0x24
90014724:	af02      	add	r7, sp, #8
90014726:	60f8      	str	r0, [r7, #12]
90014728:	60b9      	str	r1, [r7, #8]
9001472a:	607a      	str	r2, [r7, #4]
9001472c:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;
  HAL_SDRAM_StateTypeDef state = hsdram->State;
9001472e:	68fb      	ldr	r3, [r7, #12]
90014730:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
90014734:	75bb      	strb	r3, [r7, #22]

  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
90014736:	7dbb      	ldrb	r3, [r7, #22]
90014738:	2b02      	cmp	r3, #2
9001473a:	d102      	bne.n	90014742 <HAL_SDRAM_Read_DMA+0x22>
  {
    status = HAL_BUSY;
9001473c:	2302      	movs	r3, #2
9001473e:	75fb      	strb	r3, [r7, #23]
90014740:	e037      	b.n	900147b2 <HAL_SDRAM_Read_DMA+0x92>
  }
  else if ((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_WRITE_PROTECTED))
90014742:	7dbb      	ldrb	r3, [r7, #22]
90014744:	2b01      	cmp	r3, #1
90014746:	d002      	beq.n	9001474e <HAL_SDRAM_Read_DMA+0x2e>
90014748:	7dbb      	ldrb	r3, [r7, #22]
9001474a:	2b04      	cmp	r3, #4
9001474c:	d12f      	bne.n	900147ae <HAL_SDRAM_Read_DMA+0x8e>
  {
    /* Process Locked */
    __HAL_LOCK(hsdram);
9001474e:	68fb      	ldr	r3, [r7, #12]
90014750:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
90014754:	2b01      	cmp	r3, #1
90014756:	d101      	bne.n	9001475c <HAL_SDRAM_Read_DMA+0x3c>
90014758:	2302      	movs	r3, #2
9001475a:	e02b      	b.n	900147b4 <HAL_SDRAM_Read_DMA+0x94>
9001475c:	68fb      	ldr	r3, [r7, #12]
9001475e:	2201      	movs	r2, #1
90014760:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* Update the SDRAM controller state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
90014764:	68fb      	ldr	r3, [r7, #12]
90014766:	2202      	movs	r2, #2
90014768:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* Configure DMA user callbacks */
    if (state == HAL_SDRAM_STATE_READY)
9001476c:	7dbb      	ldrb	r3, [r7, #22]
9001476e:	2b01      	cmp	r3, #1
90014770:	d104      	bne.n	9001477c <HAL_SDRAM_Read_DMA+0x5c>
    {
      hsdram->hmdma->XferCpltCallback = SDRAM_DMACplt;
90014772:	68fb      	ldr	r3, [r7, #12]
90014774:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90014776:	4a11      	ldr	r2, [pc, #68]	; (900147bc <HAL_SDRAM_Read_DMA+0x9c>)
90014778:	645a      	str	r2, [r3, #68]	; 0x44
9001477a:	e003      	b.n	90014784 <HAL_SDRAM_Read_DMA+0x64>
    }
    else
    {
      hsdram->hmdma->XferCpltCallback = SDRAM_DMACpltProt;
9001477c:	68fb      	ldr	r3, [r7, #12]
9001477e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90014780:	4a0f      	ldr	r2, [pc, #60]	; (900147c0 <HAL_SDRAM_Read_DMA+0xa0>)
90014782:	645a      	str	r2, [r3, #68]	; 0x44
    }
    hsdram->hmdma->XferErrorCallback = SDRAM_DMAError;
90014784:	68fb      	ldr	r3, [r7, #12]
90014786:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90014788:	4a0e      	ldr	r2, [pc, #56]	; (900147c4 <HAL_SDRAM_Read_DMA+0xa4>)
9001478a:	655a      	str	r2, [r3, #84]	; 0x54

    /* Enable the DMA Stream */
    status = HAL_MDMA_Start_IT(hsdram->hmdma, (uint32_t)pAddress, (uint32_t)pDstBuffer, (uint32_t)(BufferSize * 4U), 1);
9001478c:	68fb      	ldr	r3, [r7, #12]
9001478e:	6b18      	ldr	r0, [r3, #48]	; 0x30
90014790:	68b9      	ldr	r1, [r7, #8]
90014792:	687a      	ldr	r2, [r7, #4]
90014794:	683b      	ldr	r3, [r7, #0]
90014796:	009b      	lsls	r3, r3, #2
90014798:	2401      	movs	r4, #1
9001479a:	9400      	str	r4, [sp, #0]
9001479c:	f7f9 ff22 	bl	9000e5e4 <HAL_MDMA_Start_IT>
900147a0:	4603      	mov	r3, r0
900147a2:	75fb      	strb	r3, [r7, #23]

    /* Process Unlocked */
    __HAL_UNLOCK(hsdram);
900147a4:	68fb      	ldr	r3, [r7, #12]
900147a6:	2200      	movs	r2, #0
900147a8:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
900147ac:	e001      	b.n	900147b2 <HAL_SDRAM_Read_DMA+0x92>
  }
  else
  {
    status = HAL_ERROR;
900147ae:	2301      	movs	r3, #1
900147b0:	75fb      	strb	r3, [r7, #23]
  }

  return status;
900147b2:	7dfb      	ldrb	r3, [r7, #23]
}
900147b4:	4618      	mov	r0, r3
900147b6:	371c      	adds	r7, #28
900147b8:	46bd      	mov	sp, r7
900147ba:	bd90      	pop	{r4, r7, pc}
900147bc:	90014917 	.word	0x90014917
900147c0:	9001494b 	.word	0x9001494b
900147c4:	9001497f 	.word	0x9001497f

900147c8 <HAL_SDRAM_Write_DMA>:
  * @param  BufferSize Size of the buffer to write to memory
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Write_DMA(SDRAM_HandleTypeDef *hsdram, uint32_t *pAddress, uint32_t *pSrcBuffer,
                                      uint32_t BufferSize)
{
900147c8:	b590      	push	{r4, r7, lr}
900147ca:	b089      	sub	sp, #36	; 0x24
900147cc:	af02      	add	r7, sp, #8
900147ce:	60f8      	str	r0, [r7, #12]
900147d0:	60b9      	str	r1, [r7, #8]
900147d2:	607a      	str	r2, [r7, #4]
900147d4:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status;

  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
900147d6:	68fb      	ldr	r3, [r7, #12]
900147d8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
900147dc:	b2db      	uxtb	r3, r3
900147de:	2b02      	cmp	r3, #2
900147e0:	d102      	bne.n	900147e8 <HAL_SDRAM_Write_DMA+0x20>
  {
    status = HAL_BUSY;
900147e2:	2302      	movs	r3, #2
900147e4:	75fb      	strb	r3, [r7, #23]
900147e6:	e02f      	b.n	90014848 <HAL_SDRAM_Write_DMA+0x80>
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
900147e8:	68fb      	ldr	r3, [r7, #12]
900147ea:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
900147ee:	b2db      	uxtb	r3, r3
900147f0:	2b01      	cmp	r3, #1
900147f2:	d127      	bne.n	90014844 <HAL_SDRAM_Write_DMA+0x7c>
  {
    /* Process Locked */
    __HAL_LOCK(hsdram);
900147f4:	68fb      	ldr	r3, [r7, #12]
900147f6:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
900147fa:	2b01      	cmp	r3, #1
900147fc:	d101      	bne.n	90014802 <HAL_SDRAM_Write_DMA+0x3a>
900147fe:	2302      	movs	r3, #2
90014800:	e023      	b.n	9001484a <HAL_SDRAM_Write_DMA+0x82>
90014802:	68fb      	ldr	r3, [r7, #12]
90014804:	2201      	movs	r2, #1
90014806:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* Update the SDRAM controller state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
9001480a:	68fb      	ldr	r3, [r7, #12]
9001480c:	2202      	movs	r2, #2
9001480e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* Configure DMA user callbacks */
    hsdram->hmdma->XferCpltCallback = SDRAM_DMACplt;
90014812:	68fb      	ldr	r3, [r7, #12]
90014814:	6b1b      	ldr	r3, [r3, #48]	; 0x30
90014816:	4a0f      	ldr	r2, [pc, #60]	; (90014854 <HAL_SDRAM_Write_DMA+0x8c>)
90014818:	645a      	str	r2, [r3, #68]	; 0x44
    hsdram->hmdma->XferErrorCallback = SDRAM_DMAError;
9001481a:	68fb      	ldr	r3, [r7, #12]
9001481c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
9001481e:	4a0e      	ldr	r2, [pc, #56]	; (90014858 <HAL_SDRAM_Write_DMA+0x90>)
90014820:	655a      	str	r2, [r3, #84]	; 0x54

    /* Enable the DMA Stream */
    status = HAL_MDMA_Start_IT(hsdram->hmdma, (uint32_t)pSrcBuffer, (uint32_t)pAddress, (uint32_t)(BufferSize * 4U), 1);
90014822:	68fb      	ldr	r3, [r7, #12]
90014824:	6b18      	ldr	r0, [r3, #48]	; 0x30
90014826:	6879      	ldr	r1, [r7, #4]
90014828:	68ba      	ldr	r2, [r7, #8]
9001482a:	683b      	ldr	r3, [r7, #0]
9001482c:	009b      	lsls	r3, r3, #2
9001482e:	2401      	movs	r4, #1
90014830:	9400      	str	r4, [sp, #0]
90014832:	f7f9 fed7 	bl	9000e5e4 <HAL_MDMA_Start_IT>
90014836:	4603      	mov	r3, r0
90014838:	75fb      	strb	r3, [r7, #23]

    /* Process Unlocked */
    __HAL_UNLOCK(hsdram);
9001483a:	68fb      	ldr	r3, [r7, #12]
9001483c:	2200      	movs	r2, #0
9001483e:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
90014842:	e001      	b.n	90014848 <HAL_SDRAM_Write_DMA+0x80>
  }
  else
  {
    status = HAL_ERROR;
90014844:	2301      	movs	r3, #1
90014846:	75fb      	strb	r3, [r7, #23]
  }

  return status;
90014848:	7dfb      	ldrb	r3, [r7, #23]
}
9001484a:	4618      	mov	r0, r3
9001484c:	371c      	adds	r7, #28
9001484e:	46bd      	mov	sp, r7
90014850:	bd90      	pop	{r4, r7, pc}
90014852:	bf00      	nop
90014854:	90014917 	.word	0x90014917
90014858:	9001497f 	.word	0x9001497f

9001485c <HAL_SDRAM_SendCommand>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command,
                                        uint32_t Timeout)
{
9001485c:	b580      	push	{r7, lr}
9001485e:	b086      	sub	sp, #24
90014860:	af00      	add	r7, sp, #0
90014862:	60f8      	str	r0, [r7, #12]
90014864:	60b9      	str	r1, [r7, #8]
90014866:	607a      	str	r2, [r7, #4]
  HAL_SDRAM_StateTypeDef state = hsdram->State;
90014868:	68fb      	ldr	r3, [r7, #12]
9001486a:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
9001486e:	75fb      	strb	r3, [r7, #23]

  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
90014870:	7dfb      	ldrb	r3, [r7, #23]
90014872:	2b02      	cmp	r3, #2
90014874:	d101      	bne.n	9001487a <HAL_SDRAM_SendCommand+0x1e>
  {
    return HAL_BUSY;
90014876:	2302      	movs	r3, #2
90014878:	e021      	b.n	900148be <HAL_SDRAM_SendCommand+0x62>
  }
  else if ((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_PRECHARGED))
9001487a:	7dfb      	ldrb	r3, [r7, #23]
9001487c:	2b01      	cmp	r3, #1
9001487e:	d002      	beq.n	90014886 <HAL_SDRAM_SendCommand+0x2a>
90014880:	7dfb      	ldrb	r3, [r7, #23]
90014882:	2b05      	cmp	r3, #5
90014884:	d118      	bne.n	900148b8 <HAL_SDRAM_SendCommand+0x5c>
  {
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
90014886:	68fb      	ldr	r3, [r7, #12]
90014888:	2202      	movs	r2, #2
9001488a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* Send SDRAM command */
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
9001488e:	68fb      	ldr	r3, [r7, #12]
90014890:	681b      	ldr	r3, [r3, #0]
90014892:	687a      	ldr	r2, [r7, #4]
90014894:	68b9      	ldr	r1, [r7, #8]
90014896:	4618      	mov	r0, r3
90014898:	f000 fad4 	bl	90014e44 <FMC_SDRAM_SendCommand>

    /* Update the SDRAM controller state state */
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
9001489c:	68bb      	ldr	r3, [r7, #8]
9001489e:	681b      	ldr	r3, [r3, #0]
900148a0:	2b02      	cmp	r3, #2
900148a2:	d104      	bne.n	900148ae <HAL_SDRAM_SendCommand+0x52>
    {
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
900148a4:	68fb      	ldr	r3, [r7, #12]
900148a6:	2205      	movs	r2, #5
900148a8:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
900148ac:	e006      	b.n	900148bc <HAL_SDRAM_SendCommand+0x60>
    }
    else
    {
      hsdram->State = HAL_SDRAM_STATE_READY;
900148ae:	68fb      	ldr	r3, [r7, #12]
900148b0:	2201      	movs	r2, #1
900148b2:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
900148b6:	e001      	b.n	900148bc <HAL_SDRAM_SendCommand+0x60>
    }
  }
  else
  {
    return HAL_ERROR;
900148b8:	2301      	movs	r3, #1
900148ba:	e000      	b.n	900148be <HAL_SDRAM_SendCommand+0x62>
  }

  return HAL_OK;
900148bc:	2300      	movs	r3, #0
}
900148be:	4618      	mov	r0, r3
900148c0:	3718      	adds	r7, #24
900148c2:	46bd      	mov	sp, r7
900148c4:	bd80      	pop	{r7, pc}

900148c6 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
900148c6:	b580      	push	{r7, lr}
900148c8:	b082      	sub	sp, #8
900148ca:	af00      	add	r7, sp, #0
900148cc:	6078      	str	r0, [r7, #4]
900148ce:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
900148d0:	687b      	ldr	r3, [r7, #4]
900148d2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
900148d6:	b2db      	uxtb	r3, r3
900148d8:	2b02      	cmp	r3, #2
900148da:	d101      	bne.n	900148e0 <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
900148dc:	2302      	movs	r3, #2
900148de:	e016      	b.n	9001490e <HAL_SDRAM_ProgramRefreshRate+0x48>
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
900148e0:	687b      	ldr	r3, [r7, #4]
900148e2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
900148e6:	b2db      	uxtb	r3, r3
900148e8:	2b01      	cmp	r3, #1
900148ea:	d10f      	bne.n	9001490c <HAL_SDRAM_ProgramRefreshRate+0x46>
  {
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_BUSY;
900148ec:	687b      	ldr	r3, [r7, #4]
900148ee:	2202      	movs	r2, #2
900148f0:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* Program the refresh rate */
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
900148f4:	687b      	ldr	r3, [r7, #4]
900148f6:	681b      	ldr	r3, [r3, #0]
900148f8:	6839      	ldr	r1, [r7, #0]
900148fa:	4618      	mov	r0, r3
900148fc:	f000 fac6 	bl	90014e8c <FMC_SDRAM_ProgramRefreshRate>

    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_READY;
90014900:	687b      	ldr	r3, [r7, #4]
90014902:	2201      	movs	r2, #1
90014904:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
90014908:	2300      	movs	r3, #0
9001490a:	e000      	b.n	9001490e <HAL_SDRAM_ProgramRefreshRate+0x48>
    return HAL_ERROR;
9001490c:	2301      	movs	r3, #1
}
9001490e:	4618      	mov	r0, r3
90014910:	3708      	adds	r7, #8
90014912:	46bd      	mov	sp, r7
90014914:	bd80      	pop	{r7, pc}

90014916 <SDRAM_DMACplt>:
  * @brief  MDMA SDRAM process complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void SDRAM_DMACplt(MDMA_HandleTypeDef *hmdma)
{
90014916:	b580      	push	{r7, lr}
90014918:	b084      	sub	sp, #16
9001491a:	af00      	add	r7, sp, #0
9001491c:	6078      	str	r0, [r7, #4]
  SDRAM_HandleTypeDef *hsdram = (SDRAM_HandleTypeDef *)(hmdma->Parent);
9001491e:	687b      	ldr	r3, [r7, #4]
90014920:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90014922:	60fb      	str	r3, [r7, #12]

  /* Disable the MDMA channel */
  __HAL_MDMA_DISABLE(hmdma);
90014924:	687b      	ldr	r3, [r7, #4]
90014926:	681b      	ldr	r3, [r3, #0]
90014928:	68da      	ldr	r2, [r3, #12]
9001492a:	687b      	ldr	r3, [r7, #4]
9001492c:	681b      	ldr	r3, [r3, #0]
9001492e:	f022 0201 	bic.w	r2, r2, #1
90014932:	60da      	str	r2, [r3, #12]

  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
90014934:	68fb      	ldr	r3, [r7, #12]
90014936:	2201      	movs	r2, #1
90014938:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

#if (USE_HAL_SDRAM_REGISTER_CALLBACKS == 1)
  hsdram->DmaXferCpltCallback(hmdma);
#else
  HAL_SDRAM_DMA_XferCpltCallback(hmdma);
9001493c:	6878      	ldr	r0, [r7, #4]
9001493e:	f7ff fe41 	bl	900145c4 <HAL_SDRAM_DMA_XferCpltCallback>
#endif /* USE_HAL_SDRAM_REGISTER_CALLBACKS */
}
90014942:	bf00      	nop
90014944:	3710      	adds	r7, #16
90014946:	46bd      	mov	sp, r7
90014948:	bd80      	pop	{r7, pc}

9001494a <SDRAM_DMACpltProt>:
  * @brief  MDMA SRAM process complete callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void SDRAM_DMACpltProt(MDMA_HandleTypeDef *hmdma)
{
9001494a:	b580      	push	{r7, lr}
9001494c:	b084      	sub	sp, #16
9001494e:	af00      	add	r7, sp, #0
90014950:	6078      	str	r0, [r7, #4]
  SDRAM_HandleTypeDef *hsdram = (SDRAM_HandleTypeDef *)(hmdma->Parent);
90014952:	687b      	ldr	r3, [r7, #4]
90014954:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90014956:	60fb      	str	r3, [r7, #12]

  /* Disable the MDMA channel */
  __HAL_MDMA_DISABLE(hmdma);
90014958:	687b      	ldr	r3, [r7, #4]
9001495a:	681b      	ldr	r3, [r3, #0]
9001495c:	68da      	ldr	r2, [r3, #12]
9001495e:	687b      	ldr	r3, [r7, #4]
90014960:	681b      	ldr	r3, [r3, #0]
90014962:	f022 0201 	bic.w	r2, r2, #1
90014966:	60da      	str	r2, [r3, #12]

  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_WRITE_PROTECTED;
90014968:	68fb      	ldr	r3, [r7, #12]
9001496a:	2204      	movs	r2, #4
9001496c:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

#if (USE_HAL_SDRAM_REGISTER_CALLBACKS == 1)
  hsdram->DmaXferCpltCallback(hmdma);
#else
  HAL_SDRAM_DMA_XferCpltCallback(hmdma);
90014970:	6878      	ldr	r0, [r7, #4]
90014972:	f7ff fe27 	bl	900145c4 <HAL_SDRAM_DMA_XferCpltCallback>
#endif /* USE_HAL_SDRAM_REGISTER_CALLBACKS */
}
90014976:	bf00      	nop
90014978:	3710      	adds	r7, #16
9001497a:	46bd      	mov	sp, r7
9001497c:	bd80      	pop	{r7, pc}

9001497e <SDRAM_DMAError>:
  * @brief  MDMA SDRAM error callback.
  * @param  hmdma : MDMA handle
  * @retval None
  */
static void SDRAM_DMAError(MDMA_HandleTypeDef *hmdma)
{
9001497e:	b580      	push	{r7, lr}
90014980:	b084      	sub	sp, #16
90014982:	af00      	add	r7, sp, #0
90014984:	6078      	str	r0, [r7, #4]
  SDRAM_HandleTypeDef *hsdram = (SDRAM_HandleTypeDef *)(hmdma->Parent);
90014986:	687b      	ldr	r3, [r7, #4]
90014988:	6c1b      	ldr	r3, [r3, #64]	; 0x40
9001498a:	60fb      	str	r3, [r7, #12]

  /* Disable the MDMA channel */
  __HAL_MDMA_DISABLE(hmdma);
9001498c:	687b      	ldr	r3, [r7, #4]
9001498e:	681b      	ldr	r3, [r3, #0]
90014990:	68da      	ldr	r2, [r3, #12]
90014992:	687b      	ldr	r3, [r7, #4]
90014994:	681b      	ldr	r3, [r3, #0]
90014996:	f022 0201 	bic.w	r2, r2, #1
9001499a:	60da      	str	r2, [r3, #12]

  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_ERROR;
9001499c:	68fb      	ldr	r3, [r7, #12]
9001499e:	2203      	movs	r2, #3
900149a0:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

#if (USE_HAL_SDRAM_REGISTER_CALLBACKS == 1)
  hsdram->DmaXferErrorCallback(hmdma);
#else
  HAL_SDRAM_DMA_XferErrorCallback(hmdma);
900149a4:	6878      	ldr	r0, [r7, #4]
900149a6:	f7ff fe17 	bl	900145d8 <HAL_SDRAM_DMA_XferErrorCallback>
#endif /* USE_HAL_SDRAM_REGISTER_CALLBACKS */
}
900149aa:	bf00      	nop
900149ac:	3710      	adds	r7, #16
900149ae:	46bd      	mov	sp, r7
900149b0:	bd80      	pop	{r7, pc}

900149b2 <HAL_TIM_PWM_Init>:
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
900149b2:	b580      	push	{r7, lr}
900149b4:	b082      	sub	sp, #8
900149b6:	af00      	add	r7, sp, #0
900149b8:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
900149ba:	687b      	ldr	r3, [r7, #4]
900149bc:	2b00      	cmp	r3, #0
900149be:	d101      	bne.n	900149c4 <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
900149c0:	2301      	movs	r3, #1
900149c2:	e049      	b.n	90014a58 <HAL_TIM_PWM_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
900149c4:	687b      	ldr	r3, [r7, #4]
900149c6:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
900149ca:	b2db      	uxtb	r3, r3
900149cc:	2b00      	cmp	r3, #0
900149ce:	d106      	bne.n	900149de <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
900149d0:	687b      	ldr	r3, [r7, #4]
900149d2:	2200      	movs	r2, #0
900149d4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->PWM_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
900149d8:	6878      	ldr	r0, [r7, #4]
900149da:	f000 f89d 	bl	90014b18 <HAL_TIM_PWM_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
900149de:	687b      	ldr	r3, [r7, #4]
900149e0:	2202      	movs	r2, #2
900149e2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
900149e6:	687b      	ldr	r3, [r7, #4]
900149e8:	681a      	ldr	r2, [r3, #0]
900149ea:	687b      	ldr	r3, [r7, #4]
900149ec:	3304      	adds	r3, #4
900149ee:	4619      	mov	r1, r3
900149f0:	4610      	mov	r0, r2
900149f2:	f000 f8a5 	bl	90014b40 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
900149f6:	687b      	ldr	r3, [r7, #4]
900149f8:	2201      	movs	r2, #1
900149fa:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
900149fe:	687b      	ldr	r3, [r7, #4]
90014a00:	2201      	movs	r2, #1
90014a02:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
90014a06:	687b      	ldr	r3, [r7, #4]
90014a08:	2201      	movs	r2, #1
90014a0a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
90014a0e:	687b      	ldr	r3, [r7, #4]
90014a10:	2201      	movs	r2, #1
90014a12:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
90014a16:	687b      	ldr	r3, [r7, #4]
90014a18:	2201      	movs	r2, #1
90014a1a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
90014a1e:	687b      	ldr	r3, [r7, #4]
90014a20:	2201      	movs	r2, #1
90014a22:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
90014a26:	687b      	ldr	r3, [r7, #4]
90014a28:	2201      	movs	r2, #1
90014a2a:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
90014a2e:	687b      	ldr	r3, [r7, #4]
90014a30:	2201      	movs	r2, #1
90014a32:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
90014a36:	687b      	ldr	r3, [r7, #4]
90014a38:	2201      	movs	r2, #1
90014a3a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
90014a3e:	687b      	ldr	r3, [r7, #4]
90014a40:	2201      	movs	r2, #1
90014a42:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
90014a46:	687b      	ldr	r3, [r7, #4]
90014a48:	2201      	movs	r2, #1
90014a4a:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
90014a4e:	687b      	ldr	r3, [r7, #4]
90014a50:	2201      	movs	r2, #1
90014a52:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
90014a56:	2300      	movs	r3, #0
}
90014a58:	4618      	mov	r0, r3
90014a5a:	3708      	adds	r7, #8
90014a5c:	46bd      	mov	sp, r7
90014a5e:	bd80      	pop	{r7, pc}

90014a60 <HAL_TIM_PWM_DeInit>:
  * @brief  DeInitializes the TIM peripheral
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
{
90014a60:	b580      	push	{r7, lr}
90014a62:	b082      	sub	sp, #8
90014a64:	af00      	add	r7, sp, #0
90014a66:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  htim->State = HAL_TIM_STATE_BUSY;
90014a68:	687b      	ldr	r3, [r7, #4]
90014a6a:	2202      	movs	r2, #2
90014a6c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Disable the TIM Peripheral Clock */
  __HAL_TIM_DISABLE(htim);
90014a70:	687b      	ldr	r3, [r7, #4]
90014a72:	681b      	ldr	r3, [r3, #0]
90014a74:	6a1a      	ldr	r2, [r3, #32]
90014a76:	f241 1311 	movw	r3, #4369	; 0x1111
90014a7a:	4013      	ands	r3, r2
90014a7c:	2b00      	cmp	r3, #0
90014a7e:	d10f      	bne.n	90014aa0 <HAL_TIM_PWM_DeInit+0x40>
90014a80:	687b      	ldr	r3, [r7, #4]
90014a82:	681b      	ldr	r3, [r3, #0]
90014a84:	6a1a      	ldr	r2, [r3, #32]
90014a86:	f240 4344 	movw	r3, #1092	; 0x444
90014a8a:	4013      	ands	r3, r2
90014a8c:	2b00      	cmp	r3, #0
90014a8e:	d107      	bne.n	90014aa0 <HAL_TIM_PWM_DeInit+0x40>
90014a90:	687b      	ldr	r3, [r7, #4]
90014a92:	681b      	ldr	r3, [r3, #0]
90014a94:	681a      	ldr	r2, [r3, #0]
90014a96:	687b      	ldr	r3, [r7, #4]
90014a98:	681b      	ldr	r3, [r3, #0]
90014a9a:	f022 0201 	bic.w	r2, r2, #1
90014a9e:	601a      	str	r2, [r3, #0]
  }
  /* DeInit the low level hardware */
  htim->PWM_MspDeInitCallback(htim);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
  HAL_TIM_PWM_MspDeInit(htim);
90014aa0:	6878      	ldr	r0, [r7, #4]
90014aa2:	f000 f843 	bl	90014b2c <HAL_TIM_PWM_MspDeInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */

  /* Change the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_RESET;
90014aa6:	687b      	ldr	r3, [r7, #4]
90014aa8:	2200      	movs	r2, #0
90014aaa:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Change the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
90014aae:	687b      	ldr	r3, [r7, #4]
90014ab0:	2200      	movs	r2, #0
90014ab2:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
90014ab6:	687b      	ldr	r3, [r7, #4]
90014ab8:	2200      	movs	r2, #0
90014aba:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
90014abe:	687b      	ldr	r3, [r7, #4]
90014ac0:	2200      	movs	r2, #0
90014ac2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
90014ac6:	687b      	ldr	r3, [r7, #4]
90014ac8:	2200      	movs	r2, #0
90014aca:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
90014ace:	687b      	ldr	r3, [r7, #4]
90014ad0:	2200      	movs	r2, #0
90014ad2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
90014ad6:	687b      	ldr	r3, [r7, #4]
90014ad8:	2200      	movs	r2, #0
90014ada:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_RESET);
90014ade:	687b      	ldr	r3, [r7, #4]
90014ae0:	2200      	movs	r2, #0
90014ae2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
90014ae6:	687b      	ldr	r3, [r7, #4]
90014ae8:	2200      	movs	r2, #0
90014aea:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
90014aee:	687b      	ldr	r3, [r7, #4]
90014af0:	2200      	movs	r2, #0
90014af2:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
90014af6:	687b      	ldr	r3, [r7, #4]
90014af8:	2200      	movs	r2, #0
90014afa:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Change TIM state */
  htim->State = HAL_TIM_STATE_RESET;
90014afe:	687b      	ldr	r3, [r7, #4]
90014b00:	2200      	movs	r2, #0
90014b02:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Release Lock */
  __HAL_UNLOCK(htim);
90014b06:	687b      	ldr	r3, [r7, #4]
90014b08:	2200      	movs	r2, #0
90014b0a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
90014b0e:	2300      	movs	r3, #0
}
90014b10:	4618      	mov	r0, r3
90014b12:	3708      	adds	r7, #8
90014b14:	46bd      	mov	sp, r7
90014b16:	bd80      	pop	{r7, pc}

90014b18 <HAL_TIM_PWM_MspInit>:
  * @brief  Initializes the TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
{
90014b18:	b480      	push	{r7}
90014b1a:	b083      	sub	sp, #12
90014b1c:	af00      	add	r7, sp, #0
90014b1e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspInit could be implemented in the user file
   */
}
90014b20:	bf00      	nop
90014b22:	370c      	adds	r7, #12
90014b24:	46bd      	mov	sp, r7
90014b26:	f85d 7b04 	ldr.w	r7, [sp], #4
90014b2a:	4770      	bx	lr

90014b2c <HAL_TIM_PWM_MspDeInit>:
  * @brief  DeInitializes TIM PWM MSP.
  * @param  htim TIM PWM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
{
90014b2c:	b480      	push	{r7}
90014b2e:	b083      	sub	sp, #12
90014b30:	af00      	add	r7, sp, #0
90014b32:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   */
}
90014b34:	bf00      	nop
90014b36:	370c      	adds	r7, #12
90014b38:	46bd      	mov	sp, r7
90014b3a:	f85d 7b04 	ldr.w	r7, [sp], #4
90014b3e:	4770      	bx	lr

90014b40 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
90014b40:	b480      	push	{r7}
90014b42:	b085      	sub	sp, #20
90014b44:	af00      	add	r7, sp, #0
90014b46:	6078      	str	r0, [r7, #4]
90014b48:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
90014b4a:	687b      	ldr	r3, [r7, #4]
90014b4c:	681b      	ldr	r3, [r3, #0]
90014b4e:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
90014b50:	687b      	ldr	r3, [r7, #4]
90014b52:	4a40      	ldr	r2, [pc, #256]	; (90014c54 <TIM_Base_SetConfig+0x114>)
90014b54:	4293      	cmp	r3, r2
90014b56:	d013      	beq.n	90014b80 <TIM_Base_SetConfig+0x40>
90014b58:	687b      	ldr	r3, [r7, #4]
90014b5a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
90014b5e:	d00f      	beq.n	90014b80 <TIM_Base_SetConfig+0x40>
90014b60:	687b      	ldr	r3, [r7, #4]
90014b62:	4a3d      	ldr	r2, [pc, #244]	; (90014c58 <TIM_Base_SetConfig+0x118>)
90014b64:	4293      	cmp	r3, r2
90014b66:	d00b      	beq.n	90014b80 <TIM_Base_SetConfig+0x40>
90014b68:	687b      	ldr	r3, [r7, #4]
90014b6a:	4a3c      	ldr	r2, [pc, #240]	; (90014c5c <TIM_Base_SetConfig+0x11c>)
90014b6c:	4293      	cmp	r3, r2
90014b6e:	d007      	beq.n	90014b80 <TIM_Base_SetConfig+0x40>
90014b70:	687b      	ldr	r3, [r7, #4]
90014b72:	4a3b      	ldr	r2, [pc, #236]	; (90014c60 <TIM_Base_SetConfig+0x120>)
90014b74:	4293      	cmp	r3, r2
90014b76:	d003      	beq.n	90014b80 <TIM_Base_SetConfig+0x40>
90014b78:	687b      	ldr	r3, [r7, #4]
90014b7a:	4a3a      	ldr	r2, [pc, #232]	; (90014c64 <TIM_Base_SetConfig+0x124>)
90014b7c:	4293      	cmp	r3, r2
90014b7e:	d108      	bne.n	90014b92 <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
90014b80:	68fb      	ldr	r3, [r7, #12]
90014b82:	f023 0370 	bic.w	r3, r3, #112	; 0x70
90014b86:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
90014b88:	683b      	ldr	r3, [r7, #0]
90014b8a:	685b      	ldr	r3, [r3, #4]
90014b8c:	68fa      	ldr	r2, [r7, #12]
90014b8e:	4313      	orrs	r3, r2
90014b90:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
90014b92:	687b      	ldr	r3, [r7, #4]
90014b94:	4a2f      	ldr	r2, [pc, #188]	; (90014c54 <TIM_Base_SetConfig+0x114>)
90014b96:	4293      	cmp	r3, r2
90014b98:	d01f      	beq.n	90014bda <TIM_Base_SetConfig+0x9a>
90014b9a:	687b      	ldr	r3, [r7, #4]
90014b9c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
90014ba0:	d01b      	beq.n	90014bda <TIM_Base_SetConfig+0x9a>
90014ba2:	687b      	ldr	r3, [r7, #4]
90014ba4:	4a2c      	ldr	r2, [pc, #176]	; (90014c58 <TIM_Base_SetConfig+0x118>)
90014ba6:	4293      	cmp	r3, r2
90014ba8:	d017      	beq.n	90014bda <TIM_Base_SetConfig+0x9a>
90014baa:	687b      	ldr	r3, [r7, #4]
90014bac:	4a2b      	ldr	r2, [pc, #172]	; (90014c5c <TIM_Base_SetConfig+0x11c>)
90014bae:	4293      	cmp	r3, r2
90014bb0:	d013      	beq.n	90014bda <TIM_Base_SetConfig+0x9a>
90014bb2:	687b      	ldr	r3, [r7, #4]
90014bb4:	4a2a      	ldr	r2, [pc, #168]	; (90014c60 <TIM_Base_SetConfig+0x120>)
90014bb6:	4293      	cmp	r3, r2
90014bb8:	d00f      	beq.n	90014bda <TIM_Base_SetConfig+0x9a>
90014bba:	687b      	ldr	r3, [r7, #4]
90014bbc:	4a29      	ldr	r2, [pc, #164]	; (90014c64 <TIM_Base_SetConfig+0x124>)
90014bbe:	4293      	cmp	r3, r2
90014bc0:	d00b      	beq.n	90014bda <TIM_Base_SetConfig+0x9a>
90014bc2:	687b      	ldr	r3, [r7, #4]
90014bc4:	4a28      	ldr	r2, [pc, #160]	; (90014c68 <TIM_Base_SetConfig+0x128>)
90014bc6:	4293      	cmp	r3, r2
90014bc8:	d007      	beq.n	90014bda <TIM_Base_SetConfig+0x9a>
90014bca:	687b      	ldr	r3, [r7, #4]
90014bcc:	4a27      	ldr	r2, [pc, #156]	; (90014c6c <TIM_Base_SetConfig+0x12c>)
90014bce:	4293      	cmp	r3, r2
90014bd0:	d003      	beq.n	90014bda <TIM_Base_SetConfig+0x9a>
90014bd2:	687b      	ldr	r3, [r7, #4]
90014bd4:	4a26      	ldr	r2, [pc, #152]	; (90014c70 <TIM_Base_SetConfig+0x130>)
90014bd6:	4293      	cmp	r3, r2
90014bd8:	d108      	bne.n	90014bec <TIM_Base_SetConfig+0xac>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
90014bda:	68fb      	ldr	r3, [r7, #12]
90014bdc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
90014be0:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
90014be2:	683b      	ldr	r3, [r7, #0]
90014be4:	68db      	ldr	r3, [r3, #12]
90014be6:	68fa      	ldr	r2, [r7, #12]
90014be8:	4313      	orrs	r3, r2
90014bea:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
90014bec:	68fb      	ldr	r3, [r7, #12]
90014bee:	f023 0280 	bic.w	r2, r3, #128	; 0x80
90014bf2:	683b      	ldr	r3, [r7, #0]
90014bf4:	695b      	ldr	r3, [r3, #20]
90014bf6:	4313      	orrs	r3, r2
90014bf8:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
90014bfa:	687b      	ldr	r3, [r7, #4]
90014bfc:	68fa      	ldr	r2, [r7, #12]
90014bfe:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
90014c00:	683b      	ldr	r3, [r7, #0]
90014c02:	689a      	ldr	r2, [r3, #8]
90014c04:	687b      	ldr	r3, [r7, #4]
90014c06:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
90014c08:	683b      	ldr	r3, [r7, #0]
90014c0a:	681a      	ldr	r2, [r3, #0]
90014c0c:	687b      	ldr	r3, [r7, #4]
90014c0e:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
90014c10:	687b      	ldr	r3, [r7, #4]
90014c12:	4a10      	ldr	r2, [pc, #64]	; (90014c54 <TIM_Base_SetConfig+0x114>)
90014c14:	4293      	cmp	r3, r2
90014c16:	d00f      	beq.n	90014c38 <TIM_Base_SetConfig+0xf8>
90014c18:	687b      	ldr	r3, [r7, #4]
90014c1a:	4a12      	ldr	r2, [pc, #72]	; (90014c64 <TIM_Base_SetConfig+0x124>)
90014c1c:	4293      	cmp	r3, r2
90014c1e:	d00b      	beq.n	90014c38 <TIM_Base_SetConfig+0xf8>
90014c20:	687b      	ldr	r3, [r7, #4]
90014c22:	4a11      	ldr	r2, [pc, #68]	; (90014c68 <TIM_Base_SetConfig+0x128>)
90014c24:	4293      	cmp	r3, r2
90014c26:	d007      	beq.n	90014c38 <TIM_Base_SetConfig+0xf8>
90014c28:	687b      	ldr	r3, [r7, #4]
90014c2a:	4a10      	ldr	r2, [pc, #64]	; (90014c6c <TIM_Base_SetConfig+0x12c>)
90014c2c:	4293      	cmp	r3, r2
90014c2e:	d003      	beq.n	90014c38 <TIM_Base_SetConfig+0xf8>
90014c30:	687b      	ldr	r3, [r7, #4]
90014c32:	4a0f      	ldr	r2, [pc, #60]	; (90014c70 <TIM_Base_SetConfig+0x130>)
90014c34:	4293      	cmp	r3, r2
90014c36:	d103      	bne.n	90014c40 <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
90014c38:	683b      	ldr	r3, [r7, #0]
90014c3a:	691a      	ldr	r2, [r3, #16]
90014c3c:	687b      	ldr	r3, [r7, #4]
90014c3e:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
90014c40:	687b      	ldr	r3, [r7, #4]
90014c42:	2201      	movs	r2, #1
90014c44:	615a      	str	r2, [r3, #20]
}
90014c46:	bf00      	nop
90014c48:	3714      	adds	r7, #20
90014c4a:	46bd      	mov	sp, r7
90014c4c:	f85d 7b04 	ldr.w	r7, [sp], #4
90014c50:	4770      	bx	lr
90014c52:	bf00      	nop
90014c54:	40010000 	.word	0x40010000
90014c58:	40000400 	.word	0x40000400
90014c5c:	40000800 	.word	0x40000800
90014c60:	40000c00 	.word	0x40000c00
90014c64:	40010400 	.word	0x40010400
90014c68:	40014000 	.word	0x40014000
90014c6c:	40014400 	.word	0x40014400
90014c70:	40014800 	.word	0x40014800

90014c74 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
90014c74:	b480      	push	{r7}
90014c76:	b083      	sub	sp, #12
90014c78:	af00      	add	r7, sp, #0
90014c7a:	6078      	str	r0, [r7, #4]
90014c7c:	6039      	str	r1, [r7, #0]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank == FMC_SDRAM_BANK1)
90014c7e:	683b      	ldr	r3, [r7, #0]
90014c80:	681b      	ldr	r3, [r3, #0]
90014c82:	2b00      	cmp	r3, #0
90014c84:	d121      	bne.n	90014cca <FMC_SDRAM_Init+0x56>
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
90014c86:	687b      	ldr	r3, [r7, #4]
90014c88:	681a      	ldr	r2, [r3, #0]
90014c8a:	4b27      	ldr	r3, [pc, #156]	; (90014d28 <FMC_SDRAM_Init+0xb4>)
90014c8c:	4013      	ands	r3, r2
90014c8e:	683a      	ldr	r2, [r7, #0]
90014c90:	6851      	ldr	r1, [r2, #4]
90014c92:	683a      	ldr	r2, [r7, #0]
90014c94:	6892      	ldr	r2, [r2, #8]
90014c96:	4311      	orrs	r1, r2
90014c98:	683a      	ldr	r2, [r7, #0]
90014c9a:	68d2      	ldr	r2, [r2, #12]
90014c9c:	4311      	orrs	r1, r2
90014c9e:	683a      	ldr	r2, [r7, #0]
90014ca0:	6912      	ldr	r2, [r2, #16]
90014ca2:	4311      	orrs	r1, r2
90014ca4:	683a      	ldr	r2, [r7, #0]
90014ca6:	6952      	ldr	r2, [r2, #20]
90014ca8:	4311      	orrs	r1, r2
90014caa:	683a      	ldr	r2, [r7, #0]
90014cac:	6992      	ldr	r2, [r2, #24]
90014cae:	4311      	orrs	r1, r2
90014cb0:	683a      	ldr	r2, [r7, #0]
90014cb2:	69d2      	ldr	r2, [r2, #28]
90014cb4:	4311      	orrs	r1, r2
90014cb6:	683a      	ldr	r2, [r7, #0]
90014cb8:	6a12      	ldr	r2, [r2, #32]
90014cba:	4311      	orrs	r1, r2
90014cbc:	683a      	ldr	r2, [r7, #0]
90014cbe:	6a52      	ldr	r2, [r2, #36]	; 0x24
90014cc0:	430a      	orrs	r2, r1
90014cc2:	431a      	orrs	r2, r3
90014cc4:	687b      	ldr	r3, [r7, #4]
90014cc6:	601a      	str	r2, [r3, #0]
90014cc8:	e026      	b.n	90014d18 <FMC_SDRAM_Init+0xa4>
                Init->ReadBurst          |
                Init->ReadPipeDelay));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
90014cca:	687b      	ldr	r3, [r7, #4]
90014ccc:	681b      	ldr	r3, [r3, #0]
90014cce:	f423 42f8 	bic.w	r2, r3, #31744	; 0x7c00
90014cd2:	683b      	ldr	r3, [r7, #0]
90014cd4:	69d9      	ldr	r1, [r3, #28]
90014cd6:	683b      	ldr	r3, [r7, #0]
90014cd8:	6a1b      	ldr	r3, [r3, #32]
90014cda:	4319      	orrs	r1, r3
90014cdc:	683b      	ldr	r3, [r7, #0]
90014cde:	6a5b      	ldr	r3, [r3, #36]	; 0x24
90014ce0:	430b      	orrs	r3, r1
90014ce2:	431a      	orrs	r2, r3
90014ce4:	687b      	ldr	r3, [r7, #4]
90014ce6:	601a      	str	r2, [r3, #0]
               FMC_SDCRx_RPIPE,
               (Init->SDClockPeriod      |
                Init->ReadBurst          |
                Init->ReadPipeDelay));

    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
90014ce8:	687b      	ldr	r3, [r7, #4]
90014cea:	685a      	ldr	r2, [r3, #4]
90014cec:	4b0e      	ldr	r3, [pc, #56]	; (90014d28 <FMC_SDRAM_Init+0xb4>)
90014cee:	4013      	ands	r3, r2
90014cf0:	683a      	ldr	r2, [r7, #0]
90014cf2:	6851      	ldr	r1, [r2, #4]
90014cf4:	683a      	ldr	r2, [r7, #0]
90014cf6:	6892      	ldr	r2, [r2, #8]
90014cf8:	4311      	orrs	r1, r2
90014cfa:	683a      	ldr	r2, [r7, #0]
90014cfc:	68d2      	ldr	r2, [r2, #12]
90014cfe:	4311      	orrs	r1, r2
90014d00:	683a      	ldr	r2, [r7, #0]
90014d02:	6912      	ldr	r2, [r2, #16]
90014d04:	4311      	orrs	r1, r2
90014d06:	683a      	ldr	r2, [r7, #0]
90014d08:	6952      	ldr	r2, [r2, #20]
90014d0a:	4311      	orrs	r1, r2
90014d0c:	683a      	ldr	r2, [r7, #0]
90014d0e:	6992      	ldr	r2, [r2, #24]
90014d10:	430a      	orrs	r2, r1
90014d12:	431a      	orrs	r2, r3
90014d14:	687b      	ldr	r3, [r7, #4]
90014d16:	605a      	str	r2, [r3, #4]
                Init->InternalBankNumber |
                Init->CASLatency         |
                Init->WriteProtection));
  }

  return HAL_OK;
90014d18:	2300      	movs	r3, #0
}
90014d1a:	4618      	mov	r0, r3
90014d1c:	370c      	adds	r7, #12
90014d1e:	46bd      	mov	sp, r7
90014d20:	f85d 7b04 	ldr.w	r7, [sp], #4
90014d24:	4770      	bx	lr
90014d26:	bf00      	nop
90014d28:	ffff8000 	.word	0xffff8000

90014d2c <FMC_SDRAM_Timing_Init>:
  * @param  Bank SDRAM bank number
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device,
                                        FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
90014d2c:	b480      	push	{r7}
90014d2e:	b085      	sub	sp, #20
90014d30:	af00      	add	r7, sp, #0
90014d32:	60f8      	str	r0, [r7, #12]
90014d34:	60b9      	str	r1, [r7, #8]
90014d36:	607a      	str	r2, [r7, #4]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));

  /* Set SDRAM device timing parameters */
  if (Bank == FMC_SDRAM_BANK1)
90014d38:	687b      	ldr	r3, [r7, #4]
90014d3a:	2b00      	cmp	r3, #0
90014d3c:	d128      	bne.n	90014d90 <FMC_SDRAM_Timing_Init+0x64>
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
90014d3e:	68fb      	ldr	r3, [r7, #12]
90014d40:	689b      	ldr	r3, [r3, #8]
90014d42:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
90014d46:	68bb      	ldr	r3, [r7, #8]
90014d48:	681b      	ldr	r3, [r3, #0]
90014d4a:	1e59      	subs	r1, r3, #1
90014d4c:	68bb      	ldr	r3, [r7, #8]
90014d4e:	685b      	ldr	r3, [r3, #4]
90014d50:	3b01      	subs	r3, #1
90014d52:	011b      	lsls	r3, r3, #4
90014d54:	4319      	orrs	r1, r3
90014d56:	68bb      	ldr	r3, [r7, #8]
90014d58:	689b      	ldr	r3, [r3, #8]
90014d5a:	3b01      	subs	r3, #1
90014d5c:	021b      	lsls	r3, r3, #8
90014d5e:	4319      	orrs	r1, r3
90014d60:	68bb      	ldr	r3, [r7, #8]
90014d62:	68db      	ldr	r3, [r3, #12]
90014d64:	3b01      	subs	r3, #1
90014d66:	031b      	lsls	r3, r3, #12
90014d68:	4319      	orrs	r1, r3
90014d6a:	68bb      	ldr	r3, [r7, #8]
90014d6c:	691b      	ldr	r3, [r3, #16]
90014d6e:	3b01      	subs	r3, #1
90014d70:	041b      	lsls	r3, r3, #16
90014d72:	4319      	orrs	r1, r3
90014d74:	68bb      	ldr	r3, [r7, #8]
90014d76:	695b      	ldr	r3, [r3, #20]
90014d78:	3b01      	subs	r3, #1
90014d7a:	051b      	lsls	r3, r3, #20
90014d7c:	4319      	orrs	r1, r3
90014d7e:	68bb      	ldr	r3, [r7, #8]
90014d80:	699b      	ldr	r3, [r3, #24]
90014d82:	3b01      	subs	r3, #1
90014d84:	061b      	lsls	r3, r3, #24
90014d86:	430b      	orrs	r3, r1
90014d88:	431a      	orrs	r2, r3
90014d8a:	68fb      	ldr	r3, [r7, #12]
90014d8c:	609a      	str	r2, [r3, #8]
90014d8e:	e02d      	b.n	90014dec <FMC_SDRAM_Timing_Init+0xc0>
                (((Timing->RPDelay) - 1U)              << FMC_SDTRx_TRP_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTRx_TRCD_Pos)));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
90014d90:	68fb      	ldr	r3, [r7, #12]
90014d92:	689a      	ldr	r2, [r3, #8]
90014d94:	4b19      	ldr	r3, [pc, #100]	; (90014dfc <FMC_SDRAM_Timing_Init+0xd0>)
90014d96:	4013      	ands	r3, r2
90014d98:	68ba      	ldr	r2, [r7, #8]
90014d9a:	68d2      	ldr	r2, [r2, #12]
90014d9c:	3a01      	subs	r2, #1
90014d9e:	0311      	lsls	r1, r2, #12
90014da0:	68ba      	ldr	r2, [r7, #8]
90014da2:	6952      	ldr	r2, [r2, #20]
90014da4:	3a01      	subs	r2, #1
90014da6:	0512      	lsls	r2, r2, #20
90014da8:	430a      	orrs	r2, r1
90014daa:	431a      	orrs	r2, r3
90014dac:	68fb      	ldr	r3, [r7, #12]
90014dae:	609a      	str	r2, [r3, #8]
               FMC_SDTRx_TRC |
               FMC_SDTRx_TRP,
               (((Timing->RowCycleDelay) - 1U)         << FMC_SDTRx_TRC_Pos)  |
               (((Timing->RPDelay) - 1U)               << FMC_SDTRx_TRP_Pos));

    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
90014db0:	68fb      	ldr	r3, [r7, #12]
90014db2:	68db      	ldr	r3, [r3, #12]
90014db4:	f003 4270 	and.w	r2, r3, #4026531840	; 0xf0000000
90014db8:	68bb      	ldr	r3, [r7, #8]
90014dba:	681b      	ldr	r3, [r3, #0]
90014dbc:	1e59      	subs	r1, r3, #1
90014dbe:	68bb      	ldr	r3, [r7, #8]
90014dc0:	685b      	ldr	r3, [r3, #4]
90014dc2:	3b01      	subs	r3, #1
90014dc4:	011b      	lsls	r3, r3, #4
90014dc6:	4319      	orrs	r1, r3
90014dc8:	68bb      	ldr	r3, [r7, #8]
90014dca:	689b      	ldr	r3, [r3, #8]
90014dcc:	3b01      	subs	r3, #1
90014dce:	021b      	lsls	r3, r3, #8
90014dd0:	4319      	orrs	r1, r3
90014dd2:	68bb      	ldr	r3, [r7, #8]
90014dd4:	691b      	ldr	r3, [r3, #16]
90014dd6:	3b01      	subs	r3, #1
90014dd8:	041b      	lsls	r3, r3, #16
90014dda:	4319      	orrs	r1, r3
90014ddc:	68bb      	ldr	r3, [r7, #8]
90014dde:	699b      	ldr	r3, [r3, #24]
90014de0:	3b01      	subs	r3, #1
90014de2:	061b      	lsls	r3, r3, #24
90014de4:	430b      	orrs	r3, r1
90014de6:	431a      	orrs	r2, r3
90014de8:	68fb      	ldr	r3, [r7, #12]
90014dea:	60da      	str	r2, [r3, #12]
                (((Timing->SelfRefreshTime) - 1U)      << FMC_SDTRx_TRAS_Pos) |
                (((Timing->WriteRecoveryTime) - 1U)    << FMC_SDTRx_TWR_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTRx_TRCD_Pos)));
  }

  return HAL_OK;
90014dec:	2300      	movs	r3, #0
}
90014dee:	4618      	mov	r0, r3
90014df0:	3714      	adds	r7, #20
90014df2:	46bd      	mov	sp, r7
90014df4:	f85d 7b04 	ldr.w	r7, [sp], #4
90014df8:	4770      	bx	lr
90014dfa:	bf00      	nop
90014dfc:	ff0f0fff 	.word	0xff0f0fff

90014e00 <FMC_SDRAM_DeInit>:
  * @brief  DeInitializes the FMC_SDRAM peripheral
  * @param  Device Pointer to SDRAM device instance
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_DeInit(FMC_SDRAM_TypeDef *Device, uint32_t Bank)
{
90014e00:	b480      	push	{r7}
90014e02:	b083      	sub	sp, #12
90014e04:	af00      	add	r7, sp, #0
90014e06:	6078      	str	r0, [r7, #4]
90014e08:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_SDRAM_BANK(Bank));

  /* De-initialize the SDRAM device */
  Device->SDCR[Bank] = 0x000002D0U;
90014e0a:	687b      	ldr	r3, [r7, #4]
90014e0c:	683a      	ldr	r2, [r7, #0]
90014e0e:	f44f 7134 	mov.w	r1, #720	; 0x2d0
90014e12:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  Device->SDTR[Bank] = 0x0FFFFFFFU;
90014e16:	687b      	ldr	r3, [r7, #4]
90014e18:	683a      	ldr	r2, [r7, #0]
90014e1a:	3202      	adds	r2, #2
90014e1c:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
90014e20:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  Device->SDCMR      = 0x00000000U;
90014e24:	687b      	ldr	r3, [r7, #4]
90014e26:	2200      	movs	r2, #0
90014e28:	611a      	str	r2, [r3, #16]
  Device->SDRTR      = 0x00000000U;
90014e2a:	687b      	ldr	r3, [r7, #4]
90014e2c:	2200      	movs	r2, #0
90014e2e:	615a      	str	r2, [r3, #20]
  Device->SDSR       = 0x00000000U;
90014e30:	687b      	ldr	r3, [r7, #4]
90014e32:	2200      	movs	r2, #0
90014e34:	619a      	str	r2, [r3, #24]

  return HAL_OK;
90014e36:	2300      	movs	r3, #0
}
90014e38:	4618      	mov	r0, r3
90014e3a:	370c      	adds	r7, #12
90014e3c:	46bd      	mov	sp, r7
90014e3e:	f85d 7b04 	ldr.w	r7, [sp], #4
90014e42:	4770      	bx	lr

90014e44 <FMC_SDRAM_SendCommand>:
  * @param  Timeout Timeout wait value
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device,
                                        FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
90014e44:	b480      	push	{r7}
90014e46:	b085      	sub	sp, #20
90014e48:	af00      	add	r7, sp, #0
90014e4a:	60f8      	str	r0, [r7, #12]
90014e4c:	60b9      	str	r1, [r7, #8]
90014e4e:	607a      	str	r2, [r7, #4]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));

  /* Set command register */
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | FMC_SDCMR_NRFS | FMC_SDCMR_MRD),
90014e50:	68fb      	ldr	r3, [r7, #12]
90014e52:	691a      	ldr	r2, [r3, #16]
90014e54:	4b0c      	ldr	r3, [pc, #48]	; (90014e88 <FMC_SDRAM_SendCommand+0x44>)
90014e56:	4013      	ands	r3, r2
90014e58:	68ba      	ldr	r2, [r7, #8]
90014e5a:	6811      	ldr	r1, [r2, #0]
90014e5c:	68ba      	ldr	r2, [r7, #8]
90014e5e:	6852      	ldr	r2, [r2, #4]
90014e60:	4311      	orrs	r1, r2
90014e62:	68ba      	ldr	r2, [r7, #8]
90014e64:	6892      	ldr	r2, [r2, #8]
90014e66:	3a01      	subs	r2, #1
90014e68:	0152      	lsls	r2, r2, #5
90014e6a:	4311      	orrs	r1, r2
90014e6c:	68ba      	ldr	r2, [r7, #8]
90014e6e:	68d2      	ldr	r2, [r2, #12]
90014e70:	0252      	lsls	r2, r2, #9
90014e72:	430a      	orrs	r2, r1
90014e74:	431a      	orrs	r2, r3
90014e76:	68fb      	ldr	r3, [r7, #12]
90014e78:	611a      	str	r2, [r3, #16]
             ((Command->CommandMode) | (Command->CommandTarget) |
              (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos) |
              ((Command->ModeRegisterDefinition) << FMC_SDCMR_MRD_Pos)));
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Timeout);
  return HAL_OK;
90014e7a:	2300      	movs	r3, #0
}
90014e7c:	4618      	mov	r0, r3
90014e7e:	3714      	adds	r7, #20
90014e80:	46bd      	mov	sp, r7
90014e82:	f85d 7b04 	ldr.w	r7, [sp], #4
90014e86:	4770      	bx	lr
90014e88:	ffc00000 	.word	0xffc00000

90014e8c <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
90014e8c:	b480      	push	{r7}
90014e8e:	b083      	sub	sp, #12
90014e90:	af00      	add	r7, sp, #0
90014e92:	6078      	str	r0, [r7, #4]
90014e94:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));

  /* Set the refresh rate in command register */
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
90014e96:	687b      	ldr	r3, [r7, #4]
90014e98:	695a      	ldr	r2, [r3, #20]
90014e9a:	4b07      	ldr	r3, [pc, #28]	; (90014eb8 <FMC_SDRAM_ProgramRefreshRate+0x2c>)
90014e9c:	4013      	ands	r3, r2
90014e9e:	683a      	ldr	r2, [r7, #0]
90014ea0:	0052      	lsls	r2, r2, #1
90014ea2:	431a      	orrs	r2, r3
90014ea4:	687b      	ldr	r3, [r7, #4]
90014ea6:	615a      	str	r2, [r3, #20]

  return HAL_OK;
90014ea8:	2300      	movs	r3, #0
}
90014eaa:	4618      	mov	r0, r3
90014eac:	370c      	adds	r7, #12
90014eae:	46bd      	mov	sp, r7
90014eb0:	f85d 7b04 	ldr.w	r7, [sp], #4
90014eb4:	4770      	bx	lr
90014eb6:	bf00      	nop
90014eb8:	ffffc001 	.word	0xffffc001

90014ebc <SDMMC_Init>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Init: SDMMC initialization structure
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
90014ebc:	b084      	sub	sp, #16
90014ebe:	b480      	push	{r7}
90014ec0:	b085      	sub	sp, #20
90014ec2:	af00      	add	r7, sp, #0
90014ec4:	6078      	str	r0, [r7, #4]
90014ec6:	f107 001c 	add.w	r0, r7, #28
90014eca:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t tmpreg = 0;
90014ece:	2300      	movs	r3, #0
90014ed0:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));

  /* Set SDMMC configuration parameters */
  tmpreg |= (Init.ClockEdge           | \
90014ed2:	69fa      	ldr	r2, [r7, #28]
             Init.ClockPowerSave      | \
90014ed4:	6a3b      	ldr	r3, [r7, #32]
  tmpreg |= (Init.ClockEdge           | \
90014ed6:	431a      	orrs	r2, r3
             Init.BusWide             | \
90014ed8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
             Init.ClockPowerSave      | \
90014eda:	431a      	orrs	r2, r3
             Init.HardwareFlowControl | \
90014edc:	6abb      	ldr	r3, [r7, #40]	; 0x28
             Init.BusWide             | \
90014ede:	431a      	orrs	r2, r3
             Init.ClockDiv
90014ee0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
             Init.HardwareFlowControl | \
90014ee2:	4313      	orrs	r3, r2
  tmpreg |= (Init.ClockEdge           | \
90014ee4:	68fa      	ldr	r2, [r7, #12]
90014ee6:	4313      	orrs	r3, r2
90014ee8:	60fb      	str	r3, [r7, #12]
            );

  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
90014eea:	687b      	ldr	r3, [r7, #4]
90014eec:	685a      	ldr	r2, [r3, #4]
90014eee:	4b07      	ldr	r3, [pc, #28]	; (90014f0c <SDMMC_Init+0x50>)
90014ef0:	4013      	ands	r3, r2
90014ef2:	68fa      	ldr	r2, [r7, #12]
90014ef4:	431a      	orrs	r2, r3
90014ef6:	687b      	ldr	r3, [r7, #4]
90014ef8:	605a      	str	r2, [r3, #4]

  return HAL_OK;
90014efa:	2300      	movs	r3, #0
}
90014efc:	4618      	mov	r0, r3
90014efe:	3714      	adds	r7, #20
90014f00:	46bd      	mov	sp, r7
90014f02:	f85d 7b04 	ldr.w	r7, [sp], #4
90014f06:	b004      	add	sp, #16
90014f08:	4770      	bx	lr
90014f0a:	bf00      	nop
90014f0c:	ffc02c00 	.word	0xffc02c00

90014f10 <SDMMC_ReadFIFO>:
  * @brief  Read data (word) from Rx FIFO in blocking mode (polling)
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_ReadFIFO(SDMMC_TypeDef *SDMMCx)
{
90014f10:	b480      	push	{r7}
90014f12:	b083      	sub	sp, #12
90014f14:	af00      	add	r7, sp, #0
90014f16:	6078      	str	r0, [r7, #4]
  /* Read data from Rx FIFO */
  return (SDMMCx->FIFO);
90014f18:	687b      	ldr	r3, [r7, #4]
90014f1a:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
}
90014f1e:	4618      	mov	r0, r3
90014f20:	370c      	adds	r7, #12
90014f22:	46bd      	mov	sp, r7
90014f24:	f85d 7b04 	ldr.w	r7, [sp], #4
90014f28:	4770      	bx	lr

90014f2a <SDMMC_WriteFIFO>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  pWriteData: pointer to data to write
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{
90014f2a:	b480      	push	{r7}
90014f2c:	b083      	sub	sp, #12
90014f2e:	af00      	add	r7, sp, #0
90014f30:	6078      	str	r0, [r7, #4]
90014f32:	6039      	str	r1, [r7, #0]
  /* Write data to FIFO */
  SDMMCx->FIFO = *pWriteData;
90014f34:	683b      	ldr	r3, [r7, #0]
90014f36:	681a      	ldr	r2, [r3, #0]
90014f38:	687b      	ldr	r3, [r7, #4]
90014f3a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  return HAL_OK;
90014f3e:	2300      	movs	r3, #0
}
90014f40:	4618      	mov	r0, r3
90014f42:	370c      	adds	r7, #12
90014f44:	46bd      	mov	sp, r7
90014f46:	f85d 7b04 	ldr.w	r7, [sp], #4
90014f4a:	4770      	bx	lr

90014f4c <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{
90014f4c:	b480      	push	{r7}
90014f4e:	b083      	sub	sp, #12
90014f50:	af00      	add	r7, sp, #0
90014f52:	6078      	str	r0, [r7, #4]
  /* Set power state to ON */
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
90014f54:	687b      	ldr	r3, [r7, #4]
90014f56:	681b      	ldr	r3, [r3, #0]
90014f58:	f043 0203 	orr.w	r2, r3, #3
90014f5c:	687b      	ldr	r3, [r7, #4]
90014f5e:	601a      	str	r2, [r3, #0]

  return HAL_OK;
90014f60:	2300      	movs	r3, #0
}
90014f62:	4618      	mov	r0, r3
90014f64:	370c      	adds	r7, #12
90014f66:	46bd      	mov	sp, r7
90014f68:	f85d 7b04 	ldr.w	r7, [sp], #4
90014f6c:	4770      	bx	lr

90014f6e <SDMMC_GetPowerState>:
  *            - 0x00: Power OFF
  *            - 0x02: Power UP
  *            - 0x03: Power ON
  */
uint32_t SDMMC_GetPowerState(SDMMC_TypeDef *SDMMCx)
{
90014f6e:	b480      	push	{r7}
90014f70:	b083      	sub	sp, #12
90014f72:	af00      	add	r7, sp, #0
90014f74:	6078      	str	r0, [r7, #4]
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
90014f76:	687b      	ldr	r3, [r7, #4]
90014f78:	681b      	ldr	r3, [r3, #0]
90014f7a:	f003 0303 	and.w	r3, r3, #3
}
90014f7e:	4618      	mov	r0, r3
90014f80:	370c      	adds	r7, #12
90014f82:	46bd      	mov	sp, r7
90014f84:	f85d 7b04 	ldr.w	r7, [sp], #4
90014f88:	4770      	bx	lr
	...

90014f8c <SDMMC_SendCommand>:
  * @param  Command: pointer to a SDMMC_CmdInitTypeDef structure that contains
  *         the configuration information for the SDMMC command
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_SendCommand(SDMMC_TypeDef *SDMMCx, SDMMC_CmdInitTypeDef *Command)
{
90014f8c:	b480      	push	{r7}
90014f8e:	b085      	sub	sp, #20
90014f90:	af00      	add	r7, sp, #0
90014f92:	6078      	str	r0, [r7, #4]
90014f94:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
90014f96:	2300      	movs	r3, #0
90014f98:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
90014f9a:	683b      	ldr	r3, [r7, #0]
90014f9c:	681a      	ldr	r2, [r3, #0]
90014f9e:	687b      	ldr	r3, [r7, #4]
90014fa0:	609a      	str	r2, [r3, #8]

  /* Set SDMMC command parameters */
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
90014fa2:	683b      	ldr	r3, [r7, #0]
90014fa4:	685a      	ldr	r2, [r3, #4]
                       Command->Response         | \
90014fa6:	683b      	ldr	r3, [r7, #0]
90014fa8:	689b      	ldr	r3, [r3, #8]
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
90014faa:	431a      	orrs	r2, r3
                       Command->WaitForInterrupt | \
90014fac:	683b      	ldr	r3, [r7, #0]
90014fae:	68db      	ldr	r3, [r3, #12]
                       Command->Response         | \
90014fb0:	431a      	orrs	r2, r3
                       Command->CPSM);
90014fb2:	683b      	ldr	r3, [r7, #0]
90014fb4:	691b      	ldr	r3, [r3, #16]
                       Command->WaitForInterrupt | \
90014fb6:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Command->CmdIndex         | \
90014fb8:	68fa      	ldr	r2, [r7, #12]
90014fba:	4313      	orrs	r3, r2
90014fbc:	60fb      	str	r3, [r7, #12]

  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
90014fbe:	687b      	ldr	r3, [r7, #4]
90014fc0:	68da      	ldr	r2, [r3, #12]
90014fc2:	4b06      	ldr	r3, [pc, #24]	; (90014fdc <SDMMC_SendCommand+0x50>)
90014fc4:	4013      	ands	r3, r2
90014fc6:	68fa      	ldr	r2, [r7, #12]
90014fc8:	431a      	orrs	r2, r3
90014fca:	687b      	ldr	r3, [r7, #4]
90014fcc:	60da      	str	r2, [r3, #12]

  return HAL_OK;
90014fce:	2300      	movs	r3, #0
}
90014fd0:	4618      	mov	r0, r3
90014fd2:	3714      	adds	r7, #20
90014fd4:	46bd      	mov	sp, r7
90014fd6:	f85d 7b04 	ldr.w	r7, [sp], #4
90014fda:	4770      	bx	lr
90014fdc:	fffee0c0 	.word	0xfffee0c0

90014fe0 <SDMMC_GetCommandResponse>:
  * @brief  Return the command index of last command for which response received
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(SDMMC_TypeDef *SDMMCx)
{
90014fe0:	b480      	push	{r7}
90014fe2:	b083      	sub	sp, #12
90014fe4:	af00      	add	r7, sp, #0
90014fe6:	6078      	str	r0, [r7, #4]
  return (uint8_t)(SDMMCx->RESPCMD);
90014fe8:	687b      	ldr	r3, [r7, #4]
90014fea:	691b      	ldr	r3, [r3, #16]
90014fec:	b2db      	uxtb	r3, r3
}
90014fee:	4618      	mov	r0, r3
90014ff0:	370c      	adds	r7, #12
90014ff2:	46bd      	mov	sp, r7
90014ff4:	f85d 7b04 	ldr.w	r7, [sp], #4
90014ff8:	4770      	bx	lr

90014ffa <SDMMC_GetResponse>:
  *            @arg SDMMC_RESP3: Response Register 3
  *            @arg SDMMC_RESP4: Response Register 4
  * @retval The Corresponding response register value
  */
uint32_t SDMMC_GetResponse(SDMMC_TypeDef *SDMMCx, uint32_t Response)
{
90014ffa:	b480      	push	{r7}
90014ffc:	b085      	sub	sp, #20
90014ffe:	af00      	add	r7, sp, #0
90015000:	6078      	str	r0, [r7, #4]
90015002:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));

  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
90015004:	687b      	ldr	r3, [r7, #4]
90015006:	3314      	adds	r3, #20
90015008:	461a      	mov	r2, r3
9001500a:	683b      	ldr	r3, [r7, #0]
9001500c:	4413      	add	r3, r2
9001500e:	60fb      	str	r3, [r7, #12]

  return (*(__IO uint32_t *) tmp);
90015010:	68fb      	ldr	r3, [r7, #12]
90015012:	681b      	ldr	r3, [r3, #0]
}
90015014:	4618      	mov	r0, r3
90015016:	3714      	adds	r7, #20
90015018:	46bd      	mov	sp, r7
9001501a:	f85d 7b04 	ldr.w	r7, [sp], #4
9001501e:	4770      	bx	lr

90015020 <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, SDMMC_DataInitTypeDef *Data)
{
90015020:	b480      	push	{r7}
90015022:	b085      	sub	sp, #20
90015024:	af00      	add	r7, sp, #0
90015026:	6078      	str	r0, [r7, #4]
90015028:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
9001502a:	2300      	movs	r3, #0
9001502c:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
  assert_param(IS_SDMMC_DPSM(Data->DPSM));

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;
9001502e:	683b      	ldr	r3, [r7, #0]
90015030:	681a      	ldr	r2, [r3, #0]
90015032:	687b      	ldr	r3, [r7, #4]
90015034:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
90015036:	683b      	ldr	r3, [r7, #0]
90015038:	685a      	ldr	r2, [r3, #4]
9001503a:	687b      	ldr	r3, [r7, #4]
9001503c:	629a      	str	r2, [r3, #40]	; 0x28

  /* Set the SDMMC data configuration parameters */
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
9001503e:	683b      	ldr	r3, [r7, #0]
90015040:	689a      	ldr	r2, [r3, #8]
                       Data->TransferDir   | \
90015042:	683b      	ldr	r3, [r7, #0]
90015044:	68db      	ldr	r3, [r3, #12]
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
90015046:	431a      	orrs	r2, r3
                       Data->TransferMode  | \
90015048:	683b      	ldr	r3, [r7, #0]
9001504a:	691b      	ldr	r3, [r3, #16]
                       Data->TransferDir   | \
9001504c:	431a      	orrs	r2, r3
                       Data->DPSM);
9001504e:	683b      	ldr	r3, [r7, #0]
90015050:	695b      	ldr	r3, [r3, #20]
                       Data->TransferMode  | \
90015052:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Data->DataBlockSize | \
90015054:	68fa      	ldr	r2, [r7, #12]
90015056:	4313      	orrs	r3, r2
90015058:	60fb      	str	r3, [r7, #12]

  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
9001505a:	687b      	ldr	r3, [r7, #4]
9001505c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
9001505e:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
90015062:	68fb      	ldr	r3, [r7, #12]
90015064:	431a      	orrs	r2, r3
90015066:	687b      	ldr	r3, [r7, #4]
90015068:	62da      	str	r2, [r3, #44]	; 0x2c

  return HAL_OK;
9001506a:	2300      	movs	r3, #0

}
9001506c:	4618      	mov	r0, r3
9001506e:	3714      	adds	r7, #20
90015070:	46bd      	mov	sp, r7
90015072:	f85d 7b04 	ldr.w	r7, [sp], #4
90015076:	4770      	bx	lr

90015078 <SDMMC_CmdBlockLength>:
  * @brief  Send the Data Block Length command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDMMC_TypeDef *SDMMCx, uint32_t BlockSize)
{
90015078:	b580      	push	{r7, lr}
9001507a:	b088      	sub	sp, #32
9001507c:	af00      	add	r7, sp, #0
9001507e:	6078      	str	r0, [r7, #4]
90015080:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
90015082:	683b      	ldr	r3, [r7, #0]
90015084:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
90015086:	2310      	movs	r3, #16
90015088:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9001508a:	f44f 7380 	mov.w	r3, #256	; 0x100
9001508e:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90015090:	2300      	movs	r3, #0
90015092:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90015094:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90015098:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9001509a:	f107 0308 	add.w	r3, r7, #8
9001509e:	4619      	mov	r1, r3
900150a0:	6878      	ldr	r0, [r7, #4]
900150a2:	f7ff ff73 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
900150a6:	f241 3288 	movw	r2, #5000	; 0x1388
900150aa:	2110      	movs	r1, #16
900150ac:	6878      	ldr	r0, [r7, #4]
900150ae:	f000 fa65 	bl	9001557c <SDMMC_GetCmdResp1>
900150b2:	61f8      	str	r0, [r7, #28]

  return errorstate;
900150b4:	69fb      	ldr	r3, [r7, #28]
}
900150b6:	4618      	mov	r0, r3
900150b8:	3720      	adds	r7, #32
900150ba:	46bd      	mov	sp, r7
900150bc:	bd80      	pop	{r7, pc}

900150be <SDMMC_CmdReadSingleBlock>:
  * @brief  Send the Read Single Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
900150be:	b580      	push	{r7, lr}
900150c0:	b088      	sub	sp, #32
900150c2:	af00      	add	r7, sp, #0
900150c4:	6078      	str	r0, [r7, #4]
900150c6:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
900150c8:	683b      	ldr	r3, [r7, #0]
900150ca:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
900150cc:	2311      	movs	r3, #17
900150ce:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900150d0:	f44f 7380 	mov.w	r3, #256	; 0x100
900150d4:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900150d6:	2300      	movs	r3, #0
900150d8:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900150da:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900150de:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900150e0:	f107 0308 	add.w	r3, r7, #8
900150e4:	4619      	mov	r1, r3
900150e6:	6878      	ldr	r0, [r7, #4]
900150e8:	f7ff ff50 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
900150ec:	f241 3288 	movw	r2, #5000	; 0x1388
900150f0:	2111      	movs	r1, #17
900150f2:	6878      	ldr	r0, [r7, #4]
900150f4:	f000 fa42 	bl	9001557c <SDMMC_GetCmdResp1>
900150f8:	61f8      	str	r0, [r7, #28]

  return errorstate;
900150fa:	69fb      	ldr	r3, [r7, #28]
}
900150fc:	4618      	mov	r0, r3
900150fe:	3720      	adds	r7, #32
90015100:	46bd      	mov	sp, r7
90015102:	bd80      	pop	{r7, pc}

90015104 <SDMMC_CmdReadMultiBlock>:
  * @brief  Send the Read Multi Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
90015104:	b580      	push	{r7, lr}
90015106:	b088      	sub	sp, #32
90015108:	af00      	add	r7, sp, #0
9001510a:	6078      	str	r0, [r7, #4]
9001510c:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
9001510e:	683b      	ldr	r3, [r7, #0]
90015110:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
90015112:	2312      	movs	r3, #18
90015114:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90015116:	f44f 7380 	mov.w	r3, #256	; 0x100
9001511a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9001511c:	2300      	movs	r3, #0
9001511e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90015120:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90015124:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90015126:	f107 0308 	add.w	r3, r7, #8
9001512a:	4619      	mov	r1, r3
9001512c:	6878      	ldr	r0, [r7, #4]
9001512e:	f7ff ff2d 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
90015132:	f241 3288 	movw	r2, #5000	; 0x1388
90015136:	2112      	movs	r1, #18
90015138:	6878      	ldr	r0, [r7, #4]
9001513a:	f000 fa1f 	bl	9001557c <SDMMC_GetCmdResp1>
9001513e:	61f8      	str	r0, [r7, #28]

  return errorstate;
90015140:	69fb      	ldr	r3, [r7, #28]
}
90015142:	4618      	mov	r0, r3
90015144:	3720      	adds	r7, #32
90015146:	46bd      	mov	sp, r7
90015148:	bd80      	pop	{r7, pc}

9001514a <SDMMC_CmdWriteSingleBlock>:
  * @brief  Send the Write Single Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
9001514a:	b580      	push	{r7, lr}
9001514c:	b088      	sub	sp, #32
9001514e:	af00      	add	r7, sp, #0
90015150:	6078      	str	r0, [r7, #4]
90015152:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
90015154:	683b      	ldr	r3, [r7, #0]
90015156:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
90015158:	2318      	movs	r3, #24
9001515a:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9001515c:	f44f 7380 	mov.w	r3, #256	; 0x100
90015160:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90015162:	2300      	movs	r3, #0
90015164:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90015166:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9001516a:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9001516c:	f107 0308 	add.w	r3, r7, #8
90015170:	4619      	mov	r1, r3
90015172:	6878      	ldr	r0, [r7, #4]
90015174:	f7ff ff0a 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
90015178:	f241 3288 	movw	r2, #5000	; 0x1388
9001517c:	2118      	movs	r1, #24
9001517e:	6878      	ldr	r0, [r7, #4]
90015180:	f000 f9fc 	bl	9001557c <SDMMC_GetCmdResp1>
90015184:	61f8      	str	r0, [r7, #28]

  return errorstate;
90015186:	69fb      	ldr	r3, [r7, #28]
}
90015188:	4618      	mov	r0, r3
9001518a:	3720      	adds	r7, #32
9001518c:	46bd      	mov	sp, r7
9001518e:	bd80      	pop	{r7, pc}

90015190 <SDMMC_CmdWriteMultiBlock>:
  * @brief  Send the Write Multi Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
90015190:	b580      	push	{r7, lr}
90015192:	b088      	sub	sp, #32
90015194:	af00      	add	r7, sp, #0
90015196:	6078      	str	r0, [r7, #4]
90015198:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
9001519a:	683b      	ldr	r3, [r7, #0]
9001519c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
9001519e:	2319      	movs	r3, #25
900151a0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900151a2:	f44f 7380 	mov.w	r3, #256	; 0x100
900151a6:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900151a8:	2300      	movs	r3, #0
900151aa:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900151ac:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900151b0:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900151b2:	f107 0308 	add.w	r3, r7, #8
900151b6:	4619      	mov	r1, r3
900151b8:	6878      	ldr	r0, [r7, #4]
900151ba:	f7ff fee7 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
900151be:	f241 3288 	movw	r2, #5000	; 0x1388
900151c2:	2119      	movs	r1, #25
900151c4:	6878      	ldr	r0, [r7, #4]
900151c6:	f000 f9d9 	bl	9001557c <SDMMC_GetCmdResp1>
900151ca:	61f8      	str	r0, [r7, #28]

  return errorstate;
900151cc:	69fb      	ldr	r3, [r7, #28]
}
900151ce:	4618      	mov	r0, r3
900151d0:	3720      	adds	r7, #32
900151d2:	46bd      	mov	sp, r7
900151d4:	bd80      	pop	{r7, pc}

900151d6 <SDMMC_CmdEraseStartAdd>:
  * @brief  Send the Start Address Erase command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdEraseStartAdd(SDMMC_TypeDef *SDMMCx, uint32_t StartAdd)
{
900151d6:	b580      	push	{r7, lr}
900151d8:	b088      	sub	sp, #32
900151da:	af00      	add	r7, sp, #0
900151dc:	6078      	str	r0, [r7, #4]
900151de:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
900151e0:	683b      	ldr	r3, [r7, #0]
900151e2:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
900151e4:	2323      	movs	r3, #35	; 0x23
900151e6:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900151e8:	f44f 7380 	mov.w	r3, #256	; 0x100
900151ec:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900151ee:	2300      	movs	r3, #0
900151f0:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900151f2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900151f6:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900151f8:	f107 0308 	add.w	r3, r7, #8
900151fc:	4619      	mov	r1, r3
900151fe:	6878      	ldr	r0, [r7, #4]
90015200:	f7ff fec4 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE_GRP_START, SDMMC_CMDTIMEOUT);
90015204:	f241 3288 	movw	r2, #5000	; 0x1388
90015208:	2123      	movs	r1, #35	; 0x23
9001520a:	6878      	ldr	r0, [r7, #4]
9001520c:	f000 f9b6 	bl	9001557c <SDMMC_GetCmdResp1>
90015210:	61f8      	str	r0, [r7, #28]

  return errorstate;
90015212:	69fb      	ldr	r3, [r7, #28]
}
90015214:	4618      	mov	r0, r3
90015216:	3720      	adds	r7, #32
90015218:	46bd      	mov	sp, r7
9001521a:	bd80      	pop	{r7, pc}

9001521c <SDMMC_CmdEraseEndAdd>:
  * @brief  Send the End Address Erase command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdEraseEndAdd(SDMMC_TypeDef *SDMMCx, uint32_t EndAdd)
{
9001521c:	b580      	push	{r7, lr}
9001521e:	b088      	sub	sp, #32
90015220:	af00      	add	r7, sp, #0
90015222:	6078      	str	r0, [r7, #4]
90015224:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
90015226:	683b      	ldr	r3, [r7, #0]
90015228:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
9001522a:	2324      	movs	r3, #36	; 0x24
9001522c:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9001522e:	f44f 7380 	mov.w	r3, #256	; 0x100
90015232:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90015234:	2300      	movs	r3, #0
90015236:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90015238:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9001523c:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9001523e:	f107 0308 	add.w	r3, r7, #8
90015242:	4619      	mov	r1, r3
90015244:	6878      	ldr	r0, [r7, #4]
90015246:	f7ff fea1 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE_GRP_END, SDMMC_CMDTIMEOUT);
9001524a:	f241 3288 	movw	r2, #5000	; 0x1388
9001524e:	2124      	movs	r1, #36	; 0x24
90015250:	6878      	ldr	r0, [r7, #4]
90015252:	f000 f993 	bl	9001557c <SDMMC_GetCmdResp1>
90015256:	61f8      	str	r0, [r7, #28]

  return errorstate;
90015258:	69fb      	ldr	r3, [r7, #28]
}
9001525a:	4618      	mov	r0, r3
9001525c:	3720      	adds	r7, #32
9001525e:	46bd      	mov	sp, r7
90015260:	bd80      	pop	{r7, pc}

90015262 <SDMMC_CmdErase>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  EraseType Type of erase to be performed
  * @retval HAL status
  */
uint32_t SDMMC_CmdErase(SDMMC_TypeDef *SDMMCx, uint32_t EraseType)
{
90015262:	b580      	push	{r7, lr}
90015264:	b088      	sub	sp, #32
90015266:	af00      	add	r7, sp, #0
90015268:	6078      	str	r0, [r7, #4]
9001526a:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Set Block Size for Card */
  sdmmc_cmdinit.Argument         = EraseType;
9001526c:	683b      	ldr	r3, [r7, #0]
9001526e:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
90015270:	2326      	movs	r3, #38	; 0x26
90015272:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90015274:	f44f 7380 	mov.w	r3, #256	; 0x100
90015278:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9001527a:	2300      	movs	r3, #0
9001527c:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9001527e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90015282:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90015284:	f107 0308 	add.w	r3, r7, #8
90015288:	4619      	mov	r1, r3
9001528a:	6878      	ldr	r0, [r7, #4]
9001528c:	f7ff fe7e 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_ERASE, SDMMC_MAXERASETIMEOUT);
90015290:	f24f 6218 	movw	r2, #63000	; 0xf618
90015294:	2126      	movs	r1, #38	; 0x26
90015296:	6878      	ldr	r0, [r7, #4]
90015298:	f000 f970 	bl	9001557c <SDMMC_GetCmdResp1>
9001529c:	61f8      	str	r0, [r7, #28]

  return errorstate;
9001529e:	69fb      	ldr	r3, [r7, #28]
}
900152a0:	4618      	mov	r0, r3
900152a2:	3720      	adds	r7, #32
900152a4:	46bd      	mov	sp, r7
900152a6:	bd80      	pop	{r7, pc}

900152a8 <SDMMC_CmdStopTransfer>:
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDMMC_TypeDef *SDMMCx)
{
900152a8:	b580      	push	{r7, lr}
900152aa:	b088      	sub	sp, #32
900152ac:	af00      	add	r7, sp, #0
900152ae:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
900152b0:	2300      	movs	r3, #0
900152b2:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
900152b4:	230c      	movs	r3, #12
900152b6:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900152b8:	f44f 7380 	mov.w	r3, #256	; 0x100
900152bc:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900152be:	2300      	movs	r3, #0
900152c0:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900152c2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900152c6:	61bb      	str	r3, [r7, #24]

  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
900152c8:	687b      	ldr	r3, [r7, #4]
900152ca:	68db      	ldr	r3, [r3, #12]
900152cc:	f043 0280 	orr.w	r2, r3, #128	; 0x80
900152d0:	687b      	ldr	r3, [r7, #4]
900152d2:	60da      	str	r2, [r3, #12]
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
900152d4:	687b      	ldr	r3, [r7, #4]
900152d6:	68db      	ldr	r3, [r3, #12]
900152d8:	f023 0240 	bic.w	r2, r3, #64	; 0x40
900152dc:	687b      	ldr	r3, [r7, #4]
900152de:	60da      	str	r2, [r3, #12]

  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900152e0:	f107 0308 	add.w	r3, r7, #8
900152e4:	4619      	mov	r1, r3
900152e6:	6878      	ldr	r0, [r7, #4]
900152e8:	f7ff fe50 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
900152ec:	4a0b      	ldr	r2, [pc, #44]	; (9001531c <SDMMC_CmdStopTransfer+0x74>)
900152ee:	210c      	movs	r1, #12
900152f0:	6878      	ldr	r0, [r7, #4]
900152f2:	f000 f943 	bl	9001557c <SDMMC_GetCmdResp1>
900152f6:	61f8      	str	r0, [r7, #28]

  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
900152f8:	687b      	ldr	r3, [r7, #4]
900152fa:	68db      	ldr	r3, [r3, #12]
900152fc:	f023 0280 	bic.w	r2, r3, #128	; 0x80
90015300:	687b      	ldr	r3, [r7, #4]
90015302:	60da      	str	r2, [r3, #12]

  /* Ignore Address Out Of Range Error, Not relevant at end of memory */
  if (errorstate == SDMMC_ERROR_ADDR_OUT_OF_RANGE)
90015304:	69fb      	ldr	r3, [r7, #28]
90015306:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
9001530a:	d101      	bne.n	90015310 <SDMMC_CmdStopTransfer+0x68>
  {
    errorstate = SDMMC_ERROR_NONE;
9001530c:	2300      	movs	r3, #0
9001530e:	61fb      	str	r3, [r7, #28]
  }

  return errorstate;
90015310:	69fb      	ldr	r3, [r7, #28]
}
90015312:	4618      	mov	r0, r3
90015314:	3720      	adds	r7, #32
90015316:	46bd      	mov	sp, r7
90015318:	bd80      	pop	{r7, pc}
9001531a:	bf00      	nop
9001531c:	05f5e100 	.word	0x05f5e100

90015320 <SDMMC_CmdSelDesel>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  addr: Address of the card to be selected
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDMMC_TypeDef *SDMMCx, uint32_t Addr)
{
90015320:	b580      	push	{r7, lr}
90015322:	b088      	sub	sp, #32
90015324:	af00      	add	r7, sp, #0
90015326:	6078      	str	r0, [r7, #4]
90015328:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
9001532a:	683b      	ldr	r3, [r7, #0]
9001532c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
9001532e:	2307      	movs	r3, #7
90015330:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90015332:	f44f 7380 	mov.w	r3, #256	; 0x100
90015336:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90015338:	2300      	movs	r3, #0
9001533a:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9001533c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90015340:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90015342:	f107 0308 	add.w	r3, r7, #8
90015346:	4619      	mov	r1, r3
90015348:	6878      	ldr	r0, [r7, #4]
9001534a:	f7ff fe1f 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
9001534e:	f241 3288 	movw	r2, #5000	; 0x1388
90015352:	2107      	movs	r1, #7
90015354:	6878      	ldr	r0, [r7, #4]
90015356:	f000 f911 	bl	9001557c <SDMMC_GetCmdResp1>
9001535a:	61f8      	str	r0, [r7, #28]

  return errorstate;
9001535c:	69fb      	ldr	r3, [r7, #28]
}
9001535e:	4618      	mov	r0, r3
90015360:	3720      	adds	r7, #32
90015362:	46bd      	mov	sp, r7
90015364:	bd80      	pop	{r7, pc}

90015366 <SDMMC_CmdGoIdleState>:
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
90015366:	b580      	push	{r7, lr}
90015368:	b088      	sub	sp, #32
9001536a:	af00      	add	r7, sp, #0
9001536c:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = 0U;
9001536e:	2300      	movs	r3, #0
90015370:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
90015372:	2300      	movs	r3, #0
90015374:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
90015376:	2300      	movs	r3, #0
90015378:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9001537a:	2300      	movs	r3, #0
9001537c:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9001537e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90015382:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90015384:	f107 0308 	add.w	r3, r7, #8
90015388:	4619      	mov	r1, r3
9001538a:	6878      	ldr	r0, [r7, #4]
9001538c:	f7ff fdfe 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdError(SDMMCx);
90015390:	6878      	ldr	r0, [r7, #4]
90015392:	f000 fa6f 	bl	90015874 <SDMMC_GetCmdError>
90015396:	61f8      	str	r0, [r7, #28]

  return errorstate;
90015398:	69fb      	ldr	r3, [r7, #28]
}
9001539a:	4618      	mov	r0, r3
9001539c:	3720      	adds	r7, #32
9001539e:	46bd      	mov	sp, r7
900153a0:	bd80      	pop	{r7, pc}

900153a2 <SDMMC_CmdSendCID>:
  * @brief  Send the Send CID command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDMMC_TypeDef *SDMMCx)
{
900153a2:	b580      	push	{r7, lr}
900153a4:	b088      	sub	sp, #32
900153a6:	af00      	add	r7, sp, #0
900153a8:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
900153aa:	2300      	movs	r3, #0
900153ac:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
900153ae:	2302      	movs	r3, #2
900153b0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900153b2:	f44f 7340 	mov.w	r3, #768	; 0x300
900153b6:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900153b8:	2300      	movs	r3, #0
900153ba:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900153bc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900153c0:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900153c2:	f107 0308 	add.w	r3, r7, #8
900153c6:	4619      	mov	r1, r3
900153c8:	6878      	ldr	r0, [r7, #4]
900153ca:	f7ff fddf 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
900153ce:	6878      	ldr	r0, [r7, #4]
900153d0:	f000 f9c6 	bl	90015760 <SDMMC_GetCmdResp2>
900153d4:	61f8      	str	r0, [r7, #28]

  return errorstate;
900153d6:	69fb      	ldr	r3, [r7, #28]
}
900153d8:	4618      	mov	r0, r3
900153da:	3720      	adds	r7, #32
900153dc:	46bd      	mov	sp, r7
900153de:	bd80      	pop	{r7, pc}

900153e0 <SDMMC_CmdSendCSD>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
900153e0:	b580      	push	{r7, lr}
900153e2:	b088      	sub	sp, #32
900153e4:	af00      	add	r7, sp, #0
900153e6:	6078      	str	r0, [r7, #4]
900153e8:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
900153ea:	683b      	ldr	r3, [r7, #0]
900153ec:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
900153ee:	2309      	movs	r3, #9
900153f0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
900153f2:	f44f 7340 	mov.w	r3, #768	; 0x300
900153f6:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900153f8:	2300      	movs	r3, #0
900153fa:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900153fc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90015400:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90015402:	f107 0308 	add.w	r3, r7, #8
90015406:	4619      	mov	r1, r3
90015408:	6878      	ldr	r0, [r7, #4]
9001540a:	f7ff fdbf 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
9001540e:	6878      	ldr	r0, [r7, #4]
90015410:	f000 f9a6 	bl	90015760 <SDMMC_GetCmdResp2>
90015414:	61f8      	str	r0, [r7, #28]

  return errorstate;
90015416:	69fb      	ldr	r3, [r7, #28]
}
90015418:	4618      	mov	r0, r3
9001541a:	3720      	adds	r7, #32
9001541c:	46bd      	mov	sp, r7
9001541e:	bd80      	pop	{r7, pc}

90015420 <SDMMC_CmdSetRelAddMmc>:
  * @param  SDMMCx Pointer to SDMMC register base
  * @param  RCA Card RCA
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAddMmc(SDMMC_TypeDef *SDMMCx, uint16_t RCA)
{
90015420:	b580      	push	{r7, lr}
90015422:	b088      	sub	sp, #32
90015424:	af00      	add	r7, sp, #0
90015426:	6078      	str	r0, [r7, #4]
90015428:	460b      	mov	r3, r1
9001542a:	807b      	strh	r3, [r7, #2]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = ((uint32_t)RCA << 16U);
9001542c:	887b      	ldrh	r3, [r7, #2]
9001542e:	041b      	lsls	r3, r3, #16
90015430:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
90015432:	2303      	movs	r3, #3
90015434:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90015436:	f44f 7380 	mov.w	r3, #256	; 0x100
9001543a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9001543c:	2300      	movs	r3, #0
9001543e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90015440:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90015444:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90015446:	f107 0308 	add.w	r3, r7, #8
9001544a:	4619      	mov	r1, r3
9001544c:	6878      	ldr	r0, [r7, #4]
9001544e:	f7ff fd9d 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_REL_ADDR, SDMMC_CMDTIMEOUT);
90015452:	f241 3288 	movw	r2, #5000	; 0x1388
90015456:	2103      	movs	r1, #3
90015458:	6878      	ldr	r0, [r7, #4]
9001545a:	f000 f88f 	bl	9001557c <SDMMC_GetCmdResp1>
9001545e:	61f8      	str	r0, [r7, #28]

  return errorstate;
90015460:	69fb      	ldr	r3, [r7, #28]
}
90015462:	4618      	mov	r0, r3
90015464:	3720      	adds	r7, #32
90015466:	46bd      	mov	sp, r7
90015468:	bd80      	pop	{r7, pc}

9001546a <SDMMC_CmdSendStatus>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
9001546a:	b580      	push	{r7, lr}
9001546c:	b088      	sub	sp, #32
9001546e:	af00      	add	r7, sp, #0
90015470:	6078      	str	r0, [r7, #4]
90015472:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
90015474:	683b      	ldr	r3, [r7, #0]
90015476:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
90015478:	230d      	movs	r3, #13
9001547a:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
9001547c:	f44f 7380 	mov.w	r3, #256	; 0x100
90015480:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90015482:	2300      	movs	r3, #0
90015484:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90015486:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9001548a:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
9001548c:	f107 0308 	add.w	r3, r7, #8
90015490:	4619      	mov	r1, r3
90015492:	6878      	ldr	r0, [r7, #4]
90015494:	f7ff fd7a 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
90015498:	f241 3288 	movw	r2, #5000	; 0x1388
9001549c:	210d      	movs	r1, #13
9001549e:	6878      	ldr	r0, [r7, #4]
900154a0:	f000 f86c 	bl	9001557c <SDMMC_GetCmdResp1>
900154a4:	61f8      	str	r0, [r7, #28]

  return errorstate;
900154a6:	69fb      	ldr	r3, [r7, #28]
}
900154a8:	4618      	mov	r0, r3
900154aa:	3720      	adds	r7, #32
900154ac:	46bd      	mov	sp, r7
900154ae:	bd80      	pop	{r7, pc}

900154b0 <SDMMC_CmdOpCondition>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdOpCondition(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
900154b0:	b580      	push	{r7, lr}
900154b2:	b088      	sub	sp, #32
900154b4:	af00      	add	r7, sp, #0
900154b6:	6078      	str	r0, [r7, #4]
900154b8:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  sdmmc_cmdinit.Argument         = Argument;
900154ba:	683b      	ldr	r3, [r7, #0]
900154bc:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_OP_COND;
900154be:	2301      	movs	r3, #1
900154c0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
900154c2:	f44f 7380 	mov.w	r3, #256	; 0x100
900154c6:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
900154c8:	2300      	movs	r3, #0
900154ca:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
900154cc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900154d0:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
900154d2:	f107 0308 	add.w	r3, r7, #8
900154d6:	4619      	mov	r1, r3
900154d8:	6878      	ldr	r0, [r7, #4]
900154da:	f7ff fd57 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
900154de:	6878      	ldr	r0, [r7, #4]
900154e0:	f000 f988 	bl	900157f4 <SDMMC_GetCmdResp3>
900154e4:	61f8      	str	r0, [r7, #28]

  return errorstate;
900154e6:	69fb      	ldr	r3, [r7, #28]
}
900154e8:	4618      	mov	r0, r3
900154ea:	3720      	adds	r7, #32
900154ec:	46bd      	mov	sp, r7
900154ee:	bd80      	pop	{r7, pc}

900154f0 <SDMMC_CmdSwitch>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @parame Argument: Argument used for the command
  * @retval HAL status
  */
uint32_t SDMMC_CmdSwitch(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
900154f0:	b580      	push	{r7, lr}
900154f2:	b088      	sub	sp, #32
900154f4:	af00      	add	r7, sp, #0
900154f6:	6078      	str	r0, [r7, #4]
900154f8:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD6 to activate SDR50 Mode and Power Limit 1.44W */
  /* CMD Response: R1 */
  sdmmc_cmdinit.Argument         = Argument; /* SDMMC_SDR25_SWITCH_PATTERN*/
900154fa:	683b      	ldr	r3, [r7, #0]
900154fc:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
900154fe:	2306      	movs	r3, #6
90015500:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90015502:	f44f 7380 	mov.w	r3, #256	; 0x100
90015506:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
90015508:	2300      	movs	r3, #0
9001550a:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
9001550c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90015510:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90015512:	f107 0308 	add.w	r3, r7, #8
90015516:	4619      	mov	r1, r3
90015518:	6878      	ldr	r0, [r7, #4]
9001551a:	f7ff fd37 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_HS_SWITCH, SDMMC_CMDTIMEOUT);
9001551e:	f241 3288 	movw	r2, #5000	; 0x1388
90015522:	2106      	movs	r1, #6
90015524:	6878      	ldr	r0, [r7, #4]
90015526:	f000 f829 	bl	9001557c <SDMMC_GetCmdResp1>
9001552a:	61f8      	str	r0, [r7, #28]

  return errorstate;
9001552c:	69fb      	ldr	r3, [r7, #28]
}
9001552e:	4618      	mov	r0, r3
90015530:	3720      	adds	r7, #32
90015532:	46bd      	mov	sp, r7
90015534:	bd80      	pop	{r7, pc}

90015536 <SDMMC_CmdSendEXTCSD>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendEXTCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
90015536:	b580      	push	{r7, lr}
90015538:	b088      	sub	sp, #32
9001553a:	af00      	add	r7, sp, #0
9001553c:	6078      	str	r0, [r7, #4]
9001553e:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;

  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
90015540:	683b      	ldr	r3, [r7, #0]
90015542:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
90015544:	2308      	movs	r3, #8
90015546:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
90015548:	f44f 7380 	mov.w	r3, #256	; 0x100
9001554c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
9001554e:	2300      	movs	r3, #0
90015550:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
90015552:	f44f 5380 	mov.w	r3, #4096	; 0x1000
90015556:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
90015558:	f107 0308 	add.w	r3, r7, #8
9001555c:	4619      	mov	r1, r3
9001555e:	6878      	ldr	r0, [r7, #4]
90015560:	f7ff fd14 	bl	90014f8c <SDMMC_SendCommand>

  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_HS_SEND_EXT_CSD, SDMMC_CMDTIMEOUT);
90015564:	f241 3288 	movw	r2, #5000	; 0x1388
90015568:	2108      	movs	r1, #8
9001556a:	6878      	ldr	r0, [r7, #4]
9001556c:	f000 f806 	bl	9001557c <SDMMC_GetCmdResp1>
90015570:	61f8      	str	r0, [r7, #28]

  return errorstate;
90015572:	69fb      	ldr	r3, [r7, #28]
}
90015574:	4618      	mov	r0, r3
90015576:	3720      	adds	r7, #32
90015578:	46bd      	mov	sp, r7
9001557a:	bd80      	pop	{r7, pc}

9001557c <SDMMC_GetCmdResp1>:
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp1(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint32_t Timeout)
{
9001557c:	b580      	push	{r7, lr}
9001557e:	b088      	sub	sp, #32
90015580:	af00      	add	r7, sp, #0
90015582:	60f8      	str	r0, [r7, #12]
90015584:	460b      	mov	r3, r1
90015586:	607a      	str	r2, [r7, #4]
90015588:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U / 1000U);
9001558a:	4b70      	ldr	r3, [pc, #448]	; (9001574c <SDMMC_GetCmdResp1+0x1d0>)
9001558c:	681b      	ldr	r3, [r3, #0]
9001558e:	4a70      	ldr	r2, [pc, #448]	; (90015750 <SDMMC_GetCmdResp1+0x1d4>)
90015590:	fba2 2303 	umull	r2, r3, r2, r3
90015594:	0a5a      	lsrs	r2, r3, #9
90015596:	687b      	ldr	r3, [r7, #4]
90015598:	fb02 f303 	mul.w	r3, r2, r3
9001559c:	61fb      	str	r3, [r7, #28]

  do
  {
    if (count-- == 0U)
9001559e:	69fb      	ldr	r3, [r7, #28]
900155a0:	1e5a      	subs	r2, r3, #1
900155a2:	61fa      	str	r2, [r7, #28]
900155a4:	2b00      	cmp	r3, #0
900155a6:	d102      	bne.n	900155ae <SDMMC_GetCmdResp1+0x32>
    {
      return SDMMC_ERROR_TIMEOUT;
900155a8:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
900155ac:	e0c9      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
    }
    sta_reg = SDMMCx->STA;
900155ae:	68fb      	ldr	r3, [r7, #12]
900155b0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900155b2:	61bb      	str	r3, [r7, #24]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT |
900155b4:	69ba      	ldr	r2, [r7, #24]
900155b6:	4b67      	ldr	r3, [pc, #412]	; (90015754 <SDMMC_GetCmdResp1+0x1d8>)
900155b8:	4013      	ands	r3, r2
                        SDMMC_FLAG_BUSYD0END)) == 0U) || ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
900155ba:	2b00      	cmp	r3, #0
900155bc:	d0ef      	beq.n	9001559e <SDMMC_GetCmdResp1+0x22>
900155be:	69bb      	ldr	r3, [r7, #24]
900155c0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
900155c4:	2b00      	cmp	r3, #0
900155c6:	d1ea      	bne.n	9001559e <SDMMC_GetCmdResp1+0x22>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
900155c8:	68fb      	ldr	r3, [r7, #12]
900155ca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900155cc:	f003 0304 	and.w	r3, r3, #4
900155d0:	2b00      	cmp	r3, #0
900155d2:	d004      	beq.n	900155de <SDMMC_GetCmdResp1+0x62>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
900155d4:	68fb      	ldr	r3, [r7, #12]
900155d6:	2204      	movs	r2, #4
900155d8:	639a      	str	r2, [r3, #56]	; 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
900155da:	2304      	movs	r3, #4
900155dc:	e0b1      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
900155de:	68fb      	ldr	r3, [r7, #12]
900155e0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900155e2:	f003 0301 	and.w	r3, r3, #1
900155e6:	2b00      	cmp	r3, #0
900155e8:	d004      	beq.n	900155f4 <SDMMC_GetCmdResp1+0x78>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
900155ea:	68fb      	ldr	r3, [r7, #12]
900155ec:	2201      	movs	r2, #1
900155ee:	639a      	str	r2, [r3, #56]	; 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
900155f0:	2301      	movs	r3, #1
900155f2:	e0a6      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  {
    /* Nothing to do */
  }

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
900155f4:	68fb      	ldr	r3, [r7, #12]
900155f6:	4a58      	ldr	r2, [pc, #352]	; (90015758 <SDMMC_GetCmdResp1+0x1dc>)
900155f8:	639a      	str	r2, [r3, #56]	; 0x38

  /* Check response received is of desired command */
  if (SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
900155fa:	68f8      	ldr	r0, [r7, #12]
900155fc:	f7ff fcf0 	bl	90014fe0 <SDMMC_GetCommandResponse>
90015600:	4603      	mov	r3, r0
90015602:	461a      	mov	r2, r3
90015604:	7afb      	ldrb	r3, [r7, #11]
90015606:	4293      	cmp	r3, r2
90015608:	d001      	beq.n	9001560e <SDMMC_GetCmdResp1+0x92>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
9001560a:	2301      	movs	r3, #1
9001560c:	e099      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
9001560e:	2100      	movs	r1, #0
90015610:	68f8      	ldr	r0, [r7, #12]
90015612:	f7ff fcf2 	bl	90014ffa <SDMMC_GetResponse>
90015616:	6178      	str	r0, [r7, #20]

  if ((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
90015618:	697a      	ldr	r2, [r7, #20]
9001561a:	4b50      	ldr	r3, [pc, #320]	; (9001575c <SDMMC_GetCmdResp1+0x1e0>)
9001561c:	4013      	ands	r3, r2
9001561e:	2b00      	cmp	r3, #0
90015620:	d101      	bne.n	90015626 <SDMMC_GetCmdResp1+0xaa>
  {
    return SDMMC_ERROR_NONE;
90015622:	2300      	movs	r3, #0
90015624:	e08d      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
90015626:	697b      	ldr	r3, [r7, #20]
90015628:	2b00      	cmp	r3, #0
9001562a:	da02      	bge.n	90015632 <SDMMC_GetCmdResp1+0xb6>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
9001562c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
90015630:	e087      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
90015632:	697b      	ldr	r3, [r7, #20]
90015634:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
90015638:	2b00      	cmp	r3, #0
9001563a:	d001      	beq.n	90015640 <SDMMC_GetCmdResp1+0xc4>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
9001563c:	2340      	movs	r3, #64	; 0x40
9001563e:	e080      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
90015640:	697b      	ldr	r3, [r7, #20]
90015642:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
90015646:	2b00      	cmp	r3, #0
90015648:	d001      	beq.n	9001564e <SDMMC_GetCmdResp1+0xd2>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
9001564a:	2380      	movs	r3, #128	; 0x80
9001564c:	e079      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
9001564e:	697b      	ldr	r3, [r7, #20]
90015650:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
90015654:	2b00      	cmp	r3, #0
90015656:	d002      	beq.n	9001565e <SDMMC_GetCmdResp1+0xe2>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
90015658:	f44f 7380 	mov.w	r3, #256	; 0x100
9001565c:	e071      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
9001565e:	697b      	ldr	r3, [r7, #20]
90015660:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
90015664:	2b00      	cmp	r3, #0
90015666:	d002      	beq.n	9001566e <SDMMC_GetCmdResp1+0xf2>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
90015668:	f44f 7300 	mov.w	r3, #512	; 0x200
9001566c:	e069      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
9001566e:	697b      	ldr	r3, [r7, #20]
90015670:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
90015674:	2b00      	cmp	r3, #0
90015676:	d002      	beq.n	9001567e <SDMMC_GetCmdResp1+0x102>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
90015678:	f44f 6380 	mov.w	r3, #1024	; 0x400
9001567c:	e061      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
9001567e:	697b      	ldr	r3, [r7, #20]
90015680:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
90015684:	2b00      	cmp	r3, #0
90015686:	d002      	beq.n	9001568e <SDMMC_GetCmdResp1+0x112>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
90015688:	f44f 6300 	mov.w	r3, #2048	; 0x800
9001568c:	e059      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
9001568e:	697b      	ldr	r3, [r7, #20]
90015690:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
90015694:	2b00      	cmp	r3, #0
90015696:	d002      	beq.n	9001569e <SDMMC_GetCmdResp1+0x122>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
90015698:	f44f 5380 	mov.w	r3, #4096	; 0x1000
9001569c:	e051      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
9001569e:	697b      	ldr	r3, [r7, #20]
900156a0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
900156a4:	2b00      	cmp	r3, #0
900156a6:	d002      	beq.n	900156ae <SDMMC_GetCmdResp1+0x132>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
900156a8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
900156ac:	e049      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
900156ae:	697b      	ldr	r3, [r7, #20]
900156b0:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
900156b4:	2b00      	cmp	r3, #0
900156b6:	d002      	beq.n	900156be <SDMMC_GetCmdResp1+0x142>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
900156b8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
900156bc:	e041      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
900156be:	697b      	ldr	r3, [r7, #20]
900156c0:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
900156c4:	2b00      	cmp	r3, #0
900156c6:	d002      	beq.n	900156ce <SDMMC_GetCmdResp1+0x152>
  {
    return SDMMC_ERROR_CC_ERR;
900156c8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
900156cc:	e039      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
900156ce:	697b      	ldr	r3, [r7, #20]
900156d0:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
900156d4:	2b00      	cmp	r3, #0
900156d6:	d002      	beq.n	900156de <SDMMC_GetCmdResp1+0x162>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
900156d8:	f44f 3300 	mov.w	r3, #131072	; 0x20000
900156dc:	e031      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
900156de:	697b      	ldr	r3, [r7, #20]
900156e0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
900156e4:	2b00      	cmp	r3, #0
900156e6:	d002      	beq.n	900156ee <SDMMC_GetCmdResp1+0x172>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
900156e8:	f44f 2380 	mov.w	r3, #262144	; 0x40000
900156ec:	e029      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
900156ee:	697b      	ldr	r3, [r7, #20]
900156f0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
900156f4:	2b00      	cmp	r3, #0
900156f6:	d002      	beq.n	900156fe <SDMMC_GetCmdResp1+0x182>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
900156f8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
900156fc:	e021      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
900156fe:	697b      	ldr	r3, [r7, #20]
90015700:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
90015704:	2b00      	cmp	r3, #0
90015706:	d002      	beq.n	9001570e <SDMMC_GetCmdResp1+0x192>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
90015708:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
9001570c:	e019      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
9001570e:	697b      	ldr	r3, [r7, #20]
90015710:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
90015714:	2b00      	cmp	r3, #0
90015716:	d002      	beq.n	9001571e <SDMMC_GetCmdResp1+0x1a2>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
90015718:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
9001571c:	e011      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
9001571e:	697b      	ldr	r3, [r7, #20]
90015720:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
90015724:	2b00      	cmp	r3, #0
90015726:	d002      	beq.n	9001572e <SDMMC_GetCmdResp1+0x1b2>
  {
    return SDMMC_ERROR_ERASE_RESET;
90015728:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
9001572c:	e009      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else if ((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
9001572e:	697b      	ldr	r3, [r7, #20]
90015730:	f003 0308 	and.w	r3, r3, #8
90015734:	2b00      	cmp	r3, #0
90015736:	d002      	beq.n	9001573e <SDMMC_GetCmdResp1+0x1c2>
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
90015738:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
9001573c:	e001      	b.n	90015742 <SDMMC_GetCmdResp1+0x1c6>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
9001573e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  }
}
90015742:	4618      	mov	r0, r3
90015744:	3720      	adds	r7, #32
90015746:	46bd      	mov	sp, r7
90015748:	bd80      	pop	{r7, pc}
9001574a:	bf00      	nop
9001574c:	24000090 	.word	0x24000090
90015750:	10624dd3 	.word	0x10624dd3
90015754:	00200045 	.word	0x00200045
90015758:	002000c5 	.word	0x002000c5
9001575c:	fdffe008 	.word	0xfdffe008

90015760 <SDMMC_GetCmdResp2>:
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
90015760:	b480      	push	{r7}
90015762:	b085      	sub	sp, #20
90015764:	af00      	add	r7, sp, #0
90015766:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
90015768:	4b1f      	ldr	r3, [pc, #124]	; (900157e8 <SDMMC_GetCmdResp2+0x88>)
9001576a:	681b      	ldr	r3, [r3, #0]
9001576c:	4a1f      	ldr	r2, [pc, #124]	; (900157ec <SDMMC_GetCmdResp2+0x8c>)
9001576e:	fba2 2303 	umull	r2, r3, r2, r3
90015772:	0a5b      	lsrs	r3, r3, #9
90015774:	f241 3288 	movw	r2, #5000	; 0x1388
90015778:	fb02 f303 	mul.w	r3, r2, r3
9001577c:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
9001577e:	68fb      	ldr	r3, [r7, #12]
90015780:	1e5a      	subs	r2, r3, #1
90015782:	60fa      	str	r2, [r7, #12]
90015784:	2b00      	cmp	r3, #0
90015786:	d102      	bne.n	9001578e <SDMMC_GetCmdResp2+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
90015788:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
9001578c:	e026      	b.n	900157dc <SDMMC_GetCmdResp2+0x7c>
    }
    sta_reg = SDMMCx->STA;
9001578e:	687b      	ldr	r3, [r7, #4]
90015790:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90015792:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90015794:	68bb      	ldr	r3, [r7, #8]
90015796:	f003 0345 	and.w	r3, r3, #69	; 0x45
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
9001579a:	2b00      	cmp	r3, #0
9001579c:	d0ef      	beq.n	9001577e <SDMMC_GetCmdResp2+0x1e>
9001579e:	68bb      	ldr	r3, [r7, #8]
900157a0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
900157a4:	2b00      	cmp	r3, #0
900157a6:	d1ea      	bne.n	9001577e <SDMMC_GetCmdResp2+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
900157a8:	687b      	ldr	r3, [r7, #4]
900157aa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900157ac:	f003 0304 	and.w	r3, r3, #4
900157b0:	2b00      	cmp	r3, #0
900157b2:	d004      	beq.n	900157be <SDMMC_GetCmdResp2+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
900157b4:	687b      	ldr	r3, [r7, #4]
900157b6:	2204      	movs	r2, #4
900157b8:	639a      	str	r2, [r3, #56]	; 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
900157ba:	2304      	movs	r3, #4
900157bc:	e00e      	b.n	900157dc <SDMMC_GetCmdResp2+0x7c>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
900157be:	687b      	ldr	r3, [r7, #4]
900157c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900157c2:	f003 0301 	and.w	r3, r3, #1
900157c6:	2b00      	cmp	r3, #0
900157c8:	d004      	beq.n	900157d4 <SDMMC_GetCmdResp2+0x74>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
900157ca:	687b      	ldr	r3, [r7, #4]
900157cc:	2201      	movs	r2, #1
900157ce:	639a      	str	r2, [r3, #56]	; 0x38

    return SDMMC_ERROR_CMD_CRC_FAIL;
900157d0:	2301      	movs	r3, #1
900157d2:	e003      	b.n	900157dc <SDMMC_GetCmdResp2+0x7c>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
900157d4:	687b      	ldr	r3, [r7, #4]
900157d6:	4a06      	ldr	r2, [pc, #24]	; (900157f0 <SDMMC_GetCmdResp2+0x90>)
900157d8:	639a      	str	r2, [r3, #56]	; 0x38
  }

  return SDMMC_ERROR_NONE;
900157da:	2300      	movs	r3, #0
}
900157dc:	4618      	mov	r0, r3
900157de:	3714      	adds	r7, #20
900157e0:	46bd      	mov	sp, r7
900157e2:	f85d 7b04 	ldr.w	r7, [sp], #4
900157e6:	4770      	bx	lr
900157e8:	24000090 	.word	0x24000090
900157ec:	10624dd3 	.word	0x10624dd3
900157f0:	002000c5 	.word	0x002000c5

900157f4 <SDMMC_GetCmdResp3>:
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
900157f4:	b480      	push	{r7}
900157f6:	b085      	sub	sp, #20
900157f8:	af00      	add	r7, sp, #0
900157fa:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
900157fc:	4b1a      	ldr	r3, [pc, #104]	; (90015868 <SDMMC_GetCmdResp3+0x74>)
900157fe:	681b      	ldr	r3, [r3, #0]
90015800:	4a1a      	ldr	r2, [pc, #104]	; (9001586c <SDMMC_GetCmdResp3+0x78>)
90015802:	fba2 2303 	umull	r2, r3, r2, r3
90015806:	0a5b      	lsrs	r3, r3, #9
90015808:	f241 3288 	movw	r2, #5000	; 0x1388
9001580c:	fb02 f303 	mul.w	r3, r2, r3
90015810:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
90015812:	68fb      	ldr	r3, [r7, #12]
90015814:	1e5a      	subs	r2, r3, #1
90015816:	60fa      	str	r2, [r7, #12]
90015818:	2b00      	cmp	r3, #0
9001581a:	d102      	bne.n	90015822 <SDMMC_GetCmdResp3+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
9001581c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
90015820:	e01b      	b.n	9001585a <SDMMC_GetCmdResp3+0x66>
    }
    sta_reg = SDMMCx->STA;
90015822:	687b      	ldr	r3, [r7, #4]
90015824:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90015826:	60bb      	str	r3, [r7, #8]
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90015828:	68bb      	ldr	r3, [r7, #8]
9001582a:	f003 0345 	and.w	r3, r3, #69	; 0x45
           ((sta_reg & SDMMC_FLAG_CMDACT) != 0U));
9001582e:	2b00      	cmp	r3, #0
90015830:	d0ef      	beq.n	90015812 <SDMMC_GetCmdResp3+0x1e>
90015832:	68bb      	ldr	r3, [r7, #8]
90015834:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  } while (((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
90015838:	2b00      	cmp	r3, #0
9001583a:	d1ea      	bne.n	90015812 <SDMMC_GetCmdResp3+0x1e>

  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
9001583c:	687b      	ldr	r3, [r7, #4]
9001583e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
90015840:	f003 0304 	and.w	r3, r3, #4
90015844:	2b00      	cmp	r3, #0
90015846:	d004      	beq.n	90015852 <SDMMC_GetCmdResp3+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
90015848:	687b      	ldr	r3, [r7, #4]
9001584a:	2204      	movs	r2, #4
9001584c:	639a      	str	r2, [r3, #56]	; 0x38

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
9001584e:	2304      	movs	r3, #4
90015850:	e003      	b.n	9001585a <SDMMC_GetCmdResp3+0x66>
  }
  else
  {
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
90015852:	687b      	ldr	r3, [r7, #4]
90015854:	4a06      	ldr	r2, [pc, #24]	; (90015870 <SDMMC_GetCmdResp3+0x7c>)
90015856:	639a      	str	r2, [r3, #56]	; 0x38
  }

  return SDMMC_ERROR_NONE;
90015858:	2300      	movs	r3, #0
}
9001585a:	4618      	mov	r0, r3
9001585c:	3714      	adds	r7, #20
9001585e:	46bd      	mov	sp, r7
90015860:	f85d 7b04 	ldr.w	r7, [sp], #4
90015864:	4770      	bx	lr
90015866:	bf00      	nop
90015868:	24000090 	.word	0x24000090
9001586c:	10624dd3 	.word	0x10624dd3
90015870:	002000c5 	.word	0x002000c5

90015874 <SDMMC_GetCmdError>:
  * @brief  Checks for error conditions for CMD0.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
90015874:	b480      	push	{r7}
90015876:	b085      	sub	sp, #20
90015878:	af00      	add	r7, sp, #0
9001587a:	6078      	str	r0, [r7, #4]
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U / 1000U);
9001587c:	4b11      	ldr	r3, [pc, #68]	; (900158c4 <SDMMC_GetCmdError+0x50>)
9001587e:	681b      	ldr	r3, [r3, #0]
90015880:	4a11      	ldr	r2, [pc, #68]	; (900158c8 <SDMMC_GetCmdError+0x54>)
90015882:	fba2 2303 	umull	r2, r3, r2, r3
90015886:	0a5b      	lsrs	r3, r3, #9
90015888:	f241 3288 	movw	r2, #5000	; 0x1388
9001588c:	fb02 f303 	mul.w	r3, r2, r3
90015890:	60fb      	str	r3, [r7, #12]

  do
  {
    if (count-- == 0U)
90015892:	68fb      	ldr	r3, [r7, #12]
90015894:	1e5a      	subs	r2, r3, #1
90015896:	60fa      	str	r2, [r7, #12]
90015898:	2b00      	cmp	r3, #0
9001589a:	d102      	bne.n	900158a2 <SDMMC_GetCmdError+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
9001589c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
900158a0:	e009      	b.n	900158b6 <SDMMC_GetCmdError+0x42>
    }

  } while (!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
900158a2:	687b      	ldr	r3, [r7, #4]
900158a4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
900158a6:	f003 0380 	and.w	r3, r3, #128	; 0x80
900158aa:	2b00      	cmp	r3, #0
900158ac:	d0f1      	beq.n	90015892 <SDMMC_GetCmdError+0x1e>

  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
900158ae:	687b      	ldr	r3, [r7, #4]
900158b0:	4a06      	ldr	r2, [pc, #24]	; (900158cc <SDMMC_GetCmdError+0x58>)
900158b2:	639a      	str	r2, [r3, #56]	; 0x38

  return SDMMC_ERROR_NONE;
900158b4:	2300      	movs	r3, #0
}
900158b6:	4618      	mov	r0, r3
900158b8:	3714      	adds	r7, #20
900158ba:	46bd      	mov	sp, r7
900158bc:	f85d 7b04 	ldr.w	r7, [sp], #4
900158c0:	4770      	bx	lr
900158c2:	bf00      	nop
900158c4:	24000090 	.word	0x24000090
900158c8:	10624dd3 	.word	0x10624dd3
900158cc:	002000c5 	.word	0x002000c5

900158d0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
900158d0:	f8df d034 	ldr.w	sp, [pc, #52]	; 90015908 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
900158d4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
900158d6:	e003      	b.n	900158e0 <LoopCopyDataInit>

900158d8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
900158d8:	4b0c      	ldr	r3, [pc, #48]	; (9001590c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
900158da:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
900158dc:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
900158de:	3104      	adds	r1, #4

900158e0 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
900158e0:	480b      	ldr	r0, [pc, #44]	; (90015910 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
900158e2:	4b0c      	ldr	r3, [pc, #48]	; (90015914 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
900158e4:	1842      	adds	r2, r0, r1
  cmp  r2, r3
900158e6:	429a      	cmp	r2, r3
  bcc  CopyDataInit
900158e8:	d3f6      	bcc.n	900158d8 <CopyDataInit>
  ldr  r2, =_sbss
900158ea:	4a0b      	ldr	r2, [pc, #44]	; (90015918 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
900158ec:	e002      	b.n	900158f4 <LoopFillZerobss>

900158ee <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
900158ee:	2300      	movs	r3, #0
  str  r3, [r2], #4
900158f0:	f842 3b04 	str.w	r3, [r2], #4

900158f4 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
900158f4:	4b09      	ldr	r3, [pc, #36]	; (9001591c <LoopFillZerobss+0x28>)
  cmp  r2, r3
900158f6:	429a      	cmp	r2, r3
  bcc  FillZerobss
900158f8:	d3f9      	bcc.n	900158ee <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
900158fa:	f7f3 fc73 	bl	900091e4 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
900158fe:	f004 f91d 	bl	90019b3c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
90015902:	f001 fa5d 	bl	90016dc0 <main>
  bx  lr    
90015906:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
90015908:	24080000 	.word	0x24080000
  ldr  r3, =_sidata
9001590c:	90025964 	.word	0x90025964
  ldr  r0, =_sdata
90015910:	24000000 	.word	0x24000000
  ldr  r3, =_edata
90015914:	24001160 	.word	0x24001160
  ldr  r2, =_sbss
90015918:	24001160 	.word	0x24001160
  ldr  r3, = _ebss
9001591c:	2400b444 	.word	0x2400b444

90015920 <ADC3_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
90015920:	e7fe      	b.n	90015920 <ADC3_IRQHandler>
	...

90015924 <_sbrk>:




caddr_t _sbrk(int incr)
{
90015924:	b580      	push	{r7, lr}
90015926:	b084      	sub	sp, #16
90015928:	af00      	add	r7, sp, #0
9001592a:	6078      	str	r0, [r7, #4]
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end,*min_stack_ptr;

	if (heap_end == 0)
9001592c:	4b15      	ldr	r3, [pc, #84]	; (90015984 <_sbrk+0x60>)
9001592e:	681b      	ldr	r3, [r3, #0]
90015930:	2b00      	cmp	r3, #0
90015932:	d102      	bne.n	9001593a <_sbrk+0x16>
		heap_end = &end;
90015934:	4b13      	ldr	r3, [pc, #76]	; (90015984 <_sbrk+0x60>)
90015936:	4a14      	ldr	r2, [pc, #80]	; (90015988 <_sbrk+0x64>)
90015938:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
9001593a:	4b12      	ldr	r3, [pc, #72]	; (90015984 <_sbrk+0x60>)
9001593c:	681b      	ldr	r3, [r3, #0]
9001593e:	60fb      	str	r3, [r7, #12]

#ifdef FreeRTOS
	/* Use the NVIC offset register to locate the main stack pointer. */
	min_stack_ptr = (char*)(*(unsigned int *)*(unsigned int *)0xE000ED08);
90015940:	4b12      	ldr	r3, [pc, #72]	; (9001598c <_sbrk+0x68>)
90015942:	681b      	ldr	r3, [r3, #0]
90015944:	681b      	ldr	r3, [r3, #0]
90015946:	60bb      	str	r3, [r7, #8]
	/* Locate the STACK bottom address */
	min_stack_ptr -= MAX_STACK_SIZE;
90015948:	68bb      	ldr	r3, [r7, #8]
9001594a:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
9001594e:	60bb      	str	r3, [r7, #8]

	if (heap_end + incr > min_stack_ptr)
90015950:	4b0c      	ldr	r3, [pc, #48]	; (90015984 <_sbrk+0x60>)
90015952:	681a      	ldr	r2, [r3, #0]
90015954:	687b      	ldr	r3, [r7, #4]
90015956:	4413      	add	r3, r2
90015958:	68ba      	ldr	r2, [r7, #8]
9001595a:	429a      	cmp	r2, r3
9001595c:	d207      	bcs.n	9001596e <_sbrk+0x4a>
	if (heap_end + incr > stack_ptr)
#endif
	{
//		write(1, "Heap and stack collision\n", 25);
//		abort();
		errno = ENOMEM;
9001595e:	f004 f8e7 	bl	90019b30 <__errno>
90015962:	4603      	mov	r3, r0
90015964:	220c      	movs	r2, #12
90015966:	601a      	str	r2, [r3, #0]
		return (caddr_t) -1;
90015968:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9001596c:	e006      	b.n	9001597c <_sbrk+0x58>
	}

	heap_end += incr;
9001596e:	4b05      	ldr	r3, [pc, #20]	; (90015984 <_sbrk+0x60>)
90015970:	681a      	ldr	r2, [r3, #0]
90015972:	687b      	ldr	r3, [r7, #4]
90015974:	4413      	add	r3, r2
90015976:	4a03      	ldr	r2, [pc, #12]	; (90015984 <_sbrk+0x60>)
90015978:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
9001597a:	68fb      	ldr	r3, [r7, #12]
}
9001597c:	4618      	mov	r0, r3
9001597e:	3710      	adds	r7, #16
90015980:	46bd      	mov	sp, r7
90015982:	bd80      	pop	{r7, pc}
90015984:	24001fac 	.word	0x24001fac
90015988:	2400b448 	.word	0x2400b448
9001598c:	e000ed08 	.word	0xe000ed08

90015990 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
90015990:	b480      	push	{r7}
90015992:	af00      	add	r7, sp, #0
	return 1;
90015994:	2301      	movs	r3, #1
}
90015996:	4618      	mov	r0, r3
90015998:	46bd      	mov	sp, r7
9001599a:	f85d 7b04 	ldr.w	r7, [sp], #4
9001599e:	4770      	bx	lr

900159a0 <_kill>:

int _kill(int pid, int sig)
{
900159a0:	b580      	push	{r7, lr}
900159a2:	b082      	sub	sp, #8
900159a4:	af00      	add	r7, sp, #0
900159a6:	6078      	str	r0, [r7, #4]
900159a8:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
900159aa:	f004 f8c1 	bl	90019b30 <__errno>
900159ae:	4603      	mov	r3, r0
900159b0:	2216      	movs	r2, #22
900159b2:	601a      	str	r2, [r3, #0]
	return -1;
900159b4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
900159b8:	4618      	mov	r0, r3
900159ba:	3708      	adds	r7, #8
900159bc:	46bd      	mov	sp, r7
900159be:	bd80      	pop	{r7, pc}

900159c0 <_exit>:

void _exit (int status)
{
900159c0:	b580      	push	{r7, lr}
900159c2:	b082      	sub	sp, #8
900159c4:	af00      	add	r7, sp, #0
900159c6:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
900159c8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
900159cc:	6878      	ldr	r0, [r7, #4]
900159ce:	f7ff ffe7 	bl	900159a0 <_kill>
	while (1) {}
900159d2:	e7fe      	b.n	900159d2 <_exit+0x12>

900159d4 <_write>:
}

int _write(int file, char *ptr, int len)
{
900159d4:	b580      	push	{r7, lr}
900159d6:	b086      	sub	sp, #24
900159d8:	af00      	add	r7, sp, #0
900159da:	60f8      	str	r0, [r7, #12]
900159dc:	60b9      	str	r1, [r7, #8]
900159de:	607a      	str	r2, [r7, #4]
	int DataIdx;

		for (DataIdx = 0; DataIdx < len; DataIdx++)
900159e0:	2300      	movs	r3, #0
900159e2:	617b      	str	r3, [r7, #20]
900159e4:	e009      	b.n	900159fa <_write+0x26>
		{
		   __io_putchar( *ptr++ );
900159e6:	68bb      	ldr	r3, [r7, #8]
900159e8:	1c5a      	adds	r2, r3, #1
900159ea:	60ba      	str	r2, [r7, #8]
900159ec:	781b      	ldrb	r3, [r3, #0]
900159ee:	4618      	mov	r0, r3
900159f0:	f3af 8000 	nop.w
		for (DataIdx = 0; DataIdx < len; DataIdx++)
900159f4:	697b      	ldr	r3, [r7, #20]
900159f6:	3301      	adds	r3, #1
900159f8:	617b      	str	r3, [r7, #20]
900159fa:	697a      	ldr	r2, [r7, #20]
900159fc:	687b      	ldr	r3, [r7, #4]
900159fe:	429a      	cmp	r2, r3
90015a00:	dbf1      	blt.n	900159e6 <_write+0x12>
		}
	return len;
90015a02:	687b      	ldr	r3, [r7, #4]
}
90015a04:	4618      	mov	r0, r3
90015a06:	3718      	adds	r7, #24
90015a08:	46bd      	mov	sp, r7
90015a0a:	bd80      	pop	{r7, pc}

90015a0c <_close>:

int _close(int file)
{
90015a0c:	b480      	push	{r7}
90015a0e:	b083      	sub	sp, #12
90015a10:	af00      	add	r7, sp, #0
90015a12:	6078      	str	r0, [r7, #4]
	return -1;
90015a14:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
90015a18:	4618      	mov	r0, r3
90015a1a:	370c      	adds	r7, #12
90015a1c:	46bd      	mov	sp, r7
90015a1e:	f85d 7b04 	ldr.w	r7, [sp], #4
90015a22:	4770      	bx	lr

90015a24 <_fstat>:

int _fstat(int file, struct stat *st)
{
90015a24:	b480      	push	{r7}
90015a26:	b083      	sub	sp, #12
90015a28:	af00      	add	r7, sp, #0
90015a2a:	6078      	str	r0, [r7, #4]
90015a2c:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
90015a2e:	683b      	ldr	r3, [r7, #0]
90015a30:	f44f 5200 	mov.w	r2, #8192	; 0x2000
90015a34:	605a      	str	r2, [r3, #4]
	return 0;
90015a36:	2300      	movs	r3, #0
}
90015a38:	4618      	mov	r0, r3
90015a3a:	370c      	adds	r7, #12
90015a3c:	46bd      	mov	sp, r7
90015a3e:	f85d 7b04 	ldr.w	r7, [sp], #4
90015a42:	4770      	bx	lr

90015a44 <_isatty>:

int _isatty(int file)
{
90015a44:	b480      	push	{r7}
90015a46:	b083      	sub	sp, #12
90015a48:	af00      	add	r7, sp, #0
90015a4a:	6078      	str	r0, [r7, #4]
	return 1;
90015a4c:	2301      	movs	r3, #1
}
90015a4e:	4618      	mov	r0, r3
90015a50:	370c      	adds	r7, #12
90015a52:	46bd      	mov	sp, r7
90015a54:	f85d 7b04 	ldr.w	r7, [sp], #4
90015a58:	4770      	bx	lr

90015a5a <_lseek>:

int _lseek(int file, int ptr, int dir)
{
90015a5a:	b480      	push	{r7}
90015a5c:	b085      	sub	sp, #20
90015a5e:	af00      	add	r7, sp, #0
90015a60:	60f8      	str	r0, [r7, #12]
90015a62:	60b9      	str	r1, [r7, #8]
90015a64:	607a      	str	r2, [r7, #4]
	return 0;
90015a66:	2300      	movs	r3, #0
}
90015a68:	4618      	mov	r0, r3
90015a6a:	3714      	adds	r7, #20
90015a6c:	46bd      	mov	sp, r7
90015a6e:	f85d 7b04 	ldr.w	r7, [sp], #4
90015a72:	4770      	bx	lr

90015a74 <_read>:

int _read(int file, char *ptr, int len)
{
90015a74:	b580      	push	{r7, lr}
90015a76:	b086      	sub	sp, #24
90015a78:	af00      	add	r7, sp, #0
90015a7a:	60f8      	str	r0, [r7, #12]
90015a7c:	60b9      	str	r1, [r7, #8]
90015a7e:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
90015a80:	2300      	movs	r3, #0
90015a82:	617b      	str	r3, [r7, #20]
90015a84:	e00a      	b.n	90015a9c <_read+0x28>
	{
	  *ptr++ = __io_getchar();
90015a86:	f3af 8000 	nop.w
90015a8a:	4601      	mov	r1, r0
90015a8c:	68bb      	ldr	r3, [r7, #8]
90015a8e:	1c5a      	adds	r2, r3, #1
90015a90:	60ba      	str	r2, [r7, #8]
90015a92:	b2ca      	uxtb	r2, r1
90015a94:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
90015a96:	697b      	ldr	r3, [r7, #20]
90015a98:	3301      	adds	r3, #1
90015a9a:	617b      	str	r3, [r7, #20]
90015a9c:	697a      	ldr	r2, [r7, #20]
90015a9e:	687b      	ldr	r3, [r7, #4]
90015aa0:	429a      	cmp	r2, r3
90015aa2:	dbf0      	blt.n	90015a86 <_read+0x12>
	}

   return len;
90015aa4:	687b      	ldr	r3, [r7, #4]
}
90015aa6:	4618      	mov	r0, r3
90015aa8:	3718      	adds	r7, #24
90015aaa:	46bd      	mov	sp, r7
90015aac:	bd80      	pop	{r7, pc}
	...

90015ab0 <AudioPlay_demo>:
  * @brief  Audio Play demo
  * @param  None
  * @retval None
  */
void AudioPlay_demo (void)
{
90015ab0:	b580      	push	{r7, lr}
90015ab2:	f5ad 7d0e 	sub.w	sp, sp, #568	; 0x238
90015ab6:	af02      	add	r7, sp, #8
  uint16_t x1, y1;
 TS_State_t  TS_State;
 uint32_t AudioState;


  BSP_LCD_GetXSize(0, &x_size);
90015ab8:	f507 7307 	add.w	r3, r7, #540	; 0x21c
90015abc:	4619      	mov	r1, r3
90015abe:	2000      	movs	r0, #0
90015ac0:	f7f1 fdce 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
90015ac4:	f507 7308 	add.w	r3, r7, #544	; 0x220
90015ac8:	4619      	mov	r1, r3
90015aca:	2000      	movs	r0, #0
90015acc:	f7f1 fde6 	bl	9000769c <BSP_LCD_GetYSize>

  AudioFreq_ptr = &AudioFreq[0]; /*96K*/
90015ad0:	4bd3      	ldr	r3, [pc, #844]	; (90015e20 <AudioPlay_demo+0x370>)
90015ad2:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
  ButtonState = 0;
90015ad6:	4bd3      	ldr	r3, [pc, #844]	; (90015e24 <AudioPlay_demo+0x374>)
90015ad8:	2200      	movs	r2, #0
90015ada:	601a      	str	r2, [r3, #0]

   uint8_t VolStr[256] = {0};
90015adc:	f507 7386 	add.w	r3, r7, #268	; 0x10c
90015ae0:	2200      	movs	r2, #0
90015ae2:	601a      	str	r2, [r3, #0]
90015ae4:	3304      	adds	r3, #4
90015ae6:	22fc      	movs	r2, #252	; 0xfc
90015ae8:	2100      	movs	r1, #0
90015aea:	4618      	mov	r0, r3
90015aec:	f004 f858 	bl	90019ba0 <memset>
  uint8_t FreqStr[256] = {0};
90015af0:	f107 030c 	add.w	r3, r7, #12
90015af4:	2200      	movs	r2, #0
90015af6:	601a      	str	r2, [r3, #0]
90015af8:	3304      	adds	r3, #4
90015afa:	22fc      	movs	r2, #252	; 0xfc
90015afc:	2100      	movs	r1, #0
90015afe:	4618      	mov	r0, r3
90015b00:	f004 f84e 	bl	90019ba0 <memset>
  uint8_t ts_status = BSP_ERROR_NONE;
90015b04:	2300      	movs	r3, #0
90015b06:	f887 322b 	strb.w	r3, [r7, #555]	; 0x22b
  Point Points2[] = {{226, 196}, {265, 223}, {226, 248}};
90015b0a:	463b      	mov	r3, r7
90015b0c:	4ac6      	ldr	r2, [pc, #792]	; (90015e28 <AudioPlay_demo+0x378>)
90015b0e:	ca07      	ldmia	r2, {r0, r1, r2}
90015b10:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  uwPauseEnabledStatus = 1; /* 0 when audio is running, 1 when Pause is on */
90015b14:	4bc5      	ldr	r3, [pc, #788]	; (90015e2c <AudioPlay_demo+0x37c>)
90015b16:	2201      	movs	r2, #1
90015b18:	601a      	str	r2, [r3, #0]
  uwVolume = 40;
90015b1a:	4bc5      	ldr	r3, [pc, #788]	; (90015e30 <AudioPlay_demo+0x380>)
90015b1c:	2228      	movs	r2, #40	; 0x28
90015b1e:	601a      	str	r2, [r3, #0]

  Audio_SetHint(0);
90015b20:	2000      	movs	r0, #0
90015b22:	f000 faef 	bl	90016104 <Audio_SetHint>
  UTIL_LCD_SetFont(&Font20);
90015b26:	48c3      	ldr	r0, [pc, #780]	; (90015e34 <AudioPlay_demo+0x384>)
90015b28:	f002 fe1a 	bl	90018760 <UTIL_LCD_SetFont>

  ButtonState = 0;
90015b2c:	4bbd      	ldr	r3, [pc, #756]	; (90015e24 <AudioPlay_demo+0x374>)
90015b2e:	2200      	movs	r2, #0
90015b30:	601a      	str	r2, [r3, #0]

  hTS.Width = x_size;
90015b32:	f8d7 321c 	ldr.w	r3, [r7, #540]	; 0x21c
90015b36:	4ac0      	ldr	r2, [pc, #768]	; (90015e38 <AudioPlay_demo+0x388>)
90015b38:	6013      	str	r3, [r2, #0]
  hTS.Height = y_size;
90015b3a:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
90015b3e:	4abe      	ldr	r2, [pc, #760]	; (90015e38 <AudioPlay_demo+0x388>)
90015b40:	6053      	str	r3, [r2, #4]
  hTS.Orientation =TS_SWAP_XY ;
90015b42:	4bbd      	ldr	r3, [pc, #756]	; (90015e38 <AudioPlay_demo+0x388>)
90015b44:	2208      	movs	r2, #8
90015b46:	609a      	str	r2, [r3, #8]
  hTS.Accuracy = 5;
90015b48:	4bbb      	ldr	r3, [pc, #748]	; (90015e38 <AudioPlay_demo+0x388>)
90015b4a:	2205      	movs	r2, #5
90015b4c:	60da      	str	r2, [r3, #12]

  /* Touchscreen initialization */
  ts_status = BSP_TS_Init(0, &hTS);
90015b4e:	49ba      	ldr	r1, [pc, #744]	; (90015e38 <AudioPlay_demo+0x388>)
90015b50:	2000      	movs	r0, #0
90015b52:	f7f2 fe81 	bl	90008858 <BSP_TS_Init>
90015b56:	4603      	mov	r3, r0
90015b58:	f887 322b 	strb.w	r3, [r7, #555]	; 0x22b
  if (ts_status != BSP_ERROR_NONE)
90015b5c:	f897 322b 	ldrb.w	r3, [r7, #555]	; 0x22b
90015b60:	2b00      	cmp	r3, #0
90015b62:	d018      	beq.n	90015b96 <AudioPlay_demo+0xe6>
  {
    UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
90015b64:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90015b68:	f002 fde6 	bl	90018738 <UTIL_LCD_SetBackColor>
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_RED);
90015b6c:	48b3      	ldr	r0, [pc, #716]	; (90015e3c <AudioPlay_demo+0x38c>)
90015b6e:	f002 fdcf 	bl	90018710 <UTIL_LCD_SetTextColor>
    UTIL_LCD_DisplayStringAt(0, y_size - 95, (uint8_t *)"ERROR", CENTER_MODE);
90015b72:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
90015b76:	f1a3 015f 	sub.w	r1, r3, #95	; 0x5f
90015b7a:	2301      	movs	r3, #1
90015b7c:	4ab0      	ldr	r2, [pc, #704]	; (90015e40 <AudioPlay_demo+0x390>)
90015b7e:	2000      	movs	r0, #0
90015b80:	f002 ff1a 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(0, y_size - 80, (uint8_t *)"Touch Screen cannot be initialized", CENTER_MODE);
90015b84:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
90015b88:	f1a3 0150 	sub.w	r1, r3, #80	; 0x50
90015b8c:	2301      	movs	r3, #1
90015b8e:	4aad      	ldr	r2, [pc, #692]	; (90015e44 <AudioPlay_demo+0x394>)
90015b90:	2000      	movs	r0, #0
90015b92:	f002 ff11 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  }


  AudioPlayInit.Device = AUDIO_OUT_DEVICE_HEADPHONE;
90015b96:	4bac      	ldr	r3, [pc, #688]	; (90015e48 <AudioPlay_demo+0x398>)
90015b98:	2202      	movs	r2, #2
90015b9a:	601a      	str	r2, [r3, #0]
  AudioPlayInit.ChannelsNbr = 2;
90015b9c:	4baa      	ldr	r3, [pc, #680]	; (90015e48 <AudioPlay_demo+0x398>)
90015b9e:	2202      	movs	r2, #2
90015ba0:	60da      	str	r2, [r3, #12]
  AudioPlayInit.SampleRate = *AudioFreq_ptr;
90015ba2:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
90015ba6:	681b      	ldr	r3, [r3, #0]
90015ba8:	4aa7      	ldr	r2, [pc, #668]	; (90015e48 <AudioPlay_demo+0x398>)
90015baa:	6053      	str	r3, [r2, #4]
  AudioPlayInit.BitsPerSample = AUDIO_RESOLUTION_16B;
90015bac:	4ba6      	ldr	r3, [pc, #664]	; (90015e48 <AudioPlay_demo+0x398>)
90015bae:	2210      	movs	r2, #16
90015bb0:	609a      	str	r2, [r3, #8]
  AudioPlayInit.Volume = uwVolume;
90015bb2:	4b9f      	ldr	r3, [pc, #636]	; (90015e30 <AudioPlay_demo+0x380>)
90015bb4:	681b      	ldr	r3, [r3, #0]
90015bb6:	4aa4      	ldr	r2, [pc, #656]	; (90015e48 <AudioPlay_demo+0x398>)
90015bb8:	6113      	str	r3, [r2, #16]


  if(BSP_AUDIO_OUT_Init(0, &AudioPlayInit) != 0)
90015bba:	49a3      	ldr	r1, [pc, #652]	; (90015e48 <AudioPlay_demo+0x398>)
90015bbc:	2000      	movs	r0, #0
90015bbe:	f7ef f9b3 	bl	90004f28 <BSP_AUDIO_OUT_Init>
90015bc2:	4603      	mov	r3, r0
90015bc4:	2b00      	cmp	r3, #0
90015bc6:	d018      	beq.n	90015bfa <AudioPlay_demo+0x14a>
  {
    UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
90015bc8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90015bcc:	f002 fdb4 	bl	90018738 <UTIL_LCD_SetBackColor>
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_RED);
90015bd0:	489a      	ldr	r0, [pc, #616]	; (90015e3c <AudioPlay_demo+0x38c>)
90015bd2:	f002 fd9d 	bl	90018710 <UTIL_LCD_SetTextColor>
    UTIL_LCD_DisplayStringAt(0, y_size - 95, (uint8_t *)"  AUDIO CODEC  FAIL ", CENTER_MODE);
90015bd6:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
90015bda:	f1a3 015f 	sub.w	r1, r3, #95	; 0x5f
90015bde:	2301      	movs	r3, #1
90015be0:	4a9a      	ldr	r2, [pc, #616]	; (90015e4c <AudioPlay_demo+0x39c>)
90015be2:	2000      	movs	r0, #0
90015be4:	f002 fee8 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(0, y_size - 80, (uint8_t *)" Try to reset board ", CENTER_MODE);
90015be8:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
90015bec:	f1a3 0150 	sub.w	r1, r3, #80	; 0x50
90015bf0:	2301      	movs	r3, #1
90015bf2:	4a97      	ldr	r2, [pc, #604]	; (90015e50 <AudioPlay_demo+0x3a0>)
90015bf4:	2000      	movs	r0, #0
90015bf6:	f002 fedf 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  Start playing the file from a circular buffer, once the DMA is enabled, it is
  always in running state. Application has to fill the buffer with the audio data
  using Transfer complete and/or half transfer complete interrupts callbacks
  (BSP_AUDIO_OUT_TransferComplete_CallBack() or BSP_AUDIO_OUT_HalfTransfer_CallBack()...
  */
  AUDIO_Start((uint32_t *)AUDIO_SRC_FILE_ADDRESS, (uint32_t)AUDIO_FILE_SIZE);
90015bfa:	f44f 2100 	mov.w	r1, #524288	; 0x80000
90015bfe:	4895      	ldr	r0, [pc, #596]	; (90015e54 <AudioPlay_demo+0x3a4>)
90015c00:	f000 faec 	bl	900161dc <AUDIO_Start>

  /* Display the state on the screen */
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
90015c04:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90015c08:	f002 fd96 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLUE);
90015c0c:	4892      	ldr	r0, [pc, #584]	; (90015e58 <AudioPlay_demo+0x3a8>)
90015c0e:	f002 fd7f 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_DisplayStringAt(0, LINE(5), (uint8_t *)"       PLAYING...     ", CENTER_MODE);
90015c12:	f002 fdb9 	bl	90018788 <UTIL_LCD_GetFont>
90015c16:	4603      	mov	r3, r0
90015c18:	88db      	ldrh	r3, [r3, #6]
90015c1a:	461a      	mov	r2, r3
90015c1c:	4613      	mov	r3, r2
90015c1e:	009b      	lsls	r3, r3, #2
90015c20:	4413      	add	r3, r2
90015c22:	4619      	mov	r1, r3
90015c24:	2301      	movs	r3, #1
90015c26:	4a8d      	ldr	r2, [pc, #564]	; (90015e5c <AudioPlay_demo+0x3ac>)
90015c28:	2000      	movs	r0, #0
90015c2a:	f002 fec5 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  sprintf((char*)VolStr, "VOL:%lu", uwVolume);
90015c2e:	4b80      	ldr	r3, [pc, #512]	; (90015e30 <AudioPlay_demo+0x380>)
90015c30:	681a      	ldr	r2, [r3, #0]
90015c32:	f507 7386 	add.w	r3, r7, #268	; 0x10c
90015c36:	498a      	ldr	r1, [pc, #552]	; (90015e60 <AudioPlay_demo+0x3b0>)
90015c38:	4618      	mov	r0, r3
90015c3a:	f003 ffb9 	bl	90019bb0 <sprintf>
  UTIL_LCD_DisplayStringAt(0,  LINE(6), (uint8_t *)VolStr, CENTER_MODE);
90015c3e:	f002 fda3 	bl	90018788 <UTIL_LCD_GetFont>
90015c42:	4603      	mov	r3, r0
90015c44:	88db      	ldrh	r3, [r3, #6]
90015c46:	461a      	mov	r2, r3
90015c48:	4613      	mov	r3, r2
90015c4a:	005b      	lsls	r3, r3, #1
90015c4c:	4413      	add	r3, r2
90015c4e:	005b      	lsls	r3, r3, #1
90015c50:	4619      	mov	r1, r3
90015c52:	f507 7286 	add.w	r2, r7, #268	; 0x10c
90015c56:	2301      	movs	r3, #1
90015c58:	2000      	movs	r0, #0
90015c5a:	f002 fead 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

  sprintf((char*)FreqStr, "FREQ:%lu", *AudioFreq_ptr);
90015c5e:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
90015c62:	681a      	ldr	r2, [r3, #0]
90015c64:	f107 030c 	add.w	r3, r7, #12
90015c68:	497e      	ldr	r1, [pc, #504]	; (90015e64 <AudioPlay_demo+0x3b4>)
90015c6a:	4618      	mov	r0, r3
90015c6c:	f003 ffa0 	bl	90019bb0 <sprintf>
  UTIL_LCD_DisplayStringAt(0, LINE(7), (uint8_t *)FreqStr, CENTER_MODE);
90015c70:	f002 fd8a 	bl	90018788 <UTIL_LCD_GetFont>
90015c74:	4603      	mov	r3, r0
90015c76:	88db      	ldrh	r3, [r3, #6]
90015c78:	461a      	mov	r2, r3
90015c7a:	4613      	mov	r3, r2
90015c7c:	00db      	lsls	r3, r3, #3
90015c7e:	1a9b      	subs	r3, r3, r2
90015c80:	4619      	mov	r1, r3
90015c82:	f107 020c 	add.w	r2, r7, #12
90015c86:	2301      	movs	r3, #1
90015c88:	2000      	movs	r0, #0
90015c8a:	f002 fe95 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

  UTIL_LCD_SetFont(&Font20);
90015c8e:	4869      	ldr	r0, [pc, #420]	; (90015e34 <AudioPlay_demo+0x384>)
90015c90:	f002 fd66 	bl	90018760 <UTIL_LCD_SetFont>

  /*******VOL +******/
  UTIL_LCD_DisplayStringAt(400,170,(uint8_t *)"VOL", LEFT_MODE);
90015c94:	2303      	movs	r3, #3
90015c96:	4a74      	ldr	r2, [pc, #464]	; (90015e68 <AudioPlay_demo+0x3b8>)
90015c98:	21aa      	movs	r1, #170	; 0xaa
90015c9a:	f44f 70c8 	mov.w	r0, #400	; 0x190
90015c9e:	f002 fe8b 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_FillCircle(420,120, 25, UTIL_LCD_COLOR_BLUE);
90015ca2:	4b6d      	ldr	r3, [pc, #436]	; (90015e58 <AudioPlay_demo+0x3a8>)
90015ca4:	2219      	movs	r2, #25
90015ca6:	2178      	movs	r1, #120	; 0x78
90015ca8:	f44f 70d2 	mov.w	r0, #420	; 0x1a4
90015cac:	f003 fa98 	bl	900191e0 <UTIL_LCD_FillCircle>
  UTIL_LCD_FillCircle(420,120, 23, UTIL_LCD_COLOR_WHITE);
90015cb0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90015cb4:	2217      	movs	r2, #23
90015cb6:	2178      	movs	r1, #120	; 0x78
90015cb8:	f44f 70d2 	mov.w	r0, #420	; 0x1a4
90015cbc:	f003 fa90 	bl	900191e0 <UTIL_LCD_FillCircle>
  UTIL_LCD_DisplayStringAt(413,113, (uint8_t *)"+", LEFT_MODE);
90015cc0:	2303      	movs	r3, #3
90015cc2:	4a6a      	ldr	r2, [pc, #424]	; (90015e6c <AudioPlay_demo+0x3bc>)
90015cc4:	2171      	movs	r1, #113	; 0x71
90015cc6:	f240 109d 	movw	r0, #413	; 0x19d
90015cca:	f002 fe75 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  /*******VOL -******/
  UTIL_LCD_FillCircle(420,220, 25, UTIL_LCD_COLOR_BLUE);
90015cce:	4b62      	ldr	r3, [pc, #392]	; (90015e58 <AudioPlay_demo+0x3a8>)
90015cd0:	2219      	movs	r2, #25
90015cd2:	21dc      	movs	r1, #220	; 0xdc
90015cd4:	f44f 70d2 	mov.w	r0, #420	; 0x1a4
90015cd8:	f003 fa82 	bl	900191e0 <UTIL_LCD_FillCircle>
  UTIL_LCD_FillCircle(420,220,  23, UTIL_LCD_COLOR_WHITE);
90015cdc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90015ce0:	2217      	movs	r2, #23
90015ce2:	21dc      	movs	r1, #220	; 0xdc
90015ce4:	f44f 70d2 	mov.w	r0, #420	; 0x1a4
90015ce8:	f003 fa7a 	bl	900191e0 <UTIL_LCD_FillCircle>
  UTIL_LCD_DisplayStringAt(413,213, (uint8_t *)"-", LEFT_MODE);
90015cec:	2303      	movs	r3, #3
90015cee:	4a60      	ldr	r2, [pc, #384]	; (90015e70 <AudioPlay_demo+0x3c0>)
90015cf0:	21d5      	movs	r1, #213	; 0xd5
90015cf2:	f240 109d 	movw	r0, #413	; 0x19d
90015cf6:	f002 fe5f 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  /********PLAY/STOP***********/
  UTIL_LCD_FillCircle(240,220, 37, UTIL_LCD_COLOR_BLUE);
90015cfa:	4b57      	ldr	r3, [pc, #348]	; (90015e58 <AudioPlay_demo+0x3a8>)
90015cfc:	2225      	movs	r2, #37	; 0x25
90015cfe:	21dc      	movs	r1, #220	; 0xdc
90015d00:	20f0      	movs	r0, #240	; 0xf0
90015d02:	f003 fa6d 	bl	900191e0 <UTIL_LCD_FillCircle>
  UTIL_LCD_FillCircle(240,220, 35, UTIL_LCD_COLOR_WHITE);
90015d06:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90015d0a:	2223      	movs	r2, #35	; 0x23
90015d0c:	21dc      	movs	r1, #220	; 0xdc
90015d0e:	20f0      	movs	r0, #240	; 0xf0
90015d10:	f003 fa66 	bl	900191e0 <UTIL_LCD_FillCircle>
  UTIL_LCD_FillRect(227, 200, 10 , 45, UTIL_LCD_COLOR_BLUE);
90015d14:	4b50      	ldr	r3, [pc, #320]	; (90015e58 <AudioPlay_demo+0x3a8>)
90015d16:	9300      	str	r3, [sp, #0]
90015d18:	232d      	movs	r3, #45	; 0x2d
90015d1a:	220a      	movs	r2, #10
90015d1c:	21c8      	movs	r1, #200	; 0xc8
90015d1e:	20e3      	movs	r0, #227	; 0xe3
90015d20:	f003 fa24 	bl	9001916c <UTIL_LCD_FillRect>
  UTIL_LCD_FillRect(244, 200, 10 , 45, UTIL_LCD_COLOR_BLUE);
90015d24:	4b4c      	ldr	r3, [pc, #304]	; (90015e58 <AudioPlay_demo+0x3a8>)
90015d26:	9300      	str	r3, [sp, #0]
90015d28:	232d      	movs	r3, #45	; 0x2d
90015d2a:	220a      	movs	r2, #10
90015d2c:	21c8      	movs	r1, #200	; 0xc8
90015d2e:	20f4      	movs	r0, #244	; 0xf4
90015d30:	f003 fa1c 	bl	9001916c <UTIL_LCD_FillRect>
  /*******FREQ +******/
  UTIL_LCD_DisplayStringAt(390,170, (uint8_t *)"FREQ",RIGHT_MODE );
90015d34:	2302      	movs	r3, #2
90015d36:	4a4f      	ldr	r2, [pc, #316]	; (90015e74 <AudioPlay_demo+0x3c4>)
90015d38:	21aa      	movs	r1, #170	; 0xaa
90015d3a:	f44f 70c3 	mov.w	r0, #390	; 0x186
90015d3e:	f002 fe3b 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_FillCircle(60,120, 25, UTIL_LCD_COLOR_BLUE);
90015d42:	4b45      	ldr	r3, [pc, #276]	; (90015e58 <AudioPlay_demo+0x3a8>)
90015d44:	2219      	movs	r2, #25
90015d46:	2178      	movs	r1, #120	; 0x78
90015d48:	203c      	movs	r0, #60	; 0x3c
90015d4a:	f003 fa49 	bl	900191e0 <UTIL_LCD_FillCircle>
  UTIL_LCD_FillCircle(60,120,  23, UTIL_LCD_COLOR_WHITE);
90015d4e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90015d52:	2217      	movs	r2, #23
90015d54:	2178      	movs	r1, #120	; 0x78
90015d56:	203c      	movs	r0, #60	; 0x3c
90015d58:	f003 fa42 	bl	900191e0 <UTIL_LCD_FillCircle>
  UTIL_LCD_DisplayStringAt(409,113, (uint8_t *)"+", RIGHT_MODE);
90015d5c:	2302      	movs	r3, #2
90015d5e:	4a43      	ldr	r2, [pc, #268]	; (90015e6c <AudioPlay_demo+0x3bc>)
90015d60:	2171      	movs	r1, #113	; 0x71
90015d62:	f240 1099 	movw	r0, #409	; 0x199
90015d66:	f002 fe27 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  /*******FREQ -******/
  UTIL_LCD_FillCircle(60,220, 25, UTIL_LCD_COLOR_BLUE);
90015d6a:	4b3b      	ldr	r3, [pc, #236]	; (90015e58 <AudioPlay_demo+0x3a8>)
90015d6c:	2219      	movs	r2, #25
90015d6e:	21dc      	movs	r1, #220	; 0xdc
90015d70:	203c      	movs	r0, #60	; 0x3c
90015d72:	f003 fa35 	bl	900191e0 <UTIL_LCD_FillCircle>
  UTIL_LCD_FillCircle(60,220, 23, UTIL_LCD_COLOR_WHITE);
90015d76:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90015d7a:	2217      	movs	r2, #23
90015d7c:	21dc      	movs	r1, #220	; 0xdc
90015d7e:	203c      	movs	r0, #60	; 0x3c
90015d80:	f003 fa2e 	bl	900191e0 <UTIL_LCD_FillCircle>
  UTIL_LCD_DisplayStringAt(409,213, (uint8_t *)"-", RIGHT_MODE);
90015d84:	2302      	movs	r3, #2
90015d86:	4a3a      	ldr	r2, [pc, #232]	; (90015e70 <AudioPlay_demo+0x3c0>)
90015d88:	21d5      	movs	r1, #213	; 0xd5
90015d8a:	f240 1099 	movw	r0, #409	; 0x199
90015d8e:	f002 fe13 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

  /* Infinite loop */
  while (1)
  {
    /* IMPORTANT: AUDIO_Process() should be called within a periodic process */
    AUDIO_Process();
90015d92:	f000 fa85 	bl	900162a0 <AUDIO_Process>
    BSP_TS_GetState(0, &TS_State);
90015d96:	f507 7304 	add.w	r3, r7, #528	; 0x210
90015d9a:	4619      	mov	r1, r3
90015d9c:	2000      	movs	r0, #0
90015d9e:	f7f2 fe27 	bl	900089f0 <BSP_TS_GetState>
    if(TS_State.TouchDetected)
90015da2:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
90015da6:	2b00      	cmp	r3, #0
90015da8:	f000 818a 	beq.w	900160c0 <AudioPlay_demo+0x610>
    {
      x1 = TS_State.TouchX;
90015dac:	f8d7 3214 	ldr.w	r3, [r7, #532]	; 0x214
90015db0:	f8a7 3228 	strh.w	r3, [r7, #552]	; 0x228
      y1 = TS_State.TouchY;
90015db4:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
90015db8:	f8a7 3226 	strh.w	r3, [r7, #550]	; 0x226
      if((y1<255)&&(y1>185))
90015dbc:	f8b7 3226 	ldrh.w	r3, [r7, #550]	; 0x226
90015dc0:	2bfe      	cmp	r3, #254	; 0xfe
90015dc2:	f200 8105 	bhi.w	90015fd0 <AudioPlay_demo+0x520>
90015dc6:	f8b7 3226 	ldrh.w	r3, [r7, #550]	; 0x226
90015dca:	2bb9      	cmp	r3, #185	; 0xb9
90015dcc:	f240 8100 	bls.w	90015fd0 <AudioPlay_demo+0x520>
      {
        if((205<x1)&&(x1<275))
90015dd0:	f8b7 3228 	ldrh.w	r3, [r7, #552]	; 0x228
90015dd4:	2bcd      	cmp	r3, #205	; 0xcd
90015dd6:	d96d      	bls.n	90015eb4 <AudioPlay_demo+0x404>
90015dd8:	f8b7 3228 	ldrh.w	r3, [r7, #552]	; 0x228
90015ddc:	f5b3 7f89 	cmp.w	r3, #274	; 0x112
90015de0:	d868      	bhi.n	90015eb4 <AudioPlay_demo+0x404>
        {
          /**Audio PLAY or AUDIO Resume*/
          BSP_AUDIO_OUT_GetState(0,&AudioState);
90015de2:	f507 7303 	add.w	r3, r7, #524	; 0x20c
90015de6:	4619      	mov	r1, r3
90015de8:	2000      	movs	r0, #0
90015dea:	f7ef fd1f 	bl	9000582c <BSP_AUDIO_OUT_GetState>

          if(AudioState==AUDIO_OUT_STATE_PLAYING)
90015dee:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
90015df2:	2b01      	cmp	r3, #1
90015df4:	d140      	bne.n	90015e78 <AudioPlay_demo+0x3c8>
          {
            BSP_AUDIO_OUT_Pause(0);
90015df6:	2000      	movs	r0, #0
90015df8:	f7ef fb4a 	bl	90005490 <BSP_AUDIO_OUT_Pause>
            UTIL_LCD_FillCircle(240,220, 35, UTIL_LCD_COLOR_WHITE);
90015dfc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90015e00:	2223      	movs	r2, #35	; 0x23
90015e02:	21dc      	movs	r1, #220	; 0xdc
90015e04:	20f0      	movs	r0, #240	; 0xf0
90015e06:	f003 f9eb 	bl	900191e0 <UTIL_LCD_FillCircle>
            UTIL_LCD_FillPolygon(Points2, 3, UTIL_LCD_COLOR_BLUE);
90015e0a:	463b      	mov	r3, r7
90015e0c:	4a12      	ldr	r2, [pc, #72]	; (90015e58 <AudioPlay_demo+0x3a8>)
90015e0e:	2103      	movs	r1, #3
90015e10:	4618      	mov	r0, r3
90015e12:	f003 fa91 	bl	90019338 <UTIL_LCD_FillPolygon>
            HAL_Delay(250);
90015e16:	20fa      	movs	r0, #250	; 0xfa
90015e18:	f7f3 fae0 	bl	900093dc <HAL_Delay>
          if(AudioState==AUDIO_OUT_STATE_PLAYING)
90015e1c:	e0d7      	b.n	90015fce <AudioPlay_demo+0x51e>
90015e1e:	bf00      	nop
90015e20:	240000a8 	.word	0x240000a8
90015e24:	240027f0 	.word	0x240027f0
90015e28:	9001e95c 	.word	0x9001e95c
90015e2c:	240027d4 	.word	0x240027d4
90015e30:	240000a0 	.word	0x240000a0
90015e34:	24000390 	.word	0x24000390
90015e38:	2400b418 	.word	0x2400b418
90015e3c:	ffff0000 	.word	0xffff0000
90015e40:	9001e8c0 	.word	0x9001e8c0
90015e44:	9001e8c8 	.word	0x9001e8c8
90015e48:	24002e58 	.word	0x24002e58
90015e4c:	9001e8ec 	.word	0x9001e8ec
90015e50:	9001e904 	.word	0x9001e904
90015e54:	90080000 	.word	0x90080000
90015e58:	ff0000ff 	.word	0xff0000ff
90015e5c:	9001e91c 	.word	0x9001e91c
90015e60:	9001e934 	.word	0x9001e934
90015e64:	9001e93c 	.word	0x9001e93c
90015e68:	9001e948 	.word	0x9001e948
90015e6c:	9001e94c 	.word	0x9001e94c
90015e70:	9001e950 	.word	0x9001e950
90015e74:	9001e954 	.word	0x9001e954
          }
          else
          {
            BSP_AUDIO_OUT_Resume(0);
90015e78:	2000      	movs	r0, #0
90015e7a:	f7ef fb55 	bl	90005528 <BSP_AUDIO_OUT_Resume>
            UTIL_LCD_FillCircle(240,220, 35, UTIL_LCD_COLOR_WHITE);
90015e7e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90015e82:	2223      	movs	r2, #35	; 0x23
90015e84:	21dc      	movs	r1, #220	; 0xdc
90015e86:	20f0      	movs	r0, #240	; 0xf0
90015e88:	f003 f9aa 	bl	900191e0 <UTIL_LCD_FillCircle>
            UTIL_LCD_FillRect(227, 200, 10 , 45, UTIL_LCD_COLOR_BLUE);
90015e8c:	4b96      	ldr	r3, [pc, #600]	; (900160e8 <AudioPlay_demo+0x638>)
90015e8e:	9300      	str	r3, [sp, #0]
90015e90:	232d      	movs	r3, #45	; 0x2d
90015e92:	220a      	movs	r2, #10
90015e94:	21c8      	movs	r1, #200	; 0xc8
90015e96:	20e3      	movs	r0, #227	; 0xe3
90015e98:	f003 f968 	bl	9001916c <UTIL_LCD_FillRect>
            UTIL_LCD_FillRect(244, 200, 10 , 45, UTIL_LCD_COLOR_BLUE);
90015e9c:	4b92      	ldr	r3, [pc, #584]	; (900160e8 <AudioPlay_demo+0x638>)
90015e9e:	9300      	str	r3, [sp, #0]
90015ea0:	232d      	movs	r3, #45	; 0x2d
90015ea2:	220a      	movs	r2, #10
90015ea4:	21c8      	movs	r1, #200	; 0xc8
90015ea6:	20f4      	movs	r0, #244	; 0xf4
90015ea8:	f003 f960 	bl	9001916c <UTIL_LCD_FillRect>
            HAL_Delay(250);
90015eac:	20fa      	movs	r0, #250	; 0xfa
90015eae:	f7f3 fa95 	bl	900093dc <HAL_Delay>
          if(AudioState==AUDIO_OUT_STATE_PLAYING)
90015eb2:	e08c      	b.n	90015fce <AudioPlay_demo+0x51e>
          }
        }
        else
        {
          if((y1<245)&&(y1>195))
90015eb4:	f8b7 3226 	ldrh.w	r3, [r7, #550]	; 0x226
90015eb8:	2bf4      	cmp	r3, #244	; 0xf4
90015eba:	f200 8100 	bhi.w	900160be <AudioPlay_demo+0x60e>
90015ebe:	f8b7 3226 	ldrh.w	r3, [r7, #550]	; 0x226
90015ec2:	2bc3      	cmp	r3, #195	; 0xc3
90015ec4:	f240 80fb 	bls.w	900160be <AudioPlay_demo+0x60e>
          {
            if((395<x1)&&(x1<445))
90015ec8:	f8b7 3228 	ldrh.w	r3, [r7, #552]	; 0x228
90015ecc:	f5b3 7fc6 	cmp.w	r3, #396	; 0x18c
90015ed0:	d333      	bcc.n	90015f3a <AudioPlay_demo+0x48a>
90015ed2:	f8b7 3228 	ldrh.w	r3, [r7, #552]	; 0x228
90015ed6:	f5b3 7fde 	cmp.w	r3, #444	; 0x1bc
90015eda:	d82e      	bhi.n	90015f3a <AudioPlay_demo+0x48a>
            {
              /**VOL -*/
              if (uwVolume > 5)
90015edc:	4b83      	ldr	r3, [pc, #524]	; (900160ec <AudioPlay_demo+0x63c>)
90015ede:	681b      	ldr	r3, [r3, #0]
90015ee0:	2b05      	cmp	r3, #5
90015ee2:	d905      	bls.n	90015ef0 <AudioPlay_demo+0x440>
              {
                uwVolume -= 5;
90015ee4:	4b81      	ldr	r3, [pc, #516]	; (900160ec <AudioPlay_demo+0x63c>)
90015ee6:	681b      	ldr	r3, [r3, #0]
90015ee8:	3b05      	subs	r3, #5
90015eea:	4a80      	ldr	r2, [pc, #512]	; (900160ec <AudioPlay_demo+0x63c>)
90015eec:	6013      	str	r3, [r2, #0]
90015eee:	e002      	b.n	90015ef6 <AudioPlay_demo+0x446>
              }
              else
              {
                uwVolume = 0;
90015ef0:	4b7e      	ldr	r3, [pc, #504]	; (900160ec <AudioPlay_demo+0x63c>)
90015ef2:	2200      	movs	r2, #0
90015ef4:	601a      	str	r2, [r3, #0]
              }

              sprintf((char*)VolStr, "VOL:%lu", uwVolume);
90015ef6:	4b7d      	ldr	r3, [pc, #500]	; (900160ec <AudioPlay_demo+0x63c>)
90015ef8:	681a      	ldr	r2, [r3, #0]
90015efa:	f507 7386 	add.w	r3, r7, #268	; 0x10c
90015efe:	497c      	ldr	r1, [pc, #496]	; (900160f0 <AudioPlay_demo+0x640>)
90015f00:	4618      	mov	r0, r3
90015f02:	f003 fe55 	bl	90019bb0 <sprintf>
              BSP_AUDIO_OUT_SetVolume(0, uwVolume);
90015f06:	4b79      	ldr	r3, [pc, #484]	; (900160ec <AudioPlay_demo+0x63c>)
90015f08:	681b      	ldr	r3, [r3, #0]
90015f0a:	4619      	mov	r1, r3
90015f0c:	2000      	movs	r0, #0
90015f0e:	f7ef fbb9 	bl	90005684 <BSP_AUDIO_OUT_SetVolume>
              UTIL_LCD_DisplayStringAt(0,  LINE(6), (uint8_t *)VolStr, CENTER_MODE);
90015f12:	f002 fc39 	bl	90018788 <UTIL_LCD_GetFont>
90015f16:	4603      	mov	r3, r0
90015f18:	88db      	ldrh	r3, [r3, #6]
90015f1a:	461a      	mov	r2, r3
90015f1c:	4613      	mov	r3, r2
90015f1e:	005b      	lsls	r3, r3, #1
90015f20:	4413      	add	r3, r2
90015f22:	005b      	lsls	r3, r3, #1
90015f24:	4619      	mov	r1, r3
90015f26:	f507 7286 	add.w	r2, r7, #268	; 0x10c
90015f2a:	2301      	movs	r3, #1
90015f2c:	2000      	movs	r0, #0
90015f2e:	f002 fd43 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
              HAL_Delay(250);
90015f32:	20fa      	movs	r0, #250	; 0xfa
90015f34:	f7f3 fa52 	bl	900093dc <HAL_Delay>
90015f38:	e049      	b.n	90015fce <AudioPlay_demo+0x51e>
            }
            else
            {
              if((35<x1)&&(x1<85))
90015f3a:	f8b7 3228 	ldrh.w	r3, [r7, #552]	; 0x228
90015f3e:	2b23      	cmp	r3, #35	; 0x23
90015f40:	f240 80bd 	bls.w	900160be <AudioPlay_demo+0x60e>
90015f44:	f8b7 3228 	ldrh.w	r3, [r7, #552]	; 0x228
90015f48:	2b54      	cmp	r3, #84	; 0x54
90015f4a:	f200 80b8 	bhi.w	900160be <AudioPlay_demo+0x60e>
              {
                /*FREQ -*/

                if((35<x1)&&(x1<85))
90015f4e:	f8b7 3228 	ldrh.w	r3, [r7, #552]	; 0x228
90015f52:	2b23      	cmp	r3, #35	; 0x23
90015f54:	f240 80b3 	bls.w	900160be <AudioPlay_demo+0x60e>
90015f58:	f8b7 3228 	ldrh.w	r3, [r7, #552]	; 0x228
90015f5c:	2b54      	cmp	r3, #84	; 0x54
90015f5e:	f200 80ae 	bhi.w	900160be <AudioPlay_demo+0x60e>
                {
                  /*FREQ +*/
                  if (*AudioFreq_ptr != 8000)
90015f62:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
90015f66:	681b      	ldr	r3, [r3, #0]
90015f68:	f5b3 5ffa 	cmp.w	r3, #8000	; 0x1f40
90015f6c:	d013      	beq.n	90015f96 <AudioPlay_demo+0x4e6>
                  {
                    AudioFreq_ptr++;
90015f6e:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
90015f72:	3304      	adds	r3, #4
90015f74:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
                    BSP_AUDIO_OUT_Stop(0);
90015f78:	2000      	movs	r0, #0
90015f7a:	f7ef fb21 	bl	900055c0 <BSP_AUDIO_OUT_Stop>
                    BSP_AUDIO_OUT_SetSampleRate(0, *AudioFreq_ptr);
90015f7e:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
90015f82:	681b      	ldr	r3, [r3, #0]
90015f84:	4619      	mov	r1, r3
90015f86:	2000      	movs	r0, #0
90015f88:	f7ef fbda 	bl	90005740 <BSP_AUDIO_OUT_SetSampleRate>
                    AUDIO_Start((uint32_t *)AUDIO_SRC_FILE_ADDRESS, (uint32_t)AUDIO_FILE_SIZE);
90015f8c:	f44f 2100 	mov.w	r1, #524288	; 0x80000
90015f90:	4858      	ldr	r0, [pc, #352]	; (900160f4 <AudioPlay_demo+0x644>)
90015f92:	f000 f923 	bl	900161dc <AUDIO_Start>
                  }
                  sprintf((char*)FreqStr, "FREQ:%lu", *AudioFreq_ptr);
90015f96:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
90015f9a:	681a      	ldr	r2, [r3, #0]
90015f9c:	f107 030c 	add.w	r3, r7, #12
90015fa0:	4955      	ldr	r1, [pc, #340]	; (900160f8 <AudioPlay_demo+0x648>)
90015fa2:	4618      	mov	r0, r3
90015fa4:	f003 fe04 	bl	90019bb0 <sprintf>
                  UTIL_LCD_DisplayStringAt(0, LINE(7), (uint8_t *)FreqStr, CENTER_MODE);
90015fa8:	f002 fbee 	bl	90018788 <UTIL_LCD_GetFont>
90015fac:	4603      	mov	r3, r0
90015fae:	88db      	ldrh	r3, [r3, #6]
90015fb0:	461a      	mov	r2, r3
90015fb2:	4613      	mov	r3, r2
90015fb4:	00db      	lsls	r3, r3, #3
90015fb6:	1a9b      	subs	r3, r3, r2
90015fb8:	4619      	mov	r1, r3
90015fba:	f107 020c 	add.w	r2, r7, #12
90015fbe:	2301      	movs	r3, #1
90015fc0:	2000      	movs	r0, #0
90015fc2:	f002 fcf9 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
                  HAL_Delay(250);
90015fc6:	20fa      	movs	r0, #250	; 0xfa
90015fc8:	f7f3 fa08 	bl	900093dc <HAL_Delay>
        if((205<x1)&&(x1<275))
90015fcc:	e077      	b.n	900160be <AudioPlay_demo+0x60e>
90015fce:	e076      	b.n	900160be <AudioPlay_demo+0x60e>
        }
      }
      else
      {

        if((95<y1)&&(y1<145))
90015fd0:	f8b7 3226 	ldrh.w	r3, [r7, #550]	; 0x226
90015fd4:	2b5f      	cmp	r3, #95	; 0x5f
90015fd6:	d973      	bls.n	900160c0 <AudioPlay_demo+0x610>
90015fd8:	f8b7 3226 	ldrh.w	r3, [r7, #550]	; 0x226
90015fdc:	2b90      	cmp	r3, #144	; 0x90
90015fde:	d86f      	bhi.n	900160c0 <AudioPlay_demo+0x610>
        {
          if((395<x1)&&(x1<445))
90015fe0:	f8b7 3228 	ldrh.w	r3, [r7, #552]	; 0x228
90015fe4:	f5b3 7fc6 	cmp.w	r3, #396	; 0x18c
90015fe8:	d333      	bcc.n	90016052 <AudioPlay_demo+0x5a2>
90015fea:	f8b7 3228 	ldrh.w	r3, [r7, #552]	; 0x228
90015fee:	f5b3 7fde 	cmp.w	r3, #444	; 0x1bc
90015ff2:	d82e      	bhi.n	90016052 <AudioPlay_demo+0x5a2>
          {
            /**VOL +*/
            if (uwVolume < 95)
90015ff4:	4b3d      	ldr	r3, [pc, #244]	; (900160ec <AudioPlay_demo+0x63c>)
90015ff6:	681b      	ldr	r3, [r3, #0]
90015ff8:	2b5e      	cmp	r3, #94	; 0x5e
90015ffa:	d805      	bhi.n	90016008 <AudioPlay_demo+0x558>
            {
              uwVolume += 5;
90015ffc:	4b3b      	ldr	r3, [pc, #236]	; (900160ec <AudioPlay_demo+0x63c>)
90015ffe:	681b      	ldr	r3, [r3, #0]
90016000:	3305      	adds	r3, #5
90016002:	4a3a      	ldr	r2, [pc, #232]	; (900160ec <AudioPlay_demo+0x63c>)
90016004:	6013      	str	r3, [r2, #0]
90016006:	e002      	b.n	9001600e <AudioPlay_demo+0x55e>
            }
            else
            {
              uwVolume = 100;
90016008:	4b38      	ldr	r3, [pc, #224]	; (900160ec <AudioPlay_demo+0x63c>)
9001600a:	2264      	movs	r2, #100	; 0x64
9001600c:	601a      	str	r2, [r3, #0]
            }
            sprintf((char*)VolStr, "VOL:%lu", uwVolume);
9001600e:	4b37      	ldr	r3, [pc, #220]	; (900160ec <AudioPlay_demo+0x63c>)
90016010:	681a      	ldr	r2, [r3, #0]
90016012:	f507 7386 	add.w	r3, r7, #268	; 0x10c
90016016:	4936      	ldr	r1, [pc, #216]	; (900160f0 <AudioPlay_demo+0x640>)
90016018:	4618      	mov	r0, r3
9001601a:	f003 fdc9 	bl	90019bb0 <sprintf>
            BSP_AUDIO_OUT_SetVolume(0, uwVolume);
9001601e:	4b33      	ldr	r3, [pc, #204]	; (900160ec <AudioPlay_demo+0x63c>)
90016020:	681b      	ldr	r3, [r3, #0]
90016022:	4619      	mov	r1, r3
90016024:	2000      	movs	r0, #0
90016026:	f7ef fb2d 	bl	90005684 <BSP_AUDIO_OUT_SetVolume>
            UTIL_LCD_DisplayStringAt(0,  LINE(6), (uint8_t *)VolStr, CENTER_MODE);
9001602a:	f002 fbad 	bl	90018788 <UTIL_LCD_GetFont>
9001602e:	4603      	mov	r3, r0
90016030:	88db      	ldrh	r3, [r3, #6]
90016032:	461a      	mov	r2, r3
90016034:	4613      	mov	r3, r2
90016036:	005b      	lsls	r3, r3, #1
90016038:	4413      	add	r3, r2
9001603a:	005b      	lsls	r3, r3, #1
9001603c:	4619      	mov	r1, r3
9001603e:	f507 7286 	add.w	r2, r7, #268	; 0x10c
90016042:	2301      	movs	r3, #1
90016044:	2000      	movs	r0, #0
90016046:	f002 fcb7 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
            HAL_Delay(250);
9001604a:	20fa      	movs	r0, #250	; 0xfa
9001604c:	f7f3 f9c6 	bl	900093dc <HAL_Delay>
90016050:	e036      	b.n	900160c0 <AudioPlay_demo+0x610>
          }
          else
          {
            if (*AudioFreq_ptr != 96000)
90016052:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
90016056:	681b      	ldr	r3, [r3, #0]
90016058:	4a28      	ldr	r2, [pc, #160]	; (900160fc <AudioPlay_demo+0x64c>)
9001605a:	4293      	cmp	r3, r2
9001605c:	d013      	beq.n	90016086 <AudioPlay_demo+0x5d6>
            {
              AudioFreq_ptr--;
9001605e:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
90016062:	3b04      	subs	r3, #4
90016064:	f8c7 322c 	str.w	r3, [r7, #556]	; 0x22c
              BSP_AUDIO_OUT_Stop(0);
90016068:	2000      	movs	r0, #0
9001606a:	f7ef faa9 	bl	900055c0 <BSP_AUDIO_OUT_Stop>
              BSP_AUDIO_OUT_SetSampleRate(0, *AudioFreq_ptr);
9001606e:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
90016072:	681b      	ldr	r3, [r3, #0]
90016074:	4619      	mov	r1, r3
90016076:	2000      	movs	r0, #0
90016078:	f7ef fb62 	bl	90005740 <BSP_AUDIO_OUT_SetSampleRate>
              AUDIO_Start((uint32_t *)AUDIO_SRC_FILE_ADDRESS, (uint32_t)AUDIO_FILE_SIZE);
9001607c:	f44f 2100 	mov.w	r1, #524288	; 0x80000
90016080:	481c      	ldr	r0, [pc, #112]	; (900160f4 <AudioPlay_demo+0x644>)
90016082:	f000 f8ab 	bl	900161dc <AUDIO_Start>
            }
            sprintf((char*)FreqStr, "FREQ:%lu", *AudioFreq_ptr);
90016086:	f8d7 322c 	ldr.w	r3, [r7, #556]	; 0x22c
9001608a:	681a      	ldr	r2, [r3, #0]
9001608c:	f107 030c 	add.w	r3, r7, #12
90016090:	4919      	ldr	r1, [pc, #100]	; (900160f8 <AudioPlay_demo+0x648>)
90016092:	4618      	mov	r0, r3
90016094:	f003 fd8c 	bl	90019bb0 <sprintf>
            UTIL_LCD_DisplayStringAt(0, LINE(7), (uint8_t *)FreqStr, CENTER_MODE);
90016098:	f002 fb76 	bl	90018788 <UTIL_LCD_GetFont>
9001609c:	4603      	mov	r3, r0
9001609e:	88db      	ldrh	r3, [r3, #6]
900160a0:	461a      	mov	r2, r3
900160a2:	4613      	mov	r3, r2
900160a4:	00db      	lsls	r3, r3, #3
900160a6:	1a9b      	subs	r3, r3, r2
900160a8:	4619      	mov	r1, r3
900160aa:	f107 020c 	add.w	r2, r7, #12
900160ae:	2301      	movs	r3, #1
900160b0:	2000      	movs	r0, #0
900160b2:	f002 fc81 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
            HAL_Delay(250);
900160b6:	20fa      	movs	r0, #250	; 0xfa
900160b8:	f7f3 f990 	bl	900093dc <HAL_Delay>
900160bc:	e000      	b.n	900160c0 <AudioPlay_demo+0x610>
        if((205<x1)&&(x1<275))
900160be:	bf00      	nop
        }
        else
        {}
      }
    }
    if (CheckForUserInput() > 0)
900160c0:	f000 fff0 	bl	900170a4 <CheckForUserInput>
900160c4:	4603      	mov	r3, r0
900160c6:	2b00      	cmp	r3, #0
900160c8:	f43f ae63 	beq.w	90015d92 <AudioPlay_demo+0x2e2>
    {
      ButtonState = 0;
900160cc:	4b0c      	ldr	r3, [pc, #48]	; (90016100 <AudioPlay_demo+0x650>)
900160ce:	2200      	movs	r2, #0
900160d0:	601a      	str	r2, [r3, #0]
      BSP_AUDIO_OUT_Stop(0);
900160d2:	2000      	movs	r0, #0
900160d4:	f7ef fa74 	bl	900055c0 <BSP_AUDIO_OUT_Stop>
      BSP_AUDIO_OUT_DeInit(0);
900160d8:	2000      	movs	r0, #0
900160da:	f7ef f81d 	bl	90005118 <BSP_AUDIO_OUT_DeInit>
      return;
900160de:	bf00      	nop
    }
  }
}
900160e0:	f507 770c 	add.w	r7, r7, #560	; 0x230
900160e4:	46bd      	mov	sp, r7
900160e6:	bd80      	pop	{r7, pc}
900160e8:	ff0000ff 	.word	0xff0000ff
900160ec:	240000a0 	.word	0x240000a0
900160f0:	9001e934 	.word	0x9001e934
900160f4:	90080000 	.word	0x90080000
900160f8:	9001e93c 	.word	0x9001e93c
900160fc:	00017700 	.word	0x00017700
90016100:	240027f0 	.word	0x240027f0

90016104 <Audio_SetHint>:
  * @brief  Display Audio demo hint
  * @param  None
  * @retval None
  */
static void Audio_SetHint(uint32_t Index)
{
90016104:	b580      	push	{r7, lr}
90016106:	b086      	sub	sp, #24
90016108:	af02      	add	r7, sp, #8
9001610a:	6078      	str	r0, [r7, #4]
  uint32_t x_size, y_size;

  BSP_LCD_GetXSize(0, &x_size);
9001610c:	f107 030c 	add.w	r3, r7, #12
90016110:	4619      	mov	r1, r3
90016112:	2000      	movs	r0, #0
90016114:	f7f1 faa4 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
90016118:	f107 0308 	add.w	r3, r7, #8
9001611c:	4619      	mov	r1, r3
9001611e:	2000      	movs	r0, #0
90016120:	f7f1 fabc 	bl	9000769c <BSP_LCD_GetYSize>

  /* Clear the LCD */
  UTIL_LCD_Clear(UTIL_LCD_COLOR_WHITE);
90016124:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90016128:	f002 fbfa 	bl	90018920 <UTIL_LCD_Clear>

  /* Set Audio Demo description */
  UTIL_LCD_FillRect(0, 0, x_size, 80, UTIL_LCD_COLOR_BLUE);
9001612c:	68fa      	ldr	r2, [r7, #12]
9001612e:	4b24      	ldr	r3, [pc, #144]	; (900161c0 <Audio_SetHint+0xbc>)
90016130:	9300      	str	r3, [sp, #0]
90016132:	2350      	movs	r3, #80	; 0x50
90016134:	2100      	movs	r1, #0
90016136:	2000      	movs	r0, #0
90016138:	f003 f818 	bl	9001916c <UTIL_LCD_FillRect>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
9001613c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90016140:	f002 fae6 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
90016144:	481e      	ldr	r0, [pc, #120]	; (900161c0 <Audio_SetHint+0xbc>)
90016146:	f002 faf7 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_SetFont(&Font24);
9001614a:	481e      	ldr	r0, [pc, #120]	; (900161c4 <Audio_SetHint+0xc0>)
9001614c:	f002 fb08 	bl	90018760 <UTIL_LCD_SetFont>
  if(Index == 0)
90016150:	687b      	ldr	r3, [r7, #4]
90016152:	2b00      	cmp	r3, #0
90016154:	d11a      	bne.n	9001618c <Audio_SetHint+0x88>
  {
    UTIL_LCD_DisplayStringAt(0, 0, (uint8_t *)"AUDIO PLAY EXAMPLE", CENTER_MODE);
90016156:	2301      	movs	r3, #1
90016158:	4a1b      	ldr	r2, [pc, #108]	; (900161c8 <Audio_SetHint+0xc4>)
9001615a:	2100      	movs	r1, #0
9001615c:	2000      	movs	r0, #0
9001615e:	f002 fc2b 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_SetFont(&Font12);
90016162:	481a      	ldr	r0, [pc, #104]	; (900161cc <Audio_SetHint+0xc8>)
90016164:	f002 fafc 	bl	90018760 <UTIL_LCD_SetFont>
    UTIL_LCD_DisplayStringAt(0, 30, (uint8_t *)"Press User button for next menu", CENTER_MODE);
90016168:	2301      	movs	r3, #1
9001616a:	4a19      	ldr	r2, [pc, #100]	; (900161d0 <Audio_SetHint+0xcc>)
9001616c:	211e      	movs	r1, #30
9001616e:	2000      	movs	r0, #0
90016170:	f002 fc22 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(0,45, (uint8_t *)"Hear nothing ? Have you copied the  audio file with ", CENTER_MODE);
90016174:	2301      	movs	r3, #1
90016176:	4a17      	ldr	r2, [pc, #92]	; (900161d4 <Audio_SetHint+0xd0>)
90016178:	212d      	movs	r1, #45	; 0x2d
9001617a:	2000      	movs	r0, #0
9001617c:	f002 fc1c 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(0,60, (uint8_t *)"STM32CubeProgrammer ?", CENTER_MODE);
90016180:	2301      	movs	r3, #1
90016182:	4a15      	ldr	r2, [pc, #84]	; (900161d8 <Audio_SetHint+0xd4>)
90016184:	213c      	movs	r1, #60	; 0x3c
90016186:	2000      	movs	r0, #0
90016188:	f002 fc16 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  }

   UTIL_LCD_DrawRect(10, 90, x_size - 20, y_size - 100, UTIL_LCD_COLOR_BLUE);
9001618c:	68fb      	ldr	r3, [r7, #12]
9001618e:	f1a3 0214 	sub.w	r2, r3, #20
90016192:	68bb      	ldr	r3, [r7, #8]
90016194:	3b64      	subs	r3, #100	; 0x64
90016196:	490a      	ldr	r1, [pc, #40]	; (900161c0 <Audio_SetHint+0xbc>)
90016198:	9100      	str	r1, [sp, #0]
9001619a:	215a      	movs	r1, #90	; 0x5a
9001619c:	200a      	movs	r0, #10
9001619e:	f002 fd75 	bl	90018c8c <UTIL_LCD_DrawRect>
    UTIL_LCD_DrawRect(11, 91, x_size - 22, y_size - 102, UTIL_LCD_COLOR_BLUE);
900161a2:	68fb      	ldr	r3, [r7, #12]
900161a4:	f1a3 0216 	sub.w	r2, r3, #22
900161a8:	68bb      	ldr	r3, [r7, #8]
900161aa:	3b66      	subs	r3, #102	; 0x66
900161ac:	4904      	ldr	r1, [pc, #16]	; (900161c0 <Audio_SetHint+0xbc>)
900161ae:	9100      	str	r1, [sp, #0]
900161b0:	215b      	movs	r1, #91	; 0x5b
900161b2:	200b      	movs	r0, #11
900161b4:	f002 fd6a 	bl	90018c8c <UTIL_LCD_DrawRect>
}
900161b8:	bf00      	nop
900161ba:	3710      	adds	r7, #16
900161bc:	46bd      	mov	sp, r7
900161be:	bd80      	pop	{r7, pc}
900161c0:	ff0000ff 	.word	0xff0000ff
900161c4:	24000388 	.word	0x24000388
900161c8:	9001e968 	.word	0x9001e968
900161cc:	240003a0 	.word	0x240003a0
900161d0:	9001e97c 	.word	0x9001e97c
900161d4:	9001e99c 	.word	0x9001e99c
900161d8:	9001e9d4 	.word	0x9001e9d4

900161dc <AUDIO_Start>:
  * @brief  Starts Audio streaming.
  * @param  None
  * @retval Audio error
  */
AUDIO_ErrorTypeDef AUDIO_Start(uint32_t *psrc_address, uint32_t file_size)
{
900161dc:	b580      	push	{r7, lr}
900161de:	b084      	sub	sp, #16
900161e0:	af00      	add	r7, sp, #0
900161e2:	6078      	str	r0, [r7, #4]
900161e4:	6039      	str	r1, [r7, #0]
  uint32_t bytesread;

  buffer_ctl.state = BUFFER_OFFSET_NONE;
900161e6:	4b15      	ldr	r3, [pc, #84]	; (9001623c <AUDIO_Start+0x60>)
900161e8:	2200      	movs	r2, #0
900161ea:	f883 2804 	strb.w	r2, [r3, #2052]	; 0x804
  buffer_ctl.AudioFileSize = file_size;
900161ee:	4a13      	ldr	r2, [pc, #76]	; (9001623c <AUDIO_Start+0x60>)
900161f0:	683b      	ldr	r3, [r7, #0]
900161f2:	f8c2 3808 	str.w	r3, [r2, #2056]	; 0x808
  buffer_ctl.SrcAddress = psrc_address;
900161f6:	4a11      	ldr	r2, [pc, #68]	; (9001623c <AUDIO_Start+0x60>)
900161f8:	687b      	ldr	r3, [r7, #4]
900161fa:	f8c2 380c 	str.w	r3, [r2, #2060]	; 0x80c

  bytesread = GetData( (void *)psrc_address,
900161fe:	f44f 6300 	mov.w	r3, #2048	; 0x800
90016202:	4a0e      	ldr	r2, [pc, #56]	; (9001623c <AUDIO_Start+0x60>)
90016204:	2100      	movs	r1, #0
90016206:	6878      	ldr	r0, [r7, #4]
90016208:	f000 f81c 	bl	90016244 <GetData>
9001620c:	60f8      	str	r0, [r7, #12]
                       0,
                       &buffer_ctl.buff[0],
                       AUDIO_BUFFER_SIZE);
  if(bytesread > 0)
9001620e:	68fb      	ldr	r3, [r7, #12]
90016210:	2b00      	cmp	r3, #0
90016212:	d00e      	beq.n	90016232 <AUDIO_Start+0x56>
  {
    BSP_AUDIO_OUT_Play(0,(uint8_t *)&buffer_ctl.buff[0], AUDIO_BUFFER_SIZE);
90016214:	f44f 6200 	mov.w	r2, #2048	; 0x800
90016218:	4908      	ldr	r1, [pc, #32]	; (9001623c <AUDIO_Start+0x60>)
9001621a:	2000      	movs	r0, #0
9001621c:	f7ef f8cc 	bl	900053b8 <BSP_AUDIO_OUT_Play>
    audio_state = AUDIO_STATE_PLAYING;
90016220:	4b07      	ldr	r3, [pc, #28]	; (90016240 <AUDIO_Start+0x64>)
90016222:	2202      	movs	r2, #2
90016224:	701a      	strb	r2, [r3, #0]
    buffer_ctl.fptr = bytesread;
90016226:	4a05      	ldr	r2, [pc, #20]	; (9001623c <AUDIO_Start+0x60>)
90016228:	68fb      	ldr	r3, [r7, #12]
9001622a:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
    return AUDIO_ERROR_NONE;
9001622e:	2300      	movs	r3, #0
90016230:	e000      	b.n	90016234 <AUDIO_Start+0x58>
  }
  return AUDIO_ERROR_IO;
90016232:	2302      	movs	r3, #2
}
90016234:	4618      	mov	r0, r3
90016236:	3710      	adds	r7, #16
90016238:	46bd      	mov	sp, r7
9001623a:	bd80      	pop	{r7, pc}
9001623c:	24001fc0 	.word	0x24001fc0
90016240:	240027d0 	.word	0x240027d0

90016244 <GetData>:
  * @brief  Gets Data from storage unit.
  * @param  None
  * @retval None
  */
static uint32_t GetData(void *pdata, uint32_t offset, uint8_t *pbuf, uint32_t NbrOfData)
{
90016244:	b480      	push	{r7}
90016246:	b087      	sub	sp, #28
90016248:	af00      	add	r7, sp, #0
9001624a:	60f8      	str	r0, [r7, #12]
9001624c:	60b9      	str	r1, [r7, #8]
9001624e:	607a      	str	r2, [r7, #4]
90016250:	603b      	str	r3, [r7, #0]
  uint8_t *lptr = pdata;
90016252:	68fb      	ldr	r3, [r7, #12]
90016254:	613b      	str	r3, [r7, #16]
  uint32_t ReadDataNbr;

  ReadDataNbr = 0;
90016256:	2300      	movs	r3, #0
90016258:	617b      	str	r3, [r7, #20]
  while(((offset + ReadDataNbr) < buffer_ctl.AudioFileSize) && (ReadDataNbr < NbrOfData))
9001625a:	e00c      	b.n	90016276 <GetData+0x32>
  {
    pbuf[ReadDataNbr]= lptr [offset + ReadDataNbr];
9001625c:	68ba      	ldr	r2, [r7, #8]
9001625e:	697b      	ldr	r3, [r7, #20]
90016260:	4413      	add	r3, r2
90016262:	693a      	ldr	r2, [r7, #16]
90016264:	441a      	add	r2, r3
90016266:	6879      	ldr	r1, [r7, #4]
90016268:	697b      	ldr	r3, [r7, #20]
9001626a:	440b      	add	r3, r1
9001626c:	7812      	ldrb	r2, [r2, #0]
9001626e:	701a      	strb	r2, [r3, #0]
    ReadDataNbr++;
90016270:	697b      	ldr	r3, [r7, #20]
90016272:	3301      	adds	r3, #1
90016274:	617b      	str	r3, [r7, #20]
  while(((offset + ReadDataNbr) < buffer_ctl.AudioFileSize) && (ReadDataNbr < NbrOfData))
90016276:	68ba      	ldr	r2, [r7, #8]
90016278:	697b      	ldr	r3, [r7, #20]
9001627a:	441a      	add	r2, r3
9001627c:	4b07      	ldr	r3, [pc, #28]	; (9001629c <GetData+0x58>)
9001627e:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
90016282:	429a      	cmp	r2, r3
90016284:	d203      	bcs.n	9001628e <GetData+0x4a>
90016286:	697a      	ldr	r2, [r7, #20]
90016288:	683b      	ldr	r3, [r7, #0]
9001628a:	429a      	cmp	r2, r3
9001628c:	d3e6      	bcc.n	9001625c <GetData+0x18>
  }

  return ReadDataNbr;
9001628e:	697b      	ldr	r3, [r7, #20]
}
90016290:	4618      	mov	r0, r3
90016292:	371c      	adds	r7, #28
90016294:	46bd      	mov	sp, r7
90016296:	f85d 7b04 	ldr.w	r7, [sp], #4
9001629a:	4770      	bx	lr
9001629c:	24001fc0 	.word	0x24001fc0

900162a0 <AUDIO_Process>:
  * @brief  Manages Audio process.
  * @param  None
  * @retval Audio error
  */
uint8_t AUDIO_Process(void)
{
900162a0:	b580      	push	{r7, lr}
900162a2:	b08a      	sub	sp, #40	; 0x28
900162a4:	af00      	add	r7, sp, #0
  uint32_t bytesread;
  AUDIO_ErrorTypeDef error_state = AUDIO_ERROR_NONE;
900162a6:	2300      	movs	r3, #0
900162a8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  switch(audio_state)
900162ac:	4b56      	ldr	r3, [pc, #344]	; (90016408 <AUDIO_Process+0x168>)
900162ae:	781b      	ldrb	r3, [r3, #0]
900162b0:	2b02      	cmp	r3, #2
900162b2:	f040 809e 	bne.w	900163f2 <AUDIO_Process+0x152>
  {
  case AUDIO_STATE_PLAYING:

    if(buffer_ctl.fptr >= buffer_ctl.AudioFileSize)
900162b6:	4b55      	ldr	r3, [pc, #340]	; (9001640c <AUDIO_Process+0x16c>)
900162b8:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
900162bc:	4b53      	ldr	r3, [pc, #332]	; (9001640c <AUDIO_Process+0x16c>)
900162be:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
900162c2:	429a      	cmp	r2, r3
900162c4:	d306      	bcc.n	900162d4 <AUDIO_Process+0x34>
    {
      /* Play audio sample again ... */
      buffer_ctl.fptr = 0;
900162c6:	4b51      	ldr	r3, [pc, #324]	; (9001640c <AUDIO_Process+0x16c>)
900162c8:	2200      	movs	r2, #0
900162ca:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
      error_state = AUDIO_ERROR_EOF;
900162ce:	2303      	movs	r3, #3
900162d0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    }

    /* 1st half buffer played; so fill it and continue playing from bottom*/
    if(buffer_ctl.state == BUFFER_OFFSET_HALF)
900162d4:	4b4d      	ldr	r3, [pc, #308]	; (9001640c <AUDIO_Process+0x16c>)
900162d6:	f893 3804 	ldrb.w	r3, [r3, #2052]	; 0x804
900162da:	2b01      	cmp	r3, #1
900162dc:	d141      	bne.n	90016362 <AUDIO_Process+0xc2>
    {
      bytesread = GetData((void *)buffer_ctl.SrcAddress,
900162de:	4b4b      	ldr	r3, [pc, #300]	; (9001640c <AUDIO_Process+0x16c>)
900162e0:	f8d3 080c 	ldr.w	r0, [r3, #2060]	; 0x80c
900162e4:	4b49      	ldr	r3, [pc, #292]	; (9001640c <AUDIO_Process+0x16c>)
900162e6:	f8d3 1800 	ldr.w	r1, [r3, #2048]	; 0x800
900162ea:	f44f 6380 	mov.w	r3, #1024	; 0x400
900162ee:	4a47      	ldr	r2, [pc, #284]	; (9001640c <AUDIO_Process+0x16c>)
900162f0:	f7ff ffa8 	bl	90016244 <GetData>
900162f4:	6238      	str	r0, [r7, #32]
                          buffer_ctl.fptr,
                          &buffer_ctl.buff[0],
                          AUDIO_BUFFER_SIZE /2);

      if( bytesread >0)
900162f6:	6a3b      	ldr	r3, [r7, #32]
900162f8:	2b00      	cmp	r3, #0
900162fa:	d032      	beq.n	90016362 <AUDIO_Process+0xc2>
      {
        buffer_ctl.state = BUFFER_OFFSET_NONE;
900162fc:	4b43      	ldr	r3, [pc, #268]	; (9001640c <AUDIO_Process+0x16c>)
900162fe:	2200      	movs	r2, #0
90016300:	f883 2804 	strb.w	r2, [r3, #2052]	; 0x804
        buffer_ctl.fptr += bytesread;
90016304:	4b41      	ldr	r3, [pc, #260]	; (9001640c <AUDIO_Process+0x16c>)
90016306:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
9001630a:	6a3b      	ldr	r3, [r7, #32]
9001630c:	4413      	add	r3, r2
9001630e:	4a3f      	ldr	r2, [pc, #252]	; (9001640c <AUDIO_Process+0x16c>)
90016310:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
90016314:	4b3d      	ldr	r3, [pc, #244]	; (9001640c <AUDIO_Process+0x16c>)
90016316:	61fb      	str	r3, [r7, #28]
90016318:	f44f 6380 	mov.w	r3, #1024	; 0x400
9001631c:	61bb      	str	r3, [r7, #24]
    if ( dsize > 0 ) { 
9001631e:	69bb      	ldr	r3, [r7, #24]
90016320:	2b00      	cmp	r3, #0
90016322:	dd1d      	ble.n	90016360 <AUDIO_Process+0xc0>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
90016324:	69fb      	ldr	r3, [r7, #28]
90016326:	f003 021f 	and.w	r2, r3, #31
9001632a:	69bb      	ldr	r3, [r7, #24]
9001632c:	4413      	add	r3, r2
9001632e:	617b      	str	r3, [r7, #20]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
90016330:	69fb      	ldr	r3, [r7, #28]
90016332:	613b      	str	r3, [r7, #16]
  __ASM volatile ("dsb 0xF":::"memory");
90016334:	f3bf 8f4f 	dsb	sy
}
90016338:	bf00      	nop
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
9001633a:	4a35      	ldr	r2, [pc, #212]	; (90016410 <AUDIO_Process+0x170>)
9001633c:	693b      	ldr	r3, [r7, #16]
9001633e:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
90016342:	693b      	ldr	r3, [r7, #16]
90016344:	3320      	adds	r3, #32
90016346:	613b      	str	r3, [r7, #16]
        op_size -= __SCB_DCACHE_LINE_SIZE;
90016348:	697b      	ldr	r3, [r7, #20]
9001634a:	3b20      	subs	r3, #32
9001634c:	617b      	str	r3, [r7, #20]
      } while ( op_size > 0 );
9001634e:	697b      	ldr	r3, [r7, #20]
90016350:	2b00      	cmp	r3, #0
90016352:	dcf2      	bgt.n	9001633a <AUDIO_Process+0x9a>
  __ASM volatile ("dsb 0xF":::"memory");
90016354:	f3bf 8f4f 	dsb	sy
}
90016358:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
9001635a:	f3bf 8f6f 	isb	sy
}
9001635e:	bf00      	nop
}
90016360:	bf00      	nop
      SCB_CleanDCache_by_Addr((uint32_t*)&buffer_ctl.buff[0], AUDIO_BUFFER_SIZE/2);
      }
    }

    /* 2nd half buffer played; so fill it and continue playing from top */
    if(buffer_ctl.state == BUFFER_OFFSET_FULL)
90016362:	4b2a      	ldr	r3, [pc, #168]	; (9001640c <AUDIO_Process+0x16c>)
90016364:	f893 3804 	ldrb.w	r3, [r3, #2052]	; 0x804
90016368:	2b02      	cmp	r3, #2
9001636a:	d146      	bne.n	900163fa <AUDIO_Process+0x15a>
    {
      bytesread = GetData((void *)buffer_ctl.SrcAddress,
9001636c:	4b27      	ldr	r3, [pc, #156]	; (9001640c <AUDIO_Process+0x16c>)
9001636e:	f8d3 080c 	ldr.w	r0, [r3, #2060]	; 0x80c
90016372:	4b26      	ldr	r3, [pc, #152]	; (9001640c <AUDIO_Process+0x16c>)
90016374:	f8d3 1800 	ldr.w	r1, [r3, #2048]	; 0x800
90016378:	f44f 6380 	mov.w	r3, #1024	; 0x400
9001637c:	4a25      	ldr	r2, [pc, #148]	; (90016414 <AUDIO_Process+0x174>)
9001637e:	f7ff ff61 	bl	90016244 <GetData>
90016382:	6238      	str	r0, [r7, #32]
                          buffer_ctl.fptr,
                          &buffer_ctl.buff[AUDIO_BUFFER_SIZE /2],
                          AUDIO_BUFFER_SIZE /2);
      if( bytesread > 0)
90016384:	6a3b      	ldr	r3, [r7, #32]
90016386:	2b00      	cmp	r3, #0
90016388:	d037      	beq.n	900163fa <AUDIO_Process+0x15a>
      {
        buffer_ctl.state = BUFFER_OFFSET_NONE;
9001638a:	4b20      	ldr	r3, [pc, #128]	; (9001640c <AUDIO_Process+0x16c>)
9001638c:	2200      	movs	r2, #0
9001638e:	f883 2804 	strb.w	r2, [r3, #2052]	; 0x804
        buffer_ctl.fptr += bytesread;
90016392:	4b1e      	ldr	r3, [pc, #120]	; (9001640c <AUDIO_Process+0x16c>)
90016394:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
90016398:	6a3b      	ldr	r3, [r7, #32]
9001639a:	4413      	add	r3, r2
9001639c:	4a1b      	ldr	r2, [pc, #108]	; (9001640c <AUDIO_Process+0x16c>)
9001639e:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
900163a2:	4b1c      	ldr	r3, [pc, #112]	; (90016414 <AUDIO_Process+0x174>)
900163a4:	60fb      	str	r3, [r7, #12]
900163a6:	f44f 6380 	mov.w	r3, #1024	; 0x400
900163aa:	60bb      	str	r3, [r7, #8]
    if ( dsize > 0 ) { 
900163ac:	68bb      	ldr	r3, [r7, #8]
900163ae:	2b00      	cmp	r3, #0
900163b0:	dd1d      	ble.n	900163ee <AUDIO_Process+0x14e>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
900163b2:	68fb      	ldr	r3, [r7, #12]
900163b4:	f003 021f 	and.w	r2, r3, #31
900163b8:	68bb      	ldr	r3, [r7, #8]
900163ba:	4413      	add	r3, r2
900163bc:	607b      	str	r3, [r7, #4]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
900163be:	68fb      	ldr	r3, [r7, #12]
900163c0:	603b      	str	r3, [r7, #0]
  __ASM volatile ("dsb 0xF":::"memory");
900163c2:	f3bf 8f4f 	dsb	sy
}
900163c6:	bf00      	nop
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
900163c8:	4a11      	ldr	r2, [pc, #68]	; (90016410 <AUDIO_Process+0x170>)
900163ca:	683b      	ldr	r3, [r7, #0]
900163cc:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
900163d0:	683b      	ldr	r3, [r7, #0]
900163d2:	3320      	adds	r3, #32
900163d4:	603b      	str	r3, [r7, #0]
        op_size -= __SCB_DCACHE_LINE_SIZE;
900163d6:	687b      	ldr	r3, [r7, #4]
900163d8:	3b20      	subs	r3, #32
900163da:	607b      	str	r3, [r7, #4]
      } while ( op_size > 0 );
900163dc:	687b      	ldr	r3, [r7, #4]
900163de:	2b00      	cmp	r3, #0
900163e0:	dcf2      	bgt.n	900163c8 <AUDIO_Process+0x128>
  __ASM volatile ("dsb 0xF":::"memory");
900163e2:	f3bf 8f4f 	dsb	sy
}
900163e6:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
900163e8:	f3bf 8f6f 	isb	sy
}
900163ec:	bf00      	nop
}
900163ee:	bf00      	nop
      /* Clean Data Cache to update the content of the SRAM */
      SCB_CleanDCache_by_Addr((uint32_t*)&buffer_ctl.buff[AUDIO_BUFFER_SIZE/2], AUDIO_BUFFER_SIZE/2);
      }
    }
    break;
900163f0:	e003      	b.n	900163fa <AUDIO_Process+0x15a>

  default:
    error_state = AUDIO_ERROR_NOTREADY;
900163f2:	2301      	movs	r3, #1
900163f4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    break;
900163f8:	e000      	b.n	900163fc <AUDIO_Process+0x15c>
    break;
900163fa:	bf00      	nop
  }
  return (uint8_t) error_state;
900163fc:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
90016400:	4618      	mov	r0, r3
90016402:	3728      	adds	r7, #40	; 0x28
90016404:	46bd      	mov	sp, r7
90016406:	bd80      	pop	{r7, pc}
90016408:	240027d0 	.word	0x240027d0
9001640c:	24001fc0 	.word	0x24001fc0
90016410:	e000ed00 	.word	0xe000ed00
90016414:	240023c0 	.word	0x240023c0

90016418 <BSP_AUDIO_OUT_TransferComplete_CallBack>:
  * @brief  Manages the full Transfer complete event.
  * @param  None
  * @retval None
  */
void BSP_AUDIO_OUT_TransferComplete_CallBack(uint32_t Interface)
{
90016418:	b480      	push	{r7}
9001641a:	b083      	sub	sp, #12
9001641c:	af00      	add	r7, sp, #0
9001641e:	6078      	str	r0, [r7, #4]
  if(audio_state == AUDIO_STATE_PLAYING)
90016420:	4b06      	ldr	r3, [pc, #24]	; (9001643c <BSP_AUDIO_OUT_TransferComplete_CallBack+0x24>)
90016422:	781b      	ldrb	r3, [r3, #0]
90016424:	2b02      	cmp	r3, #2
90016426:	d103      	bne.n	90016430 <BSP_AUDIO_OUT_TransferComplete_CallBack+0x18>
  {
    /* allows AUDIO_Process() to refill 2nd part of the buffer  */
    buffer_ctl.state = BUFFER_OFFSET_FULL;
90016428:	4b05      	ldr	r3, [pc, #20]	; (90016440 <BSP_AUDIO_OUT_TransferComplete_CallBack+0x28>)
9001642a:	2202      	movs	r2, #2
9001642c:	f883 2804 	strb.w	r2, [r3, #2052]	; 0x804
  }
}
90016430:	bf00      	nop
90016432:	370c      	adds	r7, #12
90016434:	46bd      	mov	sp, r7
90016436:	f85d 7b04 	ldr.w	r7, [sp], #4
9001643a:	4770      	bx	lr
9001643c:	240027d0 	.word	0x240027d0
90016440:	24001fc0 	.word	0x24001fc0

90016444 <BSP_AUDIO_OUT_HalfTransfer_CallBack>:
  * @brief  Manages the DMA Half Transfer complete event.
  * @param  None
  * @retval None
  */
void BSP_AUDIO_OUT_HalfTransfer_CallBack(uint32_t Interface)
{
90016444:	b480      	push	{r7}
90016446:	b083      	sub	sp, #12
90016448:	af00      	add	r7, sp, #0
9001644a:	6078      	str	r0, [r7, #4]
  if(audio_state == AUDIO_STATE_PLAYING)
9001644c:	4b06      	ldr	r3, [pc, #24]	; (90016468 <BSP_AUDIO_OUT_HalfTransfer_CallBack+0x24>)
9001644e:	781b      	ldrb	r3, [r3, #0]
90016450:	2b02      	cmp	r3, #2
90016452:	d103      	bne.n	9001645c <BSP_AUDIO_OUT_HalfTransfer_CallBack+0x18>
  {
    /* allows AUDIO_Process() to refill 1st part of the buffer  */
    buffer_ctl.state = BUFFER_OFFSET_HALF;
90016454:	4b05      	ldr	r3, [pc, #20]	; (9001646c <BSP_AUDIO_OUT_HalfTransfer_CallBack+0x28>)
90016456:	2201      	movs	r2, #1
90016458:	f883 2804 	strb.w	r2, [r3, #2052]	; 0x804
  }
}
9001645c:	bf00      	nop
9001645e:	370c      	adds	r7, #12
90016460:	46bd      	mov	sp, r7
90016462:	f85d 7b04 	ldr.w	r7, [sp], #4
90016466:	4770      	bx	lr
90016468:	240027d0 	.word	0x240027d0
9001646c:	24001fc0 	.word	0x24001fc0

90016470 <BSP_AUDIO_OUT_Error_CallBack>:
  * @brief  Manages the DMA FIFO error event.
  * @param  None
  * @retval None
  */
void BSP_AUDIO_OUT_Error_CallBack(uint32_t Interface)
{
90016470:	b580      	push	{r7, lr}
90016472:	b082      	sub	sp, #8
90016474:	af00      	add	r7, sp, #0
90016476:	6078      	str	r0, [r7, #4]
  /* Display message on the LCD screen */
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_RED);
90016478:	480f      	ldr	r0, [pc, #60]	; (900164b8 <BSP_AUDIO_OUT_Error_CallBack+0x48>)
9001647a:	f002 f95d 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_DisplayStringAt(0, LINE(14), (uint8_t *)"       DMA  ERROR     ", CENTER_MODE);
9001647e:	f002 f983 	bl	90018788 <UTIL_LCD_GetFont>
90016482:	4603      	mov	r3, r0
90016484:	88db      	ldrh	r3, [r3, #6]
90016486:	461a      	mov	r2, r3
90016488:	4613      	mov	r3, r2
9001648a:	00db      	lsls	r3, r3, #3
9001648c:	1a9b      	subs	r3, r3, r2
9001648e:	005b      	lsls	r3, r3, #1
90016490:	4619      	mov	r1, r3
90016492:	2301      	movs	r3, #1
90016494:	4a09      	ldr	r2, [pc, #36]	; (900164bc <BSP_AUDIO_OUT_Error_CallBack+0x4c>)
90016496:	2000      	movs	r0, #0
90016498:	f002 fa8e 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
9001649c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900164a0:	f002 f94a 	bl	90018738 <UTIL_LCD_SetBackColor>

  /* Stop the program with an infinite loop */
  while (BSP_PB_GetState(BUTTON_USER) != RESET)
900164a4:	bf00      	nop
900164a6:	2000      	movs	r0, #0
900164a8:	f7ee fd0e 	bl	90004ec8 <BSP_PB_GetState>
900164ac:	4603      	mov	r3, r0
900164ae:	2b00      	cmp	r3, #0
  {
    return;
900164b0:	bf00      	nop
  }

  /* could also generate a system reset to recover from the error */
  /* .... */
}
900164b2:	3708      	adds	r7, #8
900164b4:	46bd      	mov	sp, r7
900164b6:	bd80      	pop	{r7, pc}
900164b8:	ffff0000 	.word	0xffff0000
900164bc:	9001e9ec 	.word	0x9001e9ec

900164c0 <AudioRecord_demo>:
  *          - Audio OUT instance: 0 (SAI)
  *          - Audio OUT Device  : HDMI
  * @retval None
  */
void AudioRecord_demo(void)
{
900164c0:	b580      	push	{r7, lr}
900164c2:	b086      	sub	sp, #24
900164c4:	af02      	add	r7, sp, #8
   uint32_t channel_nbr = 2;
900164c6:	2302      	movs	r3, #2
900164c8:	60fb      	str	r3, [r7, #12]

  uint32_t x_size, y_size;

  BSP_LCD_GetXSize(0, &x_size);
900164ca:	f107 0308 	add.w	r3, r7, #8
900164ce:	4619      	mov	r1, r3
900164d0:	2000      	movs	r0, #0
900164d2:	f7f1 f8c5 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
900164d6:	1d3b      	adds	r3, r7, #4
900164d8:	4619      	mov	r1, r3
900164da:	2000      	movs	r0, #0
900164dc:	f7f1 f8de 	bl	9000769c <BSP_LCD_GetYSize>

  /* Clear the LCD */
  UTIL_LCD_Clear(UTIL_LCD_COLOR_WHITE);
900164e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900164e4:	f002 fa1c 	bl	90018920 <UTIL_LCD_Clear>
  /* Set Audio Demo description */
  UTIL_LCD_FillRect(0, 0, x_size, 90, UTIL_LCD_COLOR_BLUE);
900164e8:	68ba      	ldr	r2, [r7, #8]
900164ea:	4b4f      	ldr	r3, [pc, #316]	; (90016628 <AudioRecord_demo+0x168>)
900164ec:	9300      	str	r3, [sp, #0]
900164ee:	235a      	movs	r3, #90	; 0x5a
900164f0:	2100      	movs	r1, #0
900164f2:	2000      	movs	r0, #0
900164f4:	f002 fe3a 	bl	9001916c <UTIL_LCD_FillRect>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
900164f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900164fc:	f002 f908 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
90016500:	4849      	ldr	r0, [pc, #292]	; (90016628 <AudioRecord_demo+0x168>)
90016502:	f002 f919 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_SetFont(&Font24);
90016506:	4849      	ldr	r0, [pc, #292]	; (9001662c <AudioRecord_demo+0x16c>)
90016508:	f002 f92a 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, 0, (uint8_t *)"AUDIO RECORD SAI PDM EXAMPLE", CENTER_MODE);
9001650c:	2301      	movs	r3, #1
9001650e:	4a48      	ldr	r2, [pc, #288]	; (90016630 <AudioRecord_demo+0x170>)
90016510:	2100      	movs	r1, #0
90016512:	2000      	movs	r0, #0
90016514:	f002 fa50 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_SetFont(&Font16);
90016518:	4846      	ldr	r0, [pc, #280]	; (90016634 <AudioRecord_demo+0x174>)
9001651a:	f002 f921 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, 24, (uint8_t *)"Make sure the SW2 is in position PDM ", CENTER_MODE);
9001651e:	2301      	movs	r3, #1
90016520:	4a45      	ldr	r2, [pc, #276]	; (90016638 <AudioRecord_demo+0x178>)
90016522:	2118      	movs	r1, #24
90016524:	2000      	movs	r0, #0
90016526:	f002 fa47 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_DisplayStringAt(0, 40,  (uint8_t *)"Press User button for next menu", CENTER_MODE);
9001652a:	2301      	movs	r3, #1
9001652c:	4a43      	ldr	r2, [pc, #268]	; (9001663c <AudioRecord_demo+0x17c>)
9001652e:	2128      	movs	r1, #40	; 0x28
90016530:	2000      	movs	r0, #0
90016532:	f002 fa41 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  /* Set the LCD Text Color */
  UTIL_LCD_DrawRect(10, 100, x_size - 20, y_size - 110, UTIL_LCD_COLOR_BLUE);
90016536:	68bb      	ldr	r3, [r7, #8]
90016538:	f1a3 0214 	sub.w	r2, r3, #20
9001653c:	687b      	ldr	r3, [r7, #4]
9001653e:	3b6e      	subs	r3, #110	; 0x6e
90016540:	4939      	ldr	r1, [pc, #228]	; (90016628 <AudioRecord_demo+0x168>)
90016542:	9100      	str	r1, [sp, #0]
90016544:	2164      	movs	r1, #100	; 0x64
90016546:	200a      	movs	r0, #10
90016548:	f002 fba0 	bl	90018c8c <UTIL_LCD_DrawRect>
  UTIL_LCD_DrawRect(11, 101, x_size - 22, y_size - 112, UTIL_LCD_COLOR_BLUE);
9001654c:	68bb      	ldr	r3, [r7, #8]
9001654e:	f1a3 0216 	sub.w	r2, r3, #22
90016552:	687b      	ldr	r3, [r7, #4]
90016554:	3b70      	subs	r3, #112	; 0x70
90016556:	4934      	ldr	r1, [pc, #208]	; (90016628 <AudioRecord_demo+0x168>)
90016558:	9100      	str	r1, [sp, #0]
9001655a:	2165      	movs	r1, #101	; 0x65
9001655c:	200b      	movs	r0, #11
9001655e:	f002 fb95 	bl	90018c8c <UTIL_LCD_DrawRect>

  AudioFreq_ptr = AudioFreq+2; /* AUDIO_FREQUENCY_16K; */
90016562:	4a37      	ldr	r2, [pc, #220]	; (90016640 <AudioRecord_demo+0x180>)
90016564:	4b37      	ldr	r3, [pc, #220]	; (90016644 <AudioRecord_demo+0x184>)
90016566:	601a      	str	r2, [r3, #0]

  AudioOutInit.Device = AUDIO_OUT_DEVICE_HEADPHONE;
90016568:	4b37      	ldr	r3, [pc, #220]	; (90016648 <AudioRecord_demo+0x188>)
9001656a:	2202      	movs	r2, #2
9001656c:	601a      	str	r2, [r3, #0]
  AudioOutInit.ChannelsNbr = channel_nbr;
9001656e:	4a36      	ldr	r2, [pc, #216]	; (90016648 <AudioRecord_demo+0x188>)
90016570:	68fb      	ldr	r3, [r7, #12]
90016572:	60d3      	str	r3, [r2, #12]
  AudioOutInit.SampleRate = *AudioFreq_ptr;
90016574:	4b33      	ldr	r3, [pc, #204]	; (90016644 <AudioRecord_demo+0x184>)
90016576:	681b      	ldr	r3, [r3, #0]
90016578:	681b      	ldr	r3, [r3, #0]
9001657a:	4a33      	ldr	r2, [pc, #204]	; (90016648 <AudioRecord_demo+0x188>)
9001657c:	6053      	str	r3, [r2, #4]
  AudioOutInit.BitsPerSample = AUDIO_RESOLUTION_16B;
9001657e:	4b32      	ldr	r3, [pc, #200]	; (90016648 <AudioRecord_demo+0x188>)
90016580:	2210      	movs	r2, #16
90016582:	609a      	str	r2, [r3, #8]
  AudioOutInit.Volume = VolumeLevel;
90016584:	4b31      	ldr	r3, [pc, #196]	; (9001664c <AudioRecord_demo+0x18c>)
90016586:	681b      	ldr	r3, [r3, #0]
90016588:	4a2f      	ldr	r2, [pc, #188]	; (90016648 <AudioRecord_demo+0x188>)
9001658a:	6113      	str	r3, [r2, #16]

  AudioInInit.Device = AUDIO_IN_DEVICE_DIGITAL_MIC;
9001658c:	4b30      	ldr	r3, [pc, #192]	; (90016650 <AudioRecord_demo+0x190>)
9001658e:	2230      	movs	r2, #48	; 0x30
90016590:	601a      	str	r2, [r3, #0]
  AudioInInit.ChannelsNbr = channel_nbr;
90016592:	4a2f      	ldr	r2, [pc, #188]	; (90016650 <AudioRecord_demo+0x190>)
90016594:	68fb      	ldr	r3, [r7, #12]
90016596:	60d3      	str	r3, [r2, #12]
  AudioInInit.SampleRate = *AudioFreq_ptr;
90016598:	4b2a      	ldr	r3, [pc, #168]	; (90016644 <AudioRecord_demo+0x184>)
9001659a:	681b      	ldr	r3, [r3, #0]
9001659c:	681b      	ldr	r3, [r3, #0]
9001659e:	4a2c      	ldr	r2, [pc, #176]	; (90016650 <AudioRecord_demo+0x190>)
900165a0:	6053      	str	r3, [r2, #4]
  AudioInInit.BitsPerSample = AUDIO_RESOLUTION_16B;
900165a2:	4b2b      	ldr	r3, [pc, #172]	; (90016650 <AudioRecord_demo+0x190>)
900165a4:	2210      	movs	r2, #16
900165a6:	609a      	str	r2, [r3, #8]
  AudioInInit.Volume = VolumeLevel;
900165a8:	4b28      	ldr	r3, [pc, #160]	; (9001664c <AudioRecord_demo+0x18c>)
900165aa:	681b      	ldr	r3, [r3, #0]
900165ac:	4a28      	ldr	r2, [pc, #160]	; (90016650 <AudioRecord_demo+0x190>)
900165ae:	6113      	str	r3, [r2, #16]

  /* Initialize Audio Recorder with 2 channels to be used */
  BSP_AUDIO_IN_Init(1, &AudioInInit);
900165b0:	4927      	ldr	r1, [pc, #156]	; (90016650 <AudioRecord_demo+0x190>)
900165b2:	2001      	movs	r0, #1
900165b4:	f7ef f99c 	bl	900058f0 <BSP_AUDIO_IN_Init>
  BSP_AUDIO_IN_GetState(1, &InState);
900165b8:	4926      	ldr	r1, [pc, #152]	; (90016654 <AudioRecord_demo+0x194>)
900165ba:	2001      	movs	r0, #1
900165bc:	f7ef fdf0 	bl	900061a0 <BSP_AUDIO_IN_GetState>

  BSP_AUDIO_OUT_Init(0, &AudioOutInit);
900165c0:	4921      	ldr	r1, [pc, #132]	; (90016648 <AudioRecord_demo+0x188>)
900165c2:	2000      	movs	r0, #0
900165c4:	f7ee fcb0 	bl	90004f28 <BSP_AUDIO_OUT_Init>

  /* Start Recording */
  UTIL_LCD_DisplayStringAt(0, 190, (uint8_t *)"Start Recording ", CENTER_MODE);
900165c8:	2301      	movs	r3, #1
900165ca:	4a23      	ldr	r2, [pc, #140]	; (90016658 <AudioRecord_demo+0x198>)
900165cc:	21be      	movs	r1, #190	; 0xbe
900165ce:	2000      	movs	r0, #0
900165d0:	f002 f9f2 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  BSP_AUDIO_IN_RecordPDM(1, (uint8_t*)&recordPDMBuf, 2*AUDIO_IN_PDM_BUFFER_SIZE);
900165d4:	f44f 7200 	mov.w	r2, #512	; 0x200
900165d8:	4920      	ldr	r1, [pc, #128]	; (9001665c <AudioRecord_demo+0x19c>)
900165da:	2001      	movs	r0, #1
900165dc:	f7ef fdae 	bl	9000613c <BSP_AUDIO_IN_RecordPDM>

  /* Play the recorded buffer*/
  UTIL_LCD_DisplayStringAt(0, 220, (uint8_t *)"Play the recorded buffer... ", CENTER_MODE);
900165e0:	2301      	movs	r3, #1
900165e2:	4a1f      	ldr	r2, [pc, #124]	; (90016660 <AudioRecord_demo+0x1a0>)
900165e4:	21dc      	movs	r1, #220	; 0xdc
900165e6:	2000      	movs	r0, #0
900165e8:	f002 f9e6 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  BSP_AUDIO_OUT_Play(0, (uint8_t*)&RecPlayback[0], 2*AUDIO_BUFF_SIZE);
900165ec:	f44f 5200 	mov.w	r2, #8192	; 0x2000
900165f0:	491c      	ldr	r1, [pc, #112]	; (90016664 <AudioRecord_demo+0x1a4>)
900165f2:	2000      	movs	r0, #0
900165f4:	f7ee fee0 	bl	900053b8 <BSP_AUDIO_OUT_Play>

  while (1)
  {
    if (CheckForUserInput() > 0)
900165f8:	f000 fd54 	bl	900170a4 <CheckForUserInput>
900165fc:	4603      	mov	r3, r0
900165fe:	2b00      	cmp	r3, #0
90016600:	d0fa      	beq.n	900165f8 <AudioRecord_demo+0x138>
    {
      ButtonState = 0;
90016602:	4b19      	ldr	r3, [pc, #100]	; (90016668 <AudioRecord_demo+0x1a8>)
90016604:	2200      	movs	r2, #0
90016606:	601a      	str	r2, [r3, #0]
      BSP_AUDIO_OUT_Stop(0);
90016608:	2000      	movs	r0, #0
9001660a:	f7ee ffd9 	bl	900055c0 <BSP_AUDIO_OUT_Stop>
      BSP_AUDIO_OUT_DeInit(0);
9001660e:	2000      	movs	r0, #0
90016610:	f7ee fd82 	bl	90005118 <BSP_AUDIO_OUT_DeInit>
      BSP_AUDIO_IN_Stop(1);
90016614:	2001      	movs	r0, #1
90016616:	f7ef fd4f 	bl	900060b8 <BSP_AUDIO_IN_Stop>
      BSP_AUDIO_IN_DeInit(1);
9001661a:	2001      	movs	r0, #1
9001661c:	f7ef fafa 	bl	90005c14 <BSP_AUDIO_IN_DeInit>
      return;
90016620:	bf00      	nop
    }
  }
}
90016622:	3710      	adds	r7, #16
90016624:	46bd      	mov	sp, r7
90016626:	bd80      	pop	{r7, pc}
90016628:	ff0000ff 	.word	0xff0000ff
9001662c:	24000388 	.word	0x24000388
90016630:	9001eb1c 	.word	0x9001eb1c
90016634:	24000398 	.word	0x24000398
90016638:	9001eb3c 	.word	0x9001eb3c
9001663c:	9001eb64 	.word	0x9001eb64
90016640:	240000d0 	.word	0x240000d0
90016644:	24008ff0 	.word	0x24008ff0
90016648:	24002e80 	.word	0x24002e80
9001664c:	240000ec 	.word	0x240000ec
90016650:	24008ec0 	.word	0x24008ec0
90016654:	240027dc 	.word	0x240027dc
90016658:	9001eb84 	.word	0x9001eb84
9001665c:	38000000 	.word	0x38000000
90016660:	9001eb98 	.word	0x9001eb98
90016664:	24002ea0 	.word	0x24002ea0
90016668:	240027f0 	.word	0x240027f0

9001666c <BSP_AUDIO_IN_TransferComplete_CallBack>:
/**
  * @brief Calculates the remaining file size and new position of the pointer.
  * @retval None
  */
void BSP_AUDIO_IN_TransferComplete_CallBack(uint32_t Instance)
{
9001666c:	b580      	push	{r7, lr}
9001666e:	b08a      	sub	sp, #40	; 0x28
90016670:	af00      	add	r7, sp, #0
90016672:	6078      	str	r0, [r7, #4]
  if(Instance == 1U)
90016674:	687b      	ldr	r3, [r7, #4]
90016676:	2b01      	cmp	r3, #1
90016678:	d168      	bne.n	9001674c <BSP_AUDIO_IN_TransferComplete_CallBack+0xe0>
9001667a:	4b38      	ldr	r3, [pc, #224]	; (9001675c <BSP_AUDIO_IN_TransferComplete_CallBack+0xf0>)
9001667c:	617b      	str	r3, [r7, #20]
9001667e:	f44f 7300 	mov.w	r3, #512	; 0x200
90016682:	613b      	str	r3, [r7, #16]
    if ( dsize > 0 ) { 
90016684:	693b      	ldr	r3, [r7, #16]
90016686:	2b00      	cmp	r3, #0
90016688:	dd1d      	ble.n	900166c6 <BSP_AUDIO_IN_TransferComplete_CallBack+0x5a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
9001668a:	697b      	ldr	r3, [r7, #20]
9001668c:	f003 021f 	and.w	r2, r3, #31
90016690:	693b      	ldr	r3, [r7, #16]
90016692:	4413      	add	r3, r2
90016694:	60fb      	str	r3, [r7, #12]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
90016696:	697b      	ldr	r3, [r7, #20]
90016698:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("dsb 0xF":::"memory");
9001669a:	f3bf 8f4f 	dsb	sy
}
9001669e:	bf00      	nop
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
900166a0:	4a2f      	ldr	r2, [pc, #188]	; (90016760 <BSP_AUDIO_IN_TransferComplete_CallBack+0xf4>)
900166a2:	68bb      	ldr	r3, [r7, #8]
900166a4:	f8c2 325c 	str.w	r3, [r2, #604]	; 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
900166a8:	68bb      	ldr	r3, [r7, #8]
900166aa:	3320      	adds	r3, #32
900166ac:	60bb      	str	r3, [r7, #8]
        op_size -= __SCB_DCACHE_LINE_SIZE;
900166ae:	68fb      	ldr	r3, [r7, #12]
900166b0:	3b20      	subs	r3, #32
900166b2:	60fb      	str	r3, [r7, #12]
      } while ( op_size > 0 );
900166b4:	68fb      	ldr	r3, [r7, #12]
900166b6:	2b00      	cmp	r3, #0
900166b8:	dcf2      	bgt.n	900166a0 <BSP_AUDIO_IN_TransferComplete_CallBack+0x34>
  __ASM volatile ("dsb 0xF":::"memory");
900166ba:	f3bf 8f4f 	dsb	sy
}
900166be:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
900166c0:	f3bf 8f6f 	isb	sy
}
900166c4:	bf00      	nop
}
900166c6:	bf00      	nop
  {
        /* Invalidate Data Cache to get the updated content of the SRAM*/
    SCB_InvalidateDCache_by_Addr((uint32_t *)&recordPDMBuf[AUDIO_IN_PDM_BUFFER_SIZE/2], AUDIO_IN_PDM_BUFFER_SIZE*2);

    BSP_AUDIO_IN_PDMToPCM(Instance, (uint16_t*)&recordPDMBuf[AUDIO_IN_PDM_BUFFER_SIZE/2], &RecPlayback[playbackPtr]);
900166c8:	4b26      	ldr	r3, [pc, #152]	; (90016764 <BSP_AUDIO_IN_TransferComplete_CallBack+0xf8>)
900166ca:	681b      	ldr	r3, [r3, #0]
900166cc:	005b      	lsls	r3, r3, #1
900166ce:	4a26      	ldr	r2, [pc, #152]	; (90016768 <BSP_AUDIO_IN_TransferComplete_CallBack+0xfc>)
900166d0:	4413      	add	r3, r2
900166d2:	461a      	mov	r2, r3
900166d4:	4921      	ldr	r1, [pc, #132]	; (9001675c <BSP_AUDIO_IN_TransferComplete_CallBack+0xf0>)
900166d6:	6878      	ldr	r0, [r7, #4]
900166d8:	f7ef fcb4 	bl	90006044 <BSP_AUDIO_IN_PDMToPCM>

    /* Clean Data Cache to update the content of the SRAM */
    SCB_CleanDCache_by_Addr((uint32_t*)&RecPlayback[playbackPtr], AUDIO_IN_PDM_BUFFER_SIZE/4);
900166dc:	4b21      	ldr	r3, [pc, #132]	; (90016764 <BSP_AUDIO_IN_TransferComplete_CallBack+0xf8>)
900166de:	681b      	ldr	r3, [r3, #0]
900166e0:	005b      	lsls	r3, r3, #1
900166e2:	4a21      	ldr	r2, [pc, #132]	; (90016768 <BSP_AUDIO_IN_TransferComplete_CallBack+0xfc>)
900166e4:	4413      	add	r3, r2
900166e6:	627b      	str	r3, [r7, #36]	; 0x24
900166e8:	2340      	movs	r3, #64	; 0x40
900166ea:	623b      	str	r3, [r7, #32]
    if ( dsize > 0 ) { 
900166ec:	6a3b      	ldr	r3, [r7, #32]
900166ee:	2b00      	cmp	r3, #0
900166f0:	dd1d      	ble.n	9001672e <BSP_AUDIO_IN_TransferComplete_CallBack+0xc2>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
900166f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
900166f4:	f003 021f 	and.w	r2, r3, #31
900166f8:	6a3b      	ldr	r3, [r7, #32]
900166fa:	4413      	add	r3, r2
900166fc:	61fb      	str	r3, [r7, #28]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
900166fe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90016700:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("dsb 0xF":::"memory");
90016702:	f3bf 8f4f 	dsb	sy
}
90016706:	bf00      	nop
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
90016708:	4a15      	ldr	r2, [pc, #84]	; (90016760 <BSP_AUDIO_IN_TransferComplete_CallBack+0xf4>)
9001670a:	69bb      	ldr	r3, [r7, #24]
9001670c:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
90016710:	69bb      	ldr	r3, [r7, #24]
90016712:	3320      	adds	r3, #32
90016714:	61bb      	str	r3, [r7, #24]
        op_size -= __SCB_DCACHE_LINE_SIZE;
90016716:	69fb      	ldr	r3, [r7, #28]
90016718:	3b20      	subs	r3, #32
9001671a:	61fb      	str	r3, [r7, #28]
      } while ( op_size > 0 );
9001671c:	69fb      	ldr	r3, [r7, #28]
9001671e:	2b00      	cmp	r3, #0
90016720:	dcf2      	bgt.n	90016708 <BSP_AUDIO_IN_TransferComplete_CallBack+0x9c>
  __ASM volatile ("dsb 0xF":::"memory");
90016722:	f3bf 8f4f 	dsb	sy
}
90016726:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
90016728:	f3bf 8f6f 	isb	sy
}
9001672c:	bf00      	nop
}
9001672e:	bf00      	nop

    playbackPtr += AUDIO_IN_PDM_BUFFER_SIZE/4/2;
90016730:	4b0c      	ldr	r3, [pc, #48]	; (90016764 <BSP_AUDIO_IN_TransferComplete_CallBack+0xf8>)
90016732:	681b      	ldr	r3, [r3, #0]
90016734:	3320      	adds	r3, #32
90016736:	4a0b      	ldr	r2, [pc, #44]	; (90016764 <BSP_AUDIO_IN_TransferComplete_CallBack+0xf8>)
90016738:	6013      	str	r3, [r2, #0]
    if(playbackPtr >= AUDIO_BUFF_SIZE)
9001673a:	4b0a      	ldr	r3, [pc, #40]	; (90016764 <BSP_AUDIO_IN_TransferComplete_CallBack+0xf8>)
9001673c:	681b      	ldr	r3, [r3, #0]
9001673e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
90016742:	d306      	bcc.n	90016752 <BSP_AUDIO_IN_TransferComplete_CallBack+0xe6>
    {  playbackPtr = 0;
90016744:	4b07      	ldr	r3, [pc, #28]	; (90016764 <BSP_AUDIO_IN_TransferComplete_CallBack+0xf8>)
90016746:	2200      	movs	r2, #0
90016748:	601a      	str	r2, [r3, #0]
  }
  else
  {
    AudioBufferOffset = BUFFER_OFFSET_FULL;
  }
}
9001674a:	e002      	b.n	90016752 <BSP_AUDIO_IN_TransferComplete_CallBack+0xe6>
    AudioBufferOffset = BUFFER_OFFSET_FULL;
9001674c:	4b07      	ldr	r3, [pc, #28]	; (9001676c <BSP_AUDIO_IN_TransferComplete_CallBack+0x100>)
9001674e:	2202      	movs	r2, #2
90016750:	601a      	str	r2, [r3, #0]
}
90016752:	bf00      	nop
90016754:	3728      	adds	r7, #40	; 0x28
90016756:	46bd      	mov	sp, r7
90016758:	bd80      	pop	{r7, pc}
9001675a:	bf00      	nop
9001675c:	38000100 	.word	0x38000100
90016760:	e000ed00 	.word	0xe000ed00
90016764:	24008ed4 	.word	0x24008ed4
90016768:	24002ea0 	.word	0x24002ea0
9001676c:	24008fec 	.word	0x24008fec

90016770 <BSP_AUDIO_IN_HalfTransfer_CallBack>:
/**
  * @brief  Manages the DMA Half Transfer complete interrupt.
  * @retval None
  */
void BSP_AUDIO_IN_HalfTransfer_CallBack(uint32_t Instance)
{
90016770:	b580      	push	{r7, lr}
90016772:	b08a      	sub	sp, #40	; 0x28
90016774:	af00      	add	r7, sp, #0
90016776:	6078      	str	r0, [r7, #4]
  if(Instance == 1U)
90016778:	687b      	ldr	r3, [r7, #4]
9001677a:	2b01      	cmp	r3, #1
9001677c:	d168      	bne.n	90016850 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xe0>
9001677e:	4b38      	ldr	r3, [pc, #224]	; (90016860 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf0>)
90016780:	617b      	str	r3, [r7, #20]
90016782:	f44f 7300 	mov.w	r3, #512	; 0x200
90016786:	613b      	str	r3, [r7, #16]
    if ( dsize > 0 ) { 
90016788:	693b      	ldr	r3, [r7, #16]
9001678a:	2b00      	cmp	r3, #0
9001678c:	dd1d      	ble.n	900167ca <BSP_AUDIO_IN_HalfTransfer_CallBack+0x5a>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
9001678e:	697b      	ldr	r3, [r7, #20]
90016790:	f003 021f 	and.w	r2, r3, #31
90016794:	693b      	ldr	r3, [r7, #16]
90016796:	4413      	add	r3, r2
90016798:	60fb      	str	r3, [r7, #12]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
9001679a:	697b      	ldr	r3, [r7, #20]
9001679c:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("dsb 0xF":::"memory");
9001679e:	f3bf 8f4f 	dsb	sy
}
900167a2:	bf00      	nop
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
900167a4:	4a2f      	ldr	r2, [pc, #188]	; (90016864 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf4>)
900167a6:	68bb      	ldr	r3, [r7, #8]
900167a8:	f8c2 325c 	str.w	r3, [r2, #604]	; 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
900167ac:	68bb      	ldr	r3, [r7, #8]
900167ae:	3320      	adds	r3, #32
900167b0:	60bb      	str	r3, [r7, #8]
        op_size -= __SCB_DCACHE_LINE_SIZE;
900167b2:	68fb      	ldr	r3, [r7, #12]
900167b4:	3b20      	subs	r3, #32
900167b6:	60fb      	str	r3, [r7, #12]
      } while ( op_size > 0 );
900167b8:	68fb      	ldr	r3, [r7, #12]
900167ba:	2b00      	cmp	r3, #0
900167bc:	dcf2      	bgt.n	900167a4 <BSP_AUDIO_IN_HalfTransfer_CallBack+0x34>
  __ASM volatile ("dsb 0xF":::"memory");
900167be:	f3bf 8f4f 	dsb	sy
}
900167c2:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
900167c4:	f3bf 8f6f 	isb	sy
}
900167c8:	bf00      	nop
}
900167ca:	bf00      	nop
  {
        /* Invalidate Data Cache to get the updated content of the SRAM*/
    SCB_InvalidateDCache_by_Addr((uint32_t *)&recordPDMBuf[0], AUDIO_IN_PDM_BUFFER_SIZE*2);

    BSP_AUDIO_IN_PDMToPCM(Instance, (uint16_t*)&recordPDMBuf[0], &RecPlayback[playbackPtr]);
900167cc:	4b26      	ldr	r3, [pc, #152]	; (90016868 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf8>)
900167ce:	681b      	ldr	r3, [r3, #0]
900167d0:	005b      	lsls	r3, r3, #1
900167d2:	4a26      	ldr	r2, [pc, #152]	; (9001686c <BSP_AUDIO_IN_HalfTransfer_CallBack+0xfc>)
900167d4:	4413      	add	r3, r2
900167d6:	461a      	mov	r2, r3
900167d8:	4921      	ldr	r1, [pc, #132]	; (90016860 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf0>)
900167da:	6878      	ldr	r0, [r7, #4]
900167dc:	f7ef fc32 	bl	90006044 <BSP_AUDIO_IN_PDMToPCM>

    /* Clean Data Cache to update the content of the SRAM */
    SCB_CleanDCache_by_Addr((uint32_t*)&RecPlayback[playbackPtr], AUDIO_IN_PDM_BUFFER_SIZE/4);
900167e0:	4b21      	ldr	r3, [pc, #132]	; (90016868 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf8>)
900167e2:	681b      	ldr	r3, [r3, #0]
900167e4:	005b      	lsls	r3, r3, #1
900167e6:	4a21      	ldr	r2, [pc, #132]	; (9001686c <BSP_AUDIO_IN_HalfTransfer_CallBack+0xfc>)
900167e8:	4413      	add	r3, r2
900167ea:	627b      	str	r3, [r7, #36]	; 0x24
900167ec:	2340      	movs	r3, #64	; 0x40
900167ee:	623b      	str	r3, [r7, #32]
    if ( dsize > 0 ) { 
900167f0:	6a3b      	ldr	r3, [r7, #32]
900167f2:	2b00      	cmp	r3, #0
900167f4:	dd1d      	ble.n	90016832 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xc2>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
900167f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
900167f8:	f003 021f 	and.w	r2, r3, #31
900167fc:	6a3b      	ldr	r3, [r7, #32]
900167fe:	4413      	add	r3, r2
90016800:	61fb      	str	r3, [r7, #28]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
90016802:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90016804:	61bb      	str	r3, [r7, #24]
  __ASM volatile ("dsb 0xF":::"memory");
90016806:	f3bf 8f4f 	dsb	sy
}
9001680a:	bf00      	nop
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
9001680c:	4a15      	ldr	r2, [pc, #84]	; (90016864 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf4>)
9001680e:	69bb      	ldr	r3, [r7, #24]
90016810:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
90016814:	69bb      	ldr	r3, [r7, #24]
90016816:	3320      	adds	r3, #32
90016818:	61bb      	str	r3, [r7, #24]
        op_size -= __SCB_DCACHE_LINE_SIZE;
9001681a:	69fb      	ldr	r3, [r7, #28]
9001681c:	3b20      	subs	r3, #32
9001681e:	61fb      	str	r3, [r7, #28]
      } while ( op_size > 0 );
90016820:	69fb      	ldr	r3, [r7, #28]
90016822:	2b00      	cmp	r3, #0
90016824:	dcf2      	bgt.n	9001680c <BSP_AUDIO_IN_HalfTransfer_CallBack+0x9c>
  __ASM volatile ("dsb 0xF":::"memory");
90016826:	f3bf 8f4f 	dsb	sy
}
9001682a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
9001682c:	f3bf 8f6f 	isb	sy
}
90016830:	bf00      	nop
}
90016832:	bf00      	nop

    playbackPtr += AUDIO_IN_PDM_BUFFER_SIZE/4/2;
90016834:	4b0c      	ldr	r3, [pc, #48]	; (90016868 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf8>)
90016836:	681b      	ldr	r3, [r3, #0]
90016838:	3320      	adds	r3, #32
9001683a:	4a0b      	ldr	r2, [pc, #44]	; (90016868 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf8>)
9001683c:	6013      	str	r3, [r2, #0]
    if(playbackPtr >= AUDIO_BUFF_SIZE)
9001683e:	4b0a      	ldr	r3, [pc, #40]	; (90016868 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf8>)
90016840:	681b      	ldr	r3, [r3, #0]
90016842:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
90016846:	d306      	bcc.n	90016856 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xe6>
    {
      playbackPtr = 0;
90016848:	4b07      	ldr	r3, [pc, #28]	; (90016868 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xf8>)
9001684a:	2200      	movs	r2, #0
9001684c:	601a      	str	r2, [r3, #0]
  }
  else
  {
    AudioBufferOffset = BUFFER_OFFSET_HALF;
  }
}
9001684e:	e002      	b.n	90016856 <BSP_AUDIO_IN_HalfTransfer_CallBack+0xe6>
    AudioBufferOffset = BUFFER_OFFSET_HALF;
90016850:	4b07      	ldr	r3, [pc, #28]	; (90016870 <BSP_AUDIO_IN_HalfTransfer_CallBack+0x100>)
90016852:	2201      	movs	r2, #1
90016854:	601a      	str	r2, [r3, #0]
}
90016856:	bf00      	nop
90016858:	3728      	adds	r7, #40	; 0x28
9001685a:	46bd      	mov	sp, r7
9001685c:	bd80      	pop	{r7, pc}
9001685e:	bf00      	nop
90016860:	38000000 	.word	0x38000000
90016864:	e000ed00 	.word	0xe000ed00
90016868:	24008ed4 	.word	0x24008ed4
9001686c:	24002ea0 	.word	0x24002ea0
90016870:	24008fec 	.word	0x24008fec

90016874 <LCD_demo>:
  * @brief  LCD demo
  * @param  None
  * @retval None
  */
void LCD_demo (void)
{
90016874:	b580      	push	{r7, lr}
90016876:	af00      	add	r7, sp, #0
  LCD_SetHint();
90016878:	f000 f824 	bl	900168c4 <LCD_SetHint>
  LCD_Feature = 0;
9001687c:	4b10      	ldr	r3, [pc, #64]	; (900168c0 <LCD_demo+0x4c>)
9001687e:	2200      	movs	r2, #0
90016880:	701a      	strb	r2, [r3, #0]
  LCD_Show_Feature (LCD_Feature);
90016882:	4b0f      	ldr	r3, [pc, #60]	; (900168c0 <LCD_demo+0x4c>)
90016884:	781b      	ldrb	r3, [r3, #0]
90016886:	4618      	mov	r0, r3
90016888:	f000 f888 	bl	9001699c <LCD_Show_Feature>

  while (1)
  {

    if(CheckForUserInput() > 0)
9001688c:	f000 fc0a 	bl	900170a4 <CheckForUserInput>
90016890:	4603      	mov	r3, r0
90016892:	2b00      	cmp	r3, #0
90016894:	d00e      	beq.n	900168b4 <LCD_demo+0x40>
    {
      if(++LCD_Feature < LCD_FEATURES_NUM)
90016896:	4b0a      	ldr	r3, [pc, #40]	; (900168c0 <LCD_demo+0x4c>)
90016898:	781b      	ldrb	r3, [r3, #0]
9001689a:	3301      	adds	r3, #1
9001689c:	b2da      	uxtb	r2, r3
9001689e:	4b08      	ldr	r3, [pc, #32]	; (900168c0 <LCD_demo+0x4c>)
900168a0:	701a      	strb	r2, [r3, #0]
900168a2:	4b07      	ldr	r3, [pc, #28]	; (900168c0 <LCD_demo+0x4c>)
900168a4:	781b      	ldrb	r3, [r3, #0]
900168a6:	2b03      	cmp	r3, #3
900168a8:	d808      	bhi.n	900168bc <LCD_demo+0x48>
      {
       LCD_Show_Feature (LCD_Feature);
900168aa:	4b05      	ldr	r3, [pc, #20]	; (900168c0 <LCD_demo+0x4c>)
900168ac:	781b      	ldrb	r3, [r3, #0]
900168ae:	4618      	mov	r0, r3
900168b0:	f000 f874 	bl	9001699c <LCD_Show_Feature>
      else
      {
        return;
      }
    }
    HAL_Delay(100);
900168b4:	2064      	movs	r0, #100	; 0x64
900168b6:	f7f2 fd91 	bl	900093dc <HAL_Delay>
    if(CheckForUserInput() > 0)
900168ba:	e7e7      	b.n	9001688c <LCD_demo+0x18>
        return;
900168bc:	bf00      	nop
  }
}
900168be:	bd80      	pop	{r7, pc}
900168c0:	240027e8 	.word	0x240027e8

900168c4 <LCD_SetHint>:
  * @brief  Display LCD demo hint
  * @param  None
  * @retval None
  */
static void LCD_SetHint(void)
{
900168c4:	b580      	push	{r7, lr}
900168c6:	b084      	sub	sp, #16
900168c8:	af02      	add	r7, sp, #8
  uint32_t x_size, y_size;

  BSP_LCD_GetXSize(0, &x_size);
900168ca:	1d3b      	adds	r3, r7, #4
900168cc:	4619      	mov	r1, r3
900168ce:	2000      	movs	r0, #0
900168d0:	f7f0 fec6 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
900168d4:	463b      	mov	r3, r7
900168d6:	4619      	mov	r1, r3
900168d8:	2000      	movs	r0, #0
900168da:	f7f0 fedf 	bl	9000769c <BSP_LCD_GetYSize>
  /* Clear the LCD */
  UTIL_LCD_Clear(UTIL_LCD_COLOR_WHITE);
900168de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900168e2:	f002 f81d 	bl	90018920 <UTIL_LCD_Clear>

  /* Set LCD Demo description */
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLUE);
900168e6:	4826      	ldr	r0, [pc, #152]	; (90016980 <LCD_SetHint+0xbc>)
900168e8:	f001 ff12 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_FillRect(0, 0, x_size, 80, UTIL_LCD_COLOR_BLUE);
900168ec:	687a      	ldr	r2, [r7, #4]
900168ee:	4b24      	ldr	r3, [pc, #144]	; (90016980 <LCD_SetHint+0xbc>)
900168f0:	9300      	str	r3, [sp, #0]
900168f2:	2350      	movs	r3, #80	; 0x50
900168f4:	2100      	movs	r1, #0
900168f6:	2000      	movs	r0, #0
900168f8:	f002 fc38 	bl	9001916c <UTIL_LCD_FillRect>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
900168fc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90016900:	f001 ff06 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
90016904:	481e      	ldr	r0, [pc, #120]	; (90016980 <LCD_SetHint+0xbc>)
90016906:	f001 ff17 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_SetFont(&Font24);
9001690a:	481e      	ldr	r0, [pc, #120]	; (90016984 <LCD_SetHint+0xc0>)
9001690c:	f001 ff28 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, 0, (uint8_t *)"LCD", CENTER_MODE);
90016910:	2301      	movs	r3, #1
90016912:	4a1d      	ldr	r2, [pc, #116]	; (90016988 <LCD_SetHint+0xc4>)
90016914:	2100      	movs	r1, #0
90016916:	2000      	movs	r0, #0
90016918:	f002 f84e 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_SetFont(&Font12);
9001691c:	481b      	ldr	r0, [pc, #108]	; (9001698c <LCD_SetHint+0xc8>)
9001691e:	f001 ff1f 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, 30, (uint8_t *)"This example shows the different", CENTER_MODE);
90016922:	2301      	movs	r3, #1
90016924:	4a1a      	ldr	r2, [pc, #104]	; (90016990 <LCD_SetHint+0xcc>)
90016926:	211e      	movs	r1, #30
90016928:	2000      	movs	r0, #0
9001692a:	f002 f845 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_DisplayStringAt(0, 45, (uint8_t *)"LCD Features, use Tamper push-button to display", CENTER_MODE);
9001692e:	2301      	movs	r3, #1
90016930:	4a18      	ldr	r2, [pc, #96]	; (90016994 <LCD_SetHint+0xd0>)
90016932:	212d      	movs	r1, #45	; 0x2d
90016934:	2000      	movs	r0, #0
90016936:	f002 f83f 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_DisplayStringAt(0, 60, (uint8_t *)"next page", CENTER_MODE);
9001693a:	2301      	movs	r3, #1
9001693c:	4a16      	ldr	r2, [pc, #88]	; (90016998 <LCD_SetHint+0xd4>)
9001693e:	213c      	movs	r1, #60	; 0x3c
90016940:	2000      	movs	r0, #0
90016942:	f002 f839 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

  /* Set the LCD Text Color */
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLUE);
90016946:	480e      	ldr	r0, [pc, #56]	; (90016980 <LCD_SetHint+0xbc>)
90016948:	f001 fee2 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_DrawRect(10, 90, x_size - 20, y_size - 100, UTIL_LCD_COLOR_BLUE);
9001694c:	687b      	ldr	r3, [r7, #4]
9001694e:	f1a3 0214 	sub.w	r2, r3, #20
90016952:	683b      	ldr	r3, [r7, #0]
90016954:	3b64      	subs	r3, #100	; 0x64
90016956:	490a      	ldr	r1, [pc, #40]	; (90016980 <LCD_SetHint+0xbc>)
90016958:	9100      	str	r1, [sp, #0]
9001695a:	215a      	movs	r1, #90	; 0x5a
9001695c:	200a      	movs	r0, #10
9001695e:	f002 f995 	bl	90018c8c <UTIL_LCD_DrawRect>
  UTIL_LCD_DrawRect(11, 91, x_size - 22, y_size - 102, UTIL_LCD_COLOR_BLUE);
90016962:	687b      	ldr	r3, [r7, #4]
90016964:	f1a3 0216 	sub.w	r2, r3, #22
90016968:	683b      	ldr	r3, [r7, #0]
9001696a:	3b66      	subs	r3, #102	; 0x66
9001696c:	4904      	ldr	r1, [pc, #16]	; (90016980 <LCD_SetHint+0xbc>)
9001696e:	9100      	str	r1, [sp, #0]
90016970:	215b      	movs	r1, #91	; 0x5b
90016972:	200b      	movs	r0, #11
90016974:	f002 f98a 	bl	90018c8c <UTIL_LCD_DrawRect>
 }
90016978:	bf00      	nop
9001697a:	3708      	adds	r7, #8
9001697c:	46bd      	mov	sp, r7
9001697e:	bd80      	pop	{r7, pc}
90016980:	ff0000ff 	.word	0xff0000ff
90016984:	24000388 	.word	0x24000388
90016988:	9001ebb8 	.word	0x9001ebb8
9001698c:	240003a0 	.word	0x240003a0
90016990:	9001ebbc 	.word	0x9001ebbc
90016994:	9001ebe0 	.word	0x9001ebe0
90016998:	9001ec10 	.word	0x9001ec10

9001699c <LCD_Show_Feature>:
  * @brief  Show LCD Features
  * @param  feature : feature index
  * @retval None
  */
static void LCD_Show_Feature(uint8_t feature)
{
9001699c:	b5b0      	push	{r4, r5, r7, lr}
9001699e:	b092      	sub	sp, #72	; 0x48
900169a0:	af02      	add	r7, sp, #8
900169a2:	4603      	mov	r3, r0
900169a4:	71fb      	strb	r3, [r7, #7]
  Point Points[]= {{250, 160}, {270, 140}, {290, 140}, {310, 160}, {310, 180}, {290, 200}, {270, 200}, {250, 180}};
900169a6:	4ba7      	ldr	r3, [pc, #668]	; (90016c44 <LCD_Show_Feature+0x2a8>)
900169a8:	f107 0420 	add.w	r4, r7, #32
900169ac:	461d      	mov	r5, r3
900169ae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
900169b0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
900169b2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
900169b6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  Point Points2[3];
  uint32_t x_size, y_size;

  BSP_LCD_GetXSize(0, &x_size);
900169ba:	f107 0310 	add.w	r3, r7, #16
900169be:	4619      	mov	r1, r3
900169c0:	2000      	movs	r0, #0
900169c2:	f7f0 fe4d 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
900169c6:	f107 030c 	add.w	r3, r7, #12
900169ca:	4619      	mov	r1, r3
900169cc:	2000      	movs	r0, #0
900169ce:	f7f0 fe65 	bl	9000769c <BSP_LCD_GetYSize>

  Points2[0].X = x_size - 80;
900169d2:	693b      	ldr	r3, [r7, #16]
900169d4:	b29b      	uxth	r3, r3
900169d6:	3b50      	subs	r3, #80	; 0x50
900169d8:	b29b      	uxth	r3, r3
900169da:	b21b      	sxth	r3, r3
900169dc:	82bb      	strh	r3, [r7, #20]
  Points2[0].Y = y_size - 50;
900169de:	68fb      	ldr	r3, [r7, #12]
900169e0:	b29b      	uxth	r3, r3
900169e2:	3b32      	subs	r3, #50	; 0x32
900169e4:	b29b      	uxth	r3, r3
900169e6:	b21b      	sxth	r3, r3
900169e8:	82fb      	strh	r3, [r7, #22]
  Points2[1].X = x_size - 20;
900169ea:	693b      	ldr	r3, [r7, #16]
900169ec:	b29b      	uxth	r3, r3
900169ee:	3b14      	subs	r3, #20
900169f0:	b29b      	uxth	r3, r3
900169f2:	b21b      	sxth	r3, r3
900169f4:	833b      	strh	r3, [r7, #24]
  Points2[1].Y = y_size - 50;
900169f6:	68fb      	ldr	r3, [r7, #12]
900169f8:	b29b      	uxth	r3, r3
900169fa:	3b32      	subs	r3, #50	; 0x32
900169fc:	b29b      	uxth	r3, r3
900169fe:	b21b      	sxth	r3, r3
90016a00:	837b      	strh	r3, [r7, #26]
  Points2[2].X = x_size - 20;
90016a02:	693b      	ldr	r3, [r7, #16]
90016a04:	b29b      	uxth	r3, r3
90016a06:	3b14      	subs	r3, #20
90016a08:	b29b      	uxth	r3, r3
90016a0a:	b21b      	sxth	r3, r3
90016a0c:	83bb      	strh	r3, [r7, #28]
  Points2[2].Y = y_size - 100;
90016a0e:	68fb      	ldr	r3, [r7, #12]
90016a10:	b29b      	uxth	r3, r3
90016a12:	3b64      	subs	r3, #100	; 0x64
90016a14:	b29b      	uxth	r3, r3
90016a16:	b21b      	sxth	r3, r3
90016a18:	83fb      	strh	r3, [r7, #30]

  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
90016a1a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90016a1e:	f001 fe8b 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
90016a22:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90016a26:	f001 fe73 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_FillRect(12, 92, x_size - 24, y_size- 104, UTIL_LCD_COLOR_WHITE);
90016a2a:	693b      	ldr	r3, [r7, #16]
90016a2c:	f1a3 0218 	sub.w	r2, r3, #24
90016a30:	68fb      	ldr	r3, [r7, #12]
90016a32:	3b68      	subs	r3, #104	; 0x68
90016a34:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
90016a38:	9100      	str	r1, [sp, #0]
90016a3a:	215c      	movs	r1, #92	; 0x5c
90016a3c:	200c      	movs	r0, #12
90016a3e:	f002 fb95 	bl	9001916c <UTIL_LCD_FillRect>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLACK);
90016a42:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
90016a46:	f001 fe63 	bl	90018710 <UTIL_LCD_SetTextColor>

  switch (feature)
90016a4a:	79fb      	ldrb	r3, [r7, #7]
90016a4c:	2b03      	cmp	r3, #3
90016a4e:	f200 81a6 	bhi.w	90016d9e <LCD_Show_Feature+0x402>
90016a52:	a201      	add	r2, pc, #4	; (adr r2, 90016a58 <LCD_Show_Feature+0xbc>)
90016a54:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90016a58:	90016a69 	.word	0x90016a69
90016a5c:	90016ad7 	.word	0x90016ad7
90016a60:	90016bb7 	.word	0x90016bb7
90016a64:	90016c7d 	.word	0x90016c7d
  {
  case 0:
    /* Text Feature */
    UTIL_LCD_DisplayStringAt(14, 100, (uint8_t *)"Left aligned Text", LEFT_MODE);
90016a68:	2303      	movs	r3, #3
90016a6a:	4a77      	ldr	r2, [pc, #476]	; (90016c48 <LCD_Show_Feature+0x2ac>)
90016a6c:	2164      	movs	r1, #100	; 0x64
90016a6e:	200e      	movs	r0, #14
90016a70:	f001 ffa2 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(0, 115, (uint8_t *)"Center aligned Text", CENTER_MODE);
90016a74:	2301      	movs	r3, #1
90016a76:	4a75      	ldr	r2, [pc, #468]	; (90016c4c <LCD_Show_Feature+0x2b0>)
90016a78:	2173      	movs	r1, #115	; 0x73
90016a7a:	2000      	movs	r0, #0
90016a7c:	f001 ff9c 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(14, 130, (uint8_t*)"Right aligned Text", RIGHT_MODE);
90016a80:	2302      	movs	r3, #2
90016a82:	4a73      	ldr	r2, [pc, #460]	; (90016c50 <LCD_Show_Feature+0x2b4>)
90016a84:	2182      	movs	r1, #130	; 0x82
90016a86:	200e      	movs	r0, #14
90016a88:	f001 ff96 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_SetFont(&Font24);
90016a8c:	4871      	ldr	r0, [pc, #452]	; (90016c54 <LCD_Show_Feature+0x2b8>)
90016a8e:	f001 fe67 	bl	90018760 <UTIL_LCD_SetFont>
    UTIL_LCD_DisplayStringAt(14, 180, (uint8_t *)"Font24", LEFT_MODE);
90016a92:	2303      	movs	r3, #3
90016a94:	4a70      	ldr	r2, [pc, #448]	; (90016c58 <LCD_Show_Feature+0x2bc>)
90016a96:	21b4      	movs	r1, #180	; 0xb4
90016a98:	200e      	movs	r0, #14
90016a9a:	f001 ff8d 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_SetFont(&Font20);
90016a9e:	486f      	ldr	r0, [pc, #444]	; (90016c5c <LCD_Show_Feature+0x2c0>)
90016aa0:	f001 fe5e 	bl	90018760 <UTIL_LCD_SetFont>
    UTIL_LCD_DisplayStringAt(x_size/2 -20, 180, (uint8_t *)"Font20", LEFT_MODE);
90016aa4:	693b      	ldr	r3, [r7, #16]
90016aa6:	085b      	lsrs	r3, r3, #1
90016aa8:	f1a3 0014 	sub.w	r0, r3, #20
90016aac:	2303      	movs	r3, #3
90016aae:	4a6c      	ldr	r2, [pc, #432]	; (90016c60 <LCD_Show_Feature+0x2c4>)
90016ab0:	21b4      	movs	r1, #180	; 0xb4
90016ab2:	f001 ff81 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_SetFont(&Font16);
90016ab6:	486b      	ldr	r0, [pc, #428]	; (90016c64 <LCD_Show_Feature+0x2c8>)
90016ab8:	f001 fe52 	bl	90018760 <UTIL_LCD_SetFont>
    UTIL_LCD_DisplayStringAt(x_size - 80, 184, (uint8_t *)"Font16", LEFT_MODE);
90016abc:	693b      	ldr	r3, [r7, #16]
90016abe:	f1a3 0050 	sub.w	r0, r3, #80	; 0x50
90016ac2:	2303      	movs	r3, #3
90016ac4:	4a68      	ldr	r2, [pc, #416]	; (90016c68 <LCD_Show_Feature+0x2cc>)
90016ac6:	21b8      	movs	r1, #184	; 0xb8
90016ac8:	f001 ff76 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    HAL_Delay(2000);
90016acc:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
90016ad0:	f7f2 fc84 	bl	900093dc <HAL_Delay>
    break;
90016ad4:	e163      	b.n	90016d9e <LCD_Show_Feature+0x402>

  case 1:

    /* Draw misc. Shapes */
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLACK);
90016ad6:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
90016ada:	f001 fe19 	bl	90018710 <UTIL_LCD_SetTextColor>
    UTIL_LCD_DrawRect(20, 100, 60 , 40, UTIL_LCD_COLOR_BLACK);
90016ade:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
90016ae2:	9300      	str	r3, [sp, #0]
90016ae4:	2328      	movs	r3, #40	; 0x28
90016ae6:	223c      	movs	r2, #60	; 0x3c
90016ae8:	2164      	movs	r1, #100	; 0x64
90016aea:	2014      	movs	r0, #20
90016aec:	f002 f8ce 	bl	90018c8c <UTIL_LCD_DrawRect>
    UTIL_LCD_FillRect(100, 100, 60 , 40, UTIL_LCD_COLOR_BLACK);
90016af0:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
90016af4:	9300      	str	r3, [sp, #0]
90016af6:	2328      	movs	r3, #40	; 0x28
90016af8:	223c      	movs	r2, #60	; 0x3c
90016afa:	2164      	movs	r1, #100	; 0x64
90016afc:	2064      	movs	r0, #100	; 0x64
90016afe:	f002 fb35 	bl	9001916c <UTIL_LCD_FillRect>

    UTIL_LCD_DrawCircle(x_size - 120, 120, 20, UTIL_LCD_COLOR_GRAY);
90016b02:	693b      	ldr	r3, [r7, #16]
90016b04:	f1a3 0078 	sub.w	r0, r3, #120	; 0x78
90016b08:	4b58      	ldr	r3, [pc, #352]	; (90016c6c <LCD_Show_Feature+0x2d0>)
90016b0a:	2214      	movs	r2, #20
90016b0c:	2178      	movs	r1, #120	; 0x78
90016b0e:	f002 f8e7 	bl	90018ce0 <UTIL_LCD_DrawCircle>
    UTIL_LCD_FillCircle(x_size - 40, 120, 20, UTIL_LCD_COLOR_GRAY);
90016b12:	693b      	ldr	r3, [r7, #16]
90016b14:	f1a3 0028 	sub.w	r0, r3, #40	; 0x28
90016b18:	4b54      	ldr	r3, [pc, #336]	; (90016c6c <LCD_Show_Feature+0x2d0>)
90016b1a:	2214      	movs	r2, #20
90016b1c:	2178      	movs	r1, #120	; 0x78
90016b1e:	f002 fb5f 	bl	900191e0 <UTIL_LCD_FillCircle>

    UTIL_LCD_FillPolygon(Points, 8, UTIL_LCD_COLOR_GREEN);
90016b22:	f107 0320 	add.w	r3, r7, #32
90016b26:	f04f 22ff 	mov.w	r2, #4278255360	; 0xff00ff00
90016b2a:	2108      	movs	r1, #8
90016b2c:	4618      	mov	r0, r3
90016b2e:	f002 fc03 	bl	90019338 <UTIL_LCD_FillPolygon>

    UTIL_LCD_DrawEllipse(130, 170, 30, 20, UTIL_LCD_COLOR_RED);
90016b32:	4b4f      	ldr	r3, [pc, #316]	; (90016c70 <LCD_Show_Feature+0x2d4>)
90016b34:	9300      	str	r3, [sp, #0]
90016b36:	2314      	movs	r3, #20
90016b38:	221e      	movs	r2, #30
90016b3a:	21aa      	movs	r1, #170	; 0xaa
90016b3c:	2082      	movs	r0, #130	; 0x82
90016b3e:	f002 fa2e 	bl	90018f9e <UTIL_LCD_DrawEllipse>
    UTIL_LCD_FillEllipse(200, 170, 30, 20, UTIL_LCD_COLOR_RED);
90016b42:	4b4b      	ldr	r3, [pc, #300]	; (90016c70 <LCD_Show_Feature+0x2d4>)
90016b44:	9300      	str	r3, [sp, #0]
90016b46:	2314      	movs	r3, #20
90016b48:	221e      	movs	r2, #30
90016b4a:	21aa      	movs	r1, #170	; 0xaa
90016b4c:	20c8      	movs	r0, #200	; 0xc8
90016b4e:	f002 fd19 	bl	90019584 <UTIL_LCD_FillEllipse>

    UTIL_LCD_DrawHLine(20, y_size - 30, x_size / 5, UTIL_LCD_COLOR_BLACK);
90016b52:	68fb      	ldr	r3, [r7, #12]
90016b54:	f1a3 011e 	sub.w	r1, r3, #30
90016b58:	693b      	ldr	r3, [r7, #16]
90016b5a:	4a46      	ldr	r2, [pc, #280]	; (90016c74 <LCD_Show_Feature+0x2d8>)
90016b5c:	fba2 2303 	umull	r2, r3, r2, r3
90016b60:	089a      	lsrs	r2, r3, #2
90016b62:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
90016b66:	2014      	movs	r0, #20
90016b68:	f001 fe3a 	bl	900187e0 <UTIL_LCD_DrawHLine>
    UTIL_LCD_DrawLine (100, y_size - 20, 230, y_size- 50, UTIL_LCD_COLOR_BLACK);
90016b6c:	68fb      	ldr	r3, [r7, #12]
90016b6e:	f1a3 0114 	sub.w	r1, r3, #20
90016b72:	68fb      	ldr	r3, [r7, #12]
90016b74:	3b32      	subs	r3, #50	; 0x32
90016b76:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
90016b7a:	9200      	str	r2, [sp, #0]
90016b7c:	22e6      	movs	r2, #230	; 0xe6
90016b7e:	2064      	movs	r0, #100	; 0x64
90016b80:	f001 ffc8 	bl	90018b14 <UTIL_LCD_DrawLine>
    UTIL_LCD_DrawLine (100, y_size- 50, 230, y_size- 20, UTIL_LCD_COLOR_BLACK);
90016b84:	68fb      	ldr	r3, [r7, #12]
90016b86:	f1a3 0132 	sub.w	r1, r3, #50	; 0x32
90016b8a:	68fb      	ldr	r3, [r7, #12]
90016b8c:	3b14      	subs	r3, #20
90016b8e:	f04f 427f 	mov.w	r2, #4278190080	; 0xff000000
90016b92:	9200      	str	r2, [sp, #0]
90016b94:	22e6      	movs	r2, #230	; 0xe6
90016b96:	2064      	movs	r0, #100	; 0x64
90016b98:	f001 ffbc 	bl	90018b14 <UTIL_LCD_DrawLine>

    UTIL_LCD_DrawPolygon(Points2, 3, UTIL_LCD_COLOR_GREEN);
90016b9c:	f107 0314 	add.w	r3, r7, #20
90016ba0:	f04f 22ff 	mov.w	r2, #4278255360	; 0xff00ff00
90016ba4:	2103      	movs	r1, #3
90016ba6:	4618      	mov	r0, r3
90016ba8:	f002 f9a4 	bl	90018ef4 <UTIL_LCD_DrawPolygon>
    HAL_Delay(2000);
90016bac:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
90016bb0:	f7f2 fc14 	bl	900093dc <HAL_Delay>
    break;
90016bb4:	e0f3      	b.n	90016d9e <LCD_Show_Feature+0x402>

  case 2:
    /* Draw Bitmap */
    UTIL_LCD_DrawBitmap(20, 100, (uint8_t *)stlogo);
90016bb6:	4a30      	ldr	r2, [pc, #192]	; (90016c78 <LCD_Show_Feature+0x2dc>)
90016bb8:	2164      	movs	r1, #100	; 0x64
90016bba:	2014      	movs	r0, #20
90016bbc:	f002 fac0 	bl	90019140 <UTIL_LCD_DrawBitmap>
    HAL_Delay(500);
90016bc0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
90016bc4:	f7f2 fc0a 	bl	900093dc <HAL_Delay>

    UTIL_LCD_DrawBitmap(x_size/2 - 40, 100, (uint8_t *)stlogo);
90016bc8:	693b      	ldr	r3, [r7, #16]
90016bca:	085b      	lsrs	r3, r3, #1
90016bcc:	3b28      	subs	r3, #40	; 0x28
90016bce:	4a2a      	ldr	r2, [pc, #168]	; (90016c78 <LCD_Show_Feature+0x2dc>)
90016bd0:	2164      	movs	r1, #100	; 0x64
90016bd2:	4618      	mov	r0, r3
90016bd4:	f002 fab4 	bl	90019140 <UTIL_LCD_DrawBitmap>
    HAL_Delay(500);
90016bd8:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
90016bdc:	f7f2 fbfe 	bl	900093dc <HAL_Delay>

    UTIL_LCD_DrawBitmap(x_size-100, 100, (uint8_t *)stlogo);
90016be0:	693b      	ldr	r3, [r7, #16]
90016be2:	3b64      	subs	r3, #100	; 0x64
90016be4:	4a24      	ldr	r2, [pc, #144]	; (90016c78 <LCD_Show_Feature+0x2dc>)
90016be6:	2164      	movs	r1, #100	; 0x64
90016be8:	4618      	mov	r0, r3
90016bea:	f002 faa9 	bl	90019140 <UTIL_LCD_DrawBitmap>
    HAL_Delay(500);
90016bee:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
90016bf2:	f7f2 fbf3 	bl	900093dc <HAL_Delay>

    UTIL_LCD_DrawBitmap(20, y_size- 80, (uint8_t *)stlogo);
90016bf6:	68fb      	ldr	r3, [r7, #12]
90016bf8:	3b50      	subs	r3, #80	; 0x50
90016bfa:	4a1f      	ldr	r2, [pc, #124]	; (90016c78 <LCD_Show_Feature+0x2dc>)
90016bfc:	4619      	mov	r1, r3
90016bfe:	2014      	movs	r0, #20
90016c00:	f002 fa9e 	bl	90019140 <UTIL_LCD_DrawBitmap>
    HAL_Delay(500);
90016c04:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
90016c08:	f7f2 fbe8 	bl	900093dc <HAL_Delay>

    UTIL_LCD_DrawBitmap(x_size/2 - 40, y_size- 80, (uint8_t *)stlogo);
90016c0c:	693b      	ldr	r3, [r7, #16]
90016c0e:	085b      	lsrs	r3, r3, #1
90016c10:	f1a3 0028 	sub.w	r0, r3, #40	; 0x28
90016c14:	68fb      	ldr	r3, [r7, #12]
90016c16:	3b50      	subs	r3, #80	; 0x50
90016c18:	4a17      	ldr	r2, [pc, #92]	; (90016c78 <LCD_Show_Feature+0x2dc>)
90016c1a:	4619      	mov	r1, r3
90016c1c:	f002 fa90 	bl	90019140 <UTIL_LCD_DrawBitmap>
    HAL_Delay(500);
90016c20:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
90016c24:	f7f2 fbda 	bl	900093dc <HAL_Delay>

    UTIL_LCD_DrawBitmap(x_size-100, y_size- 80, (uint8_t *)stlogo);
90016c28:	693b      	ldr	r3, [r7, #16]
90016c2a:	f1a3 0064 	sub.w	r0, r3, #100	; 0x64
90016c2e:	68fb      	ldr	r3, [r7, #12]
90016c30:	3b50      	subs	r3, #80	; 0x50
90016c32:	4a11      	ldr	r2, [pc, #68]	; (90016c78 <LCD_Show_Feature+0x2dc>)
90016c34:	4619      	mov	r1, r3
90016c36:	f002 fa83 	bl	90019140 <UTIL_LCD_DrawBitmap>
    HAL_Delay(500);
90016c3a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
90016c3e:	f7f2 fbcd 	bl	900093dc <HAL_Delay>
    break;
90016c42:	e0ac      	b.n	90016d9e <LCD_Show_Feature+0x402>
90016c44:	9001ecb8 	.word	0x9001ecb8
90016c48:	9001ec1c 	.word	0x9001ec1c
90016c4c:	9001ec30 	.word	0x9001ec30
90016c50:	9001ec44 	.word	0x9001ec44
90016c54:	24000388 	.word	0x24000388
90016c58:	9001ec58 	.word	0x9001ec58
90016c5c:	24000390 	.word	0x24000390
90016c60:	9001ec60 	.word	0x9001ec60
90016c64:	24000398 	.word	0x24000398
90016c68:	9001ec68 	.word	0x9001ec68
90016c6c:	ff808080 	.word	0xff808080
90016c70:	ffff0000 	.word	0xffff0000
90016c74:	cccccccd 	.word	0xcccccccd
90016c78:	9001ecd8 	.word	0x9001ecd8

  case 3:
    BSP_SDRAM_DeInit(0);
90016c7c:	2000      	movs	r0, #0
90016c7e:	f7f1 fc4f 	bl	90008520 <BSP_SDRAM_DeInit>
    BSP_LCD_DeInit(0);
90016c82:	2000      	movs	r0, #0
90016c84:	f7f0 fb74 	bl	90007370 <BSP_LCD_DeInit>
    BSP_LCD_InitEx(0, LCD_ORIENTATION_LANDSCAPE, LCD_PIXEL_FORMAT_RGB565, 480,272);
90016c88:	f44f 7388 	mov.w	r3, #272	; 0x110
90016c8c:	9300      	str	r3, [sp, #0]
90016c8e:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
90016c92:	2202      	movs	r2, #2
90016c94:	2101      	movs	r1, #1
90016c96:	2000      	movs	r0, #0
90016c98:	f7f0 fa90 	bl	900071bc <BSP_LCD_InitEx>
    UTIL_LCD_SetLayer(0);
90016c9c:	2000      	movs	r0, #0
90016c9e:	f001 fd19 	bl	900186d4 <UTIL_LCD_SetLayer>
    UTIL_LCD_SetFuncDriver(&LCD_Driver);
90016ca2:	4841      	ldr	r0, [pc, #260]	; (90016da8 <LCD_Show_Feature+0x40c>)
90016ca4:	f001 fcc0 	bl	90018628 <UTIL_LCD_SetFuncDriver>
    UTIL_LCD_SetFont(&UTIL_LCD_DEFAULT_FONT);
90016ca8:	4840      	ldr	r0, [pc, #256]	; (90016dac <LCD_Show_Feature+0x410>)
90016caa:	f001 fd59 	bl	90018760 <UTIL_LCD_SetFont>
    /* Clear the LCD */
    UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
90016cae:	4840      	ldr	r0, [pc, #256]	; (90016db0 <LCD_Show_Feature+0x414>)
90016cb0:	f001 fd42 	bl	90018738 <UTIL_LCD_SetBackColor>
    UTIL_LCD_Clear(UTIL_LCD_COLOR_BLUE);
90016cb4:	483e      	ldr	r0, [pc, #248]	; (90016db0 <LCD_Show_Feature+0x414>)
90016cb6:	f001 fe33 	bl	90018920 <UTIL_LCD_Clear>
    BSP_LCD_GetXSize(0, &x_size);
90016cba:	f107 0310 	add.w	r3, r7, #16
90016cbe:	4619      	mov	r1, r3
90016cc0:	2000      	movs	r0, #0
90016cc2:	f7f0 fccd 	bl	90007660 <BSP_LCD_GetXSize>
    UTIL_LCD_FillRect(0, 0, x_size, 80, UTIL_LCD_COLOR_WHITE);
90016cc6:	693a      	ldr	r2, [r7, #16]
90016cc8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90016ccc:	9300      	str	r3, [sp, #0]
90016cce:	2350      	movs	r3, #80	; 0x50
90016cd0:	2100      	movs	r1, #0
90016cd2:	2000      	movs	r0, #0
90016cd4:	f002 fa4a 	bl	9001916c <UTIL_LCD_FillRect>

    /* Set the LCD Text Color */
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
90016cd8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90016cdc:	f001 fd18 	bl	90018710 <UTIL_LCD_SetTextColor>
    UTIL_LCD_DisplayStringAt(0, y_size/2, (uint8_t *)"Orientation: LANDSCAPE", CENTER_MODE);
90016ce0:	68fb      	ldr	r3, [r7, #12]
90016ce2:	0859      	lsrs	r1, r3, #1
90016ce4:	2301      	movs	r3, #1
90016ce6:	4a33      	ldr	r2, [pc, #204]	; (90016db4 <LCD_Show_Feature+0x418>)
90016ce8:	2000      	movs	r0, #0
90016cea:	f001 fe65 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(0, y_size/2 + 45, (uint8_t *)"Pixel Format: RGB565", CENTER_MODE);
90016cee:	68fb      	ldr	r3, [r7, #12]
90016cf0:	085b      	lsrs	r3, r3, #1
90016cf2:	f103 012d 	add.w	r1, r3, #45	; 0x2d
90016cf6:	2301      	movs	r3, #1
90016cf8:	4a2f      	ldr	r2, [pc, #188]	; (90016db8 <LCD_Show_Feature+0x41c>)
90016cfa:	2000      	movs	r0, #0
90016cfc:	f001 fe5c 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    HAL_Delay(2000);
90016d00:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
90016d04:	f7f2 fb6a 	bl	900093dc <HAL_Delay>

    BSP_SDRAM_DeInit(0);
90016d08:	2000      	movs	r0, #0
90016d0a:	f7f1 fc09 	bl	90008520 <BSP_SDRAM_DeInit>
    BSP_LCD_DeInit(0);
90016d0e:	2000      	movs	r0, #0
90016d10:	f7f0 fb2e 	bl	90007370 <BSP_LCD_DeInit>
    BSP_LCD_Init(0, LCD_ORIENTATION_LANDSCAPE);
90016d14:	2101      	movs	r1, #1
90016d16:	2000      	movs	r0, #0
90016d18:	f7f0 fa3c 	bl	90007194 <BSP_LCD_Init>
    UTIL_LCD_SetLayer(0);
90016d1c:	2000      	movs	r0, #0
90016d1e:	f001 fcd9 	bl	900186d4 <UTIL_LCD_SetLayer>
    BSP_LCD_SetLayerVisible(0, 1, DISABLE);
90016d22:	2200      	movs	r2, #0
90016d24:	2101      	movs	r1, #1
90016d26:	2000      	movs	r0, #0
90016d28:	f7f0 fc46 	bl	900075b8 <BSP_LCD_SetLayerVisible>
    BSP_LCD_SetLayerVisible(0, 0, ENABLE);
90016d2c:	2201      	movs	r2, #1
90016d2e:	2100      	movs	r1, #0
90016d30:	2000      	movs	r0, #0
90016d32:	f7f0 fc41 	bl	900075b8 <BSP_LCD_SetLayerVisible>
    UTIL_LCD_SetFuncDriver(&LCD_Driver);
90016d36:	481c      	ldr	r0, [pc, #112]	; (90016da8 <LCD_Show_Feature+0x40c>)
90016d38:	f001 fc76 	bl	90018628 <UTIL_LCD_SetFuncDriver>
    UTIL_LCD_SetFont(&UTIL_LCD_DEFAULT_FONT);
90016d3c:	481b      	ldr	r0, [pc, #108]	; (90016dac <LCD_Show_Feature+0x410>)
90016d3e:	f001 fd0f 	bl	90018760 <UTIL_LCD_SetFont>
    /* Clear the LCD */
    UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
90016d42:	481b      	ldr	r0, [pc, #108]	; (90016db0 <LCD_Show_Feature+0x414>)
90016d44:	f001 fcf8 	bl	90018738 <UTIL_LCD_SetBackColor>
    UTIL_LCD_Clear(UTIL_LCD_COLOR_BLUE);
90016d48:	4819      	ldr	r0, [pc, #100]	; (90016db0 <LCD_Show_Feature+0x414>)
90016d4a:	f001 fde9 	bl	90018920 <UTIL_LCD_Clear>
    BSP_LCD_GetXSize(0, &x_size);
90016d4e:	f107 0310 	add.w	r3, r7, #16
90016d52:	4619      	mov	r1, r3
90016d54:	2000      	movs	r0, #0
90016d56:	f7f0 fc83 	bl	90007660 <BSP_LCD_GetXSize>
    UTIL_LCD_FillRect(0, 0, x_size, 80, UTIL_LCD_COLOR_WHITE);
90016d5a:	693a      	ldr	r2, [r7, #16]
90016d5c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90016d60:	9300      	str	r3, [sp, #0]
90016d62:	2350      	movs	r3, #80	; 0x50
90016d64:	2100      	movs	r1, #0
90016d66:	2000      	movs	r0, #0
90016d68:	f002 fa00 	bl	9001916c <UTIL_LCD_FillRect>
    /* Set the LCD Text Color */
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
90016d6c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90016d70:	f001 fcce 	bl	90018710 <UTIL_LCD_SetTextColor>
    UTIL_LCD_DisplayStringAt(0, y_size/2, (uint8_t *)"Orientation: LANDSCAPE", CENTER_MODE);
90016d74:	68fb      	ldr	r3, [r7, #12]
90016d76:	0859      	lsrs	r1, r3, #1
90016d78:	2301      	movs	r3, #1
90016d7a:	4a0e      	ldr	r2, [pc, #56]	; (90016db4 <LCD_Show_Feature+0x418>)
90016d7c:	2000      	movs	r0, #0
90016d7e:	f001 fe1b 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(0, y_size/2 + 45, (uint8_t *)"Pixel Format: RGB888", CENTER_MODE);
90016d82:	68fb      	ldr	r3, [r7, #12]
90016d84:	085b      	lsrs	r3, r3, #1
90016d86:	f103 012d 	add.w	r1, r3, #45	; 0x2d
90016d8a:	2301      	movs	r3, #1
90016d8c:	4a0b      	ldr	r2, [pc, #44]	; (90016dbc <LCD_Show_Feature+0x420>)
90016d8e:	2000      	movs	r0, #0
90016d90:	f001 fe12 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    HAL_Delay(2000);
90016d94:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
90016d98:	f7f2 fb20 	bl	900093dc <HAL_Delay>

    break;
90016d9c:	bf00      	nop
  }
}
90016d9e:	bf00      	nop
90016da0:	3740      	adds	r7, #64	; 0x40
90016da2:	46bd      	mov	sp, r7
90016da4:	bdb0      	pop	{r4, r5, r7, pc}
90016da6:	bf00      	nop
90016da8:	9001e87c 	.word	0x9001e87c
90016dac:	24000388 	.word	0x24000388
90016db0:	ff0000ff 	.word	0xff0000ff
90016db4:	9001ec70 	.word	0x9001ec70
90016db8:	9001ec88 	.word	0x9001ec88
90016dbc:	9001eca0 	.word	0x9001eca0

90016dc0 <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
90016dc0:	b580      	push	{r7, lr}
90016dc2:	af00      	add	r7, sp, #0
  /* System Init, System clock, voltage scaling and L1-Cache configuration are done by CPU1 (Cortex-M7)
     in the meantime Domain D2 is put in STOP mode(Cortex-M4 in deep-sleep)
  */

  /* Configure the MPU attributes as Write Through */
  MPU_Config();
90016dc4:	f000 f994 	bl	900170f0 <MPU_Config>

  /* Enable the CPU Cache */
  CPU_CACHE_Enable();
90016dc8:	f000 f9ba 	bl	90017140 <CPU_CACHE_Enable>
         duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and
         handled in milliseconds basis.
       - Set NVIC Group Priority to 4
       - Low Level Initialization
     */
  HAL_Init();
90016dcc:	f7f2 fa6c 	bl	900092a8 <HAL_Init>

  /* Configure the system clock to 400 MHz */
  SystemClock_Config();
90016dd0:	f000 f842 	bl	90016e58 <SystemClock_Config>

  /* When system initialization is finished, Cortex-M7 could wakeup (when needed) the Cortex-M4  by means of
     HSEM notification or by any D2 wakeup source (SEV,EXTI..)   */

  BSP_LED_Init(LED_GREEN);
90016dd4:	2000      	movs	r0, #0
90016dd6:	f7ed ff89 	bl	90004cec <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
90016dda:	2001      	movs	r0, #1
90016ddc:	f7ed ff86 	bl	90004cec <BSP_LED_Init>

  /* Configure the User push-button in EXTI Mode */
  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
90016de0:	2101      	movs	r1, #1
90016de2:	2000      	movs	r0, #0
90016de4:	f7ed fffe 	bl	90004de4 <BSP_PB_Init>

  BSP_LCD_Init(0, LCD_ORIENTATION_LANDSCAPE);
90016de8:	2101      	movs	r1, #1
90016dea:	2000      	movs	r0, #0
90016dec:	f7f0 f9d2 	bl	90007194 <BSP_LCD_Init>
  UTIL_LCD_SetFuncDriver(&LCD_Driver);
90016df0:	4815      	ldr	r0, [pc, #84]	; (90016e48 <main+0x88>)
90016df2:	f001 fc19 	bl	90018628 <UTIL_LCD_SetFuncDriver>
  Display_DemoDescription();
90016df6:	f000 f8c5 	bl	90016f84 <Display_DemoDescription>

  /* Wait For User inputs */
  while (1)
  {

    if(ButtonState == 1)
90016dfa:	4b14      	ldr	r3, [pc, #80]	; (90016e4c <main+0x8c>)
90016dfc:	681b      	ldr	r3, [r3, #0]
90016dfe:	2b01      	cmp	r3, #1
90016e00:	d1fb      	bne.n	90016dfa <main+0x3a>
    {
      HAL_Delay(400);
90016e02:	f44f 70c8 	mov.w	r0, #400	; 0x190
90016e06:	f7f2 fae9 	bl	900093dc <HAL_Delay>
      ButtonState = 0;
90016e0a:	4b10      	ldr	r3, [pc, #64]	; (90016e4c <main+0x8c>)
90016e0c:	2200      	movs	r2, #0
90016e0e:	601a      	str	r2, [r3, #0]
      BSP_examples[DemoIndex++].DemoFunc();
90016e10:	4b0f      	ldr	r3, [pc, #60]	; (90016e50 <main+0x90>)
90016e12:	781b      	ldrb	r3, [r3, #0]
90016e14:	1c5a      	adds	r2, r3, #1
90016e16:	b2d1      	uxtb	r1, r2
90016e18:	4a0d      	ldr	r2, [pc, #52]	; (90016e50 <main+0x90>)
90016e1a:	7011      	strb	r1, [r2, #0]
90016e1c:	4619      	mov	r1, r3
90016e1e:	4a0d      	ldr	r2, [pc, #52]	; (90016e54 <main+0x94>)
90016e20:	460b      	mov	r3, r1
90016e22:	011b      	lsls	r3, r3, #4
90016e24:	1a5b      	subs	r3, r3, r1
90016e26:	009b      	lsls	r3, r3, #2
90016e28:	4413      	add	r3, r2
90016e2a:	681b      	ldr	r3, [r3, #0]
90016e2c:	4798      	blx	r3

      HAL_Delay(100);
90016e2e:	2064      	movs	r0, #100	; 0x64
90016e30:	f7f2 fad4 	bl	900093dc <HAL_Delay>

      if(DemoIndex >= COUNT_OF_EXAMPLE(BSP_examples))
90016e34:	4b06      	ldr	r3, [pc, #24]	; (90016e50 <main+0x90>)
90016e36:	781b      	ldrb	r3, [r3, #0]
90016e38:	2b07      	cmp	r3, #7
90016e3a:	d902      	bls.n	90016e42 <main+0x82>
      {
        DemoIndex = 0;
90016e3c:	4b04      	ldr	r3, [pc, #16]	; (90016e50 <main+0x90>)
90016e3e:	2200      	movs	r2, #0
90016e40:	701a      	strb	r2, [r3, #0]
      }
      Display_DemoDescription();
90016e42:	f000 f89f 	bl	90016f84 <Display_DemoDescription>
    if(ButtonState == 1)
90016e46:	e7d8      	b.n	90016dfa <main+0x3a>
90016e48:	9001e87c 	.word	0x9001e87c
90016e4c:	240027f0 	.word	0x240027f0
90016e50:	240027ec 	.word	0x240027ec
90016e54:	2400011c 	.word	0x2400011c

90016e58 <SystemClock_Config>:
  *            Flash Latency(WS)              = 4
  * @param  None
  * @retval None
  */
static void SystemClock_Config(void)
{
90016e58:	b580      	push	{r7, lr}
90016e5a:	b09e      	sub	sp, #120	; 0x78
90016e5c:	af00      	add	r7, sp, #0
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  HAL_StatusTypeDef ret = HAL_OK;
90016e5e:	2300      	movs	r3, #0
90016e60:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77

  /*!< Supply configuration update enable */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
90016e64:	2002      	movs	r0, #2
90016e66:	f7f9 fa1f 	bl	900102a8 <HAL_PWREx_ConfigSupply>

  /* The voltage scaling allows optimizing the power consumption when the device is
     clocked below the maximum system frequency, to update the voltage scaling value
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
90016e6a:	2300      	movs	r3, #0
90016e6c:	607b      	str	r3, [r7, #4]
90016e6e:	4b42      	ldr	r3, [pc, #264]	; (90016f78 <SystemClock_Config+0x120>)
90016e70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90016e72:	4a41      	ldr	r2, [pc, #260]	; (90016f78 <SystemClock_Config+0x120>)
90016e74:	f023 0301 	bic.w	r3, r3, #1
90016e78:	62d3      	str	r3, [r2, #44]	; 0x2c
90016e7a:	4b3f      	ldr	r3, [pc, #252]	; (90016f78 <SystemClock_Config+0x120>)
90016e7c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
90016e7e:	f003 0301 	and.w	r3, r3, #1
90016e82:	607b      	str	r3, [r7, #4]
90016e84:	4b3d      	ldr	r3, [pc, #244]	; (90016f7c <SystemClock_Config+0x124>)
90016e86:	699b      	ldr	r3, [r3, #24]
90016e88:	4a3c      	ldr	r2, [pc, #240]	; (90016f7c <SystemClock_Config+0x124>)
90016e8a:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
90016e8e:	6193      	str	r3, [r2, #24]
90016e90:	4b3a      	ldr	r3, [pc, #232]	; (90016f7c <SystemClock_Config+0x124>)
90016e92:	699b      	ldr	r3, [r3, #24]
90016e94:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
90016e98:	607b      	str	r3, [r7, #4]
90016e9a:	687b      	ldr	r3, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
90016e9c:	bf00      	nop
90016e9e:	4b37      	ldr	r3, [pc, #220]	; (90016f7c <SystemClock_Config+0x124>)
90016ea0:	699b      	ldr	r3, [r3, #24]
90016ea2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
90016ea6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
90016eaa:	d1f8      	bne.n	90016e9e <SystemClock_Config+0x46>

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
90016eac:	2301      	movs	r3, #1
90016eae:	60bb      	str	r3, [r7, #8]
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
90016eb0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
90016eb4:	60fb      	str	r3, [r7, #12]
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
90016eb6:	2300      	movs	r3, #0
90016eb8:	617b      	str	r3, [r7, #20]
  RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
90016eba:	2300      	movs	r3, #0
90016ebc:	627b      	str	r3, [r7, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
90016ebe:	2302      	movs	r3, #2
90016ec0:	62fb      	str	r3, [r7, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
90016ec2:	2302      	movs	r3, #2
90016ec4:	633b      	str	r3, [r7, #48]	; 0x30

  RCC_OscInitStruct.PLL.PLLM = 5;
90016ec6:	2305      	movs	r3, #5
90016ec8:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLN = 160;
90016eca:	23a0      	movs	r3, #160	; 0xa0
90016ecc:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
90016ece:	2300      	movs	r3, #0
90016ed0:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLP = 2;
90016ed2:	2302      	movs	r3, #2
90016ed4:	63fb      	str	r3, [r7, #60]	; 0x3c
  RCC_OscInitStruct.PLL.PLLR = 2;
90016ed6:	2302      	movs	r3, #2
90016ed8:	647b      	str	r3, [r7, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLQ = 4;
90016eda:	2304      	movs	r3, #4
90016edc:	643b      	str	r3, [r7, #64]	; 0x40

  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
90016ede:	2300      	movs	r3, #0
90016ee0:	64fb      	str	r3, [r7, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
90016ee2:	2308      	movs	r3, #8
90016ee4:	64bb      	str	r3, [r7, #72]	; 0x48
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
90016ee6:	f107 0308 	add.w	r3, r7, #8
90016eea:	4618      	mov	r0, r3
90016eec:	f7f9 fa16 	bl	9001031c <HAL_RCC_OscConfig>
90016ef0:	4603      	mov	r3, r0
90016ef2:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
  if(ret != HAL_OK)
90016ef6:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
90016efa:	2b00      	cmp	r3, #0
90016efc:	d001      	beq.n	90016f02 <SystemClock_Config+0xaa>
  {
    Error_Handler();
90016efe:	f000 f8f1 	bl	900170e4 <Error_Handler>
  }

/* Select PLL as system clock source and configure  bus clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 | \
90016f02:	233f      	movs	r3, #63	; 0x3f
90016f04:	657b      	str	r3, [r7, #84]	; 0x54
                                 RCC_CLOCKTYPE_PCLK2  | RCC_CLOCKTYPE_D3PCLK1);

  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
90016f06:	2303      	movs	r3, #3
90016f08:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
90016f0a:	2300      	movs	r3, #0
90016f0c:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
90016f0e:	2308      	movs	r3, #8
90016f10:	663b      	str	r3, [r7, #96]	; 0x60
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
90016f12:	2340      	movs	r3, #64	; 0x40
90016f14:	667b      	str	r3, [r7, #100]	; 0x64
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
90016f16:	2340      	movs	r3, #64	; 0x40
90016f18:	66bb      	str	r3, [r7, #104]	; 0x68
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
90016f1a:	f44f 6380 	mov.w	r3, #1024	; 0x400
90016f1e:	66fb      	str	r3, [r7, #108]	; 0x6c
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
90016f20:	2340      	movs	r3, #64	; 0x40
90016f22:	673b      	str	r3, [r7, #112]	; 0x70
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
90016f24:	f107 0354 	add.w	r3, r7, #84	; 0x54
90016f28:	2104      	movs	r1, #4
90016f2a:	4618      	mov	r0, r3
90016f2c:	f7f9 fe22 	bl	90010b74 <HAL_RCC_ClockConfig>
90016f30:	4603      	mov	r3, r0
90016f32:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
  if(ret != HAL_OK)
90016f36:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
90016f3a:	2b00      	cmp	r3, #0
90016f3c:	d001      	beq.n	90016f42 <SystemClock_Config+0xea>
  {
    Error_Handler();
90016f3e:	f000 f8d1 	bl	900170e4 <Error_Handler>
        - The activation of the SYSCFG clock
        - Enabling the I/O Compensation Cell : setting bit[0] of register SYSCFG_CCCSR
 */

  /*activate CSI clock mondatory for I/O Compensation Cell*/
  __HAL_RCC_CSI_ENABLE() ;
90016f42:	4b0f      	ldr	r3, [pc, #60]	; (90016f80 <SystemClock_Config+0x128>)
90016f44:	681b      	ldr	r3, [r3, #0]
90016f46:	4a0e      	ldr	r2, [pc, #56]	; (90016f80 <SystemClock_Config+0x128>)
90016f48:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90016f4c:	6013      	str	r3, [r2, #0]

  /* Enable SYSCFG clock mondatory for I/O Compensation Cell */
  __HAL_RCC_SYSCFG_CLK_ENABLE() ;
90016f4e:	4b0c      	ldr	r3, [pc, #48]	; (90016f80 <SystemClock_Config+0x128>)
90016f50:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
90016f54:	4a0a      	ldr	r2, [pc, #40]	; (90016f80 <SystemClock_Config+0x128>)
90016f56:	f043 0302 	orr.w	r3, r3, #2
90016f5a:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
90016f5e:	4b08      	ldr	r3, [pc, #32]	; (90016f80 <SystemClock_Config+0x128>)
90016f60:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
90016f64:	f003 0302 	and.w	r3, r3, #2
90016f68:	603b      	str	r3, [r7, #0]
90016f6a:	683b      	ldr	r3, [r7, #0]

  /* Enables the I/O Compensation Cell */
  HAL_EnableCompensationCell();
90016f6c:	f7f2 fa66 	bl	9000943c <HAL_EnableCompensationCell>
}
90016f70:	bf00      	nop
90016f72:	3778      	adds	r7, #120	; 0x78
90016f74:	46bd      	mov	sp, r7
90016f76:	bd80      	pop	{r7, pc}
90016f78:	58000400 	.word	0x58000400
90016f7c:	58024800 	.word	0x58024800
90016f80:	58024400 	.word	0x58024400

90016f84 <Display_DemoDescription>:
  * @brief  Display main demo messages
  * @param  None
  * @retval None
  */
static void Display_DemoDescription(void)
{
90016f84:	b580      	push	{r7, lr}
90016f86:	b094      	sub	sp, #80	; 0x50
90016f88:	af02      	add	r7, sp, #8
  char desc[64];
  uint32_t x_size;
  uint32_t y_size;

  UTIL_LCD_SetFont(&UTIL_LCD_DEFAULT_FONT);
90016f8a:	4839      	ldr	r0, [pc, #228]	; (90017070 <Display_DemoDescription+0xec>)
90016f8c:	f001 fbe8 	bl	90018760 <UTIL_LCD_SetFont>

  /* Clear the LCD */
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
90016f90:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90016f94:	f001 fbd0 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_Clear(UTIL_LCD_COLOR_WHITE);
90016f98:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90016f9c:	f001 fcc0 	bl	90018920 <UTIL_LCD_Clear>

  /* Set the LCD Text Color */
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_DARKBLUE);
90016fa0:	4834      	ldr	r0, [pc, #208]	; (90017074 <Display_DemoDescription+0xf0>)
90016fa2:	f001 fbb5 	bl	90018710 <UTIL_LCD_SetTextColor>

  /* Display LCD messages */
  UTIL_LCD_DisplayStringAt(0, 10, (uint8_t *)"STM32H750B BSP", CENTER_MODE);
90016fa6:	2301      	movs	r3, #1
90016fa8:	4a33      	ldr	r2, [pc, #204]	; (90017078 <Display_DemoDescription+0xf4>)
90016faa:	210a      	movs	r1, #10
90016fac:	2000      	movs	r0, #0
90016fae:	f001 fd03 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_DisplayStringAt(0, 35, (uint8_t *)"Drivers examples", CENTER_MODE);
90016fb2:	2301      	movs	r3, #1
90016fb4:	4a31      	ldr	r2, [pc, #196]	; (9001707c <Display_DemoDescription+0xf8>)
90016fb6:	2123      	movs	r1, #35	; 0x23
90016fb8:	2000      	movs	r0, #0
90016fba:	f001 fcfd 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

  BSP_LCD_GetXSize(0, &x_size);
90016fbe:	1d3b      	adds	r3, r7, #4
90016fc0:	4619      	mov	r1, r3
90016fc2:	2000      	movs	r0, #0
90016fc4:	f7f0 fb4c 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
90016fc8:	463b      	mov	r3, r7
90016fca:	4619      	mov	r1, r3
90016fcc:	2000      	movs	r0, #0
90016fce:	f7f0 fb65 	bl	9000769c <BSP_LCD_GetYSize>

  /* Draw Bitmap */
  UTIL_LCD_DrawBitmap((x_size - 80)/2, 65, (uint8_t *)stlogo);
90016fd2:	687b      	ldr	r3, [r7, #4]
90016fd4:	3b50      	subs	r3, #80	; 0x50
90016fd6:	085b      	lsrs	r3, r3, #1
90016fd8:	4a29      	ldr	r2, [pc, #164]	; (90017080 <Display_DemoDescription+0xfc>)
90016fda:	2141      	movs	r1, #65	; 0x41
90016fdc:	4618      	mov	r0, r3
90016fde:	f002 f8af 	bl	90019140 <UTIL_LCD_DrawBitmap>

  UTIL_LCD_SetFont(&Font12);
90016fe2:	4828      	ldr	r0, [pc, #160]	; (90017084 <Display_DemoDescription+0x100>)
90016fe4:	f001 fbbc 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, y_size - 20, (uint8_t *)"Copyright (c) STMicroelectronics 2019", CENTER_MODE);
90016fe8:	683b      	ldr	r3, [r7, #0]
90016fea:	f1a3 0114 	sub.w	r1, r3, #20
90016fee:	2301      	movs	r3, #1
90016ff0:	4a25      	ldr	r2, [pc, #148]	; (90017088 <Display_DemoDescription+0x104>)
90016ff2:	2000      	movs	r0, #0
90016ff4:	f001 fce0 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

  UTIL_LCD_SetFont(&Font16);
90016ff8:	4824      	ldr	r0, [pc, #144]	; (9001708c <Display_DemoDescription+0x108>)
90016ffa:	f001 fbb1 	bl	90018760 <UTIL_LCD_SetFont>
  BSP_LCD_FillRect(0, 0, y_size/2 - 15, x_size, 100, UTIL_LCD_COLOR_BLUE);
90016ffe:	683b      	ldr	r3, [r7, #0]
90017000:	085b      	lsrs	r3, r3, #1
90017002:	f1a3 020f 	sub.w	r2, r3, #15
90017006:	687b      	ldr	r3, [r7, #4]
90017008:	4921      	ldr	r1, [pc, #132]	; (90017090 <Display_DemoDescription+0x10c>)
9001700a:	9101      	str	r1, [sp, #4]
9001700c:	2164      	movs	r1, #100	; 0x64
9001700e:	9100      	str	r1, [sp, #0]
90017010:	2100      	movs	r1, #0
90017012:	2000      	movs	r0, #0
90017014:	f7f0 fd10 	bl	90007a38 <BSP_LCD_FillRect>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
90017018:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
9001701c:	f001 fb78 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
90017020:	481b      	ldr	r0, [pc, #108]	; (90017090 <Display_DemoDescription+0x10c>)
90017022:	f001 fb89 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_DisplayStringAt(0, y_size / 2 , (uint8_t *)"Press TAMPER button to start :", CENTER_MODE);
90017026:	683b      	ldr	r3, [r7, #0]
90017028:	0859      	lsrs	r1, r3, #1
9001702a:	2301      	movs	r3, #1
9001702c:	4a19      	ldr	r2, [pc, #100]	; (90017094 <Display_DemoDescription+0x110>)
9001702e:	2000      	movs	r0, #0
90017030:	f001 fcc2 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  sprintf(desc,"%s example", BSP_examples[DemoIndex].DemoName);
90017034:	4b18      	ldr	r3, [pc, #96]	; (90017098 <Display_DemoDescription+0x114>)
90017036:	781b      	ldrb	r3, [r3, #0]
90017038:	461a      	mov	r2, r3
9001703a:	4613      	mov	r3, r2
9001703c:	011b      	lsls	r3, r3, #4
9001703e:	1a9b      	subs	r3, r3, r2
90017040:	009b      	lsls	r3, r3, #2
90017042:	4a16      	ldr	r2, [pc, #88]	; (9001709c <Display_DemoDescription+0x118>)
90017044:	4413      	add	r3, r2
90017046:	1d1a      	adds	r2, r3, #4
90017048:	f107 0308 	add.w	r3, r7, #8
9001704c:	4914      	ldr	r1, [pc, #80]	; (900170a0 <Display_DemoDescription+0x11c>)
9001704e:	4618      	mov	r0, r3
90017050:	f002 fdae 	bl	90019bb0 <sprintf>
  UTIL_LCD_DisplayStringAt(0, y_size/2 + 15, (uint8_t *)desc, CENTER_MODE);
90017054:	683b      	ldr	r3, [r7, #0]
90017056:	085b      	lsrs	r3, r3, #1
90017058:	f103 010f 	add.w	r1, r3, #15
9001705c:	f107 0208 	add.w	r2, r7, #8
90017060:	2301      	movs	r3, #1
90017062:	2000      	movs	r0, #0
90017064:	f001 fca8 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
}
90017068:	bf00      	nop
9001706a:	3748      	adds	r7, #72	; 0x48
9001706c:	46bd      	mov	sp, r7
9001706e:	bd80      	pop	{r7, pc}
90017070:	24000388 	.word	0x24000388
90017074:	ff000080 	.word	0xff000080
90017078:	900210b0 	.word	0x900210b0
9001707c:	900210c0 	.word	0x900210c0
90017080:	9001ecd8 	.word	0x9001ecd8
90017084:	240003a0 	.word	0x240003a0
90017088:	900210d4 	.word	0x900210d4
9001708c:	24000398 	.word	0x24000398
90017090:	ff0000ff 	.word	0xff0000ff
90017094:	900210fc 	.word	0x900210fc
90017098:	240027ec 	.word	0x240027ec
9001709c:	2400011c 	.word	0x2400011c
900170a0:	9002111c 	.word	0x9002111c

900170a4 <CheckForUserInput>:
  * @brief  Check for user input
  * @param  None
  * @retval Input state (1 : active / 0 : Inactive)
  */
uint8_t CheckForUserInput(void)
{
900170a4:	b480      	push	{r7}
900170a6:	af00      	add	r7, sp, #0
  return ButtonState;
900170a8:	4b03      	ldr	r3, [pc, #12]	; (900170b8 <CheckForUserInput+0x14>)
900170aa:	681b      	ldr	r3, [r3, #0]
900170ac:	b2db      	uxtb	r3, r3
}
900170ae:	4618      	mov	r0, r3
900170b0:	46bd      	mov	sp, r7
900170b2:	f85d 7b04 	ldr.w	r7, [sp], #4
900170b6:	4770      	bx	lr
900170b8:	240027f0 	.word	0x240027f0

900170bc <BSP_PB_Callback>:
* @brief  EXTI line detection callbacks.
* @param  GPIO_Pin: Specifies the pins connected EXTI line
* @retval None
*/
void BSP_PB_Callback(Button_TypeDef Button)
{
900170bc:	b480      	push	{r7}
900170be:	b083      	sub	sp, #12
900170c0:	af00      	add	r7, sp, #0
900170c2:	4603      	mov	r3, r0
900170c4:	71fb      	strb	r3, [r7, #7]
 if(Button == BUTTON_USER)
900170c6:	79fb      	ldrb	r3, [r7, #7]
900170c8:	2b00      	cmp	r3, #0
900170ca:	d102      	bne.n	900170d2 <BSP_PB_Callback+0x16>
  {
    ButtonState = 1;
900170cc:	4b04      	ldr	r3, [pc, #16]	; (900170e0 <BSP_PB_Callback+0x24>)
900170ce:	2201      	movs	r2, #1
900170d0:	601a      	str	r2, [r3, #0]
  }
}
900170d2:	bf00      	nop
900170d4:	370c      	adds	r7, #12
900170d6:	46bd      	mov	sp, r7
900170d8:	f85d 7b04 	ldr.w	r7, [sp], #4
900170dc:	4770      	bx	lr
900170de:	bf00      	nop
900170e0:	240027f0 	.word	0x240027f0

900170e4 <Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void Error_Handler(void)
{
900170e4:	b580      	push	{r7, lr}
900170e6:	af00      	add	r7, sp, #0
  /* Turn LED REDon */
  BSP_LED_On(LED_RED);
900170e8:	2001      	movs	r0, #1
900170ea:	f7ed fe5d 	bl	90004da8 <BSP_LED_On>
  while(1)
900170ee:	e7fe      	b.n	900170ee <Error_Handler+0xa>

900170f0 <MPU_Config>:
  * @brief  Configure the MPU attributes
  * @param  None
  * @retval None
  */
static void MPU_Config(void)
{
900170f0:	b580      	push	{r7, lr}
900170f2:	b084      	sub	sp, #16
900170f4:	af00      	add	r7, sp, #0
    MPU_Region_InitTypeDef MPU_InitStruct;

  /* Disable the MPU */
  HAL_MPU_Disable();
900170f6:	f7f2 faf3 	bl	900096e0 <HAL_MPU_Disable>

  /* Configure the MPU attributes as WT for SDRAM */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
900170fa:	2301      	movs	r3, #1
900170fc:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.BaseAddress = SDRAM_DEVICE_ADDR;
900170fe:	f04f 4350 	mov.w	r3, #3489660928	; 0xd0000000
90017102:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_16MB;
90017104:	2317      	movs	r3, #23
90017106:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
90017108:	2303      	movs	r3, #3
9001710a:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
9001710c:	2300      	movs	r3, #0
9001710e:	73fb      	strb	r3, [r7, #15]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
90017110:	2301      	movs	r3, #1
90017112:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
90017114:	2300      	movs	r3, #0
90017116:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.Number = MPU_REGION_NUMBER3;
90017118:	2303      	movs	r3, #3
9001711a:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
9001711c:	2300      	movs	r3, #0
9001711e:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.SubRegionDisable = 0x00;
90017120:	2300      	movs	r3, #0
90017122:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
90017124:	2300      	movs	r3, #0
90017126:	733b      	strb	r3, [r7, #12]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
90017128:	463b      	mov	r3, r7
9001712a:	4618      	mov	r0, r3
9001712c:	f7f2 fb10 	bl	90009750 <HAL_MPU_ConfigRegion>

  /* Enable the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
90017130:	2004      	movs	r0, #4
90017132:	f7f2 faed 	bl	90009710 <HAL_MPU_Enable>

}
90017136:	bf00      	nop
90017138:	3710      	adds	r7, #16
9001713a:	46bd      	mov	sp, r7
9001713c:	bd80      	pop	{r7, pc}
	...

90017140 <CPU_CACHE_Enable>:
  * @brief  CPU L1-Cache enable.
  * @param  None
  * @retval None
  */
static void CPU_CACHE_Enable(void)
{
90017140:	b480      	push	{r7}
90017142:	b085      	sub	sp, #20
90017144:	af00      	add	r7, sp, #0
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
90017146:	4b34      	ldr	r3, [pc, #208]	; (90017218 <CPU_CACHE_Enable+0xd8>)
90017148:	695b      	ldr	r3, [r3, #20]
9001714a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
9001714e:	2b00      	cmp	r3, #0
90017150:	d11b      	bne.n	9001718a <CPU_CACHE_Enable+0x4a>
  __ASM volatile ("dsb 0xF":::"memory");
90017152:	f3bf 8f4f 	dsb	sy
}
90017156:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
90017158:	f3bf 8f6f 	isb	sy
}
9001715c:	bf00      	nop
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
9001715e:	4b2e      	ldr	r3, [pc, #184]	; (90017218 <CPU_CACHE_Enable+0xd8>)
90017160:	2200      	movs	r2, #0
90017162:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
90017166:	f3bf 8f4f 	dsb	sy
}
9001716a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
9001716c:	f3bf 8f6f 	isb	sy
}
90017170:	bf00      	nop
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
90017172:	4b29      	ldr	r3, [pc, #164]	; (90017218 <CPU_CACHE_Enable+0xd8>)
90017174:	695b      	ldr	r3, [r3, #20]
90017176:	4a28      	ldr	r2, [pc, #160]	; (90017218 <CPU_CACHE_Enable+0xd8>)
90017178:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
9001717c:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
9001717e:	f3bf 8f4f 	dsb	sy
}
90017182:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
90017184:	f3bf 8f6f 	isb	sy
}
90017188:	e000      	b.n	9001718c <CPU_CACHE_Enable+0x4c>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
9001718a:	bf00      	nop
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
9001718c:	4b22      	ldr	r3, [pc, #136]	; (90017218 <CPU_CACHE_Enable+0xd8>)
9001718e:	695b      	ldr	r3, [r3, #20]
90017190:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
90017194:	2b00      	cmp	r3, #0
90017196:	d138      	bne.n	9001720a <CPU_CACHE_Enable+0xca>
    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
90017198:	4b1f      	ldr	r3, [pc, #124]	; (90017218 <CPU_CACHE_Enable+0xd8>)
9001719a:	2200      	movs	r2, #0
9001719c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
900171a0:	f3bf 8f4f 	dsb	sy
}
900171a4:	bf00      	nop
    ccsidr = SCB->CCSIDR;
900171a6:	4b1c      	ldr	r3, [pc, #112]	; (90017218 <CPU_CACHE_Enable+0xd8>)
900171a8:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
900171ac:	60fb      	str	r3, [r7, #12]
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
900171ae:	68fb      	ldr	r3, [r7, #12]
900171b0:	0b5b      	lsrs	r3, r3, #13
900171b2:	f3c3 030e 	ubfx	r3, r3, #0, #15
900171b6:	60bb      	str	r3, [r7, #8]
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
900171b8:	68fb      	ldr	r3, [r7, #12]
900171ba:	08db      	lsrs	r3, r3, #3
900171bc:	f3c3 0309 	ubfx	r3, r3, #0, #10
900171c0:	607b      	str	r3, [r7, #4]
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
900171c2:	68bb      	ldr	r3, [r7, #8]
900171c4:	015a      	lsls	r2, r3, #5
900171c6:	f643 73e0 	movw	r3, #16352	; 0x3fe0
900171ca:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
900171cc:	687a      	ldr	r2, [r7, #4]
900171ce:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
900171d0:	4911      	ldr	r1, [pc, #68]	; (90017218 <CPU_CACHE_Enable+0xd8>)
900171d2:	4313      	orrs	r3, r2
900171d4:	f8c1 3260 	str.w	r3, [r1, #608]	; 0x260
      } while (ways-- != 0U);
900171d8:	687b      	ldr	r3, [r7, #4]
900171da:	1e5a      	subs	r2, r3, #1
900171dc:	607a      	str	r2, [r7, #4]
900171de:	2b00      	cmp	r3, #0
900171e0:	d1ef      	bne.n	900171c2 <CPU_CACHE_Enable+0x82>
    } while(sets-- != 0U);
900171e2:	68bb      	ldr	r3, [r7, #8]
900171e4:	1e5a      	subs	r2, r3, #1
900171e6:	60ba      	str	r2, [r7, #8]
900171e8:	2b00      	cmp	r3, #0
900171ea:	d1e5      	bne.n	900171b8 <CPU_CACHE_Enable+0x78>
  __ASM volatile ("dsb 0xF":::"memory");
900171ec:	f3bf 8f4f 	dsb	sy
}
900171f0:	bf00      	nop
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
900171f2:	4b09      	ldr	r3, [pc, #36]	; (90017218 <CPU_CACHE_Enable+0xd8>)
900171f4:	695b      	ldr	r3, [r3, #20]
900171f6:	4a08      	ldr	r2, [pc, #32]	; (90017218 <CPU_CACHE_Enable+0xd8>)
900171f8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
900171fc:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
900171fe:	f3bf 8f4f 	dsb	sy
}
90017202:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
90017204:	f3bf 8f6f 	isb	sy
}
90017208:	e000      	b.n	9001720c <CPU_CACHE_Enable+0xcc>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
9001720a:	bf00      	nop
  /* Enable I-Cache */
  SCB_EnableICache();

  /* Enable D-Cache */
  SCB_EnableDCache();
}
9001720c:	bf00      	nop
9001720e:	3714      	adds	r7, #20
90017210:	46bd      	mov	sp, r7
90017212:	f85d 7b04 	ldr.w	r7, [sp], #4
90017216:	4770      	bx	lr
90017218:	e000ed00 	.word	0xe000ed00

9001721c <MMC_demo>:
  * @brief  MMC Demo
  * @param  None
  * @retval None
  */
void MMC_demo (void)
{
9001721c:	b580      	push	{r7, lr}
9001721e:	b082      	sub	sp, #8
90017220:	af00      	add	r7, sp, #0
int32_t MMC_state ;
  MMC_SetHint();
90017222:	f000 f8e7 	bl	900173f4 <MMC_SetHint>

  MMC_state = BSP_MMC_Init(0);
90017226:	2000      	movs	r0, #0
90017228:	f7f0 ffaa 	bl	90008180 <BSP_MMC_Init>
9001722c:	6078      	str	r0, [r7, #4]

  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLACK);
9001722e:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
90017232:	f001 fa6d 	bl	90018710 <UTIL_LCD_SetTextColor>

  if(MMC_state != BSP_ERROR_NONE)
90017236:	687b      	ldr	r3, [r7, #4]
90017238:	2b00      	cmp	r3, #0
9001723a:	d00f      	beq.n	9001725c <MMC_demo+0x40>
  {
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_RED);
9001723c:	485f      	ldr	r0, [pc, #380]	; (900173bc <MMC_demo+0x1a0>)
9001723e:	f001 fa67 	bl	90018710 <UTIL_LCD_SetTextColor>
    UTIL_LCD_DisplayStringAt(20, 100, (uint8_t *)"MMC INITIALIZATION : FAIL.", LEFT_MODE);
90017242:	2303      	movs	r3, #3
90017244:	4a5e      	ldr	r2, [pc, #376]	; (900173c0 <MMC_demo+0x1a4>)
90017246:	2164      	movs	r1, #100	; 0x64
90017248:	2014      	movs	r0, #20
9001724a:	f001 fbb5 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(20, 115, (uint8_t *)"MMC Test Aborted.", LEFT_MODE);
9001724e:	2303      	movs	r3, #3
90017250:	4a5c      	ldr	r2, [pc, #368]	; (900173c4 <MMC_demo+0x1a8>)
90017252:	2173      	movs	r1, #115	; 0x73
90017254:	2014      	movs	r0, #20
90017256:	f001 fbaf 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
9001725a:	e0a4      	b.n	900173a6 <MMC_demo+0x18a>
  }
  else
  {
    UTIL_LCD_DisplayStringAt(20, 100, (uint8_t *)"MMC INITIALIZATION : OK.", LEFT_MODE);
9001725c:	2303      	movs	r3, #3
9001725e:	4a5a      	ldr	r2, [pc, #360]	; (900173c8 <MMC_demo+0x1ac>)
90017260:	2164      	movs	r1, #100	; 0x64
90017262:	2014      	movs	r0, #20
90017264:	f001 fba8 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

    MMC_state = BSP_MMC_Erase(0,BLOCK_START_ADDR, (MMC_BLOCKSIZE * NUM_OF_BLOCKS));
90017268:	f44f 6220 	mov.w	r2, #2560	; 0xa00
9001726c:	2100      	movs	r1, #0
9001726e:	2000      	movs	r0, #0
90017270:	f7f1 f840 	bl	900082f4 <BSP_MMC_Erase>
90017274:	6078      	str	r0, [r7, #4]
    while(BSP_MMC_GetCardState(0) != MMC_TRANSFER_OK)
90017276:	bf00      	nop
90017278:	2000      	movs	r0, #0
9001727a:	f7f1 f865 	bl	90008348 <BSP_MMC_GetCardState>
9001727e:	4603      	mov	r3, r0
90017280:	2b00      	cmp	r3, #0
90017282:	d1f9      	bne.n	90017278 <MMC_demo+0x5c>
    {
    }

    if(MMC_state != BSP_ERROR_NONE)
90017284:	687b      	ldr	r3, [r7, #4]
90017286:	2b00      	cmp	r3, #0
90017288:	d00f      	beq.n	900172aa <MMC_demo+0x8e>
    {
      UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_RED);
9001728a:	484c      	ldr	r0, [pc, #304]	; (900173bc <MMC_demo+0x1a0>)
9001728c:	f001 fa40 	bl	90018710 <UTIL_LCD_SetTextColor>
      UTIL_LCD_DisplayStringAt(20, 115, (uint8_t *)"MMC ERASE : FAILED.", LEFT_MODE);
90017290:	2303      	movs	r3, #3
90017292:	4a4e      	ldr	r2, [pc, #312]	; (900173cc <MMC_demo+0x1b0>)
90017294:	2173      	movs	r1, #115	; 0x73
90017296:	2014      	movs	r0, #20
90017298:	f001 fb8e 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"MMC Test Aborted.", LEFT_MODE);
9001729c:	2303      	movs	r3, #3
9001729e:	4a49      	ldr	r2, [pc, #292]	; (900173c4 <MMC_demo+0x1a8>)
900172a0:	2182      	movs	r1, #130	; 0x82
900172a2:	2014      	movs	r0, #20
900172a4:	f001 fb88 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
900172a8:	e07d      	b.n	900173a6 <MMC_demo+0x18a>
    }
    else
    {
      UTIL_LCD_DisplayStringAt(20, 115, (uint8_t *)"MMC ERASE : OK.", LEFT_MODE);
900172aa:	2303      	movs	r3, #3
900172ac:	4a48      	ldr	r2, [pc, #288]	; (900173d0 <MMC_demo+0x1b4>)
900172ae:	2173      	movs	r1, #115	; 0x73
900172b0:	2014      	movs	r0, #20
900172b2:	f001 fb81 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

      /* Fill the buffer to write */
      Fill_Buffer(aTxBuffer, BUFFER_WORDS_SIZE, 0x22FF);
900172b6:	f242 22ff 	movw	r2, #8959	; 0x22ff
900172ba:	f44f 7120 	mov.w	r1, #640	; 0x280
900172be:	4845      	ldr	r0, [pc, #276]	; (900173d4 <MMC_demo+0x1b8>)
900172c0:	f000 f90c 	bl	900174dc <Fill_Buffer>
      MMC_state = BSP_MMC_WriteBlocks(0,(uint32_t *)aTxBuffer, BLOCK_START_ADDR, NUM_OF_BLOCKS);
900172c4:	2305      	movs	r3, #5
900172c6:	2200      	movs	r2, #0
900172c8:	4942      	ldr	r1, [pc, #264]	; (900173d4 <MMC_demo+0x1b8>)
900172ca:	2000      	movs	r0, #0
900172cc:	f7f0 ffe0 	bl	90008290 <BSP_MMC_WriteBlocks>
900172d0:	6078      	str	r0, [r7, #4]

      /* Wait until MMC cards are ready to use for new operation */
      while(BSP_MMC_GetCardState(0) != MMC_TRANSFER_OK)
900172d2:	bf00      	nop
900172d4:	2000      	movs	r0, #0
900172d6:	f7f1 f837 	bl	90008348 <BSP_MMC_GetCardState>
900172da:	4603      	mov	r3, r0
900172dc:	2b00      	cmp	r3, #0
900172de:	d1f9      	bne.n	900172d4 <MMC_demo+0xb8>
      {
      }
      if(MMC_state != BSP_ERROR_NONE)
900172e0:	687b      	ldr	r3, [r7, #4]
900172e2:	2b00      	cmp	r3, #0
900172e4:	d00f      	beq.n	90017306 <MMC_demo+0xea>
      {
        UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_RED);
900172e6:	4835      	ldr	r0, [pc, #212]	; (900173bc <MMC_demo+0x1a0>)
900172e8:	f001 fa12 	bl	90018710 <UTIL_LCD_SetTextColor>
        UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"MMC WRITE : FAILED.", LEFT_MODE);
900172ec:	2303      	movs	r3, #3
900172ee:	4a3a      	ldr	r2, [pc, #232]	; (900173d8 <MMC_demo+0x1bc>)
900172f0:	2182      	movs	r1, #130	; 0x82
900172f2:	2014      	movs	r0, #20
900172f4:	f001 fb60 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
        UTIL_LCD_DisplayStringAt(20, 145, (uint8_t *)"MMC Test Aborted.", LEFT_MODE);
900172f8:	2303      	movs	r3, #3
900172fa:	4a32      	ldr	r2, [pc, #200]	; (900173c4 <MMC_demo+0x1a8>)
900172fc:	2191      	movs	r1, #145	; 0x91
900172fe:	2014      	movs	r0, #20
90017300:	f001 fb5a 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
90017304:	e04f      	b.n	900173a6 <MMC_demo+0x18a>
      }
      else
      {
        UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"MMC WRITE : OK.", LEFT_MODE);
90017306:	2303      	movs	r3, #3
90017308:	4a34      	ldr	r2, [pc, #208]	; (900173dc <MMC_demo+0x1c0>)
9001730a:	2182      	movs	r1, #130	; 0x82
9001730c:	2014      	movs	r0, #20
9001730e:	f001 fb53 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
        MMC_state = BSP_MMC_ReadBlocks(0,(uint32_t *)aRxBuffer, BLOCK_START_ADDR, NUM_OF_BLOCKS);
90017312:	2305      	movs	r3, #5
90017314:	2200      	movs	r2, #0
90017316:	4932      	ldr	r1, [pc, #200]	; (900173e0 <MMC_demo+0x1c4>)
90017318:	2000      	movs	r0, #0
9001731a:	f7f0 ff87 	bl	9000822c <BSP_MMC_ReadBlocks>
9001731e:	6078      	str	r0, [r7, #4]

        /* Wait until MMC cards are ready to use for new operation */
        while(BSP_MMC_GetCardState(0) != MMC_TRANSFER_OK)
90017320:	bf00      	nop
90017322:	2000      	movs	r0, #0
90017324:	f7f1 f810 	bl	90008348 <BSP_MMC_GetCardState>
90017328:	4603      	mov	r3, r0
9001732a:	2b00      	cmp	r3, #0
9001732c:	d1f9      	bne.n	90017322 <MMC_demo+0x106>
        {
        }
        if(MMC_state != BSP_ERROR_NONE)
9001732e:	687b      	ldr	r3, [r7, #4]
90017330:	2b00      	cmp	r3, #0
90017332:	d00f      	beq.n	90017354 <MMC_demo+0x138>
        {
          UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_RED);
90017334:	4821      	ldr	r0, [pc, #132]	; (900173bc <MMC_demo+0x1a0>)
90017336:	f001 f9eb 	bl	90018710 <UTIL_LCD_SetTextColor>
          UTIL_LCD_DisplayStringAt(20, 145, (uint8_t *)"MMC READ : FAILED.", LEFT_MODE);
9001733a:	2303      	movs	r3, #3
9001733c:	4a29      	ldr	r2, [pc, #164]	; (900173e4 <MMC_demo+0x1c8>)
9001733e:	2191      	movs	r1, #145	; 0x91
90017340:	2014      	movs	r0, #20
90017342:	f001 fb39 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
          UTIL_LCD_DisplayStringAt(20, 160, (uint8_t *)"MMC Test Aborted.", LEFT_MODE);
90017346:	2303      	movs	r3, #3
90017348:	4a1e      	ldr	r2, [pc, #120]	; (900173c4 <MMC_demo+0x1a8>)
9001734a:	21a0      	movs	r1, #160	; 0xa0
9001734c:	2014      	movs	r0, #20
9001734e:	f001 fb33 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
90017352:	e028      	b.n	900173a6 <MMC_demo+0x18a>
        }
        else
        {
          UTIL_LCD_DisplayStringAt(20, 145, (uint8_t *)"MMC READ : OK.", LEFT_MODE);
90017354:	2303      	movs	r3, #3
90017356:	4a24      	ldr	r2, [pc, #144]	; (900173e8 <MMC_demo+0x1cc>)
90017358:	2191      	movs	r1, #145	; 0x91
9001735a:	2014      	movs	r0, #20
9001735c:	f001 fb2c 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
          if(Buffercmp(aTxBuffer, aRxBuffer, BUFFER_WORDS_SIZE) > 0)
90017360:	f44f 7220 	mov.w	r2, #640	; 0x280
90017364:	491e      	ldr	r1, [pc, #120]	; (900173e0 <MMC_demo+0x1c4>)
90017366:	481b      	ldr	r0, [pc, #108]	; (900173d4 <MMC_demo+0x1b8>)
90017368:	f000 f8d9 	bl	9001751e <Buffercmp>
9001736c:	4603      	mov	r3, r0
9001736e:	2b00      	cmp	r3, #0
90017370:	d00f      	beq.n	90017392 <MMC_demo+0x176>
          {
            UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_RED);
90017372:	4812      	ldr	r0, [pc, #72]	; (900173bc <MMC_demo+0x1a0>)
90017374:	f001 f9cc 	bl	90018710 <UTIL_LCD_SetTextColor>
            UTIL_LCD_DisplayStringAt(20, 160, (uint8_t *)"MMC COMPARE : FAILED.", LEFT_MODE);
90017378:	2303      	movs	r3, #3
9001737a:	4a1c      	ldr	r2, [pc, #112]	; (900173ec <MMC_demo+0x1d0>)
9001737c:	21a0      	movs	r1, #160	; 0xa0
9001737e:	2014      	movs	r0, #20
90017380:	f001 fb1a 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
            UTIL_LCD_DisplayStringAt(20, 175, (uint8_t *)"MMC Test Aborted.", LEFT_MODE);
90017384:	2303      	movs	r3, #3
90017386:	4a0f      	ldr	r2, [pc, #60]	; (900173c4 <MMC_demo+0x1a8>)
90017388:	21af      	movs	r1, #175	; 0xaf
9001738a:	2014      	movs	r0, #20
9001738c:	f001 fb14 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
90017390:	e009      	b.n	900173a6 <MMC_demo+0x18a>
          }
          else
          {
            UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_GREEN);
90017392:	f04f 20ff 	mov.w	r0, #4278255360	; 0xff00ff00
90017396:	f001 f9bb 	bl	90018710 <UTIL_LCD_SetTextColor>
            UTIL_LCD_DisplayStringAt(20, 160, (uint8_t *)"MMC TEST : OK.", LEFT_MODE);
9001739a:	2303      	movs	r3, #3
9001739c:	4a14      	ldr	r2, [pc, #80]	; (900173f0 <MMC_demo+0x1d4>)
9001739e:	21a0      	movs	r1, #160	; 0xa0
900173a0:	2014      	movs	r0, #20
900173a2:	f001 fb09 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  }

  while (1)
  {

    if(CheckForUserInput() > 0)
900173a6:	f7ff fe7d 	bl	900170a4 <CheckForUserInput>
900173aa:	4603      	mov	r3, r0
900173ac:	2b00      	cmp	r3, #0
900173ae:	d100      	bne.n	900173b2 <MMC_demo+0x196>
900173b0:	e7f9      	b.n	900173a6 <MMC_demo+0x18a>
    {
      return;
900173b2:	bf00      	nop
    }
  }
}
900173b4:	3708      	adds	r7, #8
900173b6:	46bd      	mov	sp, r7
900173b8:	bd80      	pop	{r7, pc}
900173ba:	bf00      	nop
900173bc:	ffff0000 	.word	0xffff0000
900173c0:	90021128 	.word	0x90021128
900173c4:	90021144 	.word	0x90021144
900173c8:	90021158 	.word	0x90021158
900173cc:	90021174 	.word	0x90021174
900173d0:	90021188 	.word	0x90021188
900173d4:	240099f4 	.word	0x240099f4
900173d8:	90021198 	.word	0x90021198
900173dc:	900211ac 	.word	0x900211ac
900173e0:	24008ff4 	.word	0x24008ff4
900173e4:	900211bc 	.word	0x900211bc
900173e8:	900211d0 	.word	0x900211d0
900173ec:	900211e0 	.word	0x900211e0
900173f0:	900211f8 	.word	0x900211f8

900173f4 <MMC_SetHint>:
  * @brief  Display MMC Demo Hint
  * @param  None
  * @retval None
  */
static void MMC_SetHint(void)
{
900173f4:	b580      	push	{r7, lr}
900173f6:	b084      	sub	sp, #16
900173f8:	af02      	add	r7, sp, #8
  uint32_t x_size, y_size;

  BSP_LCD_GetXSize(0, &x_size);
900173fa:	1d3b      	adds	r3, r7, #4
900173fc:	4619      	mov	r1, r3
900173fe:	2000      	movs	r0, #0
90017400:	f7f0 f92e 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
90017404:	463b      	mov	r3, r7
90017406:	4619      	mov	r1, r3
90017408:	2000      	movs	r0, #0
9001740a:	f7f0 f947 	bl	9000769c <BSP_LCD_GetYSize>
  /* Clear the LCD */
  UTIL_LCD_Clear(UTIL_LCD_COLOR_WHITE);
9001740e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90017412:	f001 fa85 	bl	90018920 <UTIL_LCD_Clear>

  /* Set LCD Demo description */
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLUE);
90017416:	482a      	ldr	r0, [pc, #168]	; (900174c0 <MMC_SetHint+0xcc>)
90017418:	f001 f97a 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_FillRect(0, 0, x_size, 80, UTIL_LCD_COLOR_BLUE);
9001741c:	687a      	ldr	r2, [r7, #4]
9001741e:	4b28      	ldr	r3, [pc, #160]	; (900174c0 <MMC_SetHint+0xcc>)
90017420:	9300      	str	r3, [sp, #0]
90017422:	2350      	movs	r3, #80	; 0x50
90017424:	2100      	movs	r1, #0
90017426:	2000      	movs	r0, #0
90017428:	f001 fea0 	bl	9001916c <UTIL_LCD_FillRect>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
9001742c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90017430:	f001 f96e 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
90017434:	4822      	ldr	r0, [pc, #136]	; (900174c0 <MMC_SetHint+0xcc>)
90017436:	f001 f97f 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_SetFont(&Font24);
9001743a:	4822      	ldr	r0, [pc, #136]	; (900174c4 <MMC_SetHint+0xd0>)
9001743c:	f001 f990 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, 0, (uint8_t *)"MMC", CENTER_MODE);
90017440:	2301      	movs	r3, #1
90017442:	4a21      	ldr	r2, [pc, #132]	; (900174c8 <MMC_SetHint+0xd4>)
90017444:	2100      	movs	r1, #0
90017446:	2000      	movs	r0, #0
90017448:	f001 fab6 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_SetFont(&Font12);
9001744c:	481f      	ldr	r0, [pc, #124]	; (900174cc <MMC_SetHint+0xd8>)
9001744e:	f001 f987 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, 30, (uint8_t *)"This example shows how to write", CENTER_MODE);
90017452:	2301      	movs	r3, #1
90017454:	4a1e      	ldr	r2, [pc, #120]	; (900174d0 <MMC_SetHint+0xdc>)
90017456:	211e      	movs	r1, #30
90017458:	2000      	movs	r0, #0
9001745a:	f001 faad 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_DisplayStringAt(0, 45, (uint8_t *)"and read data on the microMMC and also", CENTER_MODE);
9001745e:	2301      	movs	r3, #1
90017460:	4a1c      	ldr	r2, [pc, #112]	; (900174d4 <MMC_SetHint+0xe0>)
90017462:	212d      	movs	r1, #45	; 0x2d
90017464:	2000      	movs	r0, #0
90017466:	f001 faa7 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_DisplayStringAt(0, 60, (uint8_t *)"how to detect the presence of the card", CENTER_MODE);
9001746a:	2301      	movs	r3, #1
9001746c:	4a1a      	ldr	r2, [pc, #104]	; (900174d8 <MMC_SetHint+0xe4>)
9001746e:	213c      	movs	r1, #60	; 0x3c
90017470:	2000      	movs	r0, #0
90017472:	f001 faa1 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

  /* Set the LCD Text Color */
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLUE);
90017476:	4812      	ldr	r0, [pc, #72]	; (900174c0 <MMC_SetHint+0xcc>)
90017478:	f001 f94a 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_DrawRect(10, 90, x_size - 20, y_size - 100, UTIL_LCD_COLOR_BLUE);
9001747c:	687b      	ldr	r3, [r7, #4]
9001747e:	f1a3 0214 	sub.w	r2, r3, #20
90017482:	683b      	ldr	r3, [r7, #0]
90017484:	3b64      	subs	r3, #100	; 0x64
90017486:	490e      	ldr	r1, [pc, #56]	; (900174c0 <MMC_SetHint+0xcc>)
90017488:	9100      	str	r1, [sp, #0]
9001748a:	215a      	movs	r1, #90	; 0x5a
9001748c:	200a      	movs	r0, #10
9001748e:	f001 fbfd 	bl	90018c8c <UTIL_LCD_DrawRect>
  UTIL_LCD_DrawRect(11, 91, x_size - 22, y_size - 102, UTIL_LCD_COLOR_BLUE);
90017492:	687b      	ldr	r3, [r7, #4]
90017494:	f1a3 0216 	sub.w	r2, r3, #22
90017498:	683b      	ldr	r3, [r7, #0]
9001749a:	3b66      	subs	r3, #102	; 0x66
9001749c:	4908      	ldr	r1, [pc, #32]	; (900174c0 <MMC_SetHint+0xcc>)
9001749e:	9100      	str	r1, [sp, #0]
900174a0:	215b      	movs	r1, #91	; 0x5b
900174a2:	200b      	movs	r0, #11
900174a4:	f001 fbf2 	bl	90018c8c <UTIL_LCD_DrawRect>

  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLACK);
900174a8:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
900174ac:	f001 f930 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
900174b0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900174b4:	f001 f940 	bl	90018738 <UTIL_LCD_SetBackColor>
 }
900174b8:	bf00      	nop
900174ba:	3708      	adds	r7, #8
900174bc:	46bd      	mov	sp, r7
900174be:	bd80      	pop	{r7, pc}
900174c0:	ff0000ff 	.word	0xff0000ff
900174c4:	24000388 	.word	0x24000388
900174c8:	90021208 	.word	0x90021208
900174cc:	240003a0 	.word	0x240003a0
900174d0:	9002120c 	.word	0x9002120c
900174d4:	9002122c 	.word	0x9002122c
900174d8:	90021254 	.word	0x90021254

900174dc <Fill_Buffer>:
  * @param  uwBufferLenght: size of the buffer to fill
  * @param  uwOffset: first value to fill on the buffer
  * @retval None
  */
static void Fill_Buffer(uint32_t *pBuffer, uint32_t uwBufferLenght, uint32_t uwOffset)
{
900174dc:	b480      	push	{r7}
900174de:	b087      	sub	sp, #28
900174e0:	af00      	add	r7, sp, #0
900174e2:	60f8      	str	r0, [r7, #12]
900174e4:	60b9      	str	r1, [r7, #8]
900174e6:	607a      	str	r2, [r7, #4]
  uint32_t tmpIndex = 0;
900174e8:	2300      	movs	r3, #0
900174ea:	617b      	str	r3, [r7, #20]

  /* Put in global buffer different values */
  for (tmpIndex = 0; tmpIndex < uwBufferLenght; tmpIndex++ )
900174ec:	2300      	movs	r3, #0
900174ee:	617b      	str	r3, [r7, #20]
900174f0:	e00a      	b.n	90017508 <Fill_Buffer+0x2c>
  {
    pBuffer[tmpIndex] = tmpIndex + uwOffset;
900174f2:	697b      	ldr	r3, [r7, #20]
900174f4:	009b      	lsls	r3, r3, #2
900174f6:	68fa      	ldr	r2, [r7, #12]
900174f8:	4413      	add	r3, r2
900174fa:	6979      	ldr	r1, [r7, #20]
900174fc:	687a      	ldr	r2, [r7, #4]
900174fe:	440a      	add	r2, r1
90017500:	601a      	str	r2, [r3, #0]
  for (tmpIndex = 0; tmpIndex < uwBufferLenght; tmpIndex++ )
90017502:	697b      	ldr	r3, [r7, #20]
90017504:	3301      	adds	r3, #1
90017506:	617b      	str	r3, [r7, #20]
90017508:	697a      	ldr	r2, [r7, #20]
9001750a:	68bb      	ldr	r3, [r7, #8]
9001750c:	429a      	cmp	r2, r3
9001750e:	d3f0      	bcc.n	900174f2 <Fill_Buffer+0x16>
  }
}
90017510:	bf00      	nop
90017512:	bf00      	nop
90017514:	371c      	adds	r7, #28
90017516:	46bd      	mov	sp, r7
90017518:	f85d 7b04 	ldr.w	r7, [sp], #4
9001751c:	4770      	bx	lr

9001751e <Buffercmp>:
  * @param  BufferLength: buffer's length
  * @retval 1: pBuffer identical to pBuffer1
  *         0: pBuffer differs from pBuffer1
  */
static uint8_t Buffercmp(uint32_t* pBuffer1, uint32_t* pBuffer2, uint16_t BufferLength)
{
9001751e:	b480      	push	{r7}
90017520:	b085      	sub	sp, #20
90017522:	af00      	add	r7, sp, #0
90017524:	60f8      	str	r0, [r7, #12]
90017526:	60b9      	str	r1, [r7, #8]
90017528:	4613      	mov	r3, r2
9001752a:	80fb      	strh	r3, [r7, #6]
  while (BufferLength--)
9001752c:	e00d      	b.n	9001754a <Buffercmp+0x2c>
  {
    if (*pBuffer1 != *pBuffer2)
9001752e:	68fb      	ldr	r3, [r7, #12]
90017530:	681a      	ldr	r2, [r3, #0]
90017532:	68bb      	ldr	r3, [r7, #8]
90017534:	681b      	ldr	r3, [r3, #0]
90017536:	429a      	cmp	r2, r3
90017538:	d001      	beq.n	9001753e <Buffercmp+0x20>
    {
      return 1;
9001753a:	2301      	movs	r3, #1
9001753c:	e00b      	b.n	90017556 <Buffercmp+0x38>
    }

    pBuffer1++;
9001753e:	68fb      	ldr	r3, [r7, #12]
90017540:	3304      	adds	r3, #4
90017542:	60fb      	str	r3, [r7, #12]
    pBuffer2++;
90017544:	68bb      	ldr	r3, [r7, #8]
90017546:	3304      	adds	r3, #4
90017548:	60bb      	str	r3, [r7, #8]
  while (BufferLength--)
9001754a:	88fb      	ldrh	r3, [r7, #6]
9001754c:	1e5a      	subs	r2, r3, #1
9001754e:	80fa      	strh	r2, [r7, #6]
90017550:	2b00      	cmp	r3, #0
90017552:	d1ec      	bne.n	9001752e <Buffercmp+0x10>
  }

  return 0;
90017554:	2300      	movs	r3, #0
}
90017556:	4618      	mov	r0, r3
90017558:	3714      	adds	r7, #20
9001755a:	46bd      	mov	sp, r7
9001755c:	f85d 7b04 	ldr.w	r7, [sp], #4
90017560:	4770      	bx	lr
	...

90017564 <SDRAM_demo>:
  * @brief  SDRAM Demo
  * @param  None
  * @retval None
  */
void SDRAM_demo (void)
{
90017564:	b580      	push	{r7, lr}
90017566:	af00      	add	r7, sp, #0
  SDRAM_SetHint();
90017568:	f000 f99a 	bl	900178a0 <SDRAM_SetHint>

  /* SDRAM device configuration */
  if(BSP_SDRAM_Init(0) != BSP_ERROR_NONE)
9001756c:	2000      	movs	r0, #0
9001756e:	f7f0 ff7b 	bl	90008468 <BSP_SDRAM_Init>
90017572:	4603      	mov	r3, r0
90017574:	2b00      	cmp	r3, #0
90017576:	d00c      	beq.n	90017592 <SDRAM_demo+0x2e>
  {
    UTIL_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM Initialization : FAILED.", LEFT_MODE);
90017578:	2303      	movs	r3, #3
9001757a:	4a3e      	ldr	r2, [pc, #248]	; (90017674 <SDRAM_demo+0x110>)
9001757c:	2173      	movs	r1, #115	; 0x73
9001757e:	2014      	movs	r0, #20
90017580:	f001 fa1a 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
90017584:	2303      	movs	r3, #3
90017586:	4a3c      	ldr	r2, [pc, #240]	; (90017678 <SDRAM_demo+0x114>)
90017588:	2182      	movs	r1, #130	; 0x82
9001758a:	2014      	movs	r0, #20
9001758c:	f001 fa14 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
90017590:	e005      	b.n	9001759e <SDRAM_demo+0x3a>
  }
  else
  {
    UTIL_LCD_DisplayStringAt(20, 100, (uint8_t *)"SDRAM Initialization : OK.", LEFT_MODE);
90017592:	2303      	movs	r3, #3
90017594:	4a39      	ldr	r2, [pc, #228]	; (9001767c <SDRAM_demo+0x118>)
90017596:	2164      	movs	r1, #100	; 0x64
90017598:	2014      	movs	r0, #20
9001759a:	f001 fa0d 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  }
  /* Fill the buffer to write */
  Fill_Buffer(sdram_aTxBuffer, BUFFER_SIZE, 0x250F);
9001759e:	f242 520f 	movw	r2, #9487	; 0x250f
900175a2:	f44f 7100 	mov.w	r1, #512	; 0x200
900175a6:	4836      	ldr	r0, [pc, #216]	; (90017680 <SDRAM_demo+0x11c>)
900175a8:	f000 fa46 	bl	90017a38 <Fill_Buffer>

  /* Write data to the SDRAM memory */
  if(HAL_SDRAM_Write_32b(&hsdram[0], (uint32_t *)(SDRAM_WRITE_READ_ADDR + WRITE_READ_ADDR), (uint32_t*)sdram_aTxBuffer, BUFFER_SIZE) != BSP_ERROR_NONE)
900175ac:	f44f 7300 	mov.w	r3, #512	; 0x200
900175b0:	4a33      	ldr	r2, [pc, #204]	; (90017680 <SDRAM_demo+0x11c>)
900175b2:	4934      	ldr	r1, [pc, #208]	; (90017684 <SDRAM_demo+0x120>)
900175b4:	4834      	ldr	r0, [pc, #208]	; (90017688 <SDRAM_demo+0x124>)
900175b6:	f7fd f866 	bl	90014686 <HAL_SDRAM_Write_32b>
900175ba:	4603      	mov	r3, r0
900175bc:	2b00      	cmp	r3, #0
900175be:	d00c      	beq.n	900175da <SDRAM_demo+0x76>
  {
    UTIL_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM WRITE : FAILED.", LEFT_MODE);
900175c0:	2303      	movs	r3, #3
900175c2:	4a32      	ldr	r2, [pc, #200]	; (9001768c <SDRAM_demo+0x128>)
900175c4:	2173      	movs	r1, #115	; 0x73
900175c6:	2014      	movs	r0, #20
900175c8:	f001 f9f6 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
900175cc:	2303      	movs	r3, #3
900175ce:	4a2a      	ldr	r2, [pc, #168]	; (90017678 <SDRAM_demo+0x114>)
900175d0:	2182      	movs	r1, #130	; 0x82
900175d2:	2014      	movs	r0, #20
900175d4:	f001 f9f0 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
900175d8:	e005      	b.n	900175e6 <SDRAM_demo+0x82>
  }
  else
  {
    UTIL_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM WRITE : OK.", LEFT_MODE);
900175da:	2303      	movs	r3, #3
900175dc:	4a2c      	ldr	r2, [pc, #176]	; (90017690 <SDRAM_demo+0x12c>)
900175de:	2173      	movs	r1, #115	; 0x73
900175e0:	2014      	movs	r0, #20
900175e2:	f001 f9e9 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  }

  /* Read back data from the SDRAM memory */
  if(HAL_SDRAM_Read_32b(&hsdram[0], (uint32_t *)(SDRAM_WRITE_READ_ADDR + WRITE_READ_ADDR), (uint32_t*)sdram_aRxBuffer, BUFFER_SIZE) != BSP_ERROR_NONE)
900175e6:	f44f 7300 	mov.w	r3, #512	; 0x200
900175ea:	4a2a      	ldr	r2, [pc, #168]	; (90017694 <SDRAM_demo+0x130>)
900175ec:	4925      	ldr	r1, [pc, #148]	; (90017684 <SDRAM_demo+0x120>)
900175ee:	4826      	ldr	r0, [pc, #152]	; (90017688 <SDRAM_demo+0x124>)
900175f0:	f7fc fffc 	bl	900145ec <HAL_SDRAM_Read_32b>
900175f4:	4603      	mov	r3, r0
900175f6:	2b00      	cmp	r3, #0
900175f8:	d00c      	beq.n	90017614 <SDRAM_demo+0xb0>
  {
    UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM READ : FAILED.", LEFT_MODE);
900175fa:	2303      	movs	r3, #3
900175fc:	4a26      	ldr	r2, [pc, #152]	; (90017698 <SDRAM_demo+0x134>)
900175fe:	2182      	movs	r1, #130	; 0x82
90017600:	2014      	movs	r0, #20
90017602:	f001 f9d9 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
90017606:	2303      	movs	r3, #3
90017608:	4a1b      	ldr	r2, [pc, #108]	; (90017678 <SDRAM_demo+0x114>)
9001760a:	2191      	movs	r1, #145	; 0x91
9001760c:	2014      	movs	r0, #20
9001760e:	f001 f9d3 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
90017612:	e005      	b.n	90017620 <SDRAM_demo+0xbc>
  }
  else
  {
    UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM READ : OK.", LEFT_MODE);
90017614:	2303      	movs	r3, #3
90017616:	4a21      	ldr	r2, [pc, #132]	; (9001769c <SDRAM_demo+0x138>)
90017618:	2182      	movs	r1, #130	; 0x82
9001761a:	2014      	movs	r0, #20
9001761c:	f001 f9cc 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  }

  if(Buffercmp(sdram_aTxBuffer, sdram_aRxBuffer, BUFFER_SIZE) > 0)
90017620:	f44f 7200 	mov.w	r2, #512	; 0x200
90017624:	491b      	ldr	r1, [pc, #108]	; (90017694 <SDRAM_demo+0x130>)
90017626:	4816      	ldr	r0, [pc, #88]	; (90017680 <SDRAM_demo+0x11c>)
90017628:	f000 fa27 	bl	90017a7a <Buffercmp>
9001762c:	4603      	mov	r3, r0
9001762e:	2b00      	cmp	r3, #0
90017630:	d00c      	beq.n	9001764c <SDRAM_demo+0xe8>
  {
    UTIL_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM COMPARE : FAILED.", LEFT_MODE);
90017632:	2303      	movs	r3, #3
90017634:	4a1a      	ldr	r2, [pc, #104]	; (900176a0 <SDRAM_demo+0x13c>)
90017636:	2191      	movs	r1, #145	; 0x91
90017638:	2014      	movs	r0, #20
9001763a:	f001 f9bd 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(20, 160, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
9001763e:	2303      	movs	r3, #3
90017640:	4a0d      	ldr	r2, [pc, #52]	; (90017678 <SDRAM_demo+0x114>)
90017642:	21a0      	movs	r1, #160	; 0xa0
90017644:	2014      	movs	r0, #20
90017646:	f001 f9b7 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
9001764a:	e005      	b.n	90017658 <SDRAM_demo+0xf4>
  }
  else
  {
    UTIL_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM Test : OK.", LEFT_MODE);
9001764c:	2303      	movs	r3, #3
9001764e:	4a15      	ldr	r2, [pc, #84]	; (900176a4 <SDRAM_demo+0x140>)
90017650:	2191      	movs	r1, #145	; 0x91
90017652:	2014      	movs	r0, #20
90017654:	f001 f9b0 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  }

  ButtonState = 0;
90017658:	4b13      	ldr	r3, [pc, #76]	; (900176a8 <SDRAM_demo+0x144>)
9001765a:	2200      	movs	r2, #0
9001765c:	601a      	str	r2, [r3, #0]
  while (1)
  {
    if(CheckForUserInput() > 0)
9001765e:	f7ff fd21 	bl	900170a4 <CheckForUserInput>
90017662:	4603      	mov	r3, r0
90017664:	2b00      	cmp	r3, #0
90017666:	d0fa      	beq.n	9001765e <SDRAM_demo+0xfa>
    {
      ButtonState = 0;
90017668:	4b0f      	ldr	r3, [pc, #60]	; (900176a8 <SDRAM_demo+0x144>)
9001766a:	2200      	movs	r2, #0
9001766c:	601a      	str	r2, [r3, #0]
      return;
9001766e:	bf00      	nop
    }
  }
}
90017670:	bd80      	pop	{r7, pc}
90017672:	bf00      	nop
90017674:	9002127c 	.word	0x9002127c
90017678:	9002129c 	.word	0x9002129c
9001767c:	900212b0 	.word	0x900212b0
90017680:	2400ac00 	.word	0x2400ac00
90017684:	d0177000 	.word	0xd0177000
90017688:	24002e20 	.word	0x24002e20
9001768c:	900212cc 	.word	0x900212cc
90017690:	900212e4 	.word	0x900212e4
90017694:	2400a400 	.word	0x2400a400
90017698:	900212f8 	.word	0x900212f8
9001769c:	90021310 	.word	0x90021310
900176a0:	90021324 	.word	0x90021324
900176a4:	9002133c 	.word	0x9002133c
900176a8:	240027f0 	.word	0x240027f0

900176ac <SDRAM_DMA_demo>:
  * @brief  SDRAM DMA Demo
  * @param  None
  * @retval None
  */
void SDRAM_DMA_demo (void)
{
900176ac:	b580      	push	{r7, lr}
900176ae:	b088      	sub	sp, #32
900176b0:	af00      	add	r7, sp, #0

  SDRAM_DMA_SetHint();
900176b2:	f000 f95b 	bl	9001796c <SDRAM_DMA_SetHint>

  /* SDRAM device configuration */
  if(BSP_SDRAM_Init(0) != BSP_ERROR_NONE)
900176b6:	2000      	movs	r0, #0
900176b8:	f7f0 fed6 	bl	90008468 <BSP_SDRAM_Init>
900176bc:	4603      	mov	r3, r0
900176be:	2b00      	cmp	r3, #0
900176c0:	d00c      	beq.n	900176dc <SDRAM_DMA_demo+0x30>
  {
    UTIL_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM Initialization : FAILED.", LEFT_MODE);
900176c2:	2303      	movs	r3, #3
900176c4:	4a66      	ldr	r2, [pc, #408]	; (90017860 <SDRAM_DMA_demo+0x1b4>)
900176c6:	2173      	movs	r1, #115	; 0x73
900176c8:	2014      	movs	r0, #20
900176ca:	f001 f975 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
900176ce:	2303      	movs	r3, #3
900176d0:	4a64      	ldr	r2, [pc, #400]	; (90017864 <SDRAM_DMA_demo+0x1b8>)
900176d2:	2182      	movs	r1, #130	; 0x82
900176d4:	2014      	movs	r0, #20
900176d6:	f001 f96f 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
900176da:	e005      	b.n	900176e8 <SDRAM_DMA_demo+0x3c>
  }
  else
  {
    UTIL_LCD_DisplayStringAt(20, 100, (uint8_t *)"SDRAM Initialization : OK.", LEFT_MODE);
900176dc:	2303      	movs	r3, #3
900176de:	4a62      	ldr	r2, [pc, #392]	; (90017868 <SDRAM_DMA_demo+0x1bc>)
900176e0:	2164      	movs	r1, #100	; 0x64
900176e2:	2014      	movs	r0, #20
900176e4:	f001 f968 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  }
  /* Fill the buffer to write */
  Fill_Buffer(sdram_aTxBuffer, BUFFER_SIZE, 0xA244250F);
900176e8:	4a60      	ldr	r2, [pc, #384]	; (9001786c <SDRAM_DMA_demo+0x1c0>)
900176ea:	f44f 7100 	mov.w	r1, #512	; 0x200
900176ee:	4860      	ldr	r0, [pc, #384]	; (90017870 <SDRAM_DMA_demo+0x1c4>)
900176f0:	f000 f9a2 	bl	90017a38 <Fill_Buffer>
900176f4:	4b5e      	ldr	r3, [pc, #376]	; (90017870 <SDRAM_DMA_demo+0x1c4>)
900176f6:	61fb      	str	r3, [r7, #28]
900176f8:	f44f 6300 	mov.w	r3, #2048	; 0x800
900176fc:	61bb      	str	r3, [r7, #24]
    if ( dsize > 0 ) { 
900176fe:	69bb      	ldr	r3, [r7, #24]
90017700:	2b00      	cmp	r3, #0
90017702:	dd1d      	ble.n	90017740 <SDRAM_DMA_demo+0x94>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
90017704:	69fb      	ldr	r3, [r7, #28]
90017706:	f003 021f 	and.w	r2, r3, #31
9001770a:	69bb      	ldr	r3, [r7, #24]
9001770c:	4413      	add	r3, r2
9001770e:	617b      	str	r3, [r7, #20]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
90017710:	69fb      	ldr	r3, [r7, #28]
90017712:	613b      	str	r3, [r7, #16]
  __ASM volatile ("dsb 0xF":::"memory");
90017714:	f3bf 8f4f 	dsb	sy
}
90017718:	bf00      	nop
        SCB->DCCMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
9001771a:	4a56      	ldr	r2, [pc, #344]	; (90017874 <SDRAM_DMA_demo+0x1c8>)
9001771c:	693b      	ldr	r3, [r7, #16]
9001771e:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
        op_addr += __SCB_DCACHE_LINE_SIZE;
90017722:	693b      	ldr	r3, [r7, #16]
90017724:	3320      	adds	r3, #32
90017726:	613b      	str	r3, [r7, #16]
        op_size -= __SCB_DCACHE_LINE_SIZE;
90017728:	697b      	ldr	r3, [r7, #20]
9001772a:	3b20      	subs	r3, #32
9001772c:	617b      	str	r3, [r7, #20]
      } while ( op_size > 0 );
9001772e:	697b      	ldr	r3, [r7, #20]
90017730:	2b00      	cmp	r3, #0
90017732:	dcf2      	bgt.n	9001771a <SDRAM_DMA_demo+0x6e>
  __ASM volatile ("dsb 0xF":::"memory");
90017734:	f3bf 8f4f 	dsb	sy
}
90017738:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
9001773a:	f3bf 8f6f 	isb	sy
}
9001773e:	bf00      	nop
}
90017740:	bf00      	nop

  /* Clean Data Cache to update the content of the SRAM */
  SCB_CleanDCache_by_Addr((uint32_t*)sdram_aTxBuffer, BUFFER_SIZE*4);

  /* Write data to the SDRAM memory */
  if(HAL_SDRAM_Write_DMA(&hsdram[0], (uint32_t *)(SDRAM_WRITE_READ_ADDR + WRITE_READ_ADDR), sdram_aTxBuffer, BUFFER_SIZE) != BSP_ERROR_NONE)
90017742:	f44f 7300 	mov.w	r3, #512	; 0x200
90017746:	4a4a      	ldr	r2, [pc, #296]	; (90017870 <SDRAM_DMA_demo+0x1c4>)
90017748:	494b      	ldr	r1, [pc, #300]	; (90017878 <SDRAM_DMA_demo+0x1cc>)
9001774a:	484c      	ldr	r0, [pc, #304]	; (9001787c <SDRAM_DMA_demo+0x1d0>)
9001774c:	f7fd f83c 	bl	900147c8 <HAL_SDRAM_Write_DMA>
90017750:	4603      	mov	r3, r0
90017752:	2b00      	cmp	r3, #0
90017754:	d00c      	beq.n	90017770 <SDRAM_DMA_demo+0xc4>
  {
    UTIL_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM WRITE : FAILED.", LEFT_MODE);
90017756:	2303      	movs	r3, #3
90017758:	4a49      	ldr	r2, [pc, #292]	; (90017880 <SDRAM_DMA_demo+0x1d4>)
9001775a:	2173      	movs	r1, #115	; 0x73
9001775c:	2014      	movs	r0, #20
9001775e:	f001 f92b 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
90017762:	2303      	movs	r3, #3
90017764:	4a3f      	ldr	r2, [pc, #252]	; (90017864 <SDRAM_DMA_demo+0x1b8>)
90017766:	2182      	movs	r1, #130	; 0x82
90017768:	2014      	movs	r0, #20
9001776a:	f001 f925 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
9001776e:	e005      	b.n	9001777c <SDRAM_DMA_demo+0xd0>
  }
  else
  {
    UTIL_LCD_DisplayStringAt(20, 115, (uint8_t *)"SDRAM WRITE : OK.", LEFT_MODE);
90017770:	2303      	movs	r3, #3
90017772:	4a44      	ldr	r2, [pc, #272]	; (90017884 <SDRAM_DMA_demo+0x1d8>)
90017774:	2173      	movs	r1, #115	; 0x73
90017776:	2014      	movs	r0, #20
90017778:	f001 f91e 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  }

  /* Read back data from the SDRAM memory */
  if(HAL_SDRAM_Read_DMA(&hsdram[0], (uint32_t *)(SDRAM_WRITE_READ_ADDR + WRITE_READ_ADDR), sdram_aRxBuffer, BUFFER_SIZE) != BSP_ERROR_NONE)
9001777c:	f44f 7300 	mov.w	r3, #512	; 0x200
90017780:	4a41      	ldr	r2, [pc, #260]	; (90017888 <SDRAM_DMA_demo+0x1dc>)
90017782:	493d      	ldr	r1, [pc, #244]	; (90017878 <SDRAM_DMA_demo+0x1cc>)
90017784:	483d      	ldr	r0, [pc, #244]	; (9001787c <SDRAM_DMA_demo+0x1d0>)
90017786:	f7fc ffcb 	bl	90014720 <HAL_SDRAM_Read_DMA>
9001778a:	4603      	mov	r3, r0
9001778c:	2b00      	cmp	r3, #0
9001778e:	d00c      	beq.n	900177aa <SDRAM_DMA_demo+0xfe>
  {
    UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM READ : FAILED.", LEFT_MODE);
90017790:	2303      	movs	r3, #3
90017792:	4a3e      	ldr	r2, [pc, #248]	; (9001788c <SDRAM_DMA_demo+0x1e0>)
90017794:	2182      	movs	r1, #130	; 0x82
90017796:	2014      	movs	r0, #20
90017798:	f001 f90e 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
9001779c:	2303      	movs	r3, #3
9001779e:	4a31      	ldr	r2, [pc, #196]	; (90017864 <SDRAM_DMA_demo+0x1b8>)
900177a0:	2191      	movs	r1, #145	; 0x91
900177a2:	2014      	movs	r0, #20
900177a4:	f001 f908 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
900177a8:	e005      	b.n	900177b6 <SDRAM_DMA_demo+0x10a>
  }
  else
  {
    UTIL_LCD_DisplayStringAt(20, 130, (uint8_t *)"SDRAM READ : OK.", LEFT_MODE);
900177aa:	2303      	movs	r3, #3
900177ac:	4a38      	ldr	r2, [pc, #224]	; (90017890 <SDRAM_DMA_demo+0x1e4>)
900177ae:	2182      	movs	r1, #130	; 0x82
900177b0:	2014      	movs	r0, #20
900177b2:	f001 f901 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
900177b6:	4b34      	ldr	r3, [pc, #208]	; (90017888 <SDRAM_DMA_demo+0x1dc>)
900177b8:	60fb      	str	r3, [r7, #12]
900177ba:	f44f 6300 	mov.w	r3, #2048	; 0x800
900177be:	60bb      	str	r3, [r7, #8]
    if ( dsize > 0 ) { 
900177c0:	68bb      	ldr	r3, [r7, #8]
900177c2:	2b00      	cmp	r3, #0
900177c4:	dd1d      	ble.n	90017802 <SDRAM_DMA_demo+0x156>
       int32_t op_size = dsize + (((uint32_t)addr) & (__SCB_DCACHE_LINE_SIZE - 1U));
900177c6:	68fb      	ldr	r3, [r7, #12]
900177c8:	f003 021f 	and.w	r2, r3, #31
900177cc:	68bb      	ldr	r3, [r7, #8]
900177ce:	4413      	add	r3, r2
900177d0:	607b      	str	r3, [r7, #4]
      uint32_t op_addr = (uint32_t)addr /* & ~(__SCB_DCACHE_LINE_SIZE - 1U) */;
900177d2:	68fb      	ldr	r3, [r7, #12]
900177d4:	603b      	str	r3, [r7, #0]
  __ASM volatile ("dsb 0xF":::"memory");
900177d6:	f3bf 8f4f 	dsb	sy
}
900177da:	bf00      	nop
        SCB->DCIMVAC = op_addr;             /* register accepts only 32byte aligned values, only bits 31..5 are valid */
900177dc:	4a25      	ldr	r2, [pc, #148]	; (90017874 <SDRAM_DMA_demo+0x1c8>)
900177de:	683b      	ldr	r3, [r7, #0]
900177e0:	f8c2 325c 	str.w	r3, [r2, #604]	; 0x25c
        op_addr += __SCB_DCACHE_LINE_SIZE;
900177e4:	683b      	ldr	r3, [r7, #0]
900177e6:	3320      	adds	r3, #32
900177e8:	603b      	str	r3, [r7, #0]
        op_size -= __SCB_DCACHE_LINE_SIZE;
900177ea:	687b      	ldr	r3, [r7, #4]
900177ec:	3b20      	subs	r3, #32
900177ee:	607b      	str	r3, [r7, #4]
      } while ( op_size > 0 );
900177f0:	687b      	ldr	r3, [r7, #4]
900177f2:	2b00      	cmp	r3, #0
900177f4:	dcf2      	bgt.n	900177dc <SDRAM_DMA_demo+0x130>
  __ASM volatile ("dsb 0xF":::"memory");
900177f6:	f3bf 8f4f 	dsb	sy
}
900177fa:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
900177fc:	f3bf 8f6f 	isb	sy
}
90017800:	bf00      	nop
}
90017802:	bf00      	nop
  }

  /* Invalidate Data Cache to get the updated content of the SRAM*/
  SCB_InvalidateDCache_by_Addr((uint32_t *)sdram_aRxBuffer, BUFFER_SIZE*4);

  if(Buffercmp(sdram_aTxBuffer, sdram_aRxBuffer, BUFFER_SIZE) > 0)
90017804:	f44f 7200 	mov.w	r2, #512	; 0x200
90017808:	491f      	ldr	r1, [pc, #124]	; (90017888 <SDRAM_DMA_demo+0x1dc>)
9001780a:	4819      	ldr	r0, [pc, #100]	; (90017870 <SDRAM_DMA_demo+0x1c4>)
9001780c:	f000 f935 	bl	90017a7a <Buffercmp>
90017810:	4603      	mov	r3, r0
90017812:	2b00      	cmp	r3, #0
90017814:	d00f      	beq.n	90017836 <SDRAM_DMA_demo+0x18a>
  {
    UTIL_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM COMPARE : FAILED.", LEFT_MODE);
90017816:	2303      	movs	r3, #3
90017818:	4a1e      	ldr	r2, [pc, #120]	; (90017894 <SDRAM_DMA_demo+0x1e8>)
9001781a:	2191      	movs	r1, #145	; 0x91
9001781c:	2014      	movs	r0, #20
9001781e:	f001 f8cb 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    UTIL_LCD_DisplayStringAt(20, 160, (uint8_t *)"SDRAM Test Aborted.", LEFT_MODE);
90017822:	2303      	movs	r3, #3
90017824:	4a0f      	ldr	r2, [pc, #60]	; (90017864 <SDRAM_DMA_demo+0x1b8>)
90017826:	21a0      	movs	r1, #160	; 0xa0
90017828:	2014      	movs	r0, #20
9001782a:	f001 f8c5 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    BSP_LED_On(LED2);
9001782e:	2001      	movs	r0, #1
90017830:	f7ed faba 	bl	90004da8 <BSP_LED_On>
90017834:	e005      	b.n	90017842 <SDRAM_DMA_demo+0x196>
  }
  else
  {
    UTIL_LCD_DisplayStringAt(20, 145, (uint8_t *)"SDRAM Test : OK.", LEFT_MODE);
90017836:	2303      	movs	r3, #3
90017838:	4a17      	ldr	r2, [pc, #92]	; (90017898 <SDRAM_DMA_demo+0x1ec>)
9001783a:	2191      	movs	r1, #145	; 0x91
9001783c:	2014      	movs	r0, #20
9001783e:	f001 f8bb 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  }

  ButtonState = 0;
90017842:	4b16      	ldr	r3, [pc, #88]	; (9001789c <SDRAM_DMA_demo+0x1f0>)
90017844:	2200      	movs	r2, #0
90017846:	601a      	str	r2, [r3, #0]
  while (1)
  {
    if(CheckForUserInput() > 0)
90017848:	f7ff fc2c 	bl	900170a4 <CheckForUserInput>
9001784c:	4603      	mov	r3, r0
9001784e:	2b00      	cmp	r3, #0
90017850:	d0fa      	beq.n	90017848 <SDRAM_DMA_demo+0x19c>
    {
      ButtonState = 0;
90017852:	4b12      	ldr	r3, [pc, #72]	; (9001789c <SDRAM_DMA_demo+0x1f0>)
90017854:	2200      	movs	r2, #0
90017856:	601a      	str	r2, [r3, #0]

      return;
90017858:	bf00      	nop
    }
  }
}
9001785a:	3720      	adds	r7, #32
9001785c:	46bd      	mov	sp, r7
9001785e:	bd80      	pop	{r7, pc}
90017860:	9002127c 	.word	0x9002127c
90017864:	9002129c 	.word	0x9002129c
90017868:	900212b0 	.word	0x900212b0
9001786c:	a244250f 	.word	0xa244250f
90017870:	2400ac00 	.word	0x2400ac00
90017874:	e000ed00 	.word	0xe000ed00
90017878:	d0177000 	.word	0xd0177000
9001787c:	24002e20 	.word	0x24002e20
90017880:	900212cc 	.word	0x900212cc
90017884:	900212e4 	.word	0x900212e4
90017888:	2400a400 	.word	0x2400a400
9001788c:	900212f8 	.word	0x900212f8
90017890:	90021310 	.word	0x90021310
90017894:	90021324 	.word	0x90021324
90017898:	9002133c 	.word	0x9002133c
9001789c:	240027f0 	.word	0x240027f0

900178a0 <SDRAM_SetHint>:
  * @brief  Display SDRAM Demo Hint
  * @param  None
  * @retval None
  */
static void SDRAM_SetHint(void)
{
900178a0:	b580      	push	{r7, lr}
900178a2:	b084      	sub	sp, #16
900178a4:	af02      	add	r7, sp, #8
  uint32_t x_size, y_size;

  BSP_LCD_GetXSize(0, &x_size);
900178a6:	1d3b      	adds	r3, r7, #4
900178a8:	4619      	mov	r1, r3
900178aa:	2000      	movs	r0, #0
900178ac:	f7ef fed8 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
900178b0:	463b      	mov	r3, r7
900178b2:	4619      	mov	r1, r3
900178b4:	2000      	movs	r0, #0
900178b6:	f7ef fef1 	bl	9000769c <BSP_LCD_GetYSize>

  /* Clear the LCD */
  UTIL_LCD_Clear(UTIL_LCD_COLOR_WHITE);
900178ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900178be:	f001 f82f 	bl	90018920 <UTIL_LCD_Clear>

  /* Set LCD Demo description */
  UTIL_LCD_FillRect(0, 0, x_size, 80, UTIL_LCD_COLOR_BLUE);
900178c2:	687a      	ldr	r2, [r7, #4]
900178c4:	4b23      	ldr	r3, [pc, #140]	; (90017954 <SDRAM_SetHint+0xb4>)
900178c6:	9300      	str	r3, [sp, #0]
900178c8:	2350      	movs	r3, #80	; 0x50
900178ca:	2100      	movs	r1, #0
900178cc:	2000      	movs	r0, #0
900178ce:	f001 fc4d 	bl	9001916c <UTIL_LCD_FillRect>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
900178d2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900178d6:	f000 ff1b 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
900178da:	481e      	ldr	r0, [pc, #120]	; (90017954 <SDRAM_SetHint+0xb4>)
900178dc:	f000 ff2c 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_SetFont(&Font24);
900178e0:	481d      	ldr	r0, [pc, #116]	; (90017958 <SDRAM_SetHint+0xb8>)
900178e2:	f000 ff3d 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, 0, (uint8_t *)"SDRAM", CENTER_MODE);
900178e6:	2301      	movs	r3, #1
900178e8:	4a1c      	ldr	r2, [pc, #112]	; (9001795c <SDRAM_SetHint+0xbc>)
900178ea:	2100      	movs	r1, #0
900178ec:	2000      	movs	r0, #0
900178ee:	f001 f863 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_SetFont(&Font12);
900178f2:	481b      	ldr	r0, [pc, #108]	; (90017960 <SDRAM_SetHint+0xc0>)
900178f4:	f000 ff34 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, 30, (uint8_t *)"This example shows how to write", CENTER_MODE);
900178f8:	2301      	movs	r3, #1
900178fa:	4a1a      	ldr	r2, [pc, #104]	; (90017964 <SDRAM_SetHint+0xc4>)
900178fc:	211e      	movs	r1, #30
900178fe:	2000      	movs	r0, #0
90017900:	f001 f85a 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_DisplayStringAt(0, 45, (uint8_t *)"and read data on SDRAM", CENTER_MODE);
90017904:	2301      	movs	r3, #1
90017906:	4a18      	ldr	r2, [pc, #96]	; (90017968 <SDRAM_SetHint+0xc8>)
90017908:	212d      	movs	r1, #45	; 0x2d
9001790a:	2000      	movs	r0, #0
9001790c:	f001 f854 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

   /* Set the LCD Text Color */
  UTIL_LCD_DrawRect(10, 90, x_size - 20, y_size- 100, UTIL_LCD_COLOR_BLUE);
90017910:	687b      	ldr	r3, [r7, #4]
90017912:	f1a3 0214 	sub.w	r2, r3, #20
90017916:	683b      	ldr	r3, [r7, #0]
90017918:	3b64      	subs	r3, #100	; 0x64
9001791a:	490e      	ldr	r1, [pc, #56]	; (90017954 <SDRAM_SetHint+0xb4>)
9001791c:	9100      	str	r1, [sp, #0]
9001791e:	215a      	movs	r1, #90	; 0x5a
90017920:	200a      	movs	r0, #10
90017922:	f001 f9b3 	bl	90018c8c <UTIL_LCD_DrawRect>
  UTIL_LCD_DrawRect(11, 91, x_size - 22, y_size- 102, UTIL_LCD_COLOR_BLUE);
90017926:	687b      	ldr	r3, [r7, #4]
90017928:	f1a3 0216 	sub.w	r2, r3, #22
9001792c:	683b      	ldr	r3, [r7, #0]
9001792e:	3b66      	subs	r3, #102	; 0x66
90017930:	4908      	ldr	r1, [pc, #32]	; (90017954 <SDRAM_SetHint+0xb4>)
90017932:	9100      	str	r1, [sp, #0]
90017934:	215b      	movs	r1, #91	; 0x5b
90017936:	200b      	movs	r0, #11
90017938:	f001 f9a8 	bl	90018c8c <UTIL_LCD_DrawRect>

  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLACK);
9001793c:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
90017940:	f000 fee6 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
90017944:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90017948:	f000 fef6 	bl	90018738 <UTIL_LCD_SetBackColor>
 }
9001794c:	bf00      	nop
9001794e:	3708      	adds	r7, #8
90017950:	46bd      	mov	sp, r7
90017952:	bd80      	pop	{r7, pc}
90017954:	ff0000ff 	.word	0xff0000ff
90017958:	24000388 	.word	0x24000388
9001795c:	90021350 	.word	0x90021350
90017960:	240003a0 	.word	0x240003a0
90017964:	90021358 	.word	0x90021358
90017968:	90021378 	.word	0x90021378

9001796c <SDRAM_DMA_SetHint>:
  * @brief  Display SDRAM DMA Demo Hint
  * @param  None
  * @retval None
  */
static void SDRAM_DMA_SetHint(void)
{
9001796c:	b580      	push	{r7, lr}
9001796e:	b084      	sub	sp, #16
90017970:	af02      	add	r7, sp, #8
  uint32_t x_size, y_size;

  BSP_LCD_GetXSize(0, &x_size);
90017972:	1d3b      	adds	r3, r7, #4
90017974:	4619      	mov	r1, r3
90017976:	2000      	movs	r0, #0
90017978:	f7ef fe72 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
9001797c:	463b      	mov	r3, r7
9001797e:	4619      	mov	r1, r3
90017980:	2000      	movs	r0, #0
90017982:	f7ef fe8b 	bl	9000769c <BSP_LCD_GetYSize>

  /* Clear the LCD */
  UTIL_LCD_Clear(UTIL_LCD_COLOR_WHITE);
90017986:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
9001798a:	f000 ffc9 	bl	90018920 <UTIL_LCD_Clear>

  /* Set LCD Demo description */
  UTIL_LCD_FillRect(0, 0, x_size, 80, UTIL_LCD_COLOR_BLUE);
9001798e:	687a      	ldr	r2, [r7, #4]
90017990:	4b23      	ldr	r3, [pc, #140]	; (90017a20 <SDRAM_DMA_SetHint+0xb4>)
90017992:	9300      	str	r3, [sp, #0]
90017994:	2350      	movs	r3, #80	; 0x50
90017996:	2100      	movs	r1, #0
90017998:	2000      	movs	r0, #0
9001799a:	f001 fbe7 	bl	9001916c <UTIL_LCD_FillRect>
  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
9001799e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900179a2:	f000 feb5 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
900179a6:	481e      	ldr	r0, [pc, #120]	; (90017a20 <SDRAM_DMA_SetHint+0xb4>)
900179a8:	f000 fec6 	bl	90018738 <UTIL_LCD_SetBackColor>
  UTIL_LCD_SetFont(&Font24);
900179ac:	481d      	ldr	r0, [pc, #116]	; (90017a24 <SDRAM_DMA_SetHint+0xb8>)
900179ae:	f000 fed7 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, 0, (uint8_t *)"SDRAM DMA", CENTER_MODE);
900179b2:	2301      	movs	r3, #1
900179b4:	4a1c      	ldr	r2, [pc, #112]	; (90017a28 <SDRAM_DMA_SetHint+0xbc>)
900179b6:	2100      	movs	r1, #0
900179b8:	2000      	movs	r0, #0
900179ba:	f000 fffd 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_SetFont(&Font12);
900179be:	481b      	ldr	r0, [pc, #108]	; (90017a2c <SDRAM_DMA_SetHint+0xc0>)
900179c0:	f000 fece 	bl	90018760 <UTIL_LCD_SetFont>
  UTIL_LCD_DisplayStringAt(0, 30, (uint8_t *)"This example shows how to write", CENTER_MODE);
900179c4:	2301      	movs	r3, #1
900179c6:	4a1a      	ldr	r2, [pc, #104]	; (90017a30 <SDRAM_DMA_SetHint+0xc4>)
900179c8:	211e      	movs	r1, #30
900179ca:	2000      	movs	r0, #0
900179cc:	f000 fff4 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
  UTIL_LCD_DisplayStringAt(0, 45, (uint8_t *)"and read data on SDRAM in DMA mode", CENTER_MODE);
900179d0:	2301      	movs	r3, #1
900179d2:	4a18      	ldr	r2, [pc, #96]	; (90017a34 <SDRAM_DMA_SetHint+0xc8>)
900179d4:	212d      	movs	r1, #45	; 0x2d
900179d6:	2000      	movs	r0, #0
900179d8:	f000 ffee 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

   /* Set the LCD Text Color */
  UTIL_LCD_DrawRect(10, 90, x_size - 20, y_size- 100, UTIL_LCD_COLOR_BLUE);
900179dc:	687b      	ldr	r3, [r7, #4]
900179de:	f1a3 0214 	sub.w	r2, r3, #20
900179e2:	683b      	ldr	r3, [r7, #0]
900179e4:	3b64      	subs	r3, #100	; 0x64
900179e6:	490e      	ldr	r1, [pc, #56]	; (90017a20 <SDRAM_DMA_SetHint+0xb4>)
900179e8:	9100      	str	r1, [sp, #0]
900179ea:	215a      	movs	r1, #90	; 0x5a
900179ec:	200a      	movs	r0, #10
900179ee:	f001 f94d 	bl	90018c8c <UTIL_LCD_DrawRect>
  UTIL_LCD_DrawRect(11, 91, x_size - 22, y_size- 102, UTIL_LCD_COLOR_BLUE);
900179f2:	687b      	ldr	r3, [r7, #4]
900179f4:	f1a3 0216 	sub.w	r2, r3, #22
900179f8:	683b      	ldr	r3, [r7, #0]
900179fa:	3b66      	subs	r3, #102	; 0x66
900179fc:	4908      	ldr	r1, [pc, #32]	; (90017a20 <SDRAM_DMA_SetHint+0xb4>)
900179fe:	9100      	str	r1, [sp, #0]
90017a00:	215b      	movs	r1, #91	; 0x5b
90017a02:	200b      	movs	r0, #11
90017a04:	f001 f942 	bl	90018c8c <UTIL_LCD_DrawRect>

  UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLACK);
90017a08:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
90017a0c:	f000 fe80 	bl	90018710 <UTIL_LCD_SetTextColor>
  UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
90017a10:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90017a14:	f000 fe90 	bl	90018738 <UTIL_LCD_SetBackColor>
 }
90017a18:	bf00      	nop
90017a1a:	3708      	adds	r7, #8
90017a1c:	46bd      	mov	sp, r7
90017a1e:	bd80      	pop	{r7, pc}
90017a20:	ff0000ff 	.word	0xff0000ff
90017a24:	24000388 	.word	0x24000388
90017a28:	90021390 	.word	0x90021390
90017a2c:	240003a0 	.word	0x240003a0
90017a30:	90021358 	.word	0x90021358
90017a34:	9002139c 	.word	0x9002139c

90017a38 <Fill_Buffer>:
  * @param  uwBufferLenght: size of the buffer to fill
  * @param  uwOffset: first value to fill on the buffer
  * @retval None
  */
static void Fill_Buffer(uint32_t *pBuffer, uint32_t uwBufferLenght, uint32_t uwOffset)
{
90017a38:	b480      	push	{r7}
90017a3a:	b087      	sub	sp, #28
90017a3c:	af00      	add	r7, sp, #0
90017a3e:	60f8      	str	r0, [r7, #12]
90017a40:	60b9      	str	r1, [r7, #8]
90017a42:	607a      	str	r2, [r7, #4]
  uint32_t tmpIndex = 0;
90017a44:	2300      	movs	r3, #0
90017a46:	617b      	str	r3, [r7, #20]

  /* Put in global buffer different values */
  for (tmpIndex = 0; tmpIndex < uwBufferLenght; tmpIndex++ )
90017a48:	2300      	movs	r3, #0
90017a4a:	617b      	str	r3, [r7, #20]
90017a4c:	e00a      	b.n	90017a64 <Fill_Buffer+0x2c>
  {
    pBuffer[tmpIndex] = tmpIndex + uwOffset;
90017a4e:	697b      	ldr	r3, [r7, #20]
90017a50:	009b      	lsls	r3, r3, #2
90017a52:	68fa      	ldr	r2, [r7, #12]
90017a54:	4413      	add	r3, r2
90017a56:	6979      	ldr	r1, [r7, #20]
90017a58:	687a      	ldr	r2, [r7, #4]
90017a5a:	440a      	add	r2, r1
90017a5c:	601a      	str	r2, [r3, #0]
  for (tmpIndex = 0; tmpIndex < uwBufferLenght; tmpIndex++ )
90017a5e:	697b      	ldr	r3, [r7, #20]
90017a60:	3301      	adds	r3, #1
90017a62:	617b      	str	r3, [r7, #20]
90017a64:	697a      	ldr	r2, [r7, #20]
90017a66:	68bb      	ldr	r3, [r7, #8]
90017a68:	429a      	cmp	r2, r3
90017a6a:	d3f0      	bcc.n	90017a4e <Fill_Buffer+0x16>
  }
}
90017a6c:	bf00      	nop
90017a6e:	bf00      	nop
90017a70:	371c      	adds	r7, #28
90017a72:	46bd      	mov	sp, r7
90017a74:	f85d 7b04 	ldr.w	r7, [sp], #4
90017a78:	4770      	bx	lr

90017a7a <Buffercmp>:
  * @param  BufferLength: buffer's length
  * @retval 1: pBuffer identical to pBuffer1
  *         0: pBuffer differs from pBuffer1
  */
static uint8_t Buffercmp(uint32_t* pBuffer1, uint32_t* pBuffer2, uint16_t BufferLength)
{
90017a7a:	b480      	push	{r7}
90017a7c:	b085      	sub	sp, #20
90017a7e:	af00      	add	r7, sp, #0
90017a80:	60f8      	str	r0, [r7, #12]
90017a82:	60b9      	str	r1, [r7, #8]
90017a84:	4613      	mov	r3, r2
90017a86:	80fb      	strh	r3, [r7, #6]
  while (BufferLength--)
90017a88:	e00d      	b.n	90017aa6 <Buffercmp+0x2c>
  {
    if (*pBuffer1 != *pBuffer2)
90017a8a:	68fb      	ldr	r3, [r7, #12]
90017a8c:	681a      	ldr	r2, [r3, #0]
90017a8e:	68bb      	ldr	r3, [r7, #8]
90017a90:	681b      	ldr	r3, [r3, #0]
90017a92:	429a      	cmp	r2, r3
90017a94:	d001      	beq.n	90017a9a <Buffercmp+0x20>
    {
      return 1;
90017a96:	2301      	movs	r3, #1
90017a98:	e00b      	b.n	90017ab2 <Buffercmp+0x38>
    }

    pBuffer1++;
90017a9a:	68fb      	ldr	r3, [r7, #12]
90017a9c:	3304      	adds	r3, #4
90017a9e:	60fb      	str	r3, [r7, #12]
    pBuffer2++;
90017aa0:	68bb      	ldr	r3, [r7, #8]
90017aa2:	3304      	adds	r3, #4
90017aa4:	60bb      	str	r3, [r7, #8]
  while (BufferLength--)
90017aa6:	88fb      	ldrh	r3, [r7, #6]
90017aa8:	1e5a      	subs	r2, r3, #1
90017aaa:	80fa      	strh	r2, [r7, #6]
90017aac:	2b00      	cmp	r3, #0
90017aae:	d1ec      	bne.n	90017a8a <Buffercmp+0x10>
  }

  return 0;
90017ab0:	2300      	movs	r3, #0
}
90017ab2:	4618      	mov	r0, r3
90017ab4:	3714      	adds	r7, #20
90017ab6:	46bd      	mov	sp, r7
90017ab8:	f85d 7b04 	ldr.w	r7, [sp], #4
90017abc:	4770      	bx	lr

90017abe <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
90017abe:	b480      	push	{r7}
90017ac0:	af00      	add	r7, sp, #0
}
90017ac2:	bf00      	nop
90017ac4:	46bd      	mov	sp, r7
90017ac6:	f85d 7b04 	ldr.w	r7, [sp], #4
90017aca:	4770      	bx	lr

90017acc <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
90017acc:	b480      	push	{r7}
90017ace:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
90017ad0:	e7fe      	b.n	90017ad0 <HardFault_Handler+0x4>

90017ad2 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
90017ad2:	b480      	push	{r7}
90017ad4:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
90017ad6:	e7fe      	b.n	90017ad6 <MemManage_Handler+0x4>

90017ad8 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
90017ad8:	b480      	push	{r7}
90017ada:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
90017adc:	e7fe      	b.n	90017adc <BusFault_Handler+0x4>

90017ade <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
90017ade:	b480      	push	{r7}
90017ae0:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
90017ae2:	e7fe      	b.n	90017ae2 <UsageFault_Handler+0x4>

90017ae4 <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
90017ae4:	b480      	push	{r7}
90017ae6:	af00      	add	r7, sp, #0
}
90017ae8:	bf00      	nop
90017aea:	46bd      	mov	sp, r7
90017aec:	f85d 7b04 	ldr.w	r7, [sp], #4
90017af0:	4770      	bx	lr

90017af2 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
90017af2:	b480      	push	{r7}
90017af4:	af00      	add	r7, sp, #0
}
90017af6:	bf00      	nop
90017af8:	46bd      	mov	sp, r7
90017afa:	f85d 7b04 	ldr.w	r7, [sp], #4
90017afe:	4770      	bx	lr

90017b00 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
90017b00:	b480      	push	{r7}
90017b02:	af00      	add	r7, sp, #0
}
90017b04:	bf00      	nop
90017b06:	46bd      	mov	sp, r7
90017b08:	f85d 7b04 	ldr.w	r7, [sp], #4
90017b0c:	4770      	bx	lr

90017b0e <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
90017b0e:	b580      	push	{r7, lr}
90017b10:	af00      	add	r7, sp, #0
  HAL_IncTick();
90017b12:	f7f1 fc43 	bl	9000939c <HAL_IncTick>
}
90017b16:	bf00      	nop
90017b18:	bd80      	pop	{r7, pc}

90017b1a <EXTI15_10_IRQHandler>:
  * @brief  This function handles External lines 15 to 10 interrupt request.
  * @param  None
  * @retval None
  */
void EXTI15_10_IRQHandler(void)
{
90017b1a:	b580      	push	{r7, lr}
90017b1c:	af00      	add	r7, sp, #0
BSP_PB_IRQHandler(BUTTON_USER);
90017b1e:	2000      	movs	r0, #0
90017b20:	f7ed f9e8 	bl	90004ef4 <BSP_PB_IRQHandler>
}
90017b24:	bf00      	nop
90017b26:	bd80      	pop	{r7, pc}

90017b28 <DMA2_Stream1_IRQHandler>:
  * @brief  This function handles DMA2 Stream 1 interrupt request.
  * @param  None
  * @retval None
  */
void AUDIO_OUT_SAIx_DMAx_IRQHandler(void)
{
90017b28:	b580      	push	{r7, lr}
90017b2a:	af00      	add	r7, sp, #0
  BSP_AUDIO_OUT_IRQHandler(0);
90017b2c:	2000      	movs	r0, #0
90017b2e:	f7ed fe9f 	bl	90005870 <BSP_AUDIO_OUT_IRQHandler>
}
90017b32:	bf00      	nop
90017b34:	bd80      	pop	{r7, pc}
	...

90017b38 <DMA2_Stream4_IRQHandler>:
  * @brief  This function handles DMA2 Stream 4 for SAI1B interrupt request.
  * @param  None
  * @retval None
  */
void AUDIO_IN_SAIx_DMAx_IRQHandler(void)
{
90017b38:	b580      	push	{r7, lr}
90017b3a:	af00      	add	r7, sp, #0
  HAL_DMA_IRQHandler(haudio_in_sai.hdmarx);
90017b3c:	4b03      	ldr	r3, [pc, #12]	; (90017b4c <DMA2_Stream4_IRQHandler+0x14>)
90017b3e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
90017b42:	4618      	mov	r0, r3
90017b44:	f7f3 f8e2 	bl	9000ad0c <HAL_DMA_IRQHandler>
}
90017b48:	bf00      	nop
90017b4a:	bd80      	pop	{r7, pc}
90017b4c:	24002914 	.word	0x24002914

90017b50 <BDMA_Channel1_IRQHandler>:
  * @brief  This function handles BDMA Channel 1 for SAI_PDM interrupt request.
  * @param  None
  * @retval None
  */
void AUDIO_IN_SAI_PDMx_DMAx_IRQHandler(void)
{
90017b50:	b580      	push	{r7, lr}
90017b52:	af00      	add	r7, sp, #0
   BSP_AUDIO_IN_IRQHandler(1, AUDIO_IN_DEVICE_DIGITAL_MIC);
90017b54:	2130      	movs	r1, #48	; 0x30
90017b56:	2001      	movs	r0, #1
90017b58:	f7ee fb44 	bl	900061e4 <BSP_AUDIO_IN_IRQHandler>

}
90017b5c:	bf00      	nop
90017b5e:	bd80      	pop	{r7, pc}

90017b60 <MDMA_IRQHandler>:
/**
  * @brief  Handles MDMA transfer interrupt request.
  * @retval None
  */
void MDMA_IRQHandler(void)
{
90017b60:	b580      	push	{r7, lr}
90017b62:	af00      	add	r7, sp, #0
  BSP_SDRAM_IRQHandler(0);
90017b64:	2000      	movs	r0, #0
90017b66:	f7f0 fd4d 	bl	90008604 <BSP_SDRAM_IRQHandler>
}
90017b6a:	bf00      	nop
90017b6c:	bd80      	pop	{r7, pc}
	...

90017b70 <Touchscreen_demo1>:
  * @brief  Touchscreen Demo1 : test touchscreen calibration and single touch in polling mode
  * @param  None
  * @retval None
  */
void Touchscreen_demo1(void)
{
90017b70:	b580      	push	{r7, lr}
90017b72:	b086      	sub	sp, #24
90017b74:	af00      	add	r7, sp, #0
  uint16_t x1, y1;
  uint8_t state = 0;
90017b76:	2300      	movs	r3, #0
90017b78:	75fb      	strb	r3, [r7, #23]
  uint32_t ts_status = BSP_ERROR_NONE;
90017b7a:	2300      	movs	r3, #0
90017b7c:	613b      	str	r3, [r7, #16]
  uint32_t x_size, y_size;

  BSP_LCD_GetXSize(0, &x_size);
90017b7e:	f107 0308 	add.w	r3, r7, #8
90017b82:	4619      	mov	r1, r3
90017b84:	2000      	movs	r0, #0
90017b86:	f7ef fd6b 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
90017b8a:	1d3b      	adds	r3, r7, #4
90017b8c:	4619      	mov	r1, r3
90017b8e:	2000      	movs	r0, #0
90017b90:	f7ef fd84 	bl	9000769c <BSP_LCD_GetYSize>
 ButtonState = 0;
90017b94:	4b55      	ldr	r3, [pc, #340]	; (90017cec <Touchscreen_demo1+0x17c>)
90017b96:	2200      	movs	r2, #0
90017b98:	601a      	str	r2, [r3, #0]

  hTS.Width = x_size;
90017b9a:	68bb      	ldr	r3, [r7, #8]
90017b9c:	4a54      	ldr	r2, [pc, #336]	; (90017cf0 <Touchscreen_demo1+0x180>)
90017b9e:	6013      	str	r3, [r2, #0]
  hTS.Height = y_size;
90017ba0:	687b      	ldr	r3, [r7, #4]
90017ba2:	4a53      	ldr	r2, [pc, #332]	; (90017cf0 <Touchscreen_demo1+0x180>)
90017ba4:	6053      	str	r3, [r2, #4]
  hTS.Orientation =TS_SWAP_XY ;
90017ba6:	4b52      	ldr	r3, [pc, #328]	; (90017cf0 <Touchscreen_demo1+0x180>)
90017ba8:	2208      	movs	r2, #8
90017baa:	609a      	str	r2, [r3, #8]
  hTS.Accuracy = 5;
90017bac:	4b50      	ldr	r3, [pc, #320]	; (90017cf0 <Touchscreen_demo1+0x180>)
90017bae:	2205      	movs	r2, #5
90017bb0:	60da      	str	r2, [r3, #12]

  /* Touchscreen initialization */
  ts_status = BSP_TS_Init(0, &hTS);
90017bb2:	494f      	ldr	r1, [pc, #316]	; (90017cf0 <Touchscreen_demo1+0x180>)
90017bb4:	2000      	movs	r0, #0
90017bb6:	f7f0 fe4f 	bl	90008858 <BSP_TS_Init>
90017bba:	4603      	mov	r3, r0
90017bbc:	613b      	str	r3, [r7, #16]

  if(ts_status == BSP_ERROR_NONE)
90017bbe:	693b      	ldr	r3, [r7, #16]
90017bc0:	2b00      	cmp	r3, #0
90017bc2:	f040 8090 	bne.w	90017ce6 <Touchscreen_demo1+0x176>
  {
    /* Display touch screen demo description */
    Touchscreen_SetHint_Demo(TOUCHSCREEN_DEMO_1);
90017bc6:	2001      	movs	r0, #1
90017bc8:	f000 fa70 	bl	900180ac <Touchscreen_SetHint_Demo>
    Touchscreen_DrawBackground_Circles(state);
90017bcc:	7dfb      	ldrb	r3, [r7, #23]
90017bce:	4618      	mov	r0, r3
90017bd0:	f000 fb22 	bl	90018218 <Touchscreen_DrawBackground_Circles>

    while (1)
    {
      /* Check in polling mode in touch screen the touch status and coordinates */
      /* of touches if touch occurred                                           */
      ts_status = BSP_TS_GetState(0, &TS_State);
90017bd4:	4947      	ldr	r1, [pc, #284]	; (90017cf4 <Touchscreen_demo1+0x184>)
90017bd6:	2000      	movs	r0, #0
90017bd8:	f7f0 ff0a 	bl	900089f0 <BSP_TS_GetState>
90017bdc:	4603      	mov	r3, r0
90017bde:	613b      	str	r3, [r7, #16]
      if(TS_State.TouchDetected)
90017be0:	4b44      	ldr	r3, [pc, #272]	; (90017cf4 <Touchscreen_demo1+0x184>)
90017be2:	681b      	ldr	r3, [r3, #0]
90017be4:	2b00      	cmp	r3, #0
90017be6:	d06e      	beq.n	90017cc6 <Touchscreen_demo1+0x156>
      {
        /* One or dual touch have been detected          */
        /* Only take into account the first touch so far */

        /* Get X and Y position of the first touch post calibrated */
        x1 = TS_State.TouchX;
90017be8:	4b42      	ldr	r3, [pc, #264]	; (90017cf4 <Touchscreen_demo1+0x184>)
90017bea:	685b      	ldr	r3, [r3, #4]
90017bec:	81fb      	strh	r3, [r7, #14]
        y1 = TS_State.TouchY;
90017bee:	4b41      	ldr	r3, [pc, #260]	; (90017cf4 <Touchscreen_demo1+0x184>)
90017bf0:	689b      	ldr	r3, [r3, #8]
90017bf2:	81bb      	strh	r3, [r7, #12]

        if ((y1 > (CIRCLE_YPOS(1) - CIRCLE_RADIUS)) &&
90017bf4:	89bb      	ldrh	r3, [r7, #12]
90017bf6:	2b84      	cmp	r3, #132	; 0x84
90017bf8:	d965      	bls.n	90017cc6 <Touchscreen_demo1+0x156>
90017bfa:	89bb      	ldrh	r3, [r7, #12]
90017bfc:	2bd3      	cmp	r3, #211	; 0xd3
90017bfe:	d862      	bhi.n	90017cc6 <Touchscreen_demo1+0x156>
            (y1 < (CIRCLE_YPOS(1) + CIRCLE_RADIUS)))
        {
          if ((x1 > (CIRCLE_XPOS(1) - CIRCLE_RADIUS)) &&
90017c00:	89fb      	ldrh	r3, [r7, #14]
90017c02:	2b38      	cmp	r3, #56	; 0x38
90017c04:	d913      	bls.n	90017c2e <Touchscreen_demo1+0xbe>
90017c06:	89fb      	ldrh	r3, [r7, #14]
90017c08:	2b87      	cmp	r3, #135	; 0x87
90017c0a:	d810      	bhi.n	90017c2e <Touchscreen_demo1+0xbe>
              (x1 < (CIRCLE_XPOS(1) + CIRCLE_RADIUS)))
          {
            if ((state & 1) == 0)
90017c0c:	7dfb      	ldrb	r3, [r7, #23]
90017c0e:	f003 0301 	and.w	r3, r3, #1
90017c12:	2b00      	cmp	r3, #0
90017c14:	d10b      	bne.n	90017c2e <Touchscreen_demo1+0xbe>
            {
              Touchscreen_DrawBackground_Circles(state);
90017c16:	7dfb      	ldrb	r3, [r7, #23]
90017c18:	4618      	mov	r0, r3
90017c1a:	f000 fafd 	bl	90018218 <Touchscreen_DrawBackground_Circles>
              UTIL_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLUE);
90017c1e:	4b36      	ldr	r3, [pc, #216]	; (90017cf8 <Touchscreen_demo1+0x188>)
90017c20:	2228      	movs	r2, #40	; 0x28
90017c22:	21ac      	movs	r1, #172	; 0xac
90017c24:	2060      	movs	r0, #96	; 0x60
90017c26:	f001 fadb 	bl	900191e0 <UTIL_LCD_FillCircle>
              state = 1;
90017c2a:	2301      	movs	r3, #1
90017c2c:	75fb      	strb	r3, [r7, #23]
            }
          }
          if ((x1 > (CIRCLE_XPOS(2) - CIRCLE_RADIUS)) &&
90017c2e:	89fb      	ldrh	r3, [r7, #14]
90017c30:	2b98      	cmp	r3, #152	; 0x98
90017c32:	d913      	bls.n	90017c5c <Touchscreen_demo1+0xec>
90017c34:	89fb      	ldrh	r3, [r7, #14]
90017c36:	2be7      	cmp	r3, #231	; 0xe7
90017c38:	d810      	bhi.n	90017c5c <Touchscreen_demo1+0xec>
              (x1 < (CIRCLE_XPOS(2) + CIRCLE_RADIUS)))
          {
            if ((state & 2) == 0)
90017c3a:	7dfb      	ldrb	r3, [r7, #23]
90017c3c:	f003 0302 	and.w	r3, r3, #2
90017c40:	2b00      	cmp	r3, #0
90017c42:	d10b      	bne.n	90017c5c <Touchscreen_demo1+0xec>
            {
              Touchscreen_DrawBackground_Circles(state);
90017c44:	7dfb      	ldrb	r3, [r7, #23]
90017c46:	4618      	mov	r0, r3
90017c48:	f000 fae6 	bl	90018218 <Touchscreen_DrawBackground_Circles>
              UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS, UTIL_LCD_COLOR_RED);
90017c4c:	4b2b      	ldr	r3, [pc, #172]	; (90017cfc <Touchscreen_demo1+0x18c>)
90017c4e:	2228      	movs	r2, #40	; 0x28
90017c50:	21ac      	movs	r1, #172	; 0xac
90017c52:	20c0      	movs	r0, #192	; 0xc0
90017c54:	f001 fac4 	bl	900191e0 <UTIL_LCD_FillCircle>
              state = 2;
90017c58:	2302      	movs	r3, #2
90017c5a:	75fb      	strb	r3, [r7, #23]
            }
          }

          if ((x1 > (CIRCLE_XPOS(3) - CIRCLE_RADIUS)) &&
90017c5c:	89fb      	ldrh	r3, [r7, #14]
90017c5e:	2bf8      	cmp	r3, #248	; 0xf8
90017c60:	d916      	bls.n	90017c90 <Touchscreen_demo1+0x120>
90017c62:	89fb      	ldrh	r3, [r7, #14]
90017c64:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
90017c68:	d212      	bcs.n	90017c90 <Touchscreen_demo1+0x120>
              (x1 < (CIRCLE_XPOS(3) + CIRCLE_RADIUS)))
          {
            if ((state & 4) == 0)
90017c6a:	7dfb      	ldrb	r3, [r7, #23]
90017c6c:	f003 0304 	and.w	r3, r3, #4
90017c70:	2b00      	cmp	r3, #0
90017c72:	d10d      	bne.n	90017c90 <Touchscreen_demo1+0x120>
            {
              Touchscreen_DrawBackground_Circles(state);
90017c74:	7dfb      	ldrb	r3, [r7, #23]
90017c76:	4618      	mov	r0, r3
90017c78:	f000 face 	bl	90018218 <Touchscreen_DrawBackground_Circles>
              UTIL_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS, UTIL_LCD_COLOR_YELLOW);
90017c7c:	f06f 03ff 	mvn.w	r3, #255	; 0xff
90017c80:	2228      	movs	r2, #40	; 0x28
90017c82:	21ac      	movs	r1, #172	; 0xac
90017c84:	f44f 7090 	mov.w	r0, #288	; 0x120
90017c88:	f001 faaa 	bl	900191e0 <UTIL_LCD_FillCircle>
              state = 4;
90017c8c:	2304      	movs	r3, #4
90017c8e:	75fb      	strb	r3, [r7, #23]
            }
          }

          if ((x1 > (CIRCLE_XPOS(4) - CIRCLE_RADIUS)) &&
90017c90:	89fb      	ldrh	r3, [r7, #14]
90017c92:	f5b3 7fac 	cmp.w	r3, #344	; 0x158
90017c96:	d916      	bls.n	90017cc6 <Touchscreen_demo1+0x156>
90017c98:	89fb      	ldrh	r3, [r7, #14]
90017c9a:	f5b3 7fd4 	cmp.w	r3, #424	; 0x1a8
90017c9e:	d212      	bcs.n	90017cc6 <Touchscreen_demo1+0x156>
              (x1 < (CIRCLE_XPOS(4) + CIRCLE_RADIUS)))
          {
            if ((state & 8) == 0)
90017ca0:	7dfb      	ldrb	r3, [r7, #23]
90017ca2:	f003 0308 	and.w	r3, r3, #8
90017ca6:	2b00      	cmp	r3, #0
90017ca8:	d10d      	bne.n	90017cc6 <Touchscreen_demo1+0x156>
            {
              Touchscreen_DrawBackground_Circles(state);
90017caa:	7dfb      	ldrb	r3, [r7, #23]
90017cac:	4618      	mov	r0, r3
90017cae:	f000 fab3 	bl	90018218 <Touchscreen_DrawBackground_Circles>
              UTIL_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), CIRCLE_RADIUS, UTIL_LCD_COLOR_GREEN);
90017cb2:	f04f 23ff 	mov.w	r3, #4278255360	; 0xff00ff00
90017cb6:	2228      	movs	r2, #40	; 0x28
90017cb8:	21ac      	movs	r1, #172	; 0xac
90017cba:	f44f 70c0 	mov.w	r0, #384	; 0x180
90017cbe:	f001 fa8f 	bl	900191e0 <UTIL_LCD_FillCircle>
              state = 8;
90017cc2:	2308      	movs	r3, #8
90017cc4:	75fb      	strb	r3, [r7, #23]
          }
        }

      } /* of if(TS_State.TouchDetected) */

      if(CheckForUserInput() > 0)
90017cc6:	f7ff f9ed 	bl	900170a4 <CheckForUserInput>
90017cca:	4603      	mov	r3, r0
90017ccc:	2b00      	cmp	r3, #0
90017cce:	d006      	beq.n	90017cde <Touchscreen_demo1+0x16e>
      {
        BSP_TS_DeInit(0);
90017cd0:	2000      	movs	r0, #0
90017cd2:	f7f0 fe67 	bl	900089a4 <BSP_TS_DeInit>

        ButtonState = 0;
90017cd6:	4b05      	ldr	r3, [pc, #20]	; (90017cec <Touchscreen_demo1+0x17c>)
90017cd8:	2200      	movs	r2, #0
90017cda:	601a      	str	r2, [r3, #0]
90017cdc:	e003      	b.n	90017ce6 <Touchscreen_demo1+0x176>
        return;
      }

      HAL_Delay(20);
90017cde:	2014      	movs	r0, #20
90017ce0:	f7f1 fb7c 	bl	900093dc <HAL_Delay>
      ts_status = BSP_TS_GetState(0, &TS_State);
90017ce4:	e776      	b.n	90017bd4 <Touchscreen_demo1+0x64>
    }
  } /* of if(status == BSP_ERROR_NONE) */
}
90017ce6:	3718      	adds	r7, #24
90017ce8:	46bd      	mov	sp, r7
90017cea:	bd80      	pop	{r7, pc}
90017cec:	240027f0 	.word	0x240027f0
90017cf0:	2400b418 	.word	0x2400b418
90017cf4:	2400b428 	.word	0x2400b428
90017cf8:	ff0000ff 	.word	0xff0000ff
90017cfc:	ffff0000 	.word	0xffff0000

90017d00 <Touchscreen_demo2>:
  * @brief  Touchscreen Demo2 : test touchscreen single and dual touch in polling mode
  * @param  None
  * @retval None
  */
void Touchscreen_demo2(void)
{
90017d00:	b580      	push	{r7, lr}
90017d02:	b084      	sub	sp, #16
90017d04:	af00      	add	r7, sp, #0
  uint32_t ts_status = BSP_ERROR_NONE;
90017d06:	2300      	movs	r3, #0
90017d08:	60fb      	str	r3, [r7, #12]
  uint32_t x_size, y_size;
 ButtonState = 0;
90017d0a:	4b29      	ldr	r3, [pc, #164]	; (90017db0 <Touchscreen_demo2+0xb0>)
90017d0c:	2200      	movs	r2, #0
90017d0e:	601a      	str	r2, [r3, #0]
  BSP_LCD_GetXSize(0, &x_size);
90017d10:	f107 0308 	add.w	r3, r7, #8
90017d14:	4619      	mov	r1, r3
90017d16:	2000      	movs	r0, #0
90017d18:	f7ef fca2 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
90017d1c:	1d3b      	adds	r3, r7, #4
90017d1e:	4619      	mov	r1, r3
90017d20:	2000      	movs	r0, #0
90017d22:	f7ef fcbb 	bl	9000769c <BSP_LCD_GetYSize>

  hTS.Width = x_size;
90017d26:	68bb      	ldr	r3, [r7, #8]
90017d28:	4a22      	ldr	r2, [pc, #136]	; (90017db4 <Touchscreen_demo2+0xb4>)
90017d2a:	6013      	str	r3, [r2, #0]
  hTS.Height = y_size;
90017d2c:	687b      	ldr	r3, [r7, #4]
90017d2e:	4a21      	ldr	r2, [pc, #132]	; (90017db4 <Touchscreen_demo2+0xb4>)
90017d30:	6053      	str	r3, [r2, #4]
  hTS.Orientation = TS_SWAP_XY;
90017d32:	4b20      	ldr	r3, [pc, #128]	; (90017db4 <Touchscreen_demo2+0xb4>)
90017d34:	2208      	movs	r2, #8
90017d36:	609a      	str	r2, [r3, #8]
  hTS.Accuracy = 0;
90017d38:	4b1e      	ldr	r3, [pc, #120]	; (90017db4 <Touchscreen_demo2+0xb4>)
90017d3a:	2200      	movs	r2, #0
90017d3c:	60da      	str	r2, [r3, #12]


  GestureConf.Radian = 0x0A;
90017d3e:	4b1e      	ldr	r3, [pc, #120]	; (90017db8 <Touchscreen_demo2+0xb8>)
90017d40:	220a      	movs	r2, #10
90017d42:	601a      	str	r2, [r3, #0]
  GestureConf.OffsetLeftRight = 0x19;
90017d44:	4b1c      	ldr	r3, [pc, #112]	; (90017db8 <Touchscreen_demo2+0xb8>)
90017d46:	2219      	movs	r2, #25
90017d48:	605a      	str	r2, [r3, #4]
  GestureConf.OffsetUpDown = 0x19;
90017d4a:	4b1b      	ldr	r3, [pc, #108]	; (90017db8 <Touchscreen_demo2+0xb8>)
90017d4c:	2219      	movs	r2, #25
90017d4e:	609a      	str	r2, [r3, #8]
  GestureConf.DistanceLeftRight = 0x19;
90017d50:	4b19      	ldr	r3, [pc, #100]	; (90017db8 <Touchscreen_demo2+0xb8>)
90017d52:	2219      	movs	r2, #25
90017d54:	60da      	str	r2, [r3, #12]
  GestureConf.DistanceUpDown = 0x19;
90017d56:	4b18      	ldr	r3, [pc, #96]	; (90017db8 <Touchscreen_demo2+0xb8>)
90017d58:	2219      	movs	r2, #25
90017d5a:	611a      	str	r2, [r3, #16]
  GestureConf.DistanceZoom = 0x32;
90017d5c:	4b16      	ldr	r3, [pc, #88]	; (90017db8 <Touchscreen_demo2+0xb8>)
90017d5e:	2232      	movs	r2, #50	; 0x32
90017d60:	615a      	str	r2, [r3, #20]

  /* Touchscreen initialization */
  ts_status = BSP_TS_Init(0, &hTS);
90017d62:	4914      	ldr	r1, [pc, #80]	; (90017db4 <Touchscreen_demo2+0xb4>)
90017d64:	2000      	movs	r0, #0
90017d66:	f7f0 fd77 	bl	90008858 <BSP_TS_Init>
90017d6a:	4603      	mov	r3, r0
90017d6c:	60fb      	str	r3, [r7, #12]
  ts_status = BSP_TS_GestureConfig(0, &GestureConf);
90017d6e:	4912      	ldr	r1, [pc, #72]	; (90017db8 <Touchscreen_demo2+0xb8>)
90017d70:	2000      	movs	r0, #0
90017d72:	f7f1 f915 	bl	90008fa0 <BSP_TS_GestureConfig>
90017d76:	4603      	mov	r3, r0
90017d78:	60fb      	str	r3, [r7, #12]

  if(ts_status == BSP_ERROR_NONE)
90017d7a:	68fb      	ldr	r3, [r7, #12]
90017d7c:	2b00      	cmp	r3, #0
90017d7e:	d102      	bne.n	90017d86 <Touchscreen_demo2+0x86>
  {
    /* Display touch screen demo2 description */
    Touchscreen_SetHint_Demo(TOUCHSCREEN_DEMO_2);
90017d80:	2002      	movs	r0, #2
90017d82:	f000 f993 	bl	900180ac <Touchscreen_SetHint_Demo>
  } /* of if(status == BSP_ERROR_NONE) */

  while (1)
  {
    Touchscreen_Handle_NewTouch();
90017d86:	f000 f819 	bl	90017dbc <Touchscreen_Handle_NewTouch>
    if(CheckForUserInput() > 0)
90017d8a:	f7ff f98b 	bl	900170a4 <CheckForUserInput>
90017d8e:	4603      	mov	r3, r0
90017d90:	2b00      	cmp	r3, #0
90017d92:	d006      	beq.n	90017da2 <Touchscreen_demo2+0xa2>
    {
      BSP_TS_DeInit(0);
90017d94:	2000      	movs	r0, #0
90017d96:	f7f0 fe05 	bl	900089a4 <BSP_TS_DeInit>
      ButtonState = 0;
90017d9a:	4b05      	ldr	r3, [pc, #20]	; (90017db0 <Touchscreen_demo2+0xb0>)
90017d9c:	2200      	movs	r2, #0
90017d9e:	601a      	str	r2, [r3, #0]
      return;
90017da0:	e003      	b.n	90017daa <Touchscreen_demo2+0xaa>
    }
    HAL_Delay(100);
90017da2:	2064      	movs	r0, #100	; 0x64
90017da4:	f7f1 fb1a 	bl	900093dc <HAL_Delay>
    Touchscreen_Handle_NewTouch();
90017da8:	e7ed      	b.n	90017d86 <Touchscreen_demo2+0x86>
  }
}
90017daa:	3710      	adds	r7, #16
90017dac:	46bd      	mov	sp, r7
90017dae:	bd80      	pop	{r7, pc}
90017db0:	240027f0 	.word	0x240027f0
90017db4:	2400b418 	.word	0x2400b418
90017db8:	2400b400 	.word	0x2400b400

90017dbc <Touchscreen_Handle_NewTouch>:
  * @brief  Touchscreen_Handle_NewTouch: factorization of touch management
  * @param  None
  * @retval BSP_ERROR_NONE
  */
static uint32_t Touchscreen_Handle_NewTouch(void)
{
90017dbc:	b590      	push	{r4, r7, lr}
90017dbe:	b0b5      	sub	sp, #212	; 0xd4
90017dc0:	af02      	add	r7, sp, #8
uint32_t GestureId = GESTURE_ID_NO_GESTURE;
90017dc2:	2300      	movs	r3, #0
90017dc4:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
#define TS_MULTITOUCH_FOOTPRINT_CIRCLE_RADIUS 15
#define TOUCH_INFO_STRING_SIZE                70
  uint16_t x1 = 0;
90017dc8:	2300      	movs	r3, #0
90017dca:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
  uint16_t y1 = 0;
90017dce:	2300      	movs	r3, #0
90017dd0:	f8a7 30b8 	strh.w	r3, [r7, #184]	; 0xb8
  uint16_t x2 = 0;
90017dd4:	2300      	movs	r3, #0
90017dd6:	f8a7 30b6 	strh.w	r3, [r7, #182]	; 0xb6
  uint16_t y2 = 0;
90017dda:	2300      	movs	r3, #0
90017ddc:	f8a7 30b4 	strh.w	r3, [r7, #180]	; 0xb4
  uint32_t drawTouch1 = 0; /* activate/deactivate draw of footprint of touch 1 */
90017de0:	2300      	movs	r3, #0
90017de2:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  uint32_t drawTouch2 = 0; /* activate/deactivate draw of footprint of touch 2 */
90017de6:	2300      	movs	r3, #0
90017de8:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  uint32_t colors[24] = {UTIL_LCD_COLOR_BLUE, UTIL_LCD_COLOR_GREEN, UTIL_LCD_COLOR_RED, UTIL_LCD_COLOR_CYAN, UTIL_LCD_COLOR_MAGENTA, UTIL_LCD_COLOR_YELLOW,
90017dec:	4aa1      	ldr	r2, [pc, #644]	; (90018074 <Touchscreen_Handle_NewTouch+0x2b8>)
90017dee:	f107 0350 	add.w	r3, r7, #80	; 0x50
90017df2:	4611      	mov	r1, r2
90017df4:	2260      	movs	r2, #96	; 0x60
90017df6:	4618      	mov	r0, r3
90017df8:	f001 fec4 	bl	90019b84 <memcpy>
                         UTIL_LCD_COLOR_LIGHTBLUE, UTIL_LCD_COLOR_LIGHTGREEN, UTIL_LCD_COLOR_LIGHTRED, UTIL_LCD_COLOR_LIGHTCYAN, UTIL_LCD_COLOR_LIGHTMAGENTA,
                         UTIL_LCD_COLOR_LIGHTYELLOW, UTIL_LCD_COLOR_DARKBLUE, UTIL_LCD_COLOR_DARKGREEN, UTIL_LCD_COLOR_DARKRED, UTIL_LCD_COLOR_DARKCYAN,
                         UTIL_LCD_COLOR_DARKMAGENTA, UTIL_LCD_COLOR_DARKYELLOW, UTIL_LCD_COLOR_LIGHTGRAY, UTIL_LCD_COLOR_GRAY, UTIL_LCD_COLOR_DARKGRAY,
                         UTIL_LCD_COLOR_BLACK, UTIL_LCD_COLOR_BROWN, UTIL_LCD_COLOR_ORANGE };
  uint32_t ts_status = BSP_ERROR_NONE;
90017dfc:	2300      	movs	r3, #0
90017dfe:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  uint8_t lcd_string[TOUCH_INFO_STRING_SIZE] = "";
90017e02:	2300      	movs	r3, #0
90017e04:	60bb      	str	r3, [r7, #8]
90017e06:	f107 030c 	add.w	r3, r7, #12
90017e0a:	2242      	movs	r2, #66	; 0x42
90017e0c:	2100      	movs	r1, #0
90017e0e:	4618      	mov	r0, r3
90017e10:	f001 fec6 	bl	90019ba0 <memset>
  uint32_t x_size, y_size;

  BSP_LCD_GetXSize(0, &x_size);
90017e14:	1d3b      	adds	r3, r7, #4
90017e16:	4619      	mov	r1, r3
90017e18:	2000      	movs	r0, #0
90017e1a:	f7ef fc21 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
90017e1e:	463b      	mov	r3, r7
90017e20:	4619      	mov	r1, r3
90017e22:	2000      	movs	r0, #0
90017e24:	f7ef fc3a 	bl	9000769c <BSP_LCD_GetYSize>

  /* Check in polling mode in touch screen the touch status and coordinates */
  /* of touches if touch occurred                                           */
  ts_status = BSP_TS_Get_MultiTouchState(0, &TS_MTState);
90017e28:	4993      	ldr	r1, [pc, #588]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017e2a:	2000      	movs	r0, #0
90017e2c:	f7f0 fef4 	bl	90008c18 <BSP_TS_Get_MultiTouchState>
90017e30:	4603      	mov	r3, r0
90017e32:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  if(TS_MTState.TouchDetected)
90017e36:	4b90      	ldr	r3, [pc, #576]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017e38:	681b      	ldr	r3, [r3, #0]
90017e3a:	2b00      	cmp	r3, #0
90017e3c:	f000 8114 	beq.w	90018068 <Touchscreen_Handle_NewTouch+0x2ac>
  {
    /* One or dual touch have been detected  */

    /* Erase previous information on touchscreen play pad area */
    UTIL_LCD_FillRect(0, 80, x_size, y_size - 160, UTIL_LCD_COLOR_WHITE);
90017e40:	687a      	ldr	r2, [r7, #4]
90017e42:	683b      	ldr	r3, [r7, #0]
90017e44:	3ba0      	subs	r3, #160	; 0xa0
90017e46:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
90017e4a:	9100      	str	r1, [sp, #0]
90017e4c:	2150      	movs	r1, #80	; 0x50
90017e4e:	2000      	movs	r0, #0
90017e50:	f001 f98c 	bl	9001916c <UTIL_LCD_FillRect>

    /* Re-Draw touch screen play area on LCD */
    UTIL_LCD_DrawRect(10, 90, x_size - 20, y_size - 180, UTIL_LCD_COLOR_BLUE);
90017e54:	687b      	ldr	r3, [r7, #4]
90017e56:	f1a3 0214 	sub.w	r2, r3, #20
90017e5a:	683b      	ldr	r3, [r7, #0]
90017e5c:	3bb4      	subs	r3, #180	; 0xb4
90017e5e:	4987      	ldr	r1, [pc, #540]	; (9001807c <Touchscreen_Handle_NewTouch+0x2c0>)
90017e60:	9100      	str	r1, [sp, #0]
90017e62:	215a      	movs	r1, #90	; 0x5a
90017e64:	200a      	movs	r0, #10
90017e66:	f000 ff11 	bl	90018c8c <UTIL_LCD_DrawRect>
    UTIL_LCD_DrawRect(11, 91, x_size - 22, y_size - 182, UTIL_LCD_COLOR_BLUE);
90017e6a:	687b      	ldr	r3, [r7, #4]
90017e6c:	f1a3 0216 	sub.w	r2, r3, #22
90017e70:	683b      	ldr	r3, [r7, #0]
90017e72:	3bb6      	subs	r3, #182	; 0xb6
90017e74:	4981      	ldr	r1, [pc, #516]	; (9001807c <Touchscreen_Handle_NewTouch+0x2c0>)
90017e76:	9100      	str	r1, [sp, #0]
90017e78:	215b      	movs	r1, #91	; 0x5b
90017e7a:	200b      	movs	r0, #11
90017e7c:	f000 ff06 	bl	90018c8c <UTIL_LCD_DrawRect>

    /* Erase previous information on bottom text bar */
    UTIL_LCD_FillRect(0, y_size - 80, x_size, 80, UTIL_LCD_COLOR_BLUE);
90017e80:	683b      	ldr	r3, [r7, #0]
90017e82:	f1a3 0150 	sub.w	r1, r3, #80	; 0x50
90017e86:	687a      	ldr	r2, [r7, #4]
90017e88:	4b7c      	ldr	r3, [pc, #496]	; (9001807c <Touchscreen_Handle_NewTouch+0x2c0>)
90017e8a:	9300      	str	r3, [sp, #0]
90017e8c:	2350      	movs	r3, #80	; 0x50
90017e8e:	2000      	movs	r0, #0
90017e90:	f001 f96c 	bl	9001916c <UTIL_LCD_FillRect>

    /* Deactivate drawing footprint of touch 1 and touch 2 until validated against boundaries of touch pad values */
    drawTouch1 = drawTouch2 = 0;
90017e94:	2300      	movs	r3, #0
90017e96:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
90017e9a:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
90017e9e:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

    /* Get X and Y position of the first touch post calibrated */
    x1 = TS_MTState.TouchX[0];
90017ea2:	4b75      	ldr	r3, [pc, #468]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017ea4:	685b      	ldr	r3, [r3, #4]
90017ea6:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
    y1 = TS_MTState.TouchY[0];
90017eaa:	4b73      	ldr	r3, [pc, #460]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017eac:	699b      	ldr	r3, [r3, #24]
90017eae:	f8a7 30b8 	strh.w	r3, [r7, #184]	; 0xb8

    if((y1 > (90 + TS_MULTITOUCH_FOOTPRINT_CIRCLE_RADIUS)) &&
90017eb2:	f8b7 30b8 	ldrh.w	r3, [r7, #184]	; 0xb8
90017eb6:	2b69      	cmp	r3, #105	; 0x69
90017eb8:	d908      	bls.n	90017ecc <Touchscreen_Handle_NewTouch+0x110>
       (y1 < (y_size - 90 - TS_MULTITOUCH_FOOTPRINT_CIRCLE_RADIUS)))
90017eba:	f8b7 20b8 	ldrh.w	r2, [r7, #184]	; 0xb8
90017ebe:	683b      	ldr	r3, [r7, #0]
90017ec0:	3b69      	subs	r3, #105	; 0x69
    if((y1 > (90 + TS_MULTITOUCH_FOOTPRINT_CIRCLE_RADIUS)) &&
90017ec2:	429a      	cmp	r2, r3
90017ec4:	d202      	bcs.n	90017ecc <Touchscreen_Handle_NewTouch+0x110>
    {
      drawTouch1 = 1;
90017ec6:	2301      	movs	r3, #1
90017ec8:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    }

    /* If valid touch 1 position : inside the reserved area for the use case : draw the touch */
    if(drawTouch1 == 1)
90017ecc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
90017ed0:	2b01      	cmp	r3, #1
90017ed2:	d14a      	bne.n	90017f6a <Touchscreen_Handle_NewTouch+0x1ae>
    {
      /* Draw circle of first touch : turn on colors[] table */
      UTIL_LCD_FillCircle(x1, y1, TS_MULTITOUCH_FOOTPRINT_CIRCLE_RADIUS, colors[(touchscreen_color_idx++ % 24)]);
90017ed4:	f8b7 00ba 	ldrh.w	r0, [r7, #186]	; 0xba
90017ed8:	f8b7 40b8 	ldrh.w	r4, [r7, #184]	; 0xb8
90017edc:	4b68      	ldr	r3, [pc, #416]	; (90018080 <Touchscreen_Handle_NewTouch+0x2c4>)
90017ede:	6819      	ldr	r1, [r3, #0]
90017ee0:	1c4b      	adds	r3, r1, #1
90017ee2:	4a67      	ldr	r2, [pc, #412]	; (90018080 <Touchscreen_Handle_NewTouch+0x2c4>)
90017ee4:	6013      	str	r3, [r2, #0]
90017ee6:	4b67      	ldr	r3, [pc, #412]	; (90018084 <Touchscreen_Handle_NewTouch+0x2c8>)
90017ee8:	fba3 2301 	umull	r2, r3, r3, r1
90017eec:	091a      	lsrs	r2, r3, #4
90017eee:	4613      	mov	r3, r2
90017ef0:	005b      	lsls	r3, r3, #1
90017ef2:	4413      	add	r3, r2
90017ef4:	00db      	lsls	r3, r3, #3
90017ef6:	1aca      	subs	r2, r1, r3
90017ef8:	0093      	lsls	r3, r2, #2
90017efa:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
90017efe:	4413      	add	r3, r2
90017f00:	f853 3c78 	ldr.w	r3, [r3, #-120]
90017f04:	220f      	movs	r2, #15
90017f06:	4621      	mov	r1, r4
90017f08:	f001 f96a 	bl	900191e0 <UTIL_LCD_FillCircle>

      UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
90017f0c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90017f10:	f000 fbfe 	bl	90018710 <UTIL_LCD_SetTextColor>
      UTIL_LCD_SetFont(&Font16);
90017f14:	485c      	ldr	r0, [pc, #368]	; (90018088 <Touchscreen_Handle_NewTouch+0x2cc>)
90017f16:	f000 fc23 	bl	90018760 <UTIL_LCD_SetFont>
      UTIL_LCD_DisplayStringAt(0, y_size - 70, (uint8_t *)"TOUCH INFO : ", CENTER_MODE);
90017f1a:	683b      	ldr	r3, [r7, #0]
90017f1c:	f1a3 0146 	sub.w	r1, r3, #70	; 0x46
90017f20:	2301      	movs	r3, #1
90017f22:	4a5a      	ldr	r2, [pc, #360]	; (9001808c <Touchscreen_Handle_NewTouch+0x2d0>)
90017f24:	2000      	movs	r0, #0
90017f26:	f000 fd47 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

      UTIL_LCD_SetFont(&Font12);
90017f2a:	4859      	ldr	r0, [pc, #356]	; (90018090 <Touchscreen_Handle_NewTouch+0x2d4>)
90017f2c:	f000 fc18 	bl	90018760 <UTIL_LCD_SetFont>
      sprintf((char*)lcd_string, "x1 = %u, y1 = %u, Event = %s, Weight = %lu",
90017f30:	f8b7 10ba 	ldrh.w	r1, [r7, #186]	; 0xba
90017f34:	f8b7 40b8 	ldrh.w	r4, [r7, #184]	; 0xb8
              x1,
              y1,
              ts_event_string_tab[TS_MTState.TouchEvent[0]],
90017f38:	4b4f      	ldr	r3, [pc, #316]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017f3a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
      sprintf((char*)lcd_string, "x1 = %u, y1 = %u, Event = %s, Weight = %lu",
90017f3c:	4a55      	ldr	r2, [pc, #340]	; (90018094 <Touchscreen_Handle_NewTouch+0x2d8>)
90017f3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90017f42:	4a4d      	ldr	r2, [pc, #308]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017f44:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
90017f46:	f107 0008 	add.w	r0, r7, #8
90017f4a:	9201      	str	r2, [sp, #4]
90017f4c:	9300      	str	r3, [sp, #0]
90017f4e:	4623      	mov	r3, r4
90017f50:	460a      	mov	r2, r1
90017f52:	4951      	ldr	r1, [pc, #324]	; (90018098 <Touchscreen_Handle_NewTouch+0x2dc>)
90017f54:	f001 fe2c 	bl	90019bb0 <sprintf>
              TS_MTState.TouchWeight[0]);
      UTIL_LCD_DisplayStringAt(0, y_size - 45, lcd_string, CENTER_MODE);
90017f58:	683b      	ldr	r3, [r7, #0]
90017f5a:	f1a3 012d 	sub.w	r1, r3, #45	; 0x2d
90017f5e:	f107 0208 	add.w	r2, r7, #8
90017f62:	2301      	movs	r3, #1
90017f64:	2000      	movs	r0, #0
90017f66:	f000 fd27 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    } /* of if(drawTouch1 == 1) */

    if(TS_MTState.TouchDetected > 1)
90017f6a:	4b43      	ldr	r3, [pc, #268]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017f6c:	681b      	ldr	r3, [r3, #0]
90017f6e:	2b01      	cmp	r3, #1
90017f70:	d951      	bls.n	90018016 <Touchscreen_Handle_NewTouch+0x25a>
    {
      /* Get X and Y position of the second touch post calibrated */
      x2 = TS_MTState.TouchX[1];
90017f72:	4b41      	ldr	r3, [pc, #260]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017f74:	689b      	ldr	r3, [r3, #8]
90017f76:	f8a7 30b6 	strh.w	r3, [r7, #182]	; 0xb6
      y2 = TS_MTState.TouchY[1];
90017f7a:	4b3f      	ldr	r3, [pc, #252]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017f7c:	69db      	ldr	r3, [r3, #28]
90017f7e:	f8a7 30b4 	strh.w	r3, [r7, #180]	; 0xb4

      if((y2 > (90 + TS_MULTITOUCH_FOOTPRINT_CIRCLE_RADIUS)) &&
90017f82:	f8b7 30b4 	ldrh.w	r3, [r7, #180]	; 0xb4
90017f86:	2b69      	cmp	r3, #105	; 0x69
90017f88:	d908      	bls.n	90017f9c <Touchscreen_Handle_NewTouch+0x1e0>
         (y2 < (y_size - 90 - TS_MULTITOUCH_FOOTPRINT_CIRCLE_RADIUS)))
90017f8a:	f8b7 20b4 	ldrh.w	r2, [r7, #180]	; 0xb4
90017f8e:	683b      	ldr	r3, [r7, #0]
90017f90:	3b69      	subs	r3, #105	; 0x69
      if((y2 > (90 + TS_MULTITOUCH_FOOTPRINT_CIRCLE_RADIUS)) &&
90017f92:	429a      	cmp	r2, r3
90017f94:	d202      	bcs.n	90017f9c <Touchscreen_Handle_NewTouch+0x1e0>
      {
        drawTouch2 = 1;
90017f96:	2301      	movs	r3, #1
90017f98:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
      }

      /* If valid touch 2 position : inside the reserved area for the use case : draw the touch */
      if(drawTouch2 == 1)
90017f9c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
90017fa0:	2b01      	cmp	r3, #1
90017fa2:	d138      	bne.n	90018016 <Touchscreen_Handle_NewTouch+0x25a>
      {
        sprintf((char*)lcd_string, "x2 = %u, y2 = %u, Event = %s, Weight = %lu",
90017fa4:	f8b7 10b6 	ldrh.w	r1, [r7, #182]	; 0xb6
90017fa8:	f8b7 40b4 	ldrh.w	r4, [r7, #180]	; 0xb4
                x2,
                y2,
                ts_event_string_tab[TS_MTState.TouchEvent[1]],
90017fac:	4b32      	ldr	r3, [pc, #200]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017fae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
        sprintf((char*)lcd_string, "x2 = %u, y2 = %u, Event = %s, Weight = %lu",
90017fb0:	4a38      	ldr	r2, [pc, #224]	; (90018094 <Touchscreen_Handle_NewTouch+0x2d8>)
90017fb2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
90017fb6:	4a30      	ldr	r2, [pc, #192]	; (90018078 <Touchscreen_Handle_NewTouch+0x2bc>)
90017fb8:	6b12      	ldr	r2, [r2, #48]	; 0x30
90017fba:	f107 0008 	add.w	r0, r7, #8
90017fbe:	9201      	str	r2, [sp, #4]
90017fc0:	9300      	str	r3, [sp, #0]
90017fc2:	4623      	mov	r3, r4
90017fc4:	460a      	mov	r2, r1
90017fc6:	4935      	ldr	r1, [pc, #212]	; (9001809c <Touchscreen_Handle_NewTouch+0x2e0>)
90017fc8:	f001 fdf2 	bl	90019bb0 <sprintf>
                TS_MTState.TouchWeight[1]);
        UTIL_LCD_DisplayStringAt(0, y_size - 35, lcd_string, CENTER_MODE);
90017fcc:	683b      	ldr	r3, [r7, #0]
90017fce:	f1a3 0123 	sub.w	r1, r3, #35	; 0x23
90017fd2:	f107 0208 	add.w	r2, r7, #8
90017fd6:	2301      	movs	r3, #1
90017fd8:	2000      	movs	r0, #0
90017fda:	f000 fced 	bl	900189b8 <UTIL_LCD_DisplayStringAt>

        /* Draw circle of second touch : turn on color[] table */
        UTIL_LCD_FillCircle(x2, y2, TS_MULTITOUCH_FOOTPRINT_CIRCLE_RADIUS, colors[(touchscreen_color_idx++ % 24)]);
90017fde:	f8b7 00b6 	ldrh.w	r0, [r7, #182]	; 0xb6
90017fe2:	f8b7 40b4 	ldrh.w	r4, [r7, #180]	; 0xb4
90017fe6:	4b26      	ldr	r3, [pc, #152]	; (90018080 <Touchscreen_Handle_NewTouch+0x2c4>)
90017fe8:	6819      	ldr	r1, [r3, #0]
90017fea:	1c4b      	adds	r3, r1, #1
90017fec:	4a24      	ldr	r2, [pc, #144]	; (90018080 <Touchscreen_Handle_NewTouch+0x2c4>)
90017fee:	6013      	str	r3, [r2, #0]
90017ff0:	4b24      	ldr	r3, [pc, #144]	; (90018084 <Touchscreen_Handle_NewTouch+0x2c8>)
90017ff2:	fba3 2301 	umull	r2, r3, r3, r1
90017ff6:	091a      	lsrs	r2, r3, #4
90017ff8:	4613      	mov	r3, r2
90017ffa:	005b      	lsls	r3, r3, #1
90017ffc:	4413      	add	r3, r2
90017ffe:	00db      	lsls	r3, r3, #3
90018000:	1aca      	subs	r2, r1, r3
90018002:	0093      	lsls	r3, r2, #2
90018004:	f107 02c8 	add.w	r2, r7, #200	; 0xc8
90018008:	4413      	add	r3, r2
9001800a:	f853 3c78 	ldr.w	r3, [r3, #-120]
9001800e:	220f      	movs	r2, #15
90018010:	4621      	mov	r1, r4
90018012:	f001 f8e5 	bl	900191e0 <UTIL_LCD_FillCircle>
      } /* of if(drawTouch2 == 1) */

    } /* of if(TS_MTState.TouchDetected > 1) */

    if((drawTouch1 == 1) || (drawTouch2 == 1))
90018016:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
9001801a:	2b01      	cmp	r3, #1
9001801c:	d003      	beq.n	90018026 <Touchscreen_Handle_NewTouch+0x26a>
9001801e:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
90018022:	2b01      	cmp	r3, #1
90018024:	d114      	bne.n	90018050 <Touchscreen_Handle_NewTouch+0x294>
    {
      /* Get updated gesture Id in global variable 'TS_State' */
      ts_status = BSP_TS_GetGestureId(0, &GestureId);
90018026:	f107 03b0 	add.w	r3, r7, #176	; 0xb0
9001802a:	4619      	mov	r1, r3
9001802c:	2000      	movs	r0, #0
9001802e:	f7f0 ffdf 	bl	90008ff0 <BSP_TS_GetGestureId>
90018032:	4603      	mov	r3, r0
90018034:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

      sprintf((char*)lcd_string, "Gesture Id = %s", ts_gesture_id_string_tab[GestureId]);
90018038:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
9001803c:	4a18      	ldr	r2, [pc, #96]	; (900180a0 <Touchscreen_Handle_NewTouch+0x2e4>)
9001803e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
90018042:	f107 0308 	add.w	r3, r7, #8
90018046:	4917      	ldr	r1, [pc, #92]	; (900180a4 <Touchscreen_Handle_NewTouch+0x2e8>)
90018048:	4618      	mov	r0, r3
9001804a:	f001 fdb1 	bl	90019bb0 <sprintf>
9001804e:	e00b      	b.n	90018068 <Touchscreen_Handle_NewTouch+0x2ac>
    }
    else
    {
      /* Invalid touch position */
      UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
90018050:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90018054:	f000 fb5c 	bl	90018710 <UTIL_LCD_SetTextColor>
      UTIL_LCD_DisplayStringAt(0, y_size - 70, (uint8_t *)"Invalid touch position : use drawn touch area : ", CENTER_MODE);
90018058:	683b      	ldr	r3, [r7, #0]
9001805a:	f1a3 0146 	sub.w	r1, r3, #70	; 0x46
9001805e:	2301      	movs	r3, #1
90018060:	4a11      	ldr	r2, [pc, #68]	; (900180a8 <Touchscreen_Handle_NewTouch+0x2ec>)
90018062:	2000      	movs	r0, #0
90018064:	f000 fca8 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    }
  } /* of if(TS_MTState.TouchDetected) */

  return(ts_status);
90018068:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
}
9001806c:	4618      	mov	r0, r3
9001806e:	37cc      	adds	r7, #204	; 0xcc
90018070:	46bd      	mov	sp, r7
90018072:	bd90      	pop	{r4, r7, pc}
90018074:	900214dc 	.word	0x900214dc
90018078:	24002800 	.word	0x24002800
9001807c:	ff0000ff 	.word	0xff0000ff
90018080:	24002868 	.word	0x24002868
90018084:	aaaaaaab 	.word	0xaaaaaaab
90018088:	24000398 	.word	0x24000398
9001808c:	90021430 	.word	0x90021430
90018090:	240003a0 	.word	0x240003a0
90018094:	240002fc 	.word	0x240002fc
90018098:	90021440 	.word	0x90021440
9001809c:	9002146c 	.word	0x9002146c
900180a0:	2400030c 	.word	0x2400030c
900180a4:	90021498 	.word	0x90021498
900180a8:	900214a8 	.word	0x900214a8

900180ac <Touchscreen_SetHint_Demo>:
  *         demoIndex in parameter.
  * @param  demoIndex : parameter of type @ref TouchScreenDemoTypeDef
  * @retval None
  */
static void Touchscreen_SetHint_Demo(TouchScreenDemoTypeDef demoIndex)
{
900180ac:	b580      	push	{r7, lr}
900180ae:	b086      	sub	sp, #24
900180b0:	af02      	add	r7, sp, #8
900180b2:	4603      	mov	r3, r0
900180b4:	71fb      	strb	r3, [r7, #7]
  uint32_t x_size, y_size;

  BSP_LCD_GetXSize(0, &x_size);
900180b6:	f107 030c 	add.w	r3, r7, #12
900180ba:	4619      	mov	r1, r3
900180bc:	2000      	movs	r0, #0
900180be:	f7ef facf 	bl	90007660 <BSP_LCD_GetXSize>
  BSP_LCD_GetYSize(0, &y_size);
900180c2:	f107 0308 	add.w	r3, r7, #8
900180c6:	4619      	mov	r1, r3
900180c8:	2000      	movs	r0, #0
900180ca:	f7ef fae7 	bl	9000769c <BSP_LCD_GetYSize>

  if(demoIndex <= TOUCHSCREEN_DEMO_MAX)
900180ce:	79fb      	ldrb	r3, [r7, #7]
900180d0:	2b03      	cmp	r3, #3
900180d2:	f200 8085 	bhi.w	900181e0 <Touchscreen_SetHint_Demo+0x134>
  {
    /* Clear the LCD */
    UTIL_LCD_Clear(UTIL_LCD_COLOR_WHITE);
900180d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900180da:	f000 fc21 	bl	90018920 <UTIL_LCD_Clear>

    /* Set Touchscreen Demo1 description */
    UTIL_LCD_FillRect(0, 0, x_size, 80, UTIL_LCD_COLOR_BLUE);
900180de:	68fa      	ldr	r2, [r7, #12]
900180e0:	4b41      	ldr	r3, [pc, #260]	; (900181e8 <Touchscreen_SetHint_Demo+0x13c>)
900180e2:	9300      	str	r3, [sp, #0]
900180e4:	2350      	movs	r3, #80	; 0x50
900180e6:	2100      	movs	r1, #0
900180e8:	2000      	movs	r0, #0
900180ea:	f001 f83f 	bl	9001916c <UTIL_LCD_FillRect>
    UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_WHITE);
900180ee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900180f2:	f000 fb0d 	bl	90018710 <UTIL_LCD_SetTextColor>
    UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_BLUE);
900180f6:	483c      	ldr	r0, [pc, #240]	; (900181e8 <Touchscreen_SetHint_Demo+0x13c>)
900180f8:	f000 fb1e 	bl	90018738 <UTIL_LCD_SetBackColor>
    UTIL_LCD_SetFont(&Font24);
900180fc:	483b      	ldr	r0, [pc, #236]	; (900181ec <Touchscreen_SetHint_Demo+0x140>)
900180fe:	f000 fb2f 	bl	90018760 <UTIL_LCD_SetFont>

    if(demoIndex == TOUCHSCREEN_DEMO_1)
90018102:	79fb      	ldrb	r3, [r7, #7]
90018104:	2b01      	cmp	r3, #1
90018106:	d11b      	bne.n	90018140 <Touchscreen_SetHint_Demo+0x94>
    {
      UTIL_LCD_DisplayStringAt(0, 0, (uint8_t *)"Touchscreen basic polling", CENTER_MODE);
90018108:	2301      	movs	r3, #1
9001810a:	4a39      	ldr	r2, [pc, #228]	; (900181f0 <Touchscreen_SetHint_Demo+0x144>)
9001810c:	2100      	movs	r1, #0
9001810e:	2000      	movs	r0, #0
90018110:	f000 fc52 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_SetFont(&Font12);
90018114:	4837      	ldr	r0, [pc, #220]	; (900181f4 <Touchscreen_SetHint_Demo+0x148>)
90018116:	f000 fb23 	bl	90018760 <UTIL_LCD_SetFont>
      UTIL_LCD_DisplayStringAt(0, 30, (uint8_t *)"Please use the Touchscreen to", CENTER_MODE);
9001811a:	2301      	movs	r3, #1
9001811c:	4a36      	ldr	r2, [pc, #216]	; (900181f8 <Touchscreen_SetHint_Demo+0x14c>)
9001811e:	211e      	movs	r1, #30
90018120:	2000      	movs	r0, #0
90018122:	f000 fc49 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_DisplayStringAt(0, 45, (uint8_t *)"activate the colored circle", CENTER_MODE);
90018126:	2301      	movs	r3, #1
90018128:	4a34      	ldr	r2, [pc, #208]	; (900181fc <Touchscreen_SetHint_Demo+0x150>)
9001812a:	212d      	movs	r1, #45	; 0x2d
9001812c:	2000      	movs	r0, #0
9001812e:	f000 fc43 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_DisplayStringAt(0, 60, (uint8_t *)"inside the rectangle. Then press User button", CENTER_MODE);
90018132:	2301      	movs	r3, #1
90018134:	4a32      	ldr	r2, [pc, #200]	; (90018200 <Touchscreen_SetHint_Demo+0x154>)
90018136:	213c      	movs	r1, #60	; 0x3c
90018138:	2000      	movs	r0, #0
9001813a:	f000 fc3d 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
9001813e:	e039      	b.n	900181b4 <Touchscreen_SetHint_Demo+0x108>
    }
    else if (demoIndex == TOUCHSCREEN_DEMO_2)
90018140:	79fb      	ldrb	r3, [r7, #7]
90018142:	2b02      	cmp	r3, #2
90018144:	d11b      	bne.n	9001817e <Touchscreen_SetHint_Demo+0xd2>
    {
      UTIL_LCD_DisplayStringAt(0, 0, (uint8_t *)"Touchscreen dual touch polling", CENTER_MODE);
90018146:	2301      	movs	r3, #1
90018148:	4a2e      	ldr	r2, [pc, #184]	; (90018204 <Touchscreen_SetHint_Demo+0x158>)
9001814a:	2100      	movs	r1, #0
9001814c:	2000      	movs	r0, #0
9001814e:	f000 fc33 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_SetFont(&Font12);
90018152:	4828      	ldr	r0, [pc, #160]	; (900181f4 <Touchscreen_SetHint_Demo+0x148>)
90018154:	f000 fb04 	bl	90018760 <UTIL_LCD_SetFont>
      UTIL_LCD_DisplayStringAt(0, 30, (uint8_t *)"Please press the Touchscreen to", CENTER_MODE);
90018158:	2301      	movs	r3, #1
9001815a:	4a2b      	ldr	r2, [pc, #172]	; (90018208 <Touchscreen_SetHint_Demo+0x15c>)
9001815c:	211e      	movs	r1, #30
9001815e:	2000      	movs	r0, #0
90018160:	f000 fc2a 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_DisplayStringAt(0, 45, (uint8_t *)"activate single and", CENTER_MODE);
90018164:	2301      	movs	r3, #1
90018166:	4a29      	ldr	r2, [pc, #164]	; (9001820c <Touchscreen_SetHint_Demo+0x160>)
90018168:	212d      	movs	r1, #45	; 0x2d
9001816a:	2000      	movs	r0, #0
9001816c:	f000 fc24 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_DisplayStringAt(0, 60, (uint8_t *)"dual touch", CENTER_MODE);
90018170:	2301      	movs	r3, #1
90018172:	4a27      	ldr	r2, [pc, #156]	; (90018210 <Touchscreen_SetHint_Demo+0x164>)
90018174:	213c      	movs	r1, #60	; 0x3c
90018176:	2000      	movs	r0, #0
90018178:	f000 fc1e 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
9001817c:	e01a      	b.n	900181b4 <Touchscreen_SetHint_Demo+0x108>

    }
    else /* demoIndex == TOUCHSCREEN_DEMO_3 */
    {
      UTIL_LCD_DisplayStringAt(0, 0, (uint8_t *)"Touchscreen dual touch interrupt", CENTER_MODE);
9001817e:	2301      	movs	r3, #1
90018180:	4a24      	ldr	r2, [pc, #144]	; (90018214 <Touchscreen_SetHint_Demo+0x168>)
90018182:	2100      	movs	r1, #0
90018184:	2000      	movs	r0, #0
90018186:	f000 fc17 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_SetFont(&Font12);
9001818a:	481a      	ldr	r0, [pc, #104]	; (900181f4 <Touchscreen_SetHint_Demo+0x148>)
9001818c:	f000 fae8 	bl	90018760 <UTIL_LCD_SetFont>
      UTIL_LCD_DisplayStringAt(0, 30, (uint8_t *)"Please press the Touchscreen to", CENTER_MODE);
90018190:	2301      	movs	r3, #1
90018192:	4a1d      	ldr	r2, [pc, #116]	; (90018208 <Touchscreen_SetHint_Demo+0x15c>)
90018194:	211e      	movs	r1, #30
90018196:	2000      	movs	r0, #0
90018198:	f000 fc0e 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_DisplayStringAt(0, 45, (uint8_t *)"activate single and", CENTER_MODE);
9001819c:	2301      	movs	r3, #1
9001819e:	4a1b      	ldr	r2, [pc, #108]	; (9001820c <Touchscreen_SetHint_Demo+0x160>)
900181a0:	212d      	movs	r1, #45	; 0x2d
900181a2:	2000      	movs	r0, #0
900181a4:	f000 fc08 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_DisplayStringAt(0, 60, (uint8_t *)"dual touch", CENTER_MODE);
900181a8:	2301      	movs	r3, #1
900181aa:	4a19      	ldr	r2, [pc, #100]	; (90018210 <Touchscreen_SetHint_Demo+0x164>)
900181ac:	213c      	movs	r1, #60	; 0x3c
900181ae:	2000      	movs	r0, #0
900181b0:	f000 fc02 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
    }

    UTIL_LCD_DrawRect(10, 90, x_size - 20, y_size - 100, UTIL_LCD_COLOR_BLUE);
900181b4:	68fb      	ldr	r3, [r7, #12]
900181b6:	f1a3 0214 	sub.w	r2, r3, #20
900181ba:	68bb      	ldr	r3, [r7, #8]
900181bc:	3b64      	subs	r3, #100	; 0x64
900181be:	490a      	ldr	r1, [pc, #40]	; (900181e8 <Touchscreen_SetHint_Demo+0x13c>)
900181c0:	9100      	str	r1, [sp, #0]
900181c2:	215a      	movs	r1, #90	; 0x5a
900181c4:	200a      	movs	r0, #10
900181c6:	f000 fd61 	bl	90018c8c <UTIL_LCD_DrawRect>
    UTIL_LCD_DrawRect(11, 91, x_size - 22, y_size - 102, UTIL_LCD_COLOR_BLUE);
900181ca:	68fb      	ldr	r3, [r7, #12]
900181cc:	f1a3 0216 	sub.w	r2, r3, #22
900181d0:	68bb      	ldr	r3, [r7, #8]
900181d2:	3b66      	subs	r3, #102	; 0x66
900181d4:	4904      	ldr	r1, [pc, #16]	; (900181e8 <Touchscreen_SetHint_Demo+0x13c>)
900181d6:	9100      	str	r1, [sp, #0]
900181d8:	215b      	movs	r1, #91	; 0x5b
900181da:	200b      	movs	r0, #11
900181dc:	f000 fd56 	bl	90018c8c <UTIL_LCD_DrawRect>

  } /* of if(demoIndex <= TOUCHSCREEN_DEMO_MAX) */
}
900181e0:	bf00      	nop
900181e2:	3710      	adds	r7, #16
900181e4:	46bd      	mov	sp, r7
900181e6:	bd80      	pop	{r7, pc}
900181e8:	ff0000ff 	.word	0xff0000ff
900181ec:	24000388 	.word	0x24000388
900181f0:	9002153c 	.word	0x9002153c
900181f4:	240003a0 	.word	0x240003a0
900181f8:	90021558 	.word	0x90021558
900181fc:	90021578 	.word	0x90021578
90018200:	90021594 	.word	0x90021594
90018204:	900215c4 	.word	0x900215c4
90018208:	900215e4 	.word	0x900215e4
9001820c:	90021604 	.word	0x90021604
90018210:	90021618 	.word	0x90021618
90018214:	90021624 	.word	0x90021624

90018218 <Touchscreen_DrawBackground_Circles>:
  * @brief  Draw Touchscreen Background
  * @param  state : touch zone state
  * @retval None
  */
void Touchscreen_DrawBackground_Circles(uint8_t state)
{
90018218:	b580      	push	{r7, lr}
9001821a:	b084      	sub	sp, #16
9001821c:	af00      	add	r7, sp, #0
9001821e:	4603      	mov	r3, r0
90018220:	71fb      	strb	r3, [r7, #7]
  uint16_t x, y;
  switch (state)
90018222:	79fb      	ldrb	r3, [r7, #7]
90018224:	2b20      	cmp	r3, #32
90018226:	dc4b      	bgt.n	900182c0 <Touchscreen_DrawBackground_Circles+0xa8>
90018228:	2b00      	cmp	r3, #0
9001822a:	f2c0 81e6 	blt.w	900185fa <Touchscreen_DrawBackground_Circles+0x3e2>
9001822e:	2b20      	cmp	r3, #32
90018230:	f200 81e3 	bhi.w	900185fa <Touchscreen_DrawBackground_Circles+0x3e2>
90018234:	a201      	add	r2, pc, #4	; (adr r2, 9001823c <Touchscreen_DrawBackground_Circles+0x24>)
90018236:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
9001823a:	bf00      	nop
9001823c:	900182c9 	.word	0x900182c9
90018240:	9001833f 	.word	0x9001833f
90018244:	9001835b 	.word	0x9001835b
90018248:	900185fb 	.word	0x900185fb
9001824c:	90018377 	.word	0x90018377
90018250:	900185fb 	.word	0x900185fb
90018254:	900185fb 	.word	0x900185fb
90018258:	900185fb 	.word	0x900185fb
9001825c:	90018399 	.word	0x90018399
90018260:	900185fb 	.word	0x900185fb
90018264:	900185fb 	.word	0x900185fb
90018268:	900185fb 	.word	0x900185fb
9001826c:	900185fb 	.word	0x900185fb
90018270:	900185fb 	.word	0x900185fb
90018274:	900185fb 	.word	0x900185fb
90018278:	900185fb 	.word	0x900185fb
9001827c:	900183bb 	.word	0x900183bb
90018280:	900185fb 	.word	0x900185fb
90018284:	900185fb 	.word	0x900185fb
90018288:	900185fb 	.word	0x900185fb
9001828c:	900185fb 	.word	0x900185fb
90018290:	900185fb 	.word	0x900185fb
90018294:	900185fb 	.word	0x900185fb
90018298:	900185fb 	.word	0x900185fb
9001829c:	900185fb 	.word	0x900185fb
900182a0:	900185fb 	.word	0x900185fb
900182a4:	900185fb 	.word	0x900185fb
900182a8:	900185fb 	.word	0x900185fb
900182ac:	900185fb 	.word	0x900185fb
900182b0:	900185fb 	.word	0x900185fb
900182b4:	900185fb 	.word	0x900185fb
900182b8:	900185fb 	.word	0x900185fb
900182bc:	900184cd 	.word	0x900184cd
900182c0:	2b40      	cmp	r3, #64	; 0x40
900182c2:	f000 8150 	beq.w	90018566 <Touchscreen_DrawBackground_Circles+0x34e>
      x = CIRCLE_XPOS(2);
      y = CIRCLE_YPOS(1) - CIRCLE_RADIUS - UTIL_LCD_GetFont()->Height;
      UTIL_LCD_DisplayStringAt(x, y, (uint8_t *)"Frequency", LEFT_MODE);
      break;
  }
}
900182c6:	e198      	b.n	900185fa <Touchscreen_DrawBackground_Circles+0x3e2>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLUE);
900182c8:	4bce      	ldr	r3, [pc, #824]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
900182ca:	2228      	movs	r2, #40	; 0x28
900182cc:	21ac      	movs	r1, #172	; 0xac
900182ce:	2060      	movs	r0, #96	; 0x60
900182d0:	f000 ff86 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS, UTIL_LCD_COLOR_RED);
900182d4:	4bcc      	ldr	r3, [pc, #816]	; (90018608 <Touchscreen_DrawBackground_Circles+0x3f0>)
900182d6:	2228      	movs	r2, #40	; 0x28
900182d8:	21ac      	movs	r1, #172	; 0xac
900182da:	20c0      	movs	r0, #192	; 0xc0
900182dc:	f000 ff80 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS, UTIL_LCD_COLOR_YELLOW);
900182e0:	f06f 03ff 	mvn.w	r3, #255	; 0xff
900182e4:	2228      	movs	r2, #40	; 0x28
900182e6:	21ac      	movs	r1, #172	; 0xac
900182e8:	f44f 7090 	mov.w	r0, #288	; 0x120
900182ec:	f000 ff78 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), CIRCLE_RADIUS, UTIL_LCD_COLOR_GREEN);
900182f0:	f04f 23ff 	mov.w	r3, #4278255360	; 0xff00ff00
900182f4:	2228      	movs	r2, #40	; 0x28
900182f6:	21ac      	movs	r1, #172	; 0xac
900182f8:	f44f 70c0 	mov.w	r0, #384	; 0x180
900182fc:	f000 ff70 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
90018300:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90018304:	2226      	movs	r2, #38	; 0x26
90018306:	21ac      	movs	r1, #172	; 0xac
90018308:	2060      	movs	r0, #96	; 0x60
9001830a:	f000 ff69 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
9001830e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90018312:	2226      	movs	r2, #38	; 0x26
90018314:	21ac      	movs	r1, #172	; 0xac
90018316:	20c0      	movs	r0, #192	; 0xc0
90018318:	f000 ff62 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
9001831c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90018320:	2226      	movs	r2, #38	; 0x26
90018322:	21ac      	movs	r1, #172	; 0xac
90018324:	f44f 7090 	mov.w	r0, #288	; 0x120
90018328:	f000 ff5a 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
9001832c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90018330:	2226      	movs	r2, #38	; 0x26
90018332:	21ac      	movs	r1, #172	; 0xac
90018334:	f44f 70c0 	mov.w	r0, #384	; 0x180
90018338:	f000 ff52 	bl	900191e0 <UTIL_LCD_FillCircle>
      break;
9001833c:	e15d      	b.n	900185fa <Touchscreen_DrawBackground_Circles+0x3e2>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLUE);
9001833e:	4bb1      	ldr	r3, [pc, #708]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
90018340:	2228      	movs	r2, #40	; 0x28
90018342:	21ac      	movs	r1, #172	; 0xac
90018344:	2060      	movs	r0, #96	; 0x60
90018346:	f000 ff4b 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
9001834a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9001834e:	2226      	movs	r2, #38	; 0x26
90018350:	21ac      	movs	r1, #172	; 0xac
90018352:	2060      	movs	r0, #96	; 0x60
90018354:	f000 ff44 	bl	900191e0 <UTIL_LCD_FillCircle>
      break;
90018358:	e14f      	b.n	900185fa <Touchscreen_DrawBackground_Circles+0x3e2>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS, UTIL_LCD_COLOR_RED);
9001835a:	4bab      	ldr	r3, [pc, #684]	; (90018608 <Touchscreen_DrawBackground_Circles+0x3f0>)
9001835c:	2228      	movs	r2, #40	; 0x28
9001835e:	21ac      	movs	r1, #172	; 0xac
90018360:	20c0      	movs	r0, #192	; 0xc0
90018362:	f000 ff3d 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
90018366:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9001836a:	2226      	movs	r2, #38	; 0x26
9001836c:	21ac      	movs	r1, #172	; 0xac
9001836e:	20c0      	movs	r0, #192	; 0xc0
90018370:	f000 ff36 	bl	900191e0 <UTIL_LCD_FillCircle>
      break;
90018374:	e141      	b.n	900185fa <Touchscreen_DrawBackground_Circles+0x3e2>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS, UTIL_LCD_COLOR_YELLOW);
90018376:	f06f 03ff 	mvn.w	r3, #255	; 0xff
9001837a:	2228      	movs	r2, #40	; 0x28
9001837c:	21ac      	movs	r1, #172	; 0xac
9001837e:	f44f 7090 	mov.w	r0, #288	; 0x120
90018382:	f000 ff2d 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
90018386:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9001838a:	2226      	movs	r2, #38	; 0x26
9001838c:	21ac      	movs	r1, #172	; 0xac
9001838e:	f44f 7090 	mov.w	r0, #288	; 0x120
90018392:	f000 ff25 	bl	900191e0 <UTIL_LCD_FillCircle>
      break;
90018396:	e130      	b.n	900185fa <Touchscreen_DrawBackground_Circles+0x3e2>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(4), CIRCLE_RADIUS, UTIL_LCD_COLOR_GREEN);
90018398:	f04f 23ff 	mov.w	r3, #4278255360	; 0xff00ff00
9001839c:	2228      	movs	r2, #40	; 0x28
9001839e:	21ac      	movs	r1, #172	; 0xac
900183a0:	f44f 70c0 	mov.w	r0, #384	; 0x180
900183a4:	f000 ff1c 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(4), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
900183a8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900183ac:	2226      	movs	r2, #38	; 0x26
900183ae:	21ac      	movs	r1, #172	; 0xac
900183b0:	f44f 70c0 	mov.w	r0, #384	; 0x180
900183b4:	f000 ff14 	bl	900191e0 <UTIL_LCD_FillCircle>
      break;
900183b8:	e11f      	b.n	900185fa <Touchscreen_DrawBackground_Circles+0x3e2>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLUE);
900183ba:	4b92      	ldr	r3, [pc, #584]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
900183bc:	2228      	movs	r2, #40	; 0x28
900183be:	21ac      	movs	r1, #172	; 0xac
900183c0:	2060      	movs	r0, #96	; 0x60
900183c2:	f000 ff0d 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLUE);
900183c6:	4b8f      	ldr	r3, [pc, #572]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
900183c8:	2228      	movs	r2, #40	; 0x28
900183ca:	21ac      	movs	r1, #172	; 0xac
900183cc:	20c0      	movs	r0, #192	; 0xc0
900183ce:	f000 ff07 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLUE);
900183d2:	4b8c      	ldr	r3, [pc, #560]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
900183d4:	2228      	movs	r2, #40	; 0x28
900183d6:	21ac      	movs	r1, #172	; 0xac
900183d8:	f44f 7090 	mov.w	r0, #288	; 0x120
900183dc:	f000 ff00 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLUE);
900183e0:	4b88      	ldr	r3, [pc, #544]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
900183e2:	2228      	movs	r2, #40	; 0x28
900183e4:	21ac      	movs	r1, #172	; 0xac
900183e6:	f44f 70c0 	mov.w	r0, #384	; 0x180
900183ea:	f000 fef9 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
900183ee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900183f2:	2226      	movs	r2, #38	; 0x26
900183f4:	21ac      	movs	r1, #172	; 0xac
900183f6:	2060      	movs	r0, #96	; 0x60
900183f8:	f000 fef2 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
900183fc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90018400:	2226      	movs	r2, #38	; 0x26
90018402:	21ac      	movs	r1, #172	; 0xac
90018404:	20c0      	movs	r0, #192	; 0xc0
90018406:	f000 feeb 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
9001840a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9001840e:	2226      	movs	r2, #38	; 0x26
90018410:	21ac      	movs	r1, #172	; 0xac
90018412:	f44f 7090 	mov.w	r0, #288	; 0x120
90018416:	f000 fee3 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(4), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
9001841a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9001841e:	2226      	movs	r2, #38	; 0x26
90018420:	21ac      	movs	r1, #172	; 0xac
90018422:	f44f 70c0 	mov.w	r0, #384	; 0x180
90018426:	f000 fedb 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_DrawHLine(CIRCLE_XPOS(1)-LINE_LENGHT, CIRCLE_YPOS(1), 2*LINE_LENGHT, UTIL_LCD_COLOR_BLUE);
9001842a:	4b76      	ldr	r3, [pc, #472]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
9001842c:	223c      	movs	r2, #60	; 0x3c
9001842e:	21ac      	movs	r1, #172	; 0xac
90018430:	2042      	movs	r0, #66	; 0x42
90018432:	f000 f9d5 	bl	900187e0 <UTIL_LCD_DrawHLine>
      UTIL_LCD_DrawHLine(CIRCLE_XPOS(2)-LINE_LENGHT, CIRCLE_YPOS(2), 2*LINE_LENGHT, UTIL_LCD_COLOR_BLUE);
90018436:	4b73      	ldr	r3, [pc, #460]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
90018438:	223c      	movs	r2, #60	; 0x3c
9001843a:	21ac      	movs	r1, #172	; 0xac
9001843c:	20a2      	movs	r0, #162	; 0xa2
9001843e:	f000 f9cf 	bl	900187e0 <UTIL_LCD_DrawHLine>
      UTIL_LCD_DrawVLine(CIRCLE_XPOS(2), CIRCLE_YPOS(2)-LINE_LENGHT, 2*LINE_LENGHT, UTIL_LCD_COLOR_BLUE);
90018442:	4b70      	ldr	r3, [pc, #448]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
90018444:	223c      	movs	r2, #60	; 0x3c
90018446:	218e      	movs	r1, #142	; 0x8e
90018448:	20c0      	movs	r0, #192	; 0xc0
9001844a:	f000 f9ff 	bl	9001884c <UTIL_LCD_DrawVLine>
      UTIL_LCD_DrawHLine(CIRCLE_XPOS(3)-LINE_LENGHT, CIRCLE_YPOS(3), 2*LINE_LENGHT, UTIL_LCD_COLOR_BLUE);
9001844e:	4b6d      	ldr	r3, [pc, #436]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
90018450:	223c      	movs	r2, #60	; 0x3c
90018452:	21ac      	movs	r1, #172	; 0xac
90018454:	f44f 7081 	mov.w	r0, #258	; 0x102
90018458:	f000 f9c2 	bl	900187e0 <UTIL_LCD_DrawHLine>
      UTIL_LCD_DrawHLine(CIRCLE_XPOS(4)-LINE_LENGHT, CIRCLE_YPOS(4), 2*LINE_LENGHT, UTIL_LCD_COLOR_BLUE);
9001845c:	4b69      	ldr	r3, [pc, #420]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
9001845e:	223c      	movs	r2, #60	; 0x3c
90018460:	21ac      	movs	r1, #172	; 0xac
90018462:	f44f 70b1 	mov.w	r0, #354	; 0x162
90018466:	f000 f9bb 	bl	900187e0 <UTIL_LCD_DrawHLine>
      UTIL_LCD_DrawVLine(CIRCLE_XPOS(4), CIRCLE_YPOS(4)-LINE_LENGHT, 2*LINE_LENGHT, UTIL_LCD_COLOR_BLUE);
9001846a:	4b66      	ldr	r3, [pc, #408]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
9001846c:	223c      	movs	r2, #60	; 0x3c
9001846e:	218e      	movs	r1, #142	; 0x8e
90018470:	f44f 70c0 	mov.w	r0, #384	; 0x180
90018474:	f000 f9ea 	bl	9001884c <UTIL_LCD_DrawVLine>
      UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLUE);
90018478:	4862      	ldr	r0, [pc, #392]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
9001847a:	f000 f949 	bl	90018710 <UTIL_LCD_SetTextColor>
      UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
9001847e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90018482:	f000 f959 	bl	90018738 <UTIL_LCD_SetBackColor>
      UTIL_LCD_SetFont(&Font24);
90018486:	4861      	ldr	r0, [pc, #388]	; (9001860c <Touchscreen_DrawBackground_Circles+0x3f4>)
90018488:	f000 f96a 	bl	90018760 <UTIL_LCD_SetFont>
      x = CIRCLE_XPOS(1);
9001848c:	2360      	movs	r3, #96	; 0x60
9001848e:	81fb      	strh	r3, [r7, #14]
      y = CIRCLE_YPOS(1) - CIRCLE_RADIUS - UTIL_LCD_GetFont()->Height;
90018490:	f000 f97a 	bl	90018788 <UTIL_LCD_GetFont>
90018494:	4603      	mov	r3, r0
90018496:	88db      	ldrh	r3, [r3, #6]
90018498:	f1c3 0384 	rsb	r3, r3, #132	; 0x84
9001849c:	81bb      	strh	r3, [r7, #12]
      UTIL_LCD_DisplayStringAt(x, y, (uint8_t *)"Volume", CENTER_MODE);
9001849e:	89f8      	ldrh	r0, [r7, #14]
900184a0:	89b9      	ldrh	r1, [r7, #12]
900184a2:	2301      	movs	r3, #1
900184a4:	4a5a      	ldr	r2, [pc, #360]	; (90018610 <Touchscreen_DrawBackground_Circles+0x3f8>)
900184a6:	f000 fa87 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      x = CIRCLE_XPOS(4);
900184aa:	f44f 73c0 	mov.w	r3, #384	; 0x180
900184ae:	81fb      	strh	r3, [r7, #14]
      y = CIRCLE_YPOS(4) - CIRCLE_RADIUS - UTIL_LCD_GetFont()->Height;
900184b0:	f000 f96a 	bl	90018788 <UTIL_LCD_GetFont>
900184b4:	4603      	mov	r3, r0
900184b6:	88db      	ldrh	r3, [r3, #6]
900184b8:	f1c3 0384 	rsb	r3, r3, #132	; 0x84
900184bc:	81bb      	strh	r3, [r7, #12]
      UTIL_LCD_DisplayStringAt(x, y, (uint8_t *)"Frequency", CENTER_MODE);
900184be:	89f8      	ldrh	r0, [r7, #14]
900184c0:	89b9      	ldrh	r1, [r7, #12]
900184c2:	2301      	movs	r3, #1
900184c4:	4a53      	ldr	r2, [pc, #332]	; (90018614 <Touchscreen_DrawBackground_Circles+0x3fc>)
900184c6:	f000 fa77 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      break;
900184ca:	e096      	b.n	900185fa <Touchscreen_DrawBackground_Circles+0x3e2>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLACK);
900184cc:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
900184d0:	2228      	movs	r2, #40	; 0x28
900184d2:	21ac      	movs	r1, #172	; 0xac
900184d4:	2060      	movs	r0, #96	; 0x60
900184d6:	f000 fe83 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLACK);
900184da:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
900184de:	2228      	movs	r2, #40	; 0x28
900184e0:	21ac      	movs	r1, #172	; 0xac
900184e2:	20c0      	movs	r0, #192	; 0xc0
900184e4:	f000 fe7c 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(1), CIRCLE_YPOS(1), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
900184e8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900184ec:	2226      	movs	r2, #38	; 0x26
900184ee:	21ac      	movs	r1, #172	; 0xac
900184f0:	2060      	movs	r0, #96	; 0x60
900184f2:	f000 fe75 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
900184f6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
900184fa:	2226      	movs	r2, #38	; 0x26
900184fc:	21ac      	movs	r1, #172	; 0xac
900184fe:	20c0      	movs	r0, #192	; 0xc0
90018500:	f000 fe6e 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLACK);
90018504:	f04f 407f 	mov.w	r0, #4278190080	; 0xff000000
90018508:	f000 f902 	bl	90018710 <UTIL_LCD_SetTextColor>
      UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
9001850c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
90018510:	f000 f912 	bl	90018738 <UTIL_LCD_SetBackColor>
      UTIL_LCD_SetFont(&Font20);
90018514:	4840      	ldr	r0, [pc, #256]	; (90018618 <Touchscreen_DrawBackground_Circles+0x400>)
90018516:	f000 f923 	bl	90018760 <UTIL_LCD_SetFont>
      x = CIRCLE_XPOS(1) - 10;
9001851a:	2356      	movs	r3, #86	; 0x56
9001851c:	81fb      	strh	r3, [r7, #14]
      y = CIRCLE_YPOS(1) - (UTIL_LCD_GetFont()->Height)/2;
9001851e:	f000 f933 	bl	90018788 <UTIL_LCD_GetFont>
90018522:	4603      	mov	r3, r0
90018524:	88db      	ldrh	r3, [r3, #6]
90018526:	085b      	lsrs	r3, r3, #1
90018528:	b29b      	uxth	r3, r3
9001852a:	f1c3 03ac 	rsb	r3, r3, #172	; 0xac
9001852e:	81bb      	strh	r3, [r7, #12]
      UTIL_LCD_DisplayStringAt(x, y, (uint8_t *)"Up", LEFT_MODE);
90018530:	89f8      	ldrh	r0, [r7, #14]
90018532:	89b9      	ldrh	r1, [r7, #12]
90018534:	2303      	movs	r3, #3
90018536:	4a39      	ldr	r2, [pc, #228]	; (9001861c <Touchscreen_DrawBackground_Circles+0x404>)
90018538:	f000 fa3e 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      x = CIRCLE_XPOS(2) - 10;
9001853c:	23b6      	movs	r3, #182	; 0xb6
9001853e:	81fb      	strh	r3, [r7, #14]
      y = CIRCLE_YPOS(3)  - (UTIL_LCD_GetFont()->Height)/2;
90018540:	f000 f922 	bl	90018788 <UTIL_LCD_GetFont>
90018544:	4603      	mov	r3, r0
90018546:	88db      	ldrh	r3, [r3, #6]
90018548:	085b      	lsrs	r3, r3, #1
9001854a:	b29b      	uxth	r3, r3
9001854c:	f1c3 03ac 	rsb	r3, r3, #172	; 0xac
90018550:	81bb      	strh	r3, [r7, #12]
      UTIL_LCD_DisplayStringAt(x, y, (uint8_t *)"Dw", LEFT_MODE);
90018552:	89f8      	ldrh	r0, [r7, #14]
90018554:	89b9      	ldrh	r1, [r7, #12]
90018556:	2303      	movs	r3, #3
90018558:	4a31      	ldr	r2, [pc, #196]	; (90018620 <Touchscreen_DrawBackground_Circles+0x408>)
9001855a:	f000 fa2d 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      UTIL_LCD_SetFont(&Font12);
9001855e:	4831      	ldr	r0, [pc, #196]	; (90018624 <Touchscreen_DrawBackground_Circles+0x40c>)
90018560:	f000 f8fe 	bl	90018760 <UTIL_LCD_SetFont>
      break;
90018564:	e049      	b.n	900185fa <Touchscreen_DrawBackground_Circles+0x3e2>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLUE);
90018566:	4b27      	ldr	r3, [pc, #156]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
90018568:	2228      	movs	r2, #40	; 0x28
9001856a:	21ac      	movs	r1, #172	; 0xac
9001856c:	20c0      	movs	r0, #192	; 0xc0
9001856e:	f000 fe37 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS, UTIL_LCD_COLOR_BLUE);
90018572:	4b24      	ldr	r3, [pc, #144]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
90018574:	2228      	movs	r2, #40	; 0x28
90018576:	21ac      	movs	r1, #172	; 0xac
90018578:	f44f 7090 	mov.w	r0, #288	; 0x120
9001857c:	f000 fe30 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(2), CIRCLE_YPOS(2), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
90018580:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90018584:	2226      	movs	r2, #38	; 0x26
90018586:	21ac      	movs	r1, #172	; 0xac
90018588:	20c0      	movs	r0, #192	; 0xc0
9001858a:	f000 fe29 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_FillCircle(CIRCLE_XPOS(3), CIRCLE_YPOS(3), CIRCLE_RADIUS - 2, UTIL_LCD_COLOR_WHITE);
9001858e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90018592:	2226      	movs	r2, #38	; 0x26
90018594:	21ac      	movs	r1, #172	; 0xac
90018596:	f44f 7090 	mov.w	r0, #288	; 0x120
9001859a:	f000 fe21 	bl	900191e0 <UTIL_LCD_FillCircle>
      UTIL_LCD_DrawHLine(CIRCLE_XPOS(2)-LINE_LENGHT, CIRCLE_YPOS(2), 2*LINE_LENGHT, UTIL_LCD_COLOR_BLUE);
9001859e:	4b19      	ldr	r3, [pc, #100]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
900185a0:	223c      	movs	r2, #60	; 0x3c
900185a2:	21ac      	movs	r1, #172	; 0xac
900185a4:	20a2      	movs	r0, #162	; 0xa2
900185a6:	f000 f91b 	bl	900187e0 <UTIL_LCD_DrawHLine>
      UTIL_LCD_DrawHLine(CIRCLE_XPOS(3)-LINE_LENGHT, CIRCLE_YPOS(3), 2*LINE_LENGHT, UTIL_LCD_COLOR_BLUE);
900185aa:	4b16      	ldr	r3, [pc, #88]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
900185ac:	223c      	movs	r2, #60	; 0x3c
900185ae:	21ac      	movs	r1, #172	; 0xac
900185b0:	f44f 7081 	mov.w	r0, #258	; 0x102
900185b4:	f000 f914 	bl	900187e0 <UTIL_LCD_DrawHLine>
      UTIL_LCD_DrawVLine(CIRCLE_XPOS(3), CIRCLE_YPOS(3)-LINE_LENGHT, 2*LINE_LENGHT, UTIL_LCD_COLOR_BLUE);
900185b8:	4b12      	ldr	r3, [pc, #72]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
900185ba:	223c      	movs	r2, #60	; 0x3c
900185bc:	218e      	movs	r1, #142	; 0x8e
900185be:	f44f 7090 	mov.w	r0, #288	; 0x120
900185c2:	f000 f943 	bl	9001884c <UTIL_LCD_DrawVLine>
      UTIL_LCD_SetTextColor(UTIL_LCD_COLOR_BLUE);
900185c6:	480f      	ldr	r0, [pc, #60]	; (90018604 <Touchscreen_DrawBackground_Circles+0x3ec>)
900185c8:	f000 f8a2 	bl	90018710 <UTIL_LCD_SetTextColor>
      UTIL_LCD_SetBackColor(UTIL_LCD_COLOR_WHITE);
900185cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
900185d0:	f000 f8b2 	bl	90018738 <UTIL_LCD_SetBackColor>
      UTIL_LCD_SetFont(&Font24);
900185d4:	480d      	ldr	r0, [pc, #52]	; (9001860c <Touchscreen_DrawBackground_Circles+0x3f4>)
900185d6:	f000 f8c3 	bl	90018760 <UTIL_LCD_SetFont>
      x = CIRCLE_XPOS(2);
900185da:	23c0      	movs	r3, #192	; 0xc0
900185dc:	81fb      	strh	r3, [r7, #14]
      y = CIRCLE_YPOS(1) - CIRCLE_RADIUS - UTIL_LCD_GetFont()->Height;
900185de:	f000 f8d3 	bl	90018788 <UTIL_LCD_GetFont>
900185e2:	4603      	mov	r3, r0
900185e4:	88db      	ldrh	r3, [r3, #6]
900185e6:	f1c3 0384 	rsb	r3, r3, #132	; 0x84
900185ea:	81bb      	strh	r3, [r7, #12]
      UTIL_LCD_DisplayStringAt(x, y, (uint8_t *)"Frequency", LEFT_MODE);
900185ec:	89f8      	ldrh	r0, [r7, #14]
900185ee:	89b9      	ldrh	r1, [r7, #12]
900185f0:	2303      	movs	r3, #3
900185f2:	4a08      	ldr	r2, [pc, #32]	; (90018614 <Touchscreen_DrawBackground_Circles+0x3fc>)
900185f4:	f000 f9e0 	bl	900189b8 <UTIL_LCD_DisplayStringAt>
      break;
900185f8:	bf00      	nop
}
900185fa:	bf00      	nop
900185fc:	3710      	adds	r7, #16
900185fe:	46bd      	mov	sp, r7
90018600:	bd80      	pop	{r7, pc}
90018602:	bf00      	nop
90018604:	ff0000ff 	.word	0xff0000ff
90018608:	ffff0000 	.word	0xffff0000
9001860c:	24000388 	.word	0x24000388
90018610:	90021648 	.word	0x90021648
90018614:	90021650 	.word	0x90021650
90018618:	24000390 	.word	0x24000390
9001861c:	9002165c 	.word	0x9002165c
90018620:	90021660 	.word	0x90021660
90018624:	240003a0 	.word	0x240003a0

90018628 <UTIL_LCD_SetFuncDriver>:
/**
  * @brief  Link board LCD drivers to STM32 LCD Utility drivers
  * @param  pDrv Structure of LCD functions
  */
void UTIL_LCD_SetFuncDriver(const LCD_UTILS_Drv_t *pDrv)
{
90018628:	b580      	push	{r7, lr}
9001862a:	b082      	sub	sp, #8
9001862c:	af00      	add	r7, sp, #0
9001862e:	6078      	str	r0, [r7, #4]
  FuncDriver.DrawBitmap     = pDrv->DrawBitmap;
90018630:	687b      	ldr	r3, [r7, #4]
90018632:	681b      	ldr	r3, [r3, #0]
90018634:	4a22      	ldr	r2, [pc, #136]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
90018636:	6013      	str	r3, [r2, #0]
  FuncDriver.FillRGBRect    = pDrv->FillRGBRect;
90018638:	687b      	ldr	r3, [r7, #4]
9001863a:	685b      	ldr	r3, [r3, #4]
9001863c:	4a20      	ldr	r2, [pc, #128]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
9001863e:	6053      	str	r3, [r2, #4]
  FuncDriver.DrawHLine      = pDrv->DrawHLine;
90018640:	687b      	ldr	r3, [r7, #4]
90018642:	689b      	ldr	r3, [r3, #8]
90018644:	4a1e      	ldr	r2, [pc, #120]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
90018646:	6093      	str	r3, [r2, #8]
  FuncDriver.DrawVLine      = pDrv->DrawVLine;
90018648:	687b      	ldr	r3, [r7, #4]
9001864a:	68db      	ldr	r3, [r3, #12]
9001864c:	4a1c      	ldr	r2, [pc, #112]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
9001864e:	60d3      	str	r3, [r2, #12]
  FuncDriver.FillRect       = pDrv->FillRect;
90018650:	687b      	ldr	r3, [r7, #4]
90018652:	691b      	ldr	r3, [r3, #16]
90018654:	4a1a      	ldr	r2, [pc, #104]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
90018656:	6113      	str	r3, [r2, #16]
  FuncDriver.GetPixel       = pDrv->GetPixel;
90018658:	687b      	ldr	r3, [r7, #4]
9001865a:	695b      	ldr	r3, [r3, #20]
9001865c:	4a18      	ldr	r2, [pc, #96]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
9001865e:	6153      	str	r3, [r2, #20]
  FuncDriver.SetPixel       = pDrv->SetPixel;
90018660:	687b      	ldr	r3, [r7, #4]
90018662:	699b      	ldr	r3, [r3, #24]
90018664:	4a16      	ldr	r2, [pc, #88]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
90018666:	6193      	str	r3, [r2, #24]
  FuncDriver.GetXSize       = pDrv->GetXSize;
90018668:	687b      	ldr	r3, [r7, #4]
9001866a:	69db      	ldr	r3, [r3, #28]
9001866c:	4a14      	ldr	r2, [pc, #80]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
9001866e:	61d3      	str	r3, [r2, #28]
  FuncDriver.GetYSize       = pDrv->GetYSize;
90018670:	687b      	ldr	r3, [r7, #4]
90018672:	6a1b      	ldr	r3, [r3, #32]
90018674:	4a12      	ldr	r2, [pc, #72]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
90018676:	6213      	str	r3, [r2, #32]
  FuncDriver.SetLayer       = pDrv->SetLayer;
90018678:	687b      	ldr	r3, [r7, #4]
9001867a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9001867c:	4a10      	ldr	r2, [pc, #64]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
9001867e:	6253      	str	r3, [r2, #36]	; 0x24
  FuncDriver.GetFormat      = pDrv->GetFormat;
90018680:	687b      	ldr	r3, [r7, #4]
90018682:	6a9b      	ldr	r3, [r3, #40]	; 0x28
90018684:	4a0e      	ldr	r2, [pc, #56]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
90018686:	6293      	str	r3, [r2, #40]	; 0x28

  DrawProp->LcdLayer = 0;
90018688:	4b0e      	ldr	r3, [pc, #56]	; (900186c4 <UTIL_LCD_SetFuncDriver+0x9c>)
9001868a:	2200      	movs	r2, #0
9001868c:	60da      	str	r2, [r3, #12]
  DrawProp->LcdDevice = 0;
9001868e:	4b0d      	ldr	r3, [pc, #52]	; (900186c4 <UTIL_LCD_SetFuncDriver+0x9c>)
90018690:	2200      	movs	r2, #0
90018692:	611a      	str	r2, [r3, #16]
  FuncDriver.GetXSize(0, &DrawProp->LcdXsize);
90018694:	4b0a      	ldr	r3, [pc, #40]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
90018696:	69db      	ldr	r3, [r3, #28]
90018698:	4a0b      	ldr	r2, [pc, #44]	; (900186c8 <UTIL_LCD_SetFuncDriver+0xa0>)
9001869a:	4611      	mov	r1, r2
9001869c:	2000      	movs	r0, #0
9001869e:	4798      	blx	r3
  FuncDriver.GetYSize(0, &DrawProp->LcdYsize);
900186a0:	4b07      	ldr	r3, [pc, #28]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
900186a2:	6a1b      	ldr	r3, [r3, #32]
900186a4:	4a09      	ldr	r2, [pc, #36]	; (900186cc <UTIL_LCD_SetFuncDriver+0xa4>)
900186a6:	4611      	mov	r1, r2
900186a8:	2000      	movs	r0, #0
900186aa:	4798      	blx	r3
  FuncDriver.GetFormat(0, &DrawProp->LcdPixelFormat);
900186ac:	4b04      	ldr	r3, [pc, #16]	; (900186c0 <UTIL_LCD_SetFuncDriver+0x98>)
900186ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
900186b0:	4a07      	ldr	r2, [pc, #28]	; (900186d0 <UTIL_LCD_SetFuncDriver+0xa8>)
900186b2:	4611      	mov	r1, r2
900186b4:	2000      	movs	r0, #0
900186b6:	4798      	blx	r3
}
900186b8:	bf00      	nop
900186ba:	3708      	adds	r7, #8
900186bc:	46bd      	mov	sp, r7
900186be:	bd80      	pop	{r7, pc}
900186c0:	240028ac 	.word	0x240028ac
900186c4:	2400286c 	.word	0x2400286c
900186c8:	24002880 	.word	0x24002880
900186cc:	24002884 	.word	0x24002884
900186d0:	24002888 	.word	0x24002888

900186d4 <UTIL_LCD_SetLayer>:
/**
  * @brief  Set the LCD layer.
  * @param  Layer  LCD layer
  */
void UTIL_LCD_SetLayer(uint32_t Layer)
{
900186d4:	b580      	push	{r7, lr}
900186d6:	b082      	sub	sp, #8
900186d8:	af00      	add	r7, sp, #0
900186da:	6078      	str	r0, [r7, #4]
  if(FuncDriver.SetLayer != NULL)
900186dc:	4b0a      	ldr	r3, [pc, #40]	; (90018708 <UTIL_LCD_SetLayer+0x34>)
900186de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
900186e0:	2b00      	cmp	r3, #0
900186e2:	d00c      	beq.n	900186fe <UTIL_LCD_SetLayer+0x2a>
  {
    if(FuncDriver.SetLayer(DrawProp->LcdDevice, Layer) == 0)
900186e4:	4b08      	ldr	r3, [pc, #32]	; (90018708 <UTIL_LCD_SetLayer+0x34>)
900186e6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
900186e8:	4a08      	ldr	r2, [pc, #32]	; (9001870c <UTIL_LCD_SetLayer+0x38>)
900186ea:	6912      	ldr	r2, [r2, #16]
900186ec:	6879      	ldr	r1, [r7, #4]
900186ee:	4610      	mov	r0, r2
900186f0:	4798      	blx	r3
900186f2:	4603      	mov	r3, r0
900186f4:	2b00      	cmp	r3, #0
900186f6:	d102      	bne.n	900186fe <UTIL_LCD_SetLayer+0x2a>
    {
      DrawProp->LcdLayer = Layer;
900186f8:	4a04      	ldr	r2, [pc, #16]	; (9001870c <UTIL_LCD_SetLayer+0x38>)
900186fa:	687b      	ldr	r3, [r7, #4]
900186fc:	60d3      	str	r3, [r2, #12]
    }
  }
}
900186fe:	bf00      	nop
90018700:	3708      	adds	r7, #8
90018702:	46bd      	mov	sp, r7
90018704:	bd80      	pop	{r7, pc}
90018706:	bf00      	nop
90018708:	240028ac 	.word	0x240028ac
9001870c:	2400286c 	.word	0x2400286c

90018710 <UTIL_LCD_SetTextColor>:
/**
  * @brief  Sets the LCD text color.
  * @param  Color  Text color code
  */
void UTIL_LCD_SetTextColor(uint32_t Color)
{
90018710:	b480      	push	{r7}
90018712:	b083      	sub	sp, #12
90018714:	af00      	add	r7, sp, #0
90018716:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].TextColor = Color;
90018718:	4b06      	ldr	r3, [pc, #24]	; (90018734 <UTIL_LCD_SetTextColor+0x24>)
9001871a:	68db      	ldr	r3, [r3, #12]
9001871c:	4a05      	ldr	r2, [pc, #20]	; (90018734 <UTIL_LCD_SetTextColor+0x24>)
9001871e:	015b      	lsls	r3, r3, #5
90018720:	4413      	add	r3, r2
90018722:	687a      	ldr	r2, [r7, #4]
90018724:	601a      	str	r2, [r3, #0]
}
90018726:	bf00      	nop
90018728:	370c      	adds	r7, #12
9001872a:	46bd      	mov	sp, r7
9001872c:	f85d 7b04 	ldr.w	r7, [sp], #4
90018730:	4770      	bx	lr
90018732:	bf00      	nop
90018734:	2400286c 	.word	0x2400286c

90018738 <UTIL_LCD_SetBackColor>:
/**
  * @brief  Sets the LCD background color.
  * @param  Color  Layer background color code
  */
void UTIL_LCD_SetBackColor(uint32_t Color)
{
90018738:	b480      	push	{r7}
9001873a:	b083      	sub	sp, #12
9001873c:	af00      	add	r7, sp, #0
9001873e:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].BackColor = Color;
90018740:	4b06      	ldr	r3, [pc, #24]	; (9001875c <UTIL_LCD_SetBackColor+0x24>)
90018742:	68db      	ldr	r3, [r3, #12]
90018744:	4a05      	ldr	r2, [pc, #20]	; (9001875c <UTIL_LCD_SetBackColor+0x24>)
90018746:	015b      	lsls	r3, r3, #5
90018748:	4413      	add	r3, r2
9001874a:	3304      	adds	r3, #4
9001874c:	687a      	ldr	r2, [r7, #4]
9001874e:	601a      	str	r2, [r3, #0]
}
90018750:	bf00      	nop
90018752:	370c      	adds	r7, #12
90018754:	46bd      	mov	sp, r7
90018756:	f85d 7b04 	ldr.w	r7, [sp], #4
9001875a:	4770      	bx	lr
9001875c:	2400286c 	.word	0x2400286c

90018760 <UTIL_LCD_SetFont>:
/**
  * @brief  Sets the LCD text font.
  * @param  fonts  Layer font to be used
  */
void UTIL_LCD_SetFont(sFONT *fonts)
{
90018760:	b480      	push	{r7}
90018762:	b083      	sub	sp, #12
90018764:	af00      	add	r7, sp, #0
90018766:	6078      	str	r0, [r7, #4]
  DrawProp[DrawProp->LcdLayer].pFont = fonts;
90018768:	4b06      	ldr	r3, [pc, #24]	; (90018784 <UTIL_LCD_SetFont+0x24>)
9001876a:	68db      	ldr	r3, [r3, #12]
9001876c:	4a05      	ldr	r2, [pc, #20]	; (90018784 <UTIL_LCD_SetFont+0x24>)
9001876e:	015b      	lsls	r3, r3, #5
90018770:	4413      	add	r3, r2
90018772:	3308      	adds	r3, #8
90018774:	687a      	ldr	r2, [r7, #4]
90018776:	601a      	str	r2, [r3, #0]
}
90018778:	bf00      	nop
9001877a:	370c      	adds	r7, #12
9001877c:	46bd      	mov	sp, r7
9001877e:	f85d 7b04 	ldr.w	r7, [sp], #4
90018782:	4770      	bx	lr
90018784:	2400286c 	.word	0x2400286c

90018788 <UTIL_LCD_GetFont>:
/**
  * @brief  Gets the LCD text font.
  * @retval Used layer font
  */
sFONT *UTIL_LCD_GetFont(void)
{
90018788:	b480      	push	{r7}
9001878a:	af00      	add	r7, sp, #0
  return DrawProp[DrawProp->LcdLayer].pFont;
9001878c:	4b05      	ldr	r3, [pc, #20]	; (900187a4 <UTIL_LCD_GetFont+0x1c>)
9001878e:	68db      	ldr	r3, [r3, #12]
90018790:	4a04      	ldr	r2, [pc, #16]	; (900187a4 <UTIL_LCD_GetFont+0x1c>)
90018792:	015b      	lsls	r3, r3, #5
90018794:	4413      	add	r3, r2
90018796:	3308      	adds	r3, #8
90018798:	681b      	ldr	r3, [r3, #0]
}
9001879a:	4618      	mov	r0, r3
9001879c:	46bd      	mov	sp, r7
9001879e:	f85d 7b04 	ldr.w	r7, [sp], #4
900187a2:	4770      	bx	lr
900187a4:	2400286c 	.word	0x2400286c

900187a8 <UTIL_LCD_FillRGBRect>:
  * @param  Xpos    X position
  * @param  Ypos    Y position
  * @param  Length  Line length
  */
void UTIL_LCD_FillRGBRect(uint32_t Xpos, uint32_t Ypos, uint8_t *pData, uint32_t Width, uint32_t Height)
{
900187a8:	b590      	push	{r4, r7, lr}
900187aa:	b087      	sub	sp, #28
900187ac:	af02      	add	r7, sp, #8
900187ae:	60f8      	str	r0, [r7, #12]
900187b0:	60b9      	str	r1, [r7, #8]
900187b2:	607a      	str	r2, [r7, #4]
900187b4:	603b      	str	r3, [r7, #0]
  /* Write RGB rectangle data */
  FuncDriver.FillRGBRect(DrawProp->LcdDevice, Xpos, Ypos, pData, Width, Height);
900187b6:	4b08      	ldr	r3, [pc, #32]	; (900187d8 <UTIL_LCD_FillRGBRect+0x30>)
900187b8:	685c      	ldr	r4, [r3, #4]
900187ba:	4b08      	ldr	r3, [pc, #32]	; (900187dc <UTIL_LCD_FillRGBRect+0x34>)
900187bc:	6918      	ldr	r0, [r3, #16]
900187be:	6a3b      	ldr	r3, [r7, #32]
900187c0:	9301      	str	r3, [sp, #4]
900187c2:	683b      	ldr	r3, [r7, #0]
900187c4:	9300      	str	r3, [sp, #0]
900187c6:	687b      	ldr	r3, [r7, #4]
900187c8:	68ba      	ldr	r2, [r7, #8]
900187ca:	68f9      	ldr	r1, [r7, #12]
900187cc:	47a0      	blx	r4
}
900187ce:	bf00      	nop
900187d0:	3714      	adds	r7, #20
900187d2:	46bd      	mov	sp, r7
900187d4:	bd90      	pop	{r4, r7, pc}
900187d6:	bf00      	nop
900187d8:	240028ac 	.word	0x240028ac
900187dc:	2400286c 	.word	0x2400286c

900187e0 <UTIL_LCD_DrawHLine>:
  * @param  Ypos    Y position
  * @param  Length  Line length
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawHLine(uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
900187e0:	b590      	push	{r4, r7, lr}
900187e2:	b087      	sub	sp, #28
900187e4:	af02      	add	r7, sp, #8
900187e6:	60f8      	str	r0, [r7, #12]
900187e8:	60b9      	str	r1, [r7, #8]
900187ea:	607a      	str	r2, [r7, #4]
900187ec:	603b      	str	r3, [r7, #0]
  /* Write line */
  if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
900187ee:	4b15      	ldr	r3, [pc, #84]	; (90018844 <UTIL_LCD_DrawHLine+0x64>)
900187f0:	69db      	ldr	r3, [r3, #28]
900187f2:	2b02      	cmp	r3, #2
900187f4:	d118      	bne.n	90018828 <UTIL_LCD_DrawHLine+0x48>
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
900187f6:	4b14      	ldr	r3, [pc, #80]	; (90018848 <UTIL_LCD_DrawHLine+0x68>)
900187f8:	689c      	ldr	r4, [r3, #8]
900187fa:	4b12      	ldr	r3, [pc, #72]	; (90018844 <UTIL_LCD_DrawHLine+0x64>)
900187fc:	6918      	ldr	r0, [r3, #16]
900187fe:	683b      	ldr	r3, [r7, #0]
90018800:	08db      	lsrs	r3, r3, #3
90018802:	f003 021f 	and.w	r2, r3, #31
90018806:	683b      	ldr	r3, [r7, #0]
90018808:	0a9b      	lsrs	r3, r3, #10
9001880a:	015b      	lsls	r3, r3, #5
9001880c:	f403 63fc 	and.w	r3, r3, #2016	; 0x7e0
90018810:	431a      	orrs	r2, r3
90018812:	683b      	ldr	r3, [r7, #0]
90018814:	0cdb      	lsrs	r3, r3, #19
90018816:	02db      	lsls	r3, r3, #11
90018818:	b29b      	uxth	r3, r3
9001881a:	4313      	orrs	r3, r2
9001881c:	9300      	str	r3, [sp, #0]
9001881e:	687b      	ldr	r3, [r7, #4]
90018820:	68ba      	ldr	r2, [r7, #8]
90018822:	68f9      	ldr	r1, [r7, #12]
90018824:	47a0      	blx	r4
  }
  else
  {
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
  }
}
90018826:	e009      	b.n	9001883c <UTIL_LCD_DrawHLine+0x5c>
    FuncDriver.DrawHLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
90018828:	4b07      	ldr	r3, [pc, #28]	; (90018848 <UTIL_LCD_DrawHLine+0x68>)
9001882a:	689c      	ldr	r4, [r3, #8]
9001882c:	4b05      	ldr	r3, [pc, #20]	; (90018844 <UTIL_LCD_DrawHLine+0x64>)
9001882e:	6918      	ldr	r0, [r3, #16]
90018830:	683b      	ldr	r3, [r7, #0]
90018832:	9300      	str	r3, [sp, #0]
90018834:	687b      	ldr	r3, [r7, #4]
90018836:	68ba      	ldr	r2, [r7, #8]
90018838:	68f9      	ldr	r1, [r7, #12]
9001883a:	47a0      	blx	r4
}
9001883c:	bf00      	nop
9001883e:	3714      	adds	r7, #20
90018840:	46bd      	mov	sp, r7
90018842:	bd90      	pop	{r4, r7, pc}
90018844:	2400286c 	.word	0x2400286c
90018848:	240028ac 	.word	0x240028ac

9001884c <UTIL_LCD_DrawVLine>:
  * @param  Ypos    Y position
  * @param  Length  Line length
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawVLine(uint32_t Xpos, uint32_t Ypos, uint32_t Length, uint32_t Color)
{
9001884c:	b590      	push	{r4, r7, lr}
9001884e:	b087      	sub	sp, #28
90018850:	af02      	add	r7, sp, #8
90018852:	60f8      	str	r0, [r7, #12]
90018854:	60b9      	str	r1, [r7, #8]
90018856:	607a      	str	r2, [r7, #4]
90018858:	603b      	str	r3, [r7, #0]
  /* Write line */
  if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
9001885a:	4b15      	ldr	r3, [pc, #84]	; (900188b0 <UTIL_LCD_DrawVLine+0x64>)
9001885c:	69db      	ldr	r3, [r3, #28]
9001885e:	2b02      	cmp	r3, #2
90018860:	d118      	bne.n	90018894 <UTIL_LCD_DrawVLine+0x48>
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, CONVERTARGB88882RGB565(Color));
90018862:	4b14      	ldr	r3, [pc, #80]	; (900188b4 <UTIL_LCD_DrawVLine+0x68>)
90018864:	68dc      	ldr	r4, [r3, #12]
90018866:	4b12      	ldr	r3, [pc, #72]	; (900188b0 <UTIL_LCD_DrawVLine+0x64>)
90018868:	6918      	ldr	r0, [r3, #16]
9001886a:	683b      	ldr	r3, [r7, #0]
9001886c:	08db      	lsrs	r3, r3, #3
9001886e:	f003 021f 	and.w	r2, r3, #31
90018872:	683b      	ldr	r3, [r7, #0]
90018874:	0a9b      	lsrs	r3, r3, #10
90018876:	015b      	lsls	r3, r3, #5
90018878:	f403 63fc 	and.w	r3, r3, #2016	; 0x7e0
9001887c:	431a      	orrs	r2, r3
9001887e:	683b      	ldr	r3, [r7, #0]
90018880:	0cdb      	lsrs	r3, r3, #19
90018882:	02db      	lsls	r3, r3, #11
90018884:	b29b      	uxth	r3, r3
90018886:	4313      	orrs	r3, r2
90018888:	9300      	str	r3, [sp, #0]
9001888a:	687b      	ldr	r3, [r7, #4]
9001888c:	68ba      	ldr	r2, [r7, #8]
9001888e:	68f9      	ldr	r1, [r7, #12]
90018890:	47a0      	blx	r4
  }
  else
  {
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
  }
}
90018892:	e009      	b.n	900188a8 <UTIL_LCD_DrawVLine+0x5c>
    FuncDriver.DrawVLine(DrawProp->LcdDevice, Xpos, Ypos, Length, Color);
90018894:	4b07      	ldr	r3, [pc, #28]	; (900188b4 <UTIL_LCD_DrawVLine+0x68>)
90018896:	68dc      	ldr	r4, [r3, #12]
90018898:	4b05      	ldr	r3, [pc, #20]	; (900188b0 <UTIL_LCD_DrawVLine+0x64>)
9001889a:	6918      	ldr	r0, [r3, #16]
9001889c:	683b      	ldr	r3, [r7, #0]
9001889e:	9300      	str	r3, [sp, #0]
900188a0:	687b      	ldr	r3, [r7, #4]
900188a2:	68ba      	ldr	r2, [r7, #8]
900188a4:	68f9      	ldr	r1, [r7, #12]
900188a6:	47a0      	blx	r4
}
900188a8:	bf00      	nop
900188aa:	3714      	adds	r7, #20
900188ac:	46bd      	mov	sp, r7
900188ae:	bd90      	pop	{r4, r7, pc}
900188b0:	2400286c 	.word	0x2400286c
900188b4:	240028ac 	.word	0x240028ac

900188b8 <UTIL_LCD_SetPixel>:
  * @param  Xpos     X position
  * @param  Ypos     Y position
  * @param  Color    Pixel color
  */
void UTIL_LCD_SetPixel(uint16_t Xpos, uint16_t Ypos, uint32_t Color)
{
900188b8:	b5b0      	push	{r4, r5, r7, lr}
900188ba:	b082      	sub	sp, #8
900188bc:	af00      	add	r7, sp, #0
900188be:	4603      	mov	r3, r0
900188c0:	603a      	str	r2, [r7, #0]
900188c2:	80fb      	strh	r3, [r7, #6]
900188c4:	460b      	mov	r3, r1
900188c6:	80bb      	strh	r3, [r7, #4]
  /* Set Pixel */
  if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
900188c8:	4b13      	ldr	r3, [pc, #76]	; (90018918 <UTIL_LCD_SetPixel+0x60>)
900188ca:	69db      	ldr	r3, [r3, #28]
900188cc:	2b02      	cmp	r3, #2
900188ce:	d117      	bne.n	90018900 <UTIL_LCD_SetPixel+0x48>
  {
    FuncDriver.SetPixel(DrawProp->LcdDevice, Xpos, Ypos, CONVERTARGB88882RGB565(Color));
900188d0:	4b12      	ldr	r3, [pc, #72]	; (9001891c <UTIL_LCD_SetPixel+0x64>)
900188d2:	699c      	ldr	r4, [r3, #24]
900188d4:	4b10      	ldr	r3, [pc, #64]	; (90018918 <UTIL_LCD_SetPixel+0x60>)
900188d6:	6918      	ldr	r0, [r3, #16]
900188d8:	88f9      	ldrh	r1, [r7, #6]
900188da:	88bd      	ldrh	r5, [r7, #4]
900188dc:	683b      	ldr	r3, [r7, #0]
900188de:	08db      	lsrs	r3, r3, #3
900188e0:	f003 021f 	and.w	r2, r3, #31
900188e4:	683b      	ldr	r3, [r7, #0]
900188e6:	0a9b      	lsrs	r3, r3, #10
900188e8:	015b      	lsls	r3, r3, #5
900188ea:	f403 63fc 	and.w	r3, r3, #2016	; 0x7e0
900188ee:	431a      	orrs	r2, r3
900188f0:	683b      	ldr	r3, [r7, #0]
900188f2:	0cdb      	lsrs	r3, r3, #19
900188f4:	02db      	lsls	r3, r3, #11
900188f6:	b29b      	uxth	r3, r3
900188f8:	4313      	orrs	r3, r2
900188fa:	462a      	mov	r2, r5
900188fc:	47a0      	blx	r4
  }
  else
  {
    FuncDriver.SetPixel(DrawProp->LcdDevice, Xpos, Ypos, Color);
  }
}
900188fe:	e007      	b.n	90018910 <UTIL_LCD_SetPixel+0x58>
    FuncDriver.SetPixel(DrawProp->LcdDevice, Xpos, Ypos, Color);
90018900:	4b06      	ldr	r3, [pc, #24]	; (9001891c <UTIL_LCD_SetPixel+0x64>)
90018902:	699c      	ldr	r4, [r3, #24]
90018904:	4b04      	ldr	r3, [pc, #16]	; (90018918 <UTIL_LCD_SetPixel+0x60>)
90018906:	6918      	ldr	r0, [r3, #16]
90018908:	88f9      	ldrh	r1, [r7, #6]
9001890a:	88ba      	ldrh	r2, [r7, #4]
9001890c:	683b      	ldr	r3, [r7, #0]
9001890e:	47a0      	blx	r4
}
90018910:	bf00      	nop
90018912:	3708      	adds	r7, #8
90018914:	46bd      	mov	sp, r7
90018916:	bdb0      	pop	{r4, r5, r7, pc}
90018918:	2400286c 	.word	0x2400286c
9001891c:	240028ac 	.word	0x240028ac

90018920 <UTIL_LCD_Clear>:
/**
  * @brief  Clears the whole currently active layer of LTDC.
  * @param  Color  Color of the background
  */
void UTIL_LCD_Clear(uint32_t Color)
{
90018920:	b580      	push	{r7, lr}
90018922:	b084      	sub	sp, #16
90018924:	af02      	add	r7, sp, #8
90018926:	6078      	str	r0, [r7, #4]
  /* Clear the LCD */
  UTIL_LCD_FillRect(0, 0, DrawProp->LcdXsize, DrawProp->LcdYsize, Color);
90018928:	4b07      	ldr	r3, [pc, #28]	; (90018948 <UTIL_LCD_Clear+0x28>)
9001892a:	695a      	ldr	r2, [r3, #20]
9001892c:	4b06      	ldr	r3, [pc, #24]	; (90018948 <UTIL_LCD_Clear+0x28>)
9001892e:	6999      	ldr	r1, [r3, #24]
90018930:	687b      	ldr	r3, [r7, #4]
90018932:	9300      	str	r3, [sp, #0]
90018934:	460b      	mov	r3, r1
90018936:	2100      	movs	r1, #0
90018938:	2000      	movs	r0, #0
9001893a:	f000 fc17 	bl	9001916c <UTIL_LCD_FillRect>
}
9001893e:	bf00      	nop
90018940:	3708      	adds	r7, #8
90018942:	46bd      	mov	sp, r7
90018944:	bd80      	pop	{r7, pc}
90018946:	bf00      	nop
90018948:	2400286c 	.word	0x2400286c

9001894c <UTIL_LCD_DisplayChar>:
  * @param  Ypos Line where to display the character shape.
  * @param  Ascii Character ascii code
  *           This parameter must be a number between Min_Data = 0x20 and Max_Data = 0x7E
  */
void UTIL_LCD_DisplayChar(uint32_t Xpos, uint32_t Ypos, uint8_t Ascii)
{
9001894c:	b580      	push	{r7, lr}
9001894e:	b084      	sub	sp, #16
90018950:	af00      	add	r7, sp, #0
90018952:	60f8      	str	r0, [r7, #12]
90018954:	60b9      	str	r1, [r7, #8]
90018956:	4613      	mov	r3, r2
90018958:	71fb      	strb	r3, [r7, #7]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
9001895a:	4b16      	ldr	r3, [pc, #88]	; (900189b4 <UTIL_LCD_DisplayChar+0x68>)
9001895c:	68db      	ldr	r3, [r3, #12]
9001895e:	4a15      	ldr	r2, [pc, #84]	; (900189b4 <UTIL_LCD_DisplayChar+0x68>)
90018960:	015b      	lsls	r3, r3, #5
90018962:	4413      	add	r3, r2
90018964:	3308      	adds	r3, #8
90018966:	681b      	ldr	r3, [r3, #0]
90018968:	681a      	ldr	r2, [r3, #0]
9001896a:	79fb      	ldrb	r3, [r7, #7]
9001896c:	3b20      	subs	r3, #32
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
9001896e:	4911      	ldr	r1, [pc, #68]	; (900189b4 <UTIL_LCD_DisplayChar+0x68>)
90018970:	68c9      	ldr	r1, [r1, #12]
90018972:	4810      	ldr	r0, [pc, #64]	; (900189b4 <UTIL_LCD_DisplayChar+0x68>)
90018974:	0149      	lsls	r1, r1, #5
90018976:	4401      	add	r1, r0
90018978:	3108      	adds	r1, #8
9001897a:	6809      	ldr	r1, [r1, #0]
9001897c:	88c9      	ldrh	r1, [r1, #6]
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
9001897e:	fb01 f103 	mul.w	r1, r1, r3
  DrawProp[DrawProp->LcdLayer].pFont->Height * ((DrawProp[DrawProp->LcdLayer].pFont->Width + 7) / 8)]);
90018982:	4b0c      	ldr	r3, [pc, #48]	; (900189b4 <UTIL_LCD_DisplayChar+0x68>)
90018984:	68db      	ldr	r3, [r3, #12]
90018986:	480b      	ldr	r0, [pc, #44]	; (900189b4 <UTIL_LCD_DisplayChar+0x68>)
90018988:	015b      	lsls	r3, r3, #5
9001898a:	4403      	add	r3, r0
9001898c:	3308      	adds	r3, #8
9001898e:	681b      	ldr	r3, [r3, #0]
90018990:	889b      	ldrh	r3, [r3, #4]
90018992:	3307      	adds	r3, #7
90018994:	2b00      	cmp	r3, #0
90018996:	da00      	bge.n	9001899a <UTIL_LCD_DisplayChar+0x4e>
90018998:	3307      	adds	r3, #7
9001899a:	10db      	asrs	r3, r3, #3
9001899c:	fb03 f301 	mul.w	r3, r3, r1
  DrawChar(Xpos, Ypos, &DrawProp[DrawProp->LcdLayer].pFont->table[(Ascii-' ') *\
900189a0:	4413      	add	r3, r2
900189a2:	461a      	mov	r2, r3
900189a4:	68b9      	ldr	r1, [r7, #8]
900189a6:	68f8      	ldr	r0, [r7, #12]
900189a8:	f000 fe96 	bl	900196d8 <DrawChar>
}
900189ac:	bf00      	nop
900189ae:	3710      	adds	r7, #16
900189b0:	46bd      	mov	sp, r7
900189b2:	bd80      	pop	{r7, pc}
900189b4:	2400286c 	.word	0x2400286c

900189b8 <UTIL_LCD_DisplayStringAt>:
  *            @arg  CENTER_MODE
  *            @arg  RIGHT_MODE
  *            @arg  LEFT_MODE
  */
void UTIL_LCD_DisplayStringAt(uint32_t Xpos, uint32_t Ypos, uint8_t *Text, Text_AlignModeTypdef Mode)
{
900189b8:	b580      	push	{r7, lr}
900189ba:	b08a      	sub	sp, #40	; 0x28
900189bc:	af00      	add	r7, sp, #0
900189be:	60f8      	str	r0, [r7, #12]
900189c0:	60b9      	str	r1, [r7, #8]
900189c2:	607a      	str	r2, [r7, #4]
900189c4:	70fb      	strb	r3, [r7, #3]
  uint32_t refcolumn = 1, i = 0;
900189c6:	2301      	movs	r3, #1
900189c8:	627b      	str	r3, [r7, #36]	; 0x24
900189ca:	2300      	movs	r3, #0
900189cc:	623b      	str	r3, [r7, #32]
  uint32_t size = 0, xsize = 0;
900189ce:	2300      	movs	r3, #0
900189d0:	61fb      	str	r3, [r7, #28]
900189d2:	2300      	movs	r3, #0
900189d4:	617b      	str	r3, [r7, #20]
  uint8_t  *ptr = Text;
900189d6:	687b      	ldr	r3, [r7, #4]
900189d8:	61bb      	str	r3, [r7, #24]

  /* Get the text size */
  while (*ptr++) size ++ ;
900189da:	e002      	b.n	900189e2 <UTIL_LCD_DisplayStringAt+0x2a>
900189dc:	69fb      	ldr	r3, [r7, #28]
900189de:	3301      	adds	r3, #1
900189e0:	61fb      	str	r3, [r7, #28]
900189e2:	69bb      	ldr	r3, [r7, #24]
900189e4:	1c5a      	adds	r2, r3, #1
900189e6:	61ba      	str	r2, [r7, #24]
900189e8:	781b      	ldrb	r3, [r3, #0]
900189ea:	2b00      	cmp	r3, #0
900189ec:	d1f6      	bne.n	900189dc <UTIL_LCD_DisplayStringAt+0x24>

  /* Characters number per line */
  xsize = (DrawProp->LcdXsize/DrawProp[DrawProp->LcdLayer].pFont->Width);
900189ee:	4b48      	ldr	r3, [pc, #288]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
900189f0:	695b      	ldr	r3, [r3, #20]
900189f2:	4a47      	ldr	r2, [pc, #284]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
900189f4:	68d2      	ldr	r2, [r2, #12]
900189f6:	4946      	ldr	r1, [pc, #280]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
900189f8:	0152      	lsls	r2, r2, #5
900189fa:	440a      	add	r2, r1
900189fc:	3208      	adds	r2, #8
900189fe:	6812      	ldr	r2, [r2, #0]
90018a00:	8892      	ldrh	r2, [r2, #4]
90018a02:	fbb3 f3f2 	udiv	r3, r3, r2
90018a06:	617b      	str	r3, [r7, #20]

  switch (Mode)
90018a08:	78fb      	ldrb	r3, [r7, #3]
90018a0a:	2b03      	cmp	r3, #3
90018a0c:	d018      	beq.n	90018a40 <UTIL_LCD_DisplayStringAt+0x88>
90018a0e:	2b03      	cmp	r3, #3
90018a10:	dc2a      	bgt.n	90018a68 <UTIL_LCD_DisplayStringAt+0xb0>
90018a12:	2b01      	cmp	r3, #1
90018a14:	d002      	beq.n	90018a1c <UTIL_LCD_DisplayStringAt+0x64>
90018a16:	2b02      	cmp	r3, #2
90018a18:	d015      	beq.n	90018a46 <UTIL_LCD_DisplayStringAt+0x8e>
90018a1a:	e025      	b.n	90018a68 <UTIL_LCD_DisplayStringAt+0xb0>
  {
  case CENTER_MODE:
    {
      refcolumn = Xpos + ((xsize - size)* DrawProp[DrawProp->LcdLayer].pFont->Width) / 2;
90018a1c:	697a      	ldr	r2, [r7, #20]
90018a1e:	69fb      	ldr	r3, [r7, #28]
90018a20:	1ad3      	subs	r3, r2, r3
90018a22:	4a3b      	ldr	r2, [pc, #236]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018a24:	68d2      	ldr	r2, [r2, #12]
90018a26:	493a      	ldr	r1, [pc, #232]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018a28:	0152      	lsls	r2, r2, #5
90018a2a:	440a      	add	r2, r1
90018a2c:	3208      	adds	r2, #8
90018a2e:	6812      	ldr	r2, [r2, #0]
90018a30:	8892      	ldrh	r2, [r2, #4]
90018a32:	fb02 f303 	mul.w	r3, r2, r3
90018a36:	085b      	lsrs	r3, r3, #1
90018a38:	68fa      	ldr	r2, [r7, #12]
90018a3a:	4413      	add	r3, r2
90018a3c:	627b      	str	r3, [r7, #36]	; 0x24
      break;
90018a3e:	e016      	b.n	90018a6e <UTIL_LCD_DisplayStringAt+0xb6>
    }
  case LEFT_MODE:
    {
      refcolumn = Xpos;
90018a40:	68fb      	ldr	r3, [r7, #12]
90018a42:	627b      	str	r3, [r7, #36]	; 0x24
      break;
90018a44:	e013      	b.n	90018a6e <UTIL_LCD_DisplayStringAt+0xb6>
    }
  case RIGHT_MODE:
    {
      refcolumn = - Xpos + ((xsize - size)*DrawProp[DrawProp->LcdLayer].pFont->Width);
90018a46:	697a      	ldr	r2, [r7, #20]
90018a48:	69fb      	ldr	r3, [r7, #28]
90018a4a:	1ad3      	subs	r3, r2, r3
90018a4c:	4a30      	ldr	r2, [pc, #192]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018a4e:	68d2      	ldr	r2, [r2, #12]
90018a50:	492f      	ldr	r1, [pc, #188]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018a52:	0152      	lsls	r2, r2, #5
90018a54:	440a      	add	r2, r1
90018a56:	3208      	adds	r2, #8
90018a58:	6812      	ldr	r2, [r2, #0]
90018a5a:	8892      	ldrh	r2, [r2, #4]
90018a5c:	fb02 f203 	mul.w	r2, r2, r3
90018a60:	68fb      	ldr	r3, [r7, #12]
90018a62:	1ad3      	subs	r3, r2, r3
90018a64:	627b      	str	r3, [r7, #36]	; 0x24
      break;
90018a66:	e002      	b.n	90018a6e <UTIL_LCD_DisplayStringAt+0xb6>
    }
  default:
    {
      refcolumn = Xpos;
90018a68:	68fb      	ldr	r3, [r7, #12]
90018a6a:	627b      	str	r3, [r7, #36]	; 0x24
      break;
90018a6c:	bf00      	nop
    }
  }

  /* Check that the Start column is located in the screen */
  if ((refcolumn < 1) || (refcolumn >= 0x8000))
90018a6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90018a70:	2b00      	cmp	r3, #0
90018a72:	d003      	beq.n	90018a7c <UTIL_LCD_DisplayStringAt+0xc4>
90018a74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90018a76:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
90018a7a:	d31b      	bcc.n	90018ab4 <UTIL_LCD_DisplayStringAt+0xfc>
  {
    refcolumn = 1;
90018a7c:	2301      	movs	r3, #1
90018a7e:	627b      	str	r3, [r7, #36]	; 0x24
  }

  /* Send the string character by character on LCD */
  while ((*Text != 0) & (((DrawProp->LcdXsize - (i*DrawProp[DrawProp->LcdLayer].pFont->Width)) & 0xFFFF) >= DrawProp[DrawProp->LcdLayer].pFont->Width))
90018a80:	e018      	b.n	90018ab4 <UTIL_LCD_DisplayStringAt+0xfc>
  {
    /* Display one character on LCD */
    UTIL_LCD_DisplayChar(refcolumn, Ypos, *Text);
90018a82:	687b      	ldr	r3, [r7, #4]
90018a84:	781b      	ldrb	r3, [r3, #0]
90018a86:	461a      	mov	r2, r3
90018a88:	68b9      	ldr	r1, [r7, #8]
90018a8a:	6a78      	ldr	r0, [r7, #36]	; 0x24
90018a8c:	f7ff ff5e 	bl	9001894c <UTIL_LCD_DisplayChar>
    /* Decrement the column position by 16 */
    refcolumn += DrawProp[DrawProp->LcdLayer].pFont->Width;
90018a90:	4b1f      	ldr	r3, [pc, #124]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018a92:	68db      	ldr	r3, [r3, #12]
90018a94:	4a1e      	ldr	r2, [pc, #120]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018a96:	015b      	lsls	r3, r3, #5
90018a98:	4413      	add	r3, r2
90018a9a:	3308      	adds	r3, #8
90018a9c:	681b      	ldr	r3, [r3, #0]
90018a9e:	889b      	ldrh	r3, [r3, #4]
90018aa0:	461a      	mov	r2, r3
90018aa2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
90018aa4:	4413      	add	r3, r2
90018aa6:	627b      	str	r3, [r7, #36]	; 0x24

    /* Point on the next character */
    Text++;
90018aa8:	687b      	ldr	r3, [r7, #4]
90018aaa:	3301      	adds	r3, #1
90018aac:	607b      	str	r3, [r7, #4]
    i++;
90018aae:	6a3b      	ldr	r3, [r7, #32]
90018ab0:	3301      	adds	r3, #1
90018ab2:	623b      	str	r3, [r7, #32]
  while ((*Text != 0) & (((DrawProp->LcdXsize - (i*DrawProp[DrawProp->LcdLayer].pFont->Width)) & 0xFFFF) >= DrawProp[DrawProp->LcdLayer].pFont->Width))
90018ab4:	687b      	ldr	r3, [r7, #4]
90018ab6:	781b      	ldrb	r3, [r3, #0]
90018ab8:	2b00      	cmp	r3, #0
90018aba:	bf14      	ite	ne
90018abc:	2301      	movne	r3, #1
90018abe:	2300      	moveq	r3, #0
90018ac0:	b2da      	uxtb	r2, r3
90018ac2:	4b13      	ldr	r3, [pc, #76]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018ac4:	6959      	ldr	r1, [r3, #20]
90018ac6:	4b12      	ldr	r3, [pc, #72]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018ac8:	68db      	ldr	r3, [r3, #12]
90018aca:	4811      	ldr	r0, [pc, #68]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018acc:	015b      	lsls	r3, r3, #5
90018ace:	4403      	add	r3, r0
90018ad0:	3308      	adds	r3, #8
90018ad2:	681b      	ldr	r3, [r3, #0]
90018ad4:	889b      	ldrh	r3, [r3, #4]
90018ad6:	4618      	mov	r0, r3
90018ad8:	6a3b      	ldr	r3, [r7, #32]
90018ada:	fb03 f300 	mul.w	r3, r3, r0
90018ade:	1acb      	subs	r3, r1, r3
90018ae0:	b29b      	uxth	r3, r3
90018ae2:	490b      	ldr	r1, [pc, #44]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018ae4:	68c9      	ldr	r1, [r1, #12]
90018ae6:	480a      	ldr	r0, [pc, #40]	; (90018b10 <UTIL_LCD_DisplayStringAt+0x158>)
90018ae8:	0149      	lsls	r1, r1, #5
90018aea:	4401      	add	r1, r0
90018aec:	3108      	adds	r1, #8
90018aee:	6809      	ldr	r1, [r1, #0]
90018af0:	8889      	ldrh	r1, [r1, #4]
90018af2:	428b      	cmp	r3, r1
90018af4:	bf2c      	ite	cs
90018af6:	2301      	movcs	r3, #1
90018af8:	2300      	movcc	r3, #0
90018afa:	b2db      	uxtb	r3, r3
90018afc:	4013      	ands	r3, r2
90018afe:	b2db      	uxtb	r3, r3
90018b00:	2b00      	cmp	r3, #0
90018b02:	d1be      	bne.n	90018a82 <UTIL_LCD_DisplayStringAt+0xca>
  }
}
90018b04:	bf00      	nop
90018b06:	bf00      	nop
90018b08:	3728      	adds	r7, #40	; 0x28
90018b0a:	46bd      	mov	sp, r7
90018b0c:	bd80      	pop	{r7, pc}
90018b0e:	bf00      	nop
90018b10:	2400286c 	.word	0x2400286c

90018b14 <UTIL_LCD_DrawLine>:
  * @param  Xpos2 Point 2 X position
  * @param  Ypos2 Point 2 Y position
  * @param  Color Draw color
  */
void UTIL_LCD_DrawLine(uint32_t Xpos1, uint32_t Ypos1, uint32_t Xpos2, uint32_t Ypos2, uint32_t Color)
{
90018b14:	b580      	push	{r7, lr}
90018b16:	b08e      	sub	sp, #56	; 0x38
90018b18:	af00      	add	r7, sp, #0
90018b1a:	60f8      	str	r0, [r7, #12]
90018b1c:	60b9      	str	r1, [r7, #8]
90018b1e:	607a      	str	r2, [r7, #4]
90018b20:	603b      	str	r3, [r7, #0]
  int16_t deltax = 0, deltay = 0, x = 0, y = 0, xinc1 = 0, xinc2 = 0,
90018b22:	2300      	movs	r3, #0
90018b24:	843b      	strh	r3, [r7, #32]
90018b26:	2300      	movs	r3, #0
90018b28:	83fb      	strh	r3, [r7, #30]
90018b2a:	2300      	movs	r3, #0
90018b2c:	86fb      	strh	r3, [r7, #54]	; 0x36
90018b2e:	2300      	movs	r3, #0
90018b30:	86bb      	strh	r3, [r7, #52]	; 0x34
90018b32:	2300      	movs	r3, #0
90018b34:	867b      	strh	r3, [r7, #50]	; 0x32
90018b36:	2300      	movs	r3, #0
90018b38:	863b      	strh	r3, [r7, #48]	; 0x30
  yinc1 = 0, yinc2 = 0, den = 0, num = 0, numadd = 0, numpixels = 0,
90018b3a:	2300      	movs	r3, #0
90018b3c:	85fb      	strh	r3, [r7, #46]	; 0x2e
90018b3e:	2300      	movs	r3, #0
90018b40:	85bb      	strh	r3, [r7, #44]	; 0x2c
90018b42:	2300      	movs	r3, #0
90018b44:	857b      	strh	r3, [r7, #42]	; 0x2a
90018b46:	2300      	movs	r3, #0
90018b48:	853b      	strh	r3, [r7, #40]	; 0x28
90018b4a:	2300      	movs	r3, #0
90018b4c:	84fb      	strh	r3, [r7, #38]	; 0x26
90018b4e:	2300      	movs	r3, #0
90018b50:	84bb      	strh	r3, [r7, #36]	; 0x24
  curpixel = 0;
90018b52:	2300      	movs	r3, #0
90018b54:	847b      	strh	r3, [r7, #34]	; 0x22
  int32_t x_diff, y_diff;

  x_diff = Xpos2 - Xpos1;
90018b56:	687a      	ldr	r2, [r7, #4]
90018b58:	68fb      	ldr	r3, [r7, #12]
90018b5a:	1ad3      	subs	r3, r2, r3
90018b5c:	61bb      	str	r3, [r7, #24]
  y_diff = Ypos2 - Ypos1;
90018b5e:	683a      	ldr	r2, [r7, #0]
90018b60:	68bb      	ldr	r3, [r7, #8]
90018b62:	1ad3      	subs	r3, r2, r3
90018b64:	617b      	str	r3, [r7, #20]

  deltax = ABS(x_diff);         /* The absolute difference between the x's */
90018b66:	69bb      	ldr	r3, [r7, #24]
90018b68:	2b00      	cmp	r3, #0
90018b6a:	bfb8      	it	lt
90018b6c:	425b      	neglt	r3, r3
90018b6e:	843b      	strh	r3, [r7, #32]
  deltay = ABS(y_diff);         /* The absolute difference between the y's */
90018b70:	697b      	ldr	r3, [r7, #20]
90018b72:	2b00      	cmp	r3, #0
90018b74:	bfb8      	it	lt
90018b76:	425b      	neglt	r3, r3
90018b78:	83fb      	strh	r3, [r7, #30]
  x = Xpos1;                       /* Start x off at the first pixel */
90018b7a:	68fb      	ldr	r3, [r7, #12]
90018b7c:	86fb      	strh	r3, [r7, #54]	; 0x36
  y = Ypos1;                       /* Start y off at the first pixel */
90018b7e:	68bb      	ldr	r3, [r7, #8]
90018b80:	86bb      	strh	r3, [r7, #52]	; 0x34

  if (Xpos2 >= Xpos1)                 /* The x-values are increasing */
90018b82:	687a      	ldr	r2, [r7, #4]
90018b84:	68fb      	ldr	r3, [r7, #12]
90018b86:	429a      	cmp	r2, r3
90018b88:	d304      	bcc.n	90018b94 <UTIL_LCD_DrawLine+0x80>
  {
    xinc1 = 1;
90018b8a:	2301      	movs	r3, #1
90018b8c:	867b      	strh	r3, [r7, #50]	; 0x32
    xinc2 = 1;
90018b8e:	2301      	movs	r3, #1
90018b90:	863b      	strh	r3, [r7, #48]	; 0x30
90018b92:	e005      	b.n	90018ba0 <UTIL_LCD_DrawLine+0x8c>
  }
  else                          /* The x-values are decreasing */
  {
    xinc1 = -1;
90018b94:	f64f 73ff 	movw	r3, #65535	; 0xffff
90018b98:	867b      	strh	r3, [r7, #50]	; 0x32
    xinc2 = -1;
90018b9a:	f64f 73ff 	movw	r3, #65535	; 0xffff
90018b9e:	863b      	strh	r3, [r7, #48]	; 0x30
  }

  if (Ypos2 >= Ypos1)                 /* The y-values are increasing */
90018ba0:	683a      	ldr	r2, [r7, #0]
90018ba2:	68bb      	ldr	r3, [r7, #8]
90018ba4:	429a      	cmp	r2, r3
90018ba6:	d304      	bcc.n	90018bb2 <UTIL_LCD_DrawLine+0x9e>
  {
    yinc1 = 1;
90018ba8:	2301      	movs	r3, #1
90018baa:	85fb      	strh	r3, [r7, #46]	; 0x2e
    yinc2 = 1;
90018bac:	2301      	movs	r3, #1
90018bae:	85bb      	strh	r3, [r7, #44]	; 0x2c
90018bb0:	e005      	b.n	90018bbe <UTIL_LCD_DrawLine+0xaa>
  }
  else                          /* The y-values are decreasing */
  {
    yinc1 = -1;
90018bb2:	f64f 73ff 	movw	r3, #65535	; 0xffff
90018bb6:	85fb      	strh	r3, [r7, #46]	; 0x2e
    yinc2 = -1;
90018bb8:	f64f 73ff 	movw	r3, #65535	; 0xffff
90018bbc:	85bb      	strh	r3, [r7, #44]	; 0x2c
  }

  if (deltax >= deltay)         /* There is at least one x-value for every y-value */
90018bbe:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
90018bc2:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
90018bc6:	429a      	cmp	r2, r3
90018bc8:	db11      	blt.n	90018bee <UTIL_LCD_DrawLine+0xda>
  {
    xinc1 = 0;                  /* Don't change the x when numerator >= denominator */
90018bca:	2300      	movs	r3, #0
90018bcc:	867b      	strh	r3, [r7, #50]	; 0x32
    yinc2 = 0;                  /* Don't change the y for every iteration */
90018bce:	2300      	movs	r3, #0
90018bd0:	85bb      	strh	r3, [r7, #44]	; 0x2c
    den = deltax;
90018bd2:	8c3b      	ldrh	r3, [r7, #32]
90018bd4:	857b      	strh	r3, [r7, #42]	; 0x2a
    num = deltax / 2;
90018bd6:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
90018bda:	2b00      	cmp	r3, #0
90018bdc:	da00      	bge.n	90018be0 <UTIL_LCD_DrawLine+0xcc>
90018bde:	3301      	adds	r3, #1
90018be0:	105b      	asrs	r3, r3, #1
90018be2:	853b      	strh	r3, [r7, #40]	; 0x28
    numadd = deltay;
90018be4:	8bfb      	ldrh	r3, [r7, #30]
90018be6:	84fb      	strh	r3, [r7, #38]	; 0x26
    numpixels = deltax;         /* There are more x-values than y-values */
90018be8:	8c3b      	ldrh	r3, [r7, #32]
90018bea:	84bb      	strh	r3, [r7, #36]	; 0x24
90018bec:	e010      	b.n	90018c10 <UTIL_LCD_DrawLine+0xfc>
  }
  else                          /* There is at least one y-value for every x-value */
  {
    xinc2 = 0;                  /* Don't change the x for every iteration */
90018bee:	2300      	movs	r3, #0
90018bf0:	863b      	strh	r3, [r7, #48]	; 0x30
    yinc1 = 0;                  /* Don't change the y when numerator >= denominator */
90018bf2:	2300      	movs	r3, #0
90018bf4:	85fb      	strh	r3, [r7, #46]	; 0x2e
    den = deltay;
90018bf6:	8bfb      	ldrh	r3, [r7, #30]
90018bf8:	857b      	strh	r3, [r7, #42]	; 0x2a
    num = deltay / 2;
90018bfa:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
90018bfe:	2b00      	cmp	r3, #0
90018c00:	da00      	bge.n	90018c04 <UTIL_LCD_DrawLine+0xf0>
90018c02:	3301      	adds	r3, #1
90018c04:	105b      	asrs	r3, r3, #1
90018c06:	853b      	strh	r3, [r7, #40]	; 0x28
    numadd = deltax;
90018c08:	8c3b      	ldrh	r3, [r7, #32]
90018c0a:	84fb      	strh	r3, [r7, #38]	; 0x26
    numpixels = deltay;         /* There are more y-values than x-values */
90018c0c:	8bfb      	ldrh	r3, [r7, #30]
90018c0e:	84bb      	strh	r3, [r7, #36]	; 0x24
  }

  for (curpixel = 0; curpixel <= numpixels; curpixel++)
90018c10:	2300      	movs	r3, #0
90018c12:	847b      	strh	r3, [r7, #34]	; 0x22
90018c14:	e02f      	b.n	90018c76 <UTIL_LCD_DrawLine+0x162>
  {
    UTIL_LCD_SetPixel(x, y, Color);   /* Draw the current pixel */
90018c16:	8efb      	ldrh	r3, [r7, #54]	; 0x36
90018c18:	8eb9      	ldrh	r1, [r7, #52]	; 0x34
90018c1a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
90018c1c:	4618      	mov	r0, r3
90018c1e:	f7ff fe4b 	bl	900188b8 <UTIL_LCD_SetPixel>
    num += numadd;                            /* Increase the numerator by the top of the fraction */
90018c22:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
90018c24:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
90018c26:	4413      	add	r3, r2
90018c28:	b29b      	uxth	r3, r3
90018c2a:	853b      	strh	r3, [r7, #40]	; 0x28
    if (num >= den)                           /* Check if numerator >= denominator */
90018c2c:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
90018c30:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
90018c34:	429a      	cmp	r2, r3
90018c36:	db0e      	blt.n	90018c56 <UTIL_LCD_DrawLine+0x142>
    {
      num -= den;                             /* Calculate the new numerator value */
90018c38:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
90018c3a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
90018c3c:	1ad3      	subs	r3, r2, r3
90018c3e:	b29b      	uxth	r3, r3
90018c40:	853b      	strh	r3, [r7, #40]	; 0x28
      x += xinc1;                             /* Change the x as appropriate */
90018c42:	8efa      	ldrh	r2, [r7, #54]	; 0x36
90018c44:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
90018c46:	4413      	add	r3, r2
90018c48:	b29b      	uxth	r3, r3
90018c4a:	86fb      	strh	r3, [r7, #54]	; 0x36
      y += yinc1;                             /* Change the y as appropriate */
90018c4c:	8eba      	ldrh	r2, [r7, #52]	; 0x34
90018c4e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
90018c50:	4413      	add	r3, r2
90018c52:	b29b      	uxth	r3, r3
90018c54:	86bb      	strh	r3, [r7, #52]	; 0x34
    }
    x += xinc2;                               /* Change the x as appropriate */
90018c56:	8efa      	ldrh	r2, [r7, #54]	; 0x36
90018c58:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
90018c5a:	4413      	add	r3, r2
90018c5c:	b29b      	uxth	r3, r3
90018c5e:	86fb      	strh	r3, [r7, #54]	; 0x36
    y += yinc2;                               /* Change the y as appropriate */
90018c60:	8eba      	ldrh	r2, [r7, #52]	; 0x34
90018c62:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
90018c64:	4413      	add	r3, r2
90018c66:	b29b      	uxth	r3, r3
90018c68:	86bb      	strh	r3, [r7, #52]	; 0x34
  for (curpixel = 0; curpixel <= numpixels; curpixel++)
90018c6a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
90018c6e:	b29b      	uxth	r3, r3
90018c70:	3301      	adds	r3, #1
90018c72:	b29b      	uxth	r3, r3
90018c74:	847b      	strh	r3, [r7, #34]	; 0x22
90018c76:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
90018c7a:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
90018c7e:	429a      	cmp	r2, r3
90018c80:	ddc9      	ble.n	90018c16 <UTIL_LCD_DrawLine+0x102>
  }
}
90018c82:	bf00      	nop
90018c84:	bf00      	nop
90018c86:	3738      	adds	r7, #56	; 0x38
90018c88:	46bd      	mov	sp, r7
90018c8a:	bd80      	pop	{r7, pc}

90018c8c <UTIL_LCD_DrawRect>:
  * @param  Width  Rectangle width
  * @param  Height Rectangle height
  * @param  Color  Draw color
  */
void UTIL_LCD_DrawRect(uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
90018c8c:	b580      	push	{r7, lr}
90018c8e:	b084      	sub	sp, #16
90018c90:	af00      	add	r7, sp, #0
90018c92:	60f8      	str	r0, [r7, #12]
90018c94:	60b9      	str	r1, [r7, #8]
90018c96:	607a      	str	r2, [r7, #4]
90018c98:	603b      	str	r3, [r7, #0]
  /* Draw horizontal lines */
  UTIL_LCD_DrawHLine(Xpos, Ypos, Width, Color);
90018c9a:	69bb      	ldr	r3, [r7, #24]
90018c9c:	687a      	ldr	r2, [r7, #4]
90018c9e:	68b9      	ldr	r1, [r7, #8]
90018ca0:	68f8      	ldr	r0, [r7, #12]
90018ca2:	f7ff fd9d 	bl	900187e0 <UTIL_LCD_DrawHLine>
  UTIL_LCD_DrawHLine(Xpos, (Ypos+ Height - 1U), Width, Color);
90018ca6:	68ba      	ldr	r2, [r7, #8]
90018ca8:	683b      	ldr	r3, [r7, #0]
90018caa:	4413      	add	r3, r2
90018cac:	1e59      	subs	r1, r3, #1
90018cae:	69bb      	ldr	r3, [r7, #24]
90018cb0:	687a      	ldr	r2, [r7, #4]
90018cb2:	68f8      	ldr	r0, [r7, #12]
90018cb4:	f7ff fd94 	bl	900187e0 <UTIL_LCD_DrawHLine>

  /* Draw vertical lines */
  UTIL_LCD_DrawVLine(Xpos, Ypos, Height, Color);
90018cb8:	69bb      	ldr	r3, [r7, #24]
90018cba:	683a      	ldr	r2, [r7, #0]
90018cbc:	68b9      	ldr	r1, [r7, #8]
90018cbe:	68f8      	ldr	r0, [r7, #12]
90018cc0:	f7ff fdc4 	bl	9001884c <UTIL_LCD_DrawVLine>
  UTIL_LCD_DrawVLine((Xpos + Width - 1U), Ypos, Height, Color);
90018cc4:	68fa      	ldr	r2, [r7, #12]
90018cc6:	687b      	ldr	r3, [r7, #4]
90018cc8:	4413      	add	r3, r2
90018cca:	1e58      	subs	r0, r3, #1
90018ccc:	69bb      	ldr	r3, [r7, #24]
90018cce:	683a      	ldr	r2, [r7, #0]
90018cd0:	68b9      	ldr	r1, [r7, #8]
90018cd2:	f7ff fdbb 	bl	9001884c <UTIL_LCD_DrawVLine>
}
90018cd6:	bf00      	nop
90018cd8:	3710      	adds	r7, #16
90018cda:	46bd      	mov	sp, r7
90018cdc:	bd80      	pop	{r7, pc}
	...

90018ce0 <UTIL_LCD_DrawCircle>:
  * @param  Ypos    Y position
  * @param  Radius  Circle radius
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawCircle(uint32_t Xpos, uint32_t Ypos, uint32_t Radius, uint32_t Color)
{
90018ce0:	b580      	push	{r7, lr}
90018ce2:	b088      	sub	sp, #32
90018ce4:	af00      	add	r7, sp, #0
90018ce6:	60f8      	str	r0, [r7, #12]
90018ce8:	60b9      	str	r1, [r7, #8]
90018cea:	607a      	str	r2, [r7, #4]
90018cec:	603b      	str	r3, [r7, #0]
  int32_t   decision;  /* Decision Variable */
  uint32_t  current_x; /* Current X Value */
  uint32_t  current_y; /* Current Y Value */

  decision = 3 - (Radius << 1);
90018cee:	687b      	ldr	r3, [r7, #4]
90018cf0:	005b      	lsls	r3, r3, #1
90018cf2:	f1c3 0303 	rsb	r3, r3, #3
90018cf6:	61fb      	str	r3, [r7, #28]
  current_x = 0;
90018cf8:	2300      	movs	r3, #0
90018cfa:	61bb      	str	r3, [r7, #24]
  current_y = Radius;
90018cfc:	687b      	ldr	r3, [r7, #4]
90018cfe:	617b      	str	r3, [r7, #20]

  while (current_x <= current_y)
90018d00:	e0eb      	b.n	90018eda <UTIL_LCD_DrawCircle+0x1fa>
  {
    if((Ypos - current_y) < DrawProp->LcdYsize)
90018d02:	68ba      	ldr	r2, [r7, #8]
90018d04:	697b      	ldr	r3, [r7, #20]
90018d06:	1ad2      	subs	r2, r2, r3
90018d08:	4b79      	ldr	r3, [pc, #484]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018d0a:	699b      	ldr	r3, [r3, #24]
90018d0c:	429a      	cmp	r2, r3
90018d0e:	d22d      	bcs.n	90018d6c <UTIL_LCD_DrawCircle+0x8c>
    {
      if((Xpos + current_x) < DrawProp->LcdXsize)
90018d10:	68fa      	ldr	r2, [r7, #12]
90018d12:	69bb      	ldr	r3, [r7, #24]
90018d14:	441a      	add	r2, r3
90018d16:	4b76      	ldr	r3, [pc, #472]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018d18:	695b      	ldr	r3, [r3, #20]
90018d1a:	429a      	cmp	r2, r3
90018d1c:	d20f      	bcs.n	90018d3e <UTIL_LCD_DrawCircle+0x5e>
      {
        UTIL_LCD_SetPixel((Xpos + current_x), (Ypos - current_y), Color);
90018d1e:	68fb      	ldr	r3, [r7, #12]
90018d20:	b29a      	uxth	r2, r3
90018d22:	69bb      	ldr	r3, [r7, #24]
90018d24:	b29b      	uxth	r3, r3
90018d26:	4413      	add	r3, r2
90018d28:	b298      	uxth	r0, r3
90018d2a:	68bb      	ldr	r3, [r7, #8]
90018d2c:	b29a      	uxth	r2, r3
90018d2e:	697b      	ldr	r3, [r7, #20]
90018d30:	b29b      	uxth	r3, r3
90018d32:	1ad3      	subs	r3, r2, r3
90018d34:	b29b      	uxth	r3, r3
90018d36:	683a      	ldr	r2, [r7, #0]
90018d38:	4619      	mov	r1, r3
90018d3a:	f7ff fdbd 	bl	900188b8 <UTIL_LCD_SetPixel>
      }
      if((Xpos - current_x) < DrawProp->LcdXsize)
90018d3e:	68fa      	ldr	r2, [r7, #12]
90018d40:	69bb      	ldr	r3, [r7, #24]
90018d42:	1ad2      	subs	r2, r2, r3
90018d44:	4b6a      	ldr	r3, [pc, #424]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018d46:	695b      	ldr	r3, [r3, #20]
90018d48:	429a      	cmp	r2, r3
90018d4a:	d20f      	bcs.n	90018d6c <UTIL_LCD_DrawCircle+0x8c>
      {
        UTIL_LCD_SetPixel((Xpos - current_x), (Ypos - current_y), Color);
90018d4c:	68fb      	ldr	r3, [r7, #12]
90018d4e:	b29a      	uxth	r2, r3
90018d50:	69bb      	ldr	r3, [r7, #24]
90018d52:	b29b      	uxth	r3, r3
90018d54:	1ad3      	subs	r3, r2, r3
90018d56:	b298      	uxth	r0, r3
90018d58:	68bb      	ldr	r3, [r7, #8]
90018d5a:	b29a      	uxth	r2, r3
90018d5c:	697b      	ldr	r3, [r7, #20]
90018d5e:	b29b      	uxth	r3, r3
90018d60:	1ad3      	subs	r3, r2, r3
90018d62:	b29b      	uxth	r3, r3
90018d64:	683a      	ldr	r2, [r7, #0]
90018d66:	4619      	mov	r1, r3
90018d68:	f7ff fda6 	bl	900188b8 <UTIL_LCD_SetPixel>
      }
    }

    if((Ypos - current_x) < DrawProp->LcdYsize)
90018d6c:	68ba      	ldr	r2, [r7, #8]
90018d6e:	69bb      	ldr	r3, [r7, #24]
90018d70:	1ad2      	subs	r2, r2, r3
90018d72:	4b5f      	ldr	r3, [pc, #380]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018d74:	699b      	ldr	r3, [r3, #24]
90018d76:	429a      	cmp	r2, r3
90018d78:	d22d      	bcs.n	90018dd6 <UTIL_LCD_DrawCircle+0xf6>
    {
      if((Xpos + current_y) < DrawProp->LcdXsize)
90018d7a:	68fa      	ldr	r2, [r7, #12]
90018d7c:	697b      	ldr	r3, [r7, #20]
90018d7e:	441a      	add	r2, r3
90018d80:	4b5b      	ldr	r3, [pc, #364]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018d82:	695b      	ldr	r3, [r3, #20]
90018d84:	429a      	cmp	r2, r3
90018d86:	d20f      	bcs.n	90018da8 <UTIL_LCD_DrawCircle+0xc8>
      {
        UTIL_LCD_SetPixel((Xpos + current_y), (Ypos - current_x), Color);
90018d88:	68fb      	ldr	r3, [r7, #12]
90018d8a:	b29a      	uxth	r2, r3
90018d8c:	697b      	ldr	r3, [r7, #20]
90018d8e:	b29b      	uxth	r3, r3
90018d90:	4413      	add	r3, r2
90018d92:	b298      	uxth	r0, r3
90018d94:	68bb      	ldr	r3, [r7, #8]
90018d96:	b29a      	uxth	r2, r3
90018d98:	69bb      	ldr	r3, [r7, #24]
90018d9a:	b29b      	uxth	r3, r3
90018d9c:	1ad3      	subs	r3, r2, r3
90018d9e:	b29b      	uxth	r3, r3
90018da0:	683a      	ldr	r2, [r7, #0]
90018da2:	4619      	mov	r1, r3
90018da4:	f7ff fd88 	bl	900188b8 <UTIL_LCD_SetPixel>
      }
      if((Xpos - current_y) < DrawProp->LcdXsize)
90018da8:	68fa      	ldr	r2, [r7, #12]
90018daa:	697b      	ldr	r3, [r7, #20]
90018dac:	1ad2      	subs	r2, r2, r3
90018dae:	4b50      	ldr	r3, [pc, #320]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018db0:	695b      	ldr	r3, [r3, #20]
90018db2:	429a      	cmp	r2, r3
90018db4:	d20f      	bcs.n	90018dd6 <UTIL_LCD_DrawCircle+0xf6>
      {
        UTIL_LCD_SetPixel((Xpos - current_y), (Ypos - current_x), Color);
90018db6:	68fb      	ldr	r3, [r7, #12]
90018db8:	b29a      	uxth	r2, r3
90018dba:	697b      	ldr	r3, [r7, #20]
90018dbc:	b29b      	uxth	r3, r3
90018dbe:	1ad3      	subs	r3, r2, r3
90018dc0:	b298      	uxth	r0, r3
90018dc2:	68bb      	ldr	r3, [r7, #8]
90018dc4:	b29a      	uxth	r2, r3
90018dc6:	69bb      	ldr	r3, [r7, #24]
90018dc8:	b29b      	uxth	r3, r3
90018dca:	1ad3      	subs	r3, r2, r3
90018dcc:	b29b      	uxth	r3, r3
90018dce:	683a      	ldr	r2, [r7, #0]
90018dd0:	4619      	mov	r1, r3
90018dd2:	f7ff fd71 	bl	900188b8 <UTIL_LCD_SetPixel>
      }
    }

    if((Ypos + current_y) < DrawProp->LcdYsize)
90018dd6:	68ba      	ldr	r2, [r7, #8]
90018dd8:	697b      	ldr	r3, [r7, #20]
90018dda:	441a      	add	r2, r3
90018ddc:	4b44      	ldr	r3, [pc, #272]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018dde:	699b      	ldr	r3, [r3, #24]
90018de0:	429a      	cmp	r2, r3
90018de2:	d22d      	bcs.n	90018e40 <UTIL_LCD_DrawCircle+0x160>
    {
      if((Xpos + current_x) < DrawProp->LcdXsize)
90018de4:	68fa      	ldr	r2, [r7, #12]
90018de6:	69bb      	ldr	r3, [r7, #24]
90018de8:	441a      	add	r2, r3
90018dea:	4b41      	ldr	r3, [pc, #260]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018dec:	695b      	ldr	r3, [r3, #20]
90018dee:	429a      	cmp	r2, r3
90018df0:	d20f      	bcs.n	90018e12 <UTIL_LCD_DrawCircle+0x132>
      {
        UTIL_LCD_SetPixel((Xpos + current_x), (Ypos + current_y), Color);
90018df2:	68fb      	ldr	r3, [r7, #12]
90018df4:	b29a      	uxth	r2, r3
90018df6:	69bb      	ldr	r3, [r7, #24]
90018df8:	b29b      	uxth	r3, r3
90018dfa:	4413      	add	r3, r2
90018dfc:	b298      	uxth	r0, r3
90018dfe:	68bb      	ldr	r3, [r7, #8]
90018e00:	b29a      	uxth	r2, r3
90018e02:	697b      	ldr	r3, [r7, #20]
90018e04:	b29b      	uxth	r3, r3
90018e06:	4413      	add	r3, r2
90018e08:	b29b      	uxth	r3, r3
90018e0a:	683a      	ldr	r2, [r7, #0]
90018e0c:	4619      	mov	r1, r3
90018e0e:	f7ff fd53 	bl	900188b8 <UTIL_LCD_SetPixel>
      }
      if((Xpos - current_x) < DrawProp->LcdXsize)
90018e12:	68fa      	ldr	r2, [r7, #12]
90018e14:	69bb      	ldr	r3, [r7, #24]
90018e16:	1ad2      	subs	r2, r2, r3
90018e18:	4b35      	ldr	r3, [pc, #212]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018e1a:	695b      	ldr	r3, [r3, #20]
90018e1c:	429a      	cmp	r2, r3
90018e1e:	d20f      	bcs.n	90018e40 <UTIL_LCD_DrawCircle+0x160>
      {
        UTIL_LCD_SetPixel((Xpos - current_x), (Ypos + current_y), Color);
90018e20:	68fb      	ldr	r3, [r7, #12]
90018e22:	b29a      	uxth	r2, r3
90018e24:	69bb      	ldr	r3, [r7, #24]
90018e26:	b29b      	uxth	r3, r3
90018e28:	1ad3      	subs	r3, r2, r3
90018e2a:	b298      	uxth	r0, r3
90018e2c:	68bb      	ldr	r3, [r7, #8]
90018e2e:	b29a      	uxth	r2, r3
90018e30:	697b      	ldr	r3, [r7, #20]
90018e32:	b29b      	uxth	r3, r3
90018e34:	4413      	add	r3, r2
90018e36:	b29b      	uxth	r3, r3
90018e38:	683a      	ldr	r2, [r7, #0]
90018e3a:	4619      	mov	r1, r3
90018e3c:	f7ff fd3c 	bl	900188b8 <UTIL_LCD_SetPixel>
      }
    }

    if((Ypos + current_x) < DrawProp->LcdYsize)
90018e40:	68ba      	ldr	r2, [r7, #8]
90018e42:	69bb      	ldr	r3, [r7, #24]
90018e44:	441a      	add	r2, r3
90018e46:	4b2a      	ldr	r3, [pc, #168]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018e48:	699b      	ldr	r3, [r3, #24]
90018e4a:	429a      	cmp	r2, r3
90018e4c:	d22d      	bcs.n	90018eaa <UTIL_LCD_DrawCircle+0x1ca>
    {
      if((Xpos + current_y) < DrawProp->LcdXsize)
90018e4e:	68fa      	ldr	r2, [r7, #12]
90018e50:	697b      	ldr	r3, [r7, #20]
90018e52:	441a      	add	r2, r3
90018e54:	4b26      	ldr	r3, [pc, #152]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018e56:	695b      	ldr	r3, [r3, #20]
90018e58:	429a      	cmp	r2, r3
90018e5a:	d20f      	bcs.n	90018e7c <UTIL_LCD_DrawCircle+0x19c>
      {
        UTIL_LCD_SetPixel((Xpos + current_y), (Ypos + current_x), Color);
90018e5c:	68fb      	ldr	r3, [r7, #12]
90018e5e:	b29a      	uxth	r2, r3
90018e60:	697b      	ldr	r3, [r7, #20]
90018e62:	b29b      	uxth	r3, r3
90018e64:	4413      	add	r3, r2
90018e66:	b298      	uxth	r0, r3
90018e68:	68bb      	ldr	r3, [r7, #8]
90018e6a:	b29a      	uxth	r2, r3
90018e6c:	69bb      	ldr	r3, [r7, #24]
90018e6e:	b29b      	uxth	r3, r3
90018e70:	4413      	add	r3, r2
90018e72:	b29b      	uxth	r3, r3
90018e74:	683a      	ldr	r2, [r7, #0]
90018e76:	4619      	mov	r1, r3
90018e78:	f7ff fd1e 	bl	900188b8 <UTIL_LCD_SetPixel>
      }
      if((Xpos - current_y) < DrawProp->LcdXsize)
90018e7c:	68fa      	ldr	r2, [r7, #12]
90018e7e:	697b      	ldr	r3, [r7, #20]
90018e80:	1ad2      	subs	r2, r2, r3
90018e82:	4b1b      	ldr	r3, [pc, #108]	; (90018ef0 <UTIL_LCD_DrawCircle+0x210>)
90018e84:	695b      	ldr	r3, [r3, #20]
90018e86:	429a      	cmp	r2, r3
90018e88:	d20f      	bcs.n	90018eaa <UTIL_LCD_DrawCircle+0x1ca>
      {
        UTIL_LCD_SetPixel((Xpos - current_y), (Ypos + current_x), Color);
90018e8a:	68fb      	ldr	r3, [r7, #12]
90018e8c:	b29a      	uxth	r2, r3
90018e8e:	697b      	ldr	r3, [r7, #20]
90018e90:	b29b      	uxth	r3, r3
90018e92:	1ad3      	subs	r3, r2, r3
90018e94:	b298      	uxth	r0, r3
90018e96:	68bb      	ldr	r3, [r7, #8]
90018e98:	b29a      	uxth	r2, r3
90018e9a:	69bb      	ldr	r3, [r7, #24]
90018e9c:	b29b      	uxth	r3, r3
90018e9e:	4413      	add	r3, r2
90018ea0:	b29b      	uxth	r3, r3
90018ea2:	683a      	ldr	r2, [r7, #0]
90018ea4:	4619      	mov	r1, r3
90018ea6:	f7ff fd07 	bl	900188b8 <UTIL_LCD_SetPixel>
      }
    }

    if (decision < 0)
90018eaa:	69fb      	ldr	r3, [r7, #28]
90018eac:	2b00      	cmp	r3, #0
90018eae:	da06      	bge.n	90018ebe <UTIL_LCD_DrawCircle+0x1de>
    {
      decision += (current_x << 2) + 6;
90018eb0:	69bb      	ldr	r3, [r7, #24]
90018eb2:	009a      	lsls	r2, r3, #2
90018eb4:	69fb      	ldr	r3, [r7, #28]
90018eb6:	4413      	add	r3, r2
90018eb8:	3306      	adds	r3, #6
90018eba:	61fb      	str	r3, [r7, #28]
90018ebc:	e00a      	b.n	90018ed4 <UTIL_LCD_DrawCircle+0x1f4>
    }
    else
    {
      decision += ((current_x - current_y) << 2) + 10;
90018ebe:	69ba      	ldr	r2, [r7, #24]
90018ec0:	697b      	ldr	r3, [r7, #20]
90018ec2:	1ad3      	subs	r3, r2, r3
90018ec4:	009a      	lsls	r2, r3, #2
90018ec6:	69fb      	ldr	r3, [r7, #28]
90018ec8:	4413      	add	r3, r2
90018eca:	330a      	adds	r3, #10
90018ecc:	61fb      	str	r3, [r7, #28]
      current_y--;
90018ece:	697b      	ldr	r3, [r7, #20]
90018ed0:	3b01      	subs	r3, #1
90018ed2:	617b      	str	r3, [r7, #20]
    }
    current_x++;
90018ed4:	69bb      	ldr	r3, [r7, #24]
90018ed6:	3301      	adds	r3, #1
90018ed8:	61bb      	str	r3, [r7, #24]
  while (current_x <= current_y)
90018eda:	69ba      	ldr	r2, [r7, #24]
90018edc:	697b      	ldr	r3, [r7, #20]
90018ede:	429a      	cmp	r2, r3
90018ee0:	f67f af0f 	bls.w	90018d02 <UTIL_LCD_DrawCircle+0x22>
  }
}
90018ee4:	bf00      	nop
90018ee6:	bf00      	nop
90018ee8:	3720      	adds	r7, #32
90018eea:	46bd      	mov	sp, r7
90018eec:	bd80      	pop	{r7, pc}
90018eee:	bf00      	nop
90018ef0:	2400286c 	.word	0x2400286c

90018ef4 <UTIL_LCD_DrawPolygon>:
  * @param  Points      Pointer to the points array
  * @param  PointCount  Number of points
  * @param  Color       Draw color
  */
void UTIL_LCD_DrawPolygon(pPoint Points, uint32_t PointCount, uint32_t Color)
{
90018ef4:	b590      	push	{r4, r7, lr}
90018ef6:	b089      	sub	sp, #36	; 0x24
90018ef8:	af02      	add	r7, sp, #8
90018efa:	60f8      	str	r0, [r7, #12]
90018efc:	60b9      	str	r1, [r7, #8]
90018efe:	607a      	str	r2, [r7, #4]
  int16_t x_pos = 0, y_pos = 0;
90018f00:	2300      	movs	r3, #0
90018f02:	82fb      	strh	r3, [r7, #22]
90018f04:	2300      	movs	r3, #0
90018f06:	82bb      	strh	r3, [r7, #20]

  if(PointCount < 2)
90018f08:	68bb      	ldr	r3, [r7, #8]
90018f0a:	2b01      	cmp	r3, #1
90018f0c:	d943      	bls.n	90018f96 <UTIL_LCD_DrawPolygon+0xa2>
  {
    return;
  }

  UTIL_LCD_DrawLine(Points->X, Points->Y, (Points+PointCount-1)->X, (Points+PointCount-1)->Y, Color);
90018f0e:	68fb      	ldr	r3, [r7, #12]
90018f10:	f9b3 3000 	ldrsh.w	r3, [r3]
90018f14:	4618      	mov	r0, r3
90018f16:	68fb      	ldr	r3, [r7, #12]
90018f18:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
90018f1c:	4619      	mov	r1, r3
90018f1e:	68ba      	ldr	r2, [r7, #8]
90018f20:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
90018f24:	4413      	add	r3, r2
90018f26:	009b      	lsls	r3, r3, #2
90018f28:	68fa      	ldr	r2, [r7, #12]
90018f2a:	4413      	add	r3, r2
90018f2c:	f9b3 3000 	ldrsh.w	r3, [r3]
90018f30:	461c      	mov	r4, r3
90018f32:	68ba      	ldr	r2, [r7, #8]
90018f34:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
90018f38:	4413      	add	r3, r2
90018f3a:	009b      	lsls	r3, r3, #2
90018f3c:	68fa      	ldr	r2, [r7, #12]
90018f3e:	4413      	add	r3, r2
90018f40:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
90018f44:	461a      	mov	r2, r3
90018f46:	687b      	ldr	r3, [r7, #4]
90018f48:	9300      	str	r3, [sp, #0]
90018f4a:	4613      	mov	r3, r2
90018f4c:	4622      	mov	r2, r4
90018f4e:	f7ff fde1 	bl	90018b14 <UTIL_LCD_DrawLine>

  while(--PointCount)
90018f52:	e019      	b.n	90018f88 <UTIL_LCD_DrawPolygon+0x94>
  {
    x_pos = Points->X;
90018f54:	68fb      	ldr	r3, [r7, #12]
90018f56:	881b      	ldrh	r3, [r3, #0]
90018f58:	82fb      	strh	r3, [r7, #22]
    y_pos = Points->Y;
90018f5a:	68fb      	ldr	r3, [r7, #12]
90018f5c:	885b      	ldrh	r3, [r3, #2]
90018f5e:	82bb      	strh	r3, [r7, #20]
    Points++;
90018f60:	68fb      	ldr	r3, [r7, #12]
90018f62:	3304      	adds	r3, #4
90018f64:	60fb      	str	r3, [r7, #12]
    UTIL_LCD_DrawLine(x_pos, y_pos, Points->X, Points->Y, Color);
90018f66:	f9b7 0016 	ldrsh.w	r0, [r7, #22]
90018f6a:	f9b7 1014 	ldrsh.w	r1, [r7, #20]
90018f6e:	68fb      	ldr	r3, [r7, #12]
90018f70:	f9b3 3000 	ldrsh.w	r3, [r3]
90018f74:	461a      	mov	r2, r3
90018f76:	68fb      	ldr	r3, [r7, #12]
90018f78:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
90018f7c:	461c      	mov	r4, r3
90018f7e:	687b      	ldr	r3, [r7, #4]
90018f80:	9300      	str	r3, [sp, #0]
90018f82:	4623      	mov	r3, r4
90018f84:	f7ff fdc6 	bl	90018b14 <UTIL_LCD_DrawLine>
  while(--PointCount)
90018f88:	68bb      	ldr	r3, [r7, #8]
90018f8a:	3b01      	subs	r3, #1
90018f8c:	60bb      	str	r3, [r7, #8]
90018f8e:	68bb      	ldr	r3, [r7, #8]
90018f90:	2b00      	cmp	r3, #0
90018f92:	d1df      	bne.n	90018f54 <UTIL_LCD_DrawPolygon+0x60>
90018f94:	e000      	b.n	90018f98 <UTIL_LCD_DrawPolygon+0xa4>
    return;
90018f96:	bf00      	nop
  }
}
90018f98:	371c      	adds	r7, #28
90018f9a:	46bd      	mov	sp, r7
90018f9c:	bd90      	pop	{r4, r7, pc}

90018f9e <UTIL_LCD_DrawEllipse>:
  * @param  XRadius Ellipse X radius
  * @param  YRadius Ellipse Y radius
  * @param  Color   Draw color
  */
void UTIL_LCD_DrawEllipse(int Xpos, int Ypos, int XRadius, int YRadius, uint32_t Color)
{
90018f9e:	b580      	push	{r7, lr}
90018fa0:	b08c      	sub	sp, #48	; 0x30
90018fa2:	af00      	add	r7, sp, #0
90018fa4:	60f8      	str	r0, [r7, #12]
90018fa6:	60b9      	str	r1, [r7, #8]
90018fa8:	607a      	str	r2, [r7, #4]
90018faa:	603b      	str	r3, [r7, #0]
  int x_pos = 0, y_pos = -YRadius, err = 2-2*XRadius, e2;
90018fac:	2300      	movs	r3, #0
90018fae:	62fb      	str	r3, [r7, #44]	; 0x2c
90018fb0:	683b      	ldr	r3, [r7, #0]
90018fb2:	425b      	negs	r3, r3
90018fb4:	62bb      	str	r3, [r7, #40]	; 0x28
90018fb6:	687b      	ldr	r3, [r7, #4]
90018fb8:	f1c3 0301 	rsb	r3, r3, #1
90018fbc:	005b      	lsls	r3, r3, #1
90018fbe:	627b      	str	r3, [r7, #36]	; 0x24
  float k = 0, rad1 = 0, rad2 = 0;
90018fc0:	f04f 0300 	mov.w	r3, #0
90018fc4:	61fb      	str	r3, [r7, #28]
90018fc6:	f04f 0300 	mov.w	r3, #0
90018fca:	61bb      	str	r3, [r7, #24]
90018fcc:	f04f 0300 	mov.w	r3, #0
90018fd0:	617b      	str	r3, [r7, #20]

  rad1 = XRadius;
90018fd2:	687b      	ldr	r3, [r7, #4]
90018fd4:	ee07 3a90 	vmov	s15, r3
90018fd8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
90018fdc:	edc7 7a06 	vstr	s15, [r7, #24]
  rad2 = YRadius;
90018fe0:	683b      	ldr	r3, [r7, #0]
90018fe2:	ee07 3a90 	vmov	s15, r3
90018fe6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
90018fea:	edc7 7a05 	vstr	s15, [r7, #20]

  k = (float)(rad2/rad1);
90018fee:	edd7 6a05 	vldr	s13, [r7, #20]
90018ff2:	ed97 7a06 	vldr	s14, [r7, #24]
90018ff6:	eec6 7a87 	vdiv.f32	s15, s13, s14
90018ffa:	edc7 7a07 	vstr	s15, [r7, #28]

  do
  {
    UTIL_LCD_SetPixel((Xpos-(uint32_t)(x_pos/k)), (Ypos + y_pos), Color);
90018ffe:	68fb      	ldr	r3, [r7, #12]
90019000:	b29a      	uxth	r2, r3
90019002:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90019004:	ee07 3a90 	vmov	s15, r3
90019008:	eef8 6ae7 	vcvt.f32.s32	s13, s15
9001900c:	ed97 7a07 	vldr	s14, [r7, #28]
90019010:	eec6 7a87 	vdiv.f32	s15, s13, s14
90019014:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90019018:	ee17 3a90 	vmov	r3, s15
9001901c:	b29b      	uxth	r3, r3
9001901e:	1ad3      	subs	r3, r2, r3
90019020:	b298      	uxth	r0, r3
90019022:	68bb      	ldr	r3, [r7, #8]
90019024:	b29a      	uxth	r2, r3
90019026:	6abb      	ldr	r3, [r7, #40]	; 0x28
90019028:	b29b      	uxth	r3, r3
9001902a:	4413      	add	r3, r2
9001902c:	b29b      	uxth	r3, r3
9001902e:	6bba      	ldr	r2, [r7, #56]	; 0x38
90019030:	4619      	mov	r1, r3
90019032:	f7ff fc41 	bl	900188b8 <UTIL_LCD_SetPixel>
    UTIL_LCD_SetPixel((Xpos+(uint32_t)(x_pos/k)), (Ypos + y_pos), Color);
90019036:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90019038:	ee07 3a90 	vmov	s15, r3
9001903c:	eef8 6ae7 	vcvt.f32.s32	s13, s15
90019040:	ed97 7a07 	vldr	s14, [r7, #28]
90019044:	eec6 7a87 	vdiv.f32	s15, s13, s14
90019048:	eefc 7ae7 	vcvt.u32.f32	s15, s15
9001904c:	ee17 3a90 	vmov	r3, s15
90019050:	b29a      	uxth	r2, r3
90019052:	68fb      	ldr	r3, [r7, #12]
90019054:	b29b      	uxth	r3, r3
90019056:	4413      	add	r3, r2
90019058:	b298      	uxth	r0, r3
9001905a:	68bb      	ldr	r3, [r7, #8]
9001905c:	b29a      	uxth	r2, r3
9001905e:	6abb      	ldr	r3, [r7, #40]	; 0x28
90019060:	b29b      	uxth	r3, r3
90019062:	4413      	add	r3, r2
90019064:	b29b      	uxth	r3, r3
90019066:	6bba      	ldr	r2, [r7, #56]	; 0x38
90019068:	4619      	mov	r1, r3
9001906a:	f7ff fc25 	bl	900188b8 <UTIL_LCD_SetPixel>
    UTIL_LCD_SetPixel((Xpos+(uint32_t)(x_pos/k)), (Ypos - y_pos), Color);
9001906e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90019070:	ee07 3a90 	vmov	s15, r3
90019074:	eef8 6ae7 	vcvt.f32.s32	s13, s15
90019078:	ed97 7a07 	vldr	s14, [r7, #28]
9001907c:	eec6 7a87 	vdiv.f32	s15, s13, s14
90019080:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90019084:	ee17 3a90 	vmov	r3, s15
90019088:	b29a      	uxth	r2, r3
9001908a:	68fb      	ldr	r3, [r7, #12]
9001908c:	b29b      	uxth	r3, r3
9001908e:	4413      	add	r3, r2
90019090:	b298      	uxth	r0, r3
90019092:	68bb      	ldr	r3, [r7, #8]
90019094:	b29a      	uxth	r2, r3
90019096:	6abb      	ldr	r3, [r7, #40]	; 0x28
90019098:	b29b      	uxth	r3, r3
9001909a:	1ad3      	subs	r3, r2, r3
9001909c:	b29b      	uxth	r3, r3
9001909e:	6bba      	ldr	r2, [r7, #56]	; 0x38
900190a0:	4619      	mov	r1, r3
900190a2:	f7ff fc09 	bl	900188b8 <UTIL_LCD_SetPixel>
    UTIL_LCD_SetPixel((Xpos-(uint32_t)(x_pos/k)), (Ypos - y_pos), Color);
900190a6:	68fb      	ldr	r3, [r7, #12]
900190a8:	b29a      	uxth	r2, r3
900190aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
900190ac:	ee07 3a90 	vmov	s15, r3
900190b0:	eef8 6ae7 	vcvt.f32.s32	s13, s15
900190b4:	ed97 7a07 	vldr	s14, [r7, #28]
900190b8:	eec6 7a87 	vdiv.f32	s15, s13, s14
900190bc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
900190c0:	ee17 3a90 	vmov	r3, s15
900190c4:	b29b      	uxth	r3, r3
900190c6:	1ad3      	subs	r3, r2, r3
900190c8:	b298      	uxth	r0, r3
900190ca:	68bb      	ldr	r3, [r7, #8]
900190cc:	b29a      	uxth	r2, r3
900190ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
900190d0:	b29b      	uxth	r3, r3
900190d2:	1ad3      	subs	r3, r2, r3
900190d4:	b29b      	uxth	r3, r3
900190d6:	6bba      	ldr	r2, [r7, #56]	; 0x38
900190d8:	4619      	mov	r1, r3
900190da:	f7ff fbed 	bl	900188b8 <UTIL_LCD_SetPixel>

    e2 = err;
900190de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
900190e0:	623b      	str	r3, [r7, #32]
    if (e2 <= x_pos)
900190e2:	6a3a      	ldr	r2, [r7, #32]
900190e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
900190e6:	429a      	cmp	r2, r3
900190e8:	dc13      	bgt.n	90019112 <UTIL_LCD_DrawEllipse+0x174>
    {
      err += ++x_pos*2+1;
900190ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
900190ec:	3301      	adds	r3, #1
900190ee:	62fb      	str	r3, [r7, #44]	; 0x2c
900190f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
900190f2:	005b      	lsls	r3, r3, #1
900190f4:	3301      	adds	r3, #1
900190f6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
900190f8:	4413      	add	r3, r2
900190fa:	627b      	str	r3, [r7, #36]	; 0x24
      if (-y_pos == x_pos && e2 <= y_pos) e2 = 0;
900190fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
900190fe:	425b      	negs	r3, r3
90019100:	6afa      	ldr	r2, [r7, #44]	; 0x2c
90019102:	429a      	cmp	r2, r3
90019104:	d105      	bne.n	90019112 <UTIL_LCD_DrawEllipse+0x174>
90019106:	6a3a      	ldr	r2, [r7, #32]
90019108:	6abb      	ldr	r3, [r7, #40]	; 0x28
9001910a:	429a      	cmp	r2, r3
9001910c:	dc01      	bgt.n	90019112 <UTIL_LCD_DrawEllipse+0x174>
9001910e:	2300      	movs	r3, #0
90019110:	623b      	str	r3, [r7, #32]
    }
    if (e2 > y_pos)
90019112:	6a3a      	ldr	r2, [r7, #32]
90019114:	6abb      	ldr	r3, [r7, #40]	; 0x28
90019116:	429a      	cmp	r2, r3
90019118:	dd08      	ble.n	9001912c <UTIL_LCD_DrawEllipse+0x18e>
    {
      err += ++y_pos*2+1;
9001911a:	6abb      	ldr	r3, [r7, #40]	; 0x28
9001911c:	3301      	adds	r3, #1
9001911e:	62bb      	str	r3, [r7, #40]	; 0x28
90019120:	6abb      	ldr	r3, [r7, #40]	; 0x28
90019122:	005b      	lsls	r3, r3, #1
90019124:	3301      	adds	r3, #1
90019126:	6a7a      	ldr	r2, [r7, #36]	; 0x24
90019128:	4413      	add	r3, r2
9001912a:	627b      	str	r3, [r7, #36]	; 0x24
    }
  }while (y_pos <= 0);
9001912c:	6abb      	ldr	r3, [r7, #40]	; 0x28
9001912e:	2b00      	cmp	r3, #0
90019130:	f77f af65 	ble.w	90018ffe <UTIL_LCD_DrawEllipse+0x60>
}
90019134:	bf00      	nop
90019136:	bf00      	nop
90019138:	3730      	adds	r7, #48	; 0x30
9001913a:	46bd      	mov	sp, r7
9001913c:	bd80      	pop	{r7, pc}
	...

90019140 <UTIL_LCD_DrawBitmap>:
  * @param  Xpos  Bmp X position in the LCD
  * @param  Ypos  Bmp Y position in the LCD
  * @param  pData Pointer to Bmp picture address in the internal Flash
  */
void UTIL_LCD_DrawBitmap(uint32_t Xpos, uint32_t Ypos, uint8_t *pData)
{
90019140:	b590      	push	{r4, r7, lr}
90019142:	b085      	sub	sp, #20
90019144:	af00      	add	r7, sp, #0
90019146:	60f8      	str	r0, [r7, #12]
90019148:	60b9      	str	r1, [r7, #8]
9001914a:	607a      	str	r2, [r7, #4]
  FuncDriver.DrawBitmap(DrawProp->LcdDevice, Xpos, Ypos, pData);
9001914c:	4b05      	ldr	r3, [pc, #20]	; (90019164 <UTIL_LCD_DrawBitmap+0x24>)
9001914e:	681c      	ldr	r4, [r3, #0]
90019150:	4b05      	ldr	r3, [pc, #20]	; (90019168 <UTIL_LCD_DrawBitmap+0x28>)
90019152:	6918      	ldr	r0, [r3, #16]
90019154:	687b      	ldr	r3, [r7, #4]
90019156:	68ba      	ldr	r2, [r7, #8]
90019158:	68f9      	ldr	r1, [r7, #12]
9001915a:	47a0      	blx	r4
}
9001915c:	bf00      	nop
9001915e:	3714      	adds	r7, #20
90019160:	46bd      	mov	sp, r7
90019162:	bd90      	pop	{r4, r7, pc}
90019164:	240028ac 	.word	0x240028ac
90019168:	2400286c 	.word	0x2400286c

9001916c <UTIL_LCD_FillRect>:
  * @param  Width  Rectangle width
  * @param  Height Rectangle height
  * @param  Color  Draw color
  */
void UTIL_LCD_FillRect(uint32_t Xpos, uint32_t Ypos, uint32_t Width, uint32_t Height, uint32_t Color)
{
9001916c:	b590      	push	{r4, r7, lr}
9001916e:	b087      	sub	sp, #28
90019170:	af02      	add	r7, sp, #8
90019172:	60f8      	str	r0, [r7, #12]
90019174:	60b9      	str	r1, [r7, #8]
90019176:	607a      	str	r2, [r7, #4]
90019178:	603b      	str	r3, [r7, #0]
  /* Fill the rectangle */
  if(DrawProp->LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
9001917a:	4b17      	ldr	r3, [pc, #92]	; (900191d8 <UTIL_LCD_FillRect+0x6c>)
9001917c:	69db      	ldr	r3, [r3, #28]
9001917e:	2b02      	cmp	r3, #2
90019180:	d11a      	bne.n	900191b8 <UTIL_LCD_FillRect+0x4c>
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, CONVERTARGB88882RGB565(Color));
90019182:	4b16      	ldr	r3, [pc, #88]	; (900191dc <UTIL_LCD_FillRect+0x70>)
90019184:	691c      	ldr	r4, [r3, #16]
90019186:	4b14      	ldr	r3, [pc, #80]	; (900191d8 <UTIL_LCD_FillRect+0x6c>)
90019188:	6918      	ldr	r0, [r3, #16]
9001918a:	6a3b      	ldr	r3, [r7, #32]
9001918c:	08db      	lsrs	r3, r3, #3
9001918e:	f003 021f 	and.w	r2, r3, #31
90019192:	6a3b      	ldr	r3, [r7, #32]
90019194:	0a9b      	lsrs	r3, r3, #10
90019196:	015b      	lsls	r3, r3, #5
90019198:	f403 63fc 	and.w	r3, r3, #2016	; 0x7e0
9001919c:	431a      	orrs	r2, r3
9001919e:	6a3b      	ldr	r3, [r7, #32]
900191a0:	0cdb      	lsrs	r3, r3, #19
900191a2:	02db      	lsls	r3, r3, #11
900191a4:	b29b      	uxth	r3, r3
900191a6:	4313      	orrs	r3, r2
900191a8:	9301      	str	r3, [sp, #4]
900191aa:	683b      	ldr	r3, [r7, #0]
900191ac:	9300      	str	r3, [sp, #0]
900191ae:	687b      	ldr	r3, [r7, #4]
900191b0:	68ba      	ldr	r2, [r7, #8]
900191b2:	68f9      	ldr	r1, [r7, #12]
900191b4:	47a0      	blx	r4
  }
  else
  {
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
  }
}
900191b6:	e00b      	b.n	900191d0 <UTIL_LCD_FillRect+0x64>
    FuncDriver.FillRect(DrawProp->LcdDevice, Xpos, Ypos, Width, Height, Color);
900191b8:	4b08      	ldr	r3, [pc, #32]	; (900191dc <UTIL_LCD_FillRect+0x70>)
900191ba:	691c      	ldr	r4, [r3, #16]
900191bc:	4b06      	ldr	r3, [pc, #24]	; (900191d8 <UTIL_LCD_FillRect+0x6c>)
900191be:	6918      	ldr	r0, [r3, #16]
900191c0:	6a3b      	ldr	r3, [r7, #32]
900191c2:	9301      	str	r3, [sp, #4]
900191c4:	683b      	ldr	r3, [r7, #0]
900191c6:	9300      	str	r3, [sp, #0]
900191c8:	687b      	ldr	r3, [r7, #4]
900191ca:	68ba      	ldr	r2, [r7, #8]
900191cc:	68f9      	ldr	r1, [r7, #12]
900191ce:	47a0      	blx	r4
}
900191d0:	bf00      	nop
900191d2:	3714      	adds	r7, #20
900191d4:	46bd      	mov	sp, r7
900191d6:	bd90      	pop	{r4, r7, pc}
900191d8:	2400286c 	.word	0x2400286c
900191dc:	240028ac 	.word	0x240028ac

900191e0 <UTIL_LCD_FillCircle>:
  * @param  Ypos   Y position
  * @param  Radius Circle radius
  * @param  Color  Draw color
  */
void UTIL_LCD_FillCircle(uint32_t Xpos, uint32_t Ypos, uint32_t Radius, uint32_t Color)
{
900191e0:	b580      	push	{r7, lr}
900191e2:	b088      	sub	sp, #32
900191e4:	af00      	add	r7, sp, #0
900191e6:	60f8      	str	r0, [r7, #12]
900191e8:	60b9      	str	r1, [r7, #8]
900191ea:	607a      	str	r2, [r7, #4]
900191ec:	603b      	str	r3, [r7, #0]
  int32_t   decision;  /* Decision Variable */
  uint32_t  current_x; /* Current X Value */
  uint32_t  current_y; /* Current Y Value */

  decision = 3 - (Radius << 1);
900191ee:	687b      	ldr	r3, [r7, #4]
900191f0:	005b      	lsls	r3, r3, #1
900191f2:	f1c3 0303 	rsb	r3, r3, #3
900191f6:	61fb      	str	r3, [r7, #28]

  current_x = 0;
900191f8:	2300      	movs	r3, #0
900191fa:	61bb      	str	r3, [r7, #24]
  current_y = Radius;
900191fc:	687b      	ldr	r3, [r7, #4]
900191fe:	617b      	str	r3, [r7, #20]

  while (current_x <= current_y)
90019200:	e08b      	b.n	9001931a <UTIL_LCD_FillCircle+0x13a>
  {
    if(current_y > 0)
90019202:	697b      	ldr	r3, [r7, #20]
90019204:	2b00      	cmp	r3, #0
90019206:	d036      	beq.n	90019276 <UTIL_LCD_FillCircle+0x96>
    {
      if(current_y >= Xpos)
90019208:	697a      	ldr	r2, [r7, #20]
9001920a:	68fb      	ldr	r3, [r7, #12]
9001920c:	429a      	cmp	r2, r3
9001920e:	d31c      	bcc.n	9001924a <UTIL_LCD_FillCircle+0x6a>
      {
        UTIL_LCD_DrawHLine(0, Ypos + current_x, 2*current_y - (current_y - Xpos), Color);
90019210:	68ba      	ldr	r2, [r7, #8]
90019212:	69bb      	ldr	r3, [r7, #24]
90019214:	18d0      	adds	r0, r2, r3
90019216:	697b      	ldr	r3, [r7, #20]
90019218:	005a      	lsls	r2, r3, #1
9001921a:	68f9      	ldr	r1, [r7, #12]
9001921c:	697b      	ldr	r3, [r7, #20]
9001921e:	1acb      	subs	r3, r1, r3
90019220:	441a      	add	r2, r3
90019222:	683b      	ldr	r3, [r7, #0]
90019224:	4601      	mov	r1, r0
90019226:	2000      	movs	r0, #0
90019228:	f7ff fada 	bl	900187e0 <UTIL_LCD_DrawHLine>
        UTIL_LCD_DrawHLine(0, Ypos - current_x, 2*current_y - (current_y - Xpos), Color);
9001922c:	68ba      	ldr	r2, [r7, #8]
9001922e:	69bb      	ldr	r3, [r7, #24]
90019230:	1ad0      	subs	r0, r2, r3
90019232:	697b      	ldr	r3, [r7, #20]
90019234:	005a      	lsls	r2, r3, #1
90019236:	68f9      	ldr	r1, [r7, #12]
90019238:	697b      	ldr	r3, [r7, #20]
9001923a:	1acb      	subs	r3, r1, r3
9001923c:	441a      	add	r2, r3
9001923e:	683b      	ldr	r3, [r7, #0]
90019240:	4601      	mov	r1, r0
90019242:	2000      	movs	r0, #0
90019244:	f7ff facc 	bl	900187e0 <UTIL_LCD_DrawHLine>
90019248:	e015      	b.n	90019276 <UTIL_LCD_FillCircle+0x96>
      }
      else
      {
        UTIL_LCD_DrawHLine(Xpos - current_y, Ypos + current_x, 2*current_y, Color);
9001924a:	68fa      	ldr	r2, [r7, #12]
9001924c:	697b      	ldr	r3, [r7, #20]
9001924e:	1ad0      	subs	r0, r2, r3
90019250:	68ba      	ldr	r2, [r7, #8]
90019252:	69bb      	ldr	r3, [r7, #24]
90019254:	18d1      	adds	r1, r2, r3
90019256:	697b      	ldr	r3, [r7, #20]
90019258:	005a      	lsls	r2, r3, #1
9001925a:	683b      	ldr	r3, [r7, #0]
9001925c:	f7ff fac0 	bl	900187e0 <UTIL_LCD_DrawHLine>
        UTIL_LCD_DrawHLine(Xpos - current_y, Ypos - current_x, 2*current_y, Color);
90019260:	68fa      	ldr	r2, [r7, #12]
90019262:	697b      	ldr	r3, [r7, #20]
90019264:	1ad0      	subs	r0, r2, r3
90019266:	68ba      	ldr	r2, [r7, #8]
90019268:	69bb      	ldr	r3, [r7, #24]
9001926a:	1ad1      	subs	r1, r2, r3
9001926c:	697b      	ldr	r3, [r7, #20]
9001926e:	005a      	lsls	r2, r3, #1
90019270:	683b      	ldr	r3, [r7, #0]
90019272:	f7ff fab5 	bl	900187e0 <UTIL_LCD_DrawHLine>
      }
    }

    if(current_x > 0)
90019276:	69bb      	ldr	r3, [r7, #24]
90019278:	2b00      	cmp	r3, #0
9001927a:	d036      	beq.n	900192ea <UTIL_LCD_FillCircle+0x10a>
    {
      if(current_x >= Xpos)
9001927c:	69ba      	ldr	r2, [r7, #24]
9001927e:	68fb      	ldr	r3, [r7, #12]
90019280:	429a      	cmp	r2, r3
90019282:	d31c      	bcc.n	900192be <UTIL_LCD_FillCircle+0xde>
      {
        UTIL_LCD_DrawHLine(0, Ypos - current_y, 2*current_x - (current_x - Xpos), Color);
90019284:	68ba      	ldr	r2, [r7, #8]
90019286:	697b      	ldr	r3, [r7, #20]
90019288:	1ad0      	subs	r0, r2, r3
9001928a:	69bb      	ldr	r3, [r7, #24]
9001928c:	005a      	lsls	r2, r3, #1
9001928e:	68f9      	ldr	r1, [r7, #12]
90019290:	69bb      	ldr	r3, [r7, #24]
90019292:	1acb      	subs	r3, r1, r3
90019294:	441a      	add	r2, r3
90019296:	683b      	ldr	r3, [r7, #0]
90019298:	4601      	mov	r1, r0
9001929a:	2000      	movs	r0, #0
9001929c:	f7ff faa0 	bl	900187e0 <UTIL_LCD_DrawHLine>
        UTIL_LCD_DrawHLine(0, Ypos + current_y, 2*current_x - (current_x - Xpos), Color);
900192a0:	68ba      	ldr	r2, [r7, #8]
900192a2:	697b      	ldr	r3, [r7, #20]
900192a4:	18d0      	adds	r0, r2, r3
900192a6:	69bb      	ldr	r3, [r7, #24]
900192a8:	005a      	lsls	r2, r3, #1
900192aa:	68f9      	ldr	r1, [r7, #12]
900192ac:	69bb      	ldr	r3, [r7, #24]
900192ae:	1acb      	subs	r3, r1, r3
900192b0:	441a      	add	r2, r3
900192b2:	683b      	ldr	r3, [r7, #0]
900192b4:	4601      	mov	r1, r0
900192b6:	2000      	movs	r0, #0
900192b8:	f7ff fa92 	bl	900187e0 <UTIL_LCD_DrawHLine>
900192bc:	e015      	b.n	900192ea <UTIL_LCD_FillCircle+0x10a>
      }
      else
      {
        UTIL_LCD_DrawHLine(Xpos - current_x, Ypos - current_y, 2*current_x, Color);
900192be:	68fa      	ldr	r2, [r7, #12]
900192c0:	69bb      	ldr	r3, [r7, #24]
900192c2:	1ad0      	subs	r0, r2, r3
900192c4:	68ba      	ldr	r2, [r7, #8]
900192c6:	697b      	ldr	r3, [r7, #20]
900192c8:	1ad1      	subs	r1, r2, r3
900192ca:	69bb      	ldr	r3, [r7, #24]
900192cc:	005a      	lsls	r2, r3, #1
900192ce:	683b      	ldr	r3, [r7, #0]
900192d0:	f7ff fa86 	bl	900187e0 <UTIL_LCD_DrawHLine>
        UTIL_LCD_DrawHLine(Xpos - current_x, Ypos + current_y, 2*current_x, Color);
900192d4:	68fa      	ldr	r2, [r7, #12]
900192d6:	69bb      	ldr	r3, [r7, #24]
900192d8:	1ad0      	subs	r0, r2, r3
900192da:	68ba      	ldr	r2, [r7, #8]
900192dc:	697b      	ldr	r3, [r7, #20]
900192de:	18d1      	adds	r1, r2, r3
900192e0:	69bb      	ldr	r3, [r7, #24]
900192e2:	005a      	lsls	r2, r3, #1
900192e4:	683b      	ldr	r3, [r7, #0]
900192e6:	f7ff fa7b 	bl	900187e0 <UTIL_LCD_DrawHLine>
      }
    }
    if (decision < 0)
900192ea:	69fb      	ldr	r3, [r7, #28]
900192ec:	2b00      	cmp	r3, #0
900192ee:	da06      	bge.n	900192fe <UTIL_LCD_FillCircle+0x11e>
    {
      decision += (current_x << 2) + 6;
900192f0:	69bb      	ldr	r3, [r7, #24]
900192f2:	009a      	lsls	r2, r3, #2
900192f4:	69fb      	ldr	r3, [r7, #28]
900192f6:	4413      	add	r3, r2
900192f8:	3306      	adds	r3, #6
900192fa:	61fb      	str	r3, [r7, #28]
900192fc:	e00a      	b.n	90019314 <UTIL_LCD_FillCircle+0x134>
    }
    else
    {
      decision += ((current_x - current_y) << 2) + 10;
900192fe:	69ba      	ldr	r2, [r7, #24]
90019300:	697b      	ldr	r3, [r7, #20]
90019302:	1ad3      	subs	r3, r2, r3
90019304:	009a      	lsls	r2, r3, #2
90019306:	69fb      	ldr	r3, [r7, #28]
90019308:	4413      	add	r3, r2
9001930a:	330a      	adds	r3, #10
9001930c:	61fb      	str	r3, [r7, #28]
      current_y--;
9001930e:	697b      	ldr	r3, [r7, #20]
90019310:	3b01      	subs	r3, #1
90019312:	617b      	str	r3, [r7, #20]
    }
    current_x++;
90019314:	69bb      	ldr	r3, [r7, #24]
90019316:	3301      	adds	r3, #1
90019318:	61bb      	str	r3, [r7, #24]
  while (current_x <= current_y)
9001931a:	69ba      	ldr	r2, [r7, #24]
9001931c:	697b      	ldr	r3, [r7, #20]
9001931e:	429a      	cmp	r2, r3
90019320:	f67f af6f 	bls.w	90019202 <UTIL_LCD_FillCircle+0x22>
  }

  UTIL_LCD_DrawCircle(Xpos, Ypos, Radius, Color);
90019324:	683b      	ldr	r3, [r7, #0]
90019326:	687a      	ldr	r2, [r7, #4]
90019328:	68b9      	ldr	r1, [r7, #8]
9001932a:	68f8      	ldr	r0, [r7, #12]
9001932c:	f7ff fcd8 	bl	90018ce0 <UTIL_LCD_DrawCircle>
}
90019330:	bf00      	nop
90019332:	3720      	adds	r7, #32
90019334:	46bd      	mov	sp, r7
90019336:	bd80      	pop	{r7, pc}

90019338 <UTIL_LCD_FillPolygon>:
  * @param  Points     Pointer to the points array
  * @param  PointCount Number of points
  * @param  Color      Draw color
  */
void UTIL_LCD_FillPolygon(pPoint Points, uint32_t PointCount, uint32_t Color)
{
90019338:	b580      	push	{r7, lr}
9001933a:	b094      	sub	sp, #80	; 0x50
9001933c:	af00      	add	r7, sp, #0
9001933e:	60f8      	str	r0, [r7, #12]
90019340:	60b9      	str	r1, [r7, #8]
90019342:	607a      	str	r2, [r7, #4]
  int16_t X = 0, Y = 0, X2 = 0, Y2 = 0, x_center = 0, y_center = 0, x_first = 0, y_first = 0, pixel_x = 0, pixel_y = 0, counter = 0;
90019344:	2300      	movs	r3, #0
90019346:	86fb      	strh	r3, [r7, #54]	; 0x36
90019348:	2300      	movs	r3, #0
9001934a:	86bb      	strh	r3, [r7, #52]	; 0x34
9001934c:	2300      	movs	r3, #0
9001934e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
90019352:	2300      	movs	r3, #0
90019354:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
90019358:	2300      	movs	r3, #0
9001935a:	867b      	strh	r3, [r7, #50]	; 0x32
9001935c:	2300      	movs	r3, #0
9001935e:	863b      	strh	r3, [r7, #48]	; 0x30
90019360:	2300      	movs	r3, #0
90019362:	85fb      	strh	r3, [r7, #46]	; 0x2e
90019364:	2300      	movs	r3, #0
90019366:	85bb      	strh	r3, [r7, #44]	; 0x2c
90019368:	2300      	movs	r3, #0
9001936a:	857b      	strh	r3, [r7, #42]	; 0x2a
9001936c:	2300      	movs	r3, #0
9001936e:	853b      	strh	r3, [r7, #40]	; 0x28
90019370:	2300      	movs	r3, #0
90019372:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
  uint32_t  image_left = 0, image_right = 0, image_top = 0, image_bottom = 0;
90019376:	2300      	movs	r3, #0
90019378:	647b      	str	r3, [r7, #68]	; 0x44
9001937a:	2300      	movs	r3, #0
9001937c:	643b      	str	r3, [r7, #64]	; 0x40
9001937e:	2300      	movs	r3, #0
90019380:	63fb      	str	r3, [r7, #60]	; 0x3c
90019382:	2300      	movs	r3, #0
90019384:	63bb      	str	r3, [r7, #56]	; 0x38
  Triangle_Positions_t positions;

  image_left = image_right = Points->X;
90019386:	68fb      	ldr	r3, [r7, #12]
90019388:	f9b3 3000 	ldrsh.w	r3, [r3]
9001938c:	643b      	str	r3, [r7, #64]	; 0x40
9001938e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
90019390:	647b      	str	r3, [r7, #68]	; 0x44
  image_top= image_bottom = Points->Y;
90019392:	68fb      	ldr	r3, [r7, #12]
90019394:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
90019398:	63bb      	str	r3, [r7, #56]	; 0x38
9001939a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
9001939c:	63fb      	str	r3, [r7, #60]	; 0x3c

  for(counter = 1; counter < PointCount; counter++)
9001939e:	2301      	movs	r3, #1
900193a0:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
900193a4:	e034      	b.n	90019410 <UTIL_LCD_FillPolygon+0xd8>
  {
    pixel_x = POLY_X(counter);
900193a6:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
900193aa:	009b      	lsls	r3, r3, #2
900193ac:	68fa      	ldr	r2, [r7, #12]
900193ae:	4413      	add	r3, r2
900193b0:	881b      	ldrh	r3, [r3, #0]
900193b2:	857b      	strh	r3, [r7, #42]	; 0x2a
    if(pixel_x < image_left)
900193b4:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
900193b8:	6c7a      	ldr	r2, [r7, #68]	; 0x44
900193ba:	429a      	cmp	r2, r3
900193bc:	d902      	bls.n	900193c4 <UTIL_LCD_FillPolygon+0x8c>
    {
      image_left = pixel_x;
900193be:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
900193c2:	647b      	str	r3, [r7, #68]	; 0x44
    }
    if(pixel_x > image_right)
900193c4:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
900193c8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
900193ca:	429a      	cmp	r2, r3
900193cc:	d202      	bcs.n	900193d4 <UTIL_LCD_FillPolygon+0x9c>
    {
      image_right = pixel_x;
900193ce:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
900193d2:	643b      	str	r3, [r7, #64]	; 0x40
    }

    pixel_y = POLY_Y(counter);
900193d4:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
900193d8:	009b      	lsls	r3, r3, #2
900193da:	68fa      	ldr	r2, [r7, #12]
900193dc:	4413      	add	r3, r2
900193de:	885b      	ldrh	r3, [r3, #2]
900193e0:	853b      	strh	r3, [r7, #40]	; 0x28
    if(pixel_y < image_top)
900193e2:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
900193e6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
900193e8:	429a      	cmp	r2, r3
900193ea:	d902      	bls.n	900193f2 <UTIL_LCD_FillPolygon+0xba>
    {
      image_top = pixel_y;
900193ec:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
900193f0:	63fb      	str	r3, [r7, #60]	; 0x3c
    }
    if(pixel_y > image_bottom)
900193f2:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
900193f6:	6bba      	ldr	r2, [r7, #56]	; 0x38
900193f8:	429a      	cmp	r2, r3
900193fa:	d202      	bcs.n	90019402 <UTIL_LCD_FillPolygon+0xca>
    {
      image_bottom = pixel_y;
900193fc:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
90019400:	63bb      	str	r3, [r7, #56]	; 0x38
  for(counter = 1; counter < PointCount; counter++)
90019402:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
90019406:	b29b      	uxth	r3, r3
90019408:	3301      	adds	r3, #1
9001940a:	b29b      	uxth	r3, r3
9001940c:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
90019410:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
90019414:	68ba      	ldr	r2, [r7, #8]
90019416:	429a      	cmp	r2, r3
90019418:	d8c5      	bhi.n	900193a6 <UTIL_LCD_FillPolygon+0x6e>
    }
  }

  if(PointCount < 2)
9001941a:	68bb      	ldr	r3, [r7, #8]
9001941c:	2b01      	cmp	r3, #1
9001941e:	f240 80ad 	bls.w	9001957c <UTIL_LCD_FillPolygon+0x244>
  {
    return;
  }

  x_center = (image_left + image_right)/2;
90019422:	6c7a      	ldr	r2, [r7, #68]	; 0x44
90019424:	6c3b      	ldr	r3, [r7, #64]	; 0x40
90019426:	4413      	add	r3, r2
90019428:	085b      	lsrs	r3, r3, #1
9001942a:	867b      	strh	r3, [r7, #50]	; 0x32
  y_center = (image_bottom + image_top)/2;
9001942c:	6bba      	ldr	r2, [r7, #56]	; 0x38
9001942e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
90019430:	4413      	add	r3, r2
90019432:	085b      	lsrs	r3, r3, #1
90019434:	863b      	strh	r3, [r7, #48]	; 0x30

  x_first = Points->X;
90019436:	68fb      	ldr	r3, [r7, #12]
90019438:	881b      	ldrh	r3, [r3, #0]
9001943a:	85fb      	strh	r3, [r7, #46]	; 0x2e
  y_first = Points->Y;
9001943c:	68fb      	ldr	r3, [r7, #12]
9001943e:	885b      	ldrh	r3, [r3, #2]
90019440:	85bb      	strh	r3, [r7, #44]	; 0x2c

  while(--PointCount)
90019442:	e052      	b.n	900194ea <UTIL_LCD_FillPolygon+0x1b2>
  {
    X = Points->X;
90019444:	68fb      	ldr	r3, [r7, #12]
90019446:	881b      	ldrh	r3, [r3, #0]
90019448:	86fb      	strh	r3, [r7, #54]	; 0x36
    Y = Points->Y;
9001944a:	68fb      	ldr	r3, [r7, #12]
9001944c:	885b      	ldrh	r3, [r3, #2]
9001944e:	86bb      	strh	r3, [r7, #52]	; 0x34
    Points++;
90019450:	68fb      	ldr	r3, [r7, #12]
90019452:	3304      	adds	r3, #4
90019454:	60fb      	str	r3, [r7, #12]
    X2 = Points->X;
90019456:	68fb      	ldr	r3, [r7, #12]
90019458:	881b      	ldrh	r3, [r3, #0]
9001945a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    Y2 = Points->Y;
9001945e:	68fb      	ldr	r3, [r7, #12]
90019460:	885b      	ldrh	r3, [r3, #2]
90019462:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
    positions.x1 = X;
90019466:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
9001946a:	613b      	str	r3, [r7, #16]
    positions.y1 = Y;
9001946c:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
90019470:	617b      	str	r3, [r7, #20]
    positions.x2 = X2;
90019472:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
90019476:	61bb      	str	r3, [r7, #24]
    positions.y2 = Y2;
90019478:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
9001947c:	61fb      	str	r3, [r7, #28]
    positions.x3 = x_center;
9001947e:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
90019482:	623b      	str	r3, [r7, #32]
    positions.y3 = y_center;
90019484:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
90019488:	627b      	str	r3, [r7, #36]	; 0x24
    FillTriangle(&positions, Color);
9001948a:	f107 0310 	add.w	r3, r7, #16
9001948e:	6879      	ldr	r1, [r7, #4]
90019490:	4618      	mov	r0, r3
90019492:	f000 fa7f 	bl	90019994 <FillTriangle>

    positions.x2 = x_center;
90019496:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
9001949a:	61bb      	str	r3, [r7, #24]
    positions.y2 = y_center;
9001949c:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
900194a0:	61fb      	str	r3, [r7, #28]
    positions.x3 = X2;
900194a2:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
900194a6:	623b      	str	r3, [r7, #32]
    positions.y3 = Y2;
900194a8:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
900194ac:	627b      	str	r3, [r7, #36]	; 0x24
    FillTriangle(&positions, Color);
900194ae:	f107 0310 	add.w	r3, r7, #16
900194b2:	6879      	ldr	r1, [r7, #4]
900194b4:	4618      	mov	r0, r3
900194b6:	f000 fa6d 	bl	90019994 <FillTriangle>

    positions.x1 = x_center;
900194ba:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
900194be:	613b      	str	r3, [r7, #16]
    positions.y1 = y_center;
900194c0:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
900194c4:	617b      	str	r3, [r7, #20]
    positions.x2 = X2;
900194c6:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
900194ca:	61bb      	str	r3, [r7, #24]
    positions.y2 = Y2;
900194cc:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
900194d0:	61fb      	str	r3, [r7, #28]
    positions.x3 = X;
900194d2:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
900194d6:	623b      	str	r3, [r7, #32]
    positions.y3 = Y;
900194d8:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
900194dc:	627b      	str	r3, [r7, #36]	; 0x24
    FillTriangle(&positions, Color);
900194de:	f107 0310 	add.w	r3, r7, #16
900194e2:	6879      	ldr	r1, [r7, #4]
900194e4:	4618      	mov	r0, r3
900194e6:	f000 fa55 	bl	90019994 <FillTriangle>
  while(--PointCount)
900194ea:	68bb      	ldr	r3, [r7, #8]
900194ec:	3b01      	subs	r3, #1
900194ee:	60bb      	str	r3, [r7, #8]
900194f0:	68bb      	ldr	r3, [r7, #8]
900194f2:	2b00      	cmp	r3, #0
900194f4:	d1a6      	bne.n	90019444 <UTIL_LCD_FillPolygon+0x10c>
  }

    positions.x1 = x_first;
900194f6:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
900194fa:	613b      	str	r3, [r7, #16]
    positions.y1 = y_first;
900194fc:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
90019500:	617b      	str	r3, [r7, #20]
    positions.x2 = X2;
90019502:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
90019506:	61bb      	str	r3, [r7, #24]
    positions.y2 = Y2;
90019508:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
9001950c:	61fb      	str	r3, [r7, #28]
    positions.x3 = x_center;
9001950e:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
90019512:	623b      	str	r3, [r7, #32]
    positions.y3 = y_center;
90019514:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
90019518:	627b      	str	r3, [r7, #36]	; 0x24
    FillTriangle(&positions, Color);
9001951a:	f107 0310 	add.w	r3, r7, #16
9001951e:	6879      	ldr	r1, [r7, #4]
90019520:	4618      	mov	r0, r3
90019522:	f000 fa37 	bl	90019994 <FillTriangle>

    positions.x2 = x_center;
90019526:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
9001952a:	61bb      	str	r3, [r7, #24]
    positions.y2 = y_center;
9001952c:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
90019530:	61fb      	str	r3, [r7, #28]
    positions.x3 = X2;
90019532:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
90019536:	623b      	str	r3, [r7, #32]
    positions.y3 = Y2;
90019538:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
9001953c:	627b      	str	r3, [r7, #36]	; 0x24
    FillTriangle(&positions, Color);
9001953e:	f107 0310 	add.w	r3, r7, #16
90019542:	6879      	ldr	r1, [r7, #4]
90019544:	4618      	mov	r0, r3
90019546:	f000 fa25 	bl	90019994 <FillTriangle>

    positions.x1 = x_center;
9001954a:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
9001954e:	613b      	str	r3, [r7, #16]
    positions.y1 = y_center;
90019550:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
90019554:	617b      	str	r3, [r7, #20]
    positions.x2 = X2;
90019556:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
9001955a:	61bb      	str	r3, [r7, #24]
    positions.y2 = Y2;
9001955c:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
90019560:	61fb      	str	r3, [r7, #28]
    positions.x3 = x_first;
90019562:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
90019566:	623b      	str	r3, [r7, #32]
    positions.y3 = y_first;
90019568:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
9001956c:	627b      	str	r3, [r7, #36]	; 0x24
    FillTriangle(&positions, Color);
9001956e:	f107 0310 	add.w	r3, r7, #16
90019572:	6879      	ldr	r1, [r7, #4]
90019574:	4618      	mov	r0, r3
90019576:	f000 fa0d 	bl	90019994 <FillTriangle>
9001957a:	e000      	b.n	9001957e <UTIL_LCD_FillPolygon+0x246>
    return;
9001957c:	bf00      	nop
}
9001957e:	3750      	adds	r7, #80	; 0x50
90019580:	46bd      	mov	sp, r7
90019582:	bd80      	pop	{r7, pc}

90019584 <UTIL_LCD_FillEllipse>:
  * @param  XRadius Ellipse X radius
  * @param  YRadius Ellipse Y radius
  * @param  Color   Draw color
  */
void UTIL_LCD_FillEllipse(int Xpos, int Ypos, int XRadius, int YRadius, uint32_t Color)
{
90019584:	b580      	push	{r7, lr}
90019586:	b08c      	sub	sp, #48	; 0x30
90019588:	af00      	add	r7, sp, #0
9001958a:	60f8      	str	r0, [r7, #12]
9001958c:	60b9      	str	r1, [r7, #8]
9001958e:	607a      	str	r2, [r7, #4]
90019590:	603b      	str	r3, [r7, #0]
  int x_pos = 0, y_pos = -YRadius, err = 2-2*XRadius, e2;
90019592:	2300      	movs	r3, #0
90019594:	62fb      	str	r3, [r7, #44]	; 0x2c
90019596:	683b      	ldr	r3, [r7, #0]
90019598:	425b      	negs	r3, r3
9001959a:	62bb      	str	r3, [r7, #40]	; 0x28
9001959c:	687b      	ldr	r3, [r7, #4]
9001959e:	f1c3 0301 	rsb	r3, r3, #1
900195a2:	005b      	lsls	r3, r3, #1
900195a4:	627b      	str	r3, [r7, #36]	; 0x24
  float k = 0, rad1 = 0, rad2 = 0;
900195a6:	f04f 0300 	mov.w	r3, #0
900195aa:	61fb      	str	r3, [r7, #28]
900195ac:	f04f 0300 	mov.w	r3, #0
900195b0:	61bb      	str	r3, [r7, #24]
900195b2:	f04f 0300 	mov.w	r3, #0
900195b6:	617b      	str	r3, [r7, #20]

  rad1 = XRadius;
900195b8:	687b      	ldr	r3, [r7, #4]
900195ba:	ee07 3a90 	vmov	s15, r3
900195be:	eef8 7ae7 	vcvt.f32.s32	s15, s15
900195c2:	edc7 7a06 	vstr	s15, [r7, #24]
  rad2 = YRadius;
900195c6:	683b      	ldr	r3, [r7, #0]
900195c8:	ee07 3a90 	vmov	s15, r3
900195cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
900195d0:	edc7 7a05 	vstr	s15, [r7, #20]

  k = (float)(rad2/rad1);
900195d4:	edd7 6a05 	vldr	s13, [r7, #20]
900195d8:	ed97 7a06 	vldr	s14, [r7, #24]
900195dc:	eec6 7a87 	vdiv.f32	s15, s13, s14
900195e0:	edc7 7a07 	vstr	s15, [r7, #28]

  do
  {
    UTIL_LCD_DrawHLine((Xpos-(uint32_t)(x_pos/k)), (Ypos + y_pos), (2*(uint32_t)(x_pos/k) + 1), Color);
900195e4:	68fb      	ldr	r3, [r7, #12]
900195e6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
900195e8:	ee07 2a90 	vmov	s15, r2
900195ec:	eef8 6ae7 	vcvt.f32.s32	s13, s15
900195f0:	ed97 7a07 	vldr	s14, [r7, #28]
900195f4:	eec6 7a87 	vdiv.f32	s15, s13, s14
900195f8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
900195fc:	ee17 2a90 	vmov	r2, s15
90019600:	1a98      	subs	r0, r3, r2
90019602:	68ba      	ldr	r2, [r7, #8]
90019604:	6abb      	ldr	r3, [r7, #40]	; 0x28
90019606:	4413      	add	r3, r2
90019608:	4619      	mov	r1, r3
9001960a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
9001960c:	ee07 3a90 	vmov	s15, r3
90019610:	eef8 6ae7 	vcvt.f32.s32	s13, s15
90019614:	ed97 7a07 	vldr	s14, [r7, #28]
90019618:	eec6 7a87 	vdiv.f32	s15, s13, s14
9001961c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90019620:	ee17 3a90 	vmov	r3, s15
90019624:	005b      	lsls	r3, r3, #1
90019626:	1c5a      	adds	r2, r3, #1
90019628:	6bbb      	ldr	r3, [r7, #56]	; 0x38
9001962a:	f7ff f8d9 	bl	900187e0 <UTIL_LCD_DrawHLine>
    UTIL_LCD_DrawHLine((Xpos-(uint32_t)(x_pos/k)), (Ypos - y_pos), (2*(uint32_t)(x_pos/k) + 1), Color);
9001962e:	68fb      	ldr	r3, [r7, #12]
90019630:	6afa      	ldr	r2, [r7, #44]	; 0x2c
90019632:	ee07 2a90 	vmov	s15, r2
90019636:	eef8 6ae7 	vcvt.f32.s32	s13, s15
9001963a:	ed97 7a07 	vldr	s14, [r7, #28]
9001963e:	eec6 7a87 	vdiv.f32	s15, s13, s14
90019642:	eefc 7ae7 	vcvt.u32.f32	s15, s15
90019646:	ee17 2a90 	vmov	r2, s15
9001964a:	1a98      	subs	r0, r3, r2
9001964c:	68ba      	ldr	r2, [r7, #8]
9001964e:	6abb      	ldr	r3, [r7, #40]	; 0x28
90019650:	1ad3      	subs	r3, r2, r3
90019652:	4619      	mov	r1, r3
90019654:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90019656:	ee07 3a90 	vmov	s15, r3
9001965a:	eef8 6ae7 	vcvt.f32.s32	s13, s15
9001965e:	ed97 7a07 	vldr	s14, [r7, #28]
90019662:	eec6 7a87 	vdiv.f32	s15, s13, s14
90019666:	eefc 7ae7 	vcvt.u32.f32	s15, s15
9001966a:	ee17 3a90 	vmov	r3, s15
9001966e:	005b      	lsls	r3, r3, #1
90019670:	1c5a      	adds	r2, r3, #1
90019672:	6bbb      	ldr	r3, [r7, #56]	; 0x38
90019674:	f7ff f8b4 	bl	900187e0 <UTIL_LCD_DrawHLine>

    e2 = err;
90019678:	6a7b      	ldr	r3, [r7, #36]	; 0x24
9001967a:	623b      	str	r3, [r7, #32]
    if (e2 <= x_pos)
9001967c:	6a3a      	ldr	r2, [r7, #32]
9001967e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90019680:	429a      	cmp	r2, r3
90019682:	dc13      	bgt.n	900196ac <UTIL_LCD_FillEllipse+0x128>
    {
      err += ++x_pos*2+1;
90019684:	6afb      	ldr	r3, [r7, #44]	; 0x2c
90019686:	3301      	adds	r3, #1
90019688:	62fb      	str	r3, [r7, #44]	; 0x2c
9001968a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
9001968c:	005b      	lsls	r3, r3, #1
9001968e:	3301      	adds	r3, #1
90019690:	6a7a      	ldr	r2, [r7, #36]	; 0x24
90019692:	4413      	add	r3, r2
90019694:	627b      	str	r3, [r7, #36]	; 0x24
      if (-y_pos == x_pos && e2 <= y_pos) e2 = 0;
90019696:	6abb      	ldr	r3, [r7, #40]	; 0x28
90019698:	425b      	negs	r3, r3
9001969a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
9001969c:	429a      	cmp	r2, r3
9001969e:	d105      	bne.n	900196ac <UTIL_LCD_FillEllipse+0x128>
900196a0:	6a3a      	ldr	r2, [r7, #32]
900196a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
900196a4:	429a      	cmp	r2, r3
900196a6:	dc01      	bgt.n	900196ac <UTIL_LCD_FillEllipse+0x128>
900196a8:	2300      	movs	r3, #0
900196aa:	623b      	str	r3, [r7, #32]
    }
    if (e2 > y_pos) err += ++y_pos*2+1;
900196ac:	6a3a      	ldr	r2, [r7, #32]
900196ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
900196b0:	429a      	cmp	r2, r3
900196b2:	dd08      	ble.n	900196c6 <UTIL_LCD_FillEllipse+0x142>
900196b4:	6abb      	ldr	r3, [r7, #40]	; 0x28
900196b6:	3301      	adds	r3, #1
900196b8:	62bb      	str	r3, [r7, #40]	; 0x28
900196ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
900196bc:	005b      	lsls	r3, r3, #1
900196be:	3301      	adds	r3, #1
900196c0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
900196c2:	4413      	add	r3, r2
900196c4:	627b      	str	r3, [r7, #36]	; 0x24
  }
  while (y_pos <= 0);
900196c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
900196c8:	2b00      	cmp	r3, #0
900196ca:	dd8b      	ble.n	900195e4 <UTIL_LCD_FillEllipse+0x60>
}
900196cc:	bf00      	nop
900196ce:	bf00      	nop
900196d0:	3730      	adds	r7, #48	; 0x30
900196d2:	46bd      	mov	sp, r7
900196d4:	bd80      	pop	{r7, pc}
	...

900196d8 <DrawChar>:
  * @param  Xpos  Line where to display the character shape
  * @param  Ypos  Start column address
  * @param  pData Pointer to the character data
  */
static void DrawChar(uint32_t Xpos, uint32_t Ypos, const uint8_t *pData)
{
900196d8:	b580      	push	{r7, lr}
900196da:	b0b2      	sub	sp, #200	; 0xc8
900196dc:	af02      	add	r7, sp, #8
900196de:	60f8      	str	r0, [r7, #12]
900196e0:	60b9      	str	r1, [r7, #8]
900196e2:	607a      	str	r2, [r7, #4]
  uint32_t i = 0, j = 0, offset;
900196e4:	2300      	movs	r3, #0
900196e6:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
900196ea:	2300      	movs	r3, #0
900196ec:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  uint32_t height, width;
  uint8_t  *pchar;
  uint32_t line;

  height = DrawProp[DrawProp->LcdLayer].pFont->Height;
900196f0:	4ba7      	ldr	r3, [pc, #668]	; (90019990 <DrawChar+0x2b8>)
900196f2:	68db      	ldr	r3, [r3, #12]
900196f4:	4aa6      	ldr	r2, [pc, #664]	; (90019990 <DrawChar+0x2b8>)
900196f6:	015b      	lsls	r3, r3, #5
900196f8:	4413      	add	r3, r2
900196fa:	3308      	adds	r3, #8
900196fc:	681b      	ldr	r3, [r3, #0]
900196fe:	88db      	ldrh	r3, [r3, #6]
90019700:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
  width  = DrawProp[DrawProp->LcdLayer].pFont->Width;
90019704:	4ba2      	ldr	r3, [pc, #648]	; (90019990 <DrawChar+0x2b8>)
90019706:	68db      	ldr	r3, [r3, #12]
90019708:	4aa1      	ldr	r2, [pc, #644]	; (90019990 <DrawChar+0x2b8>)
9001970a:	015b      	lsls	r3, r3, #5
9001970c:	4413      	add	r3, r2
9001970e:	3308      	adds	r3, #8
90019710:	681b      	ldr	r3, [r3, #0]
90019712:	889b      	ldrh	r3, [r3, #4]
90019714:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  uint16_t rgb565[24];
  uint32_t argb8888[24];

  offset =  8 *((width + 7)/8) -  width ;
90019718:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
9001971c:	3307      	adds	r3, #7
9001971e:	f023 0207 	bic.w	r2, r3, #7
90019722:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
90019726:	1ad3      	subs	r3, r2, r3
90019728:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

  for(i = 0; i < height; i++)
9001972c:	2300      	movs	r3, #0
9001972e:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
90019732:	e120      	b.n	90019976 <DrawChar+0x29e>
  {
    pchar = ((uint8_t *)pData + (width + 7)/8 * i);
90019734:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
90019738:	3307      	adds	r3, #7
9001973a:	08db      	lsrs	r3, r3, #3
9001973c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
90019740:	fb02 f303 	mul.w	r3, r2, r3
90019744:	687a      	ldr	r2, [r7, #4]
90019746:	4413      	add	r3, r2
90019748:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4

    switch(((width + 7)/8))
9001974c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
90019750:	3307      	adds	r3, #7
90019752:	08db      	lsrs	r3, r3, #3
90019754:	2b01      	cmp	r3, #1
90019756:	d002      	beq.n	9001975e <DrawChar+0x86>
90019758:	2b02      	cmp	r3, #2
9001975a:	d006      	beq.n	9001976a <DrawChar+0x92>
9001975c:	e011      	b.n	90019782 <DrawChar+0xaa>
    {

    case 1:
      line =  pchar[0];
9001975e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
90019762:	781b      	ldrb	r3, [r3, #0]
90019764:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
      break;
90019768:	e01d      	b.n	900197a6 <DrawChar+0xce>

    case 2:
      line =  (pchar[0]<< 8) | pchar[1];
9001976a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
9001976e:	781b      	ldrb	r3, [r3, #0]
90019770:	021b      	lsls	r3, r3, #8
90019772:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
90019776:	3201      	adds	r2, #1
90019778:	7812      	ldrb	r2, [r2, #0]
9001977a:	4313      	orrs	r3, r2
9001977c:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
      break;
90019780:	e011      	b.n	900197a6 <DrawChar+0xce>

    case 3:
    default:
      line =  (pchar[0]<< 16) | (pchar[1]<< 8) | pchar[2];
90019782:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
90019786:	781b      	ldrb	r3, [r3, #0]
90019788:	041a      	lsls	r2, r3, #16
9001978a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
9001978e:	3301      	adds	r3, #1
90019790:	781b      	ldrb	r3, [r3, #0]
90019792:	021b      	lsls	r3, r3, #8
90019794:	4313      	orrs	r3, r2
90019796:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
9001979a:	3202      	adds	r2, #2
9001979c:	7812      	ldrb	r2, [r2, #0]
9001979e:	4313      	orrs	r3, r2
900197a0:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
      break;
900197a4:	bf00      	nop
    }

    if(DrawProp[DrawProp->LcdLayer].LcdPixelFormat == LCD_PIXEL_FORMAT_RGB565)
900197a6:	4b7a      	ldr	r3, [pc, #488]	; (90019990 <DrawChar+0x2b8>)
900197a8:	68db      	ldr	r3, [r3, #12]
900197aa:	4a79      	ldr	r2, [pc, #484]	; (90019990 <DrawChar+0x2b8>)
900197ac:	015b      	lsls	r3, r3, #5
900197ae:	4413      	add	r3, r2
900197b0:	331c      	adds	r3, #28
900197b2:	681b      	ldr	r3, [r3, #0]
900197b4:	2b02      	cmp	r3, #2
900197b6:	f040 808e 	bne.w	900198d6 <DrawChar+0x1fe>
    {
      for (j = 0; j < width; j++)
900197ba:	2300      	movs	r3, #0
900197bc:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
900197c0:	e076      	b.n	900198b0 <DrawChar+0x1d8>
      {
        if(line & (1 << (width- j + offset- 1)))
900197c2:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
900197c6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
900197ca:	1ad2      	subs	r2, r2, r3
900197cc:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
900197d0:	4413      	add	r3, r2
900197d2:	3b01      	subs	r3, #1
900197d4:	2201      	movs	r2, #1
900197d6:	fa02 f303 	lsl.w	r3, r2, r3
900197da:	461a      	mov	r2, r3
900197dc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
900197e0:	4013      	ands	r3, r2
900197e2:	2b00      	cmp	r3, #0
900197e4:	d02e      	beq.n	90019844 <DrawChar+0x16c>
        {
          rgb565[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].TextColor);
900197e6:	4b6a      	ldr	r3, [pc, #424]	; (90019990 <DrawChar+0x2b8>)
900197e8:	68db      	ldr	r3, [r3, #12]
900197ea:	4a69      	ldr	r2, [pc, #420]	; (90019990 <DrawChar+0x2b8>)
900197ec:	015b      	lsls	r3, r3, #5
900197ee:	4413      	add	r3, r2
900197f0:	681b      	ldr	r3, [r3, #0]
900197f2:	08db      	lsrs	r3, r3, #3
900197f4:	b29b      	uxth	r3, r3
900197f6:	f003 031f 	and.w	r3, r3, #31
900197fa:	b29a      	uxth	r2, r3
900197fc:	4b64      	ldr	r3, [pc, #400]	; (90019990 <DrawChar+0x2b8>)
900197fe:	68db      	ldr	r3, [r3, #12]
90019800:	4963      	ldr	r1, [pc, #396]	; (90019990 <DrawChar+0x2b8>)
90019802:	015b      	lsls	r3, r3, #5
90019804:	440b      	add	r3, r1
90019806:	681b      	ldr	r3, [r3, #0]
90019808:	0a9b      	lsrs	r3, r3, #10
9001980a:	b29b      	uxth	r3, r3
9001980c:	015b      	lsls	r3, r3, #5
9001980e:	b29b      	uxth	r3, r3
90019810:	f403 63fc 	and.w	r3, r3, #2016	; 0x7e0
90019814:	b29b      	uxth	r3, r3
90019816:	4313      	orrs	r3, r2
90019818:	b29a      	uxth	r2, r3
9001981a:	4b5d      	ldr	r3, [pc, #372]	; (90019990 <DrawChar+0x2b8>)
9001981c:	68db      	ldr	r3, [r3, #12]
9001981e:	495c      	ldr	r1, [pc, #368]	; (90019990 <DrawChar+0x2b8>)
90019820:	015b      	lsls	r3, r3, #5
90019822:	440b      	add	r3, r1
90019824:	681b      	ldr	r3, [r3, #0]
90019826:	0cdb      	lsrs	r3, r3, #19
90019828:	b29b      	uxth	r3, r3
9001982a:	02db      	lsls	r3, r3, #11
9001982c:	b29b      	uxth	r3, r3
9001982e:	4313      	orrs	r3, r2
90019830:	b29a      	uxth	r2, r3
90019832:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
90019836:	005b      	lsls	r3, r3, #1
90019838:	f107 01c0 	add.w	r1, r7, #192	; 0xc0
9001983c:	440b      	add	r3, r1
9001983e:	f823 2c4c 	strh.w	r2, [r3, #-76]
90019842:	e030      	b.n	900198a6 <DrawChar+0x1ce>
        }
        else
        {
          rgb565[j] = CONVERTARGB88882RGB565(DrawProp[DrawProp->LcdLayer].BackColor);
90019844:	4b52      	ldr	r3, [pc, #328]	; (90019990 <DrawChar+0x2b8>)
90019846:	68db      	ldr	r3, [r3, #12]
90019848:	4a51      	ldr	r2, [pc, #324]	; (90019990 <DrawChar+0x2b8>)
9001984a:	015b      	lsls	r3, r3, #5
9001984c:	4413      	add	r3, r2
9001984e:	3304      	adds	r3, #4
90019850:	681b      	ldr	r3, [r3, #0]
90019852:	08db      	lsrs	r3, r3, #3
90019854:	b29b      	uxth	r3, r3
90019856:	f003 031f 	and.w	r3, r3, #31
9001985a:	b29a      	uxth	r2, r3
9001985c:	4b4c      	ldr	r3, [pc, #304]	; (90019990 <DrawChar+0x2b8>)
9001985e:	68db      	ldr	r3, [r3, #12]
90019860:	494b      	ldr	r1, [pc, #300]	; (90019990 <DrawChar+0x2b8>)
90019862:	015b      	lsls	r3, r3, #5
90019864:	440b      	add	r3, r1
90019866:	3304      	adds	r3, #4
90019868:	681b      	ldr	r3, [r3, #0]
9001986a:	0a9b      	lsrs	r3, r3, #10
9001986c:	b29b      	uxth	r3, r3
9001986e:	015b      	lsls	r3, r3, #5
90019870:	b29b      	uxth	r3, r3
90019872:	f403 63fc 	and.w	r3, r3, #2016	; 0x7e0
90019876:	b29b      	uxth	r3, r3
90019878:	4313      	orrs	r3, r2
9001987a:	b29a      	uxth	r2, r3
9001987c:	4b44      	ldr	r3, [pc, #272]	; (90019990 <DrawChar+0x2b8>)
9001987e:	68db      	ldr	r3, [r3, #12]
90019880:	4943      	ldr	r1, [pc, #268]	; (90019990 <DrawChar+0x2b8>)
90019882:	015b      	lsls	r3, r3, #5
90019884:	440b      	add	r3, r1
90019886:	3304      	adds	r3, #4
90019888:	681b      	ldr	r3, [r3, #0]
9001988a:	0cdb      	lsrs	r3, r3, #19
9001988c:	b29b      	uxth	r3, r3
9001988e:	02db      	lsls	r3, r3, #11
90019890:	b29b      	uxth	r3, r3
90019892:	4313      	orrs	r3, r2
90019894:	b29a      	uxth	r2, r3
90019896:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
9001989a:	005b      	lsls	r3, r3, #1
9001989c:	f107 01c0 	add.w	r1, r7, #192	; 0xc0
900198a0:	440b      	add	r3, r1
900198a2:	f823 2c4c 	strh.w	r2, [r3, #-76]
      for (j = 0; j < width; j++)
900198a6:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
900198aa:	3301      	adds	r3, #1
900198ac:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
900198b0:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
900198b4:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
900198b8:	429a      	cmp	r2, r3
900198ba:	d382      	bcc.n	900197c2 <DrawChar+0xea>
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, (uint8_t*)&rgb565[0], width, 1);
900198bc:	68b9      	ldr	r1, [r7, #8]
900198be:	1c4b      	adds	r3, r1, #1
900198c0:	60bb      	str	r3, [r7, #8]
900198c2:	f107 0274 	add.w	r2, r7, #116	; 0x74
900198c6:	2301      	movs	r3, #1
900198c8:	9300      	str	r3, [sp, #0]
900198ca:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
900198ce:	68f8      	ldr	r0, [r7, #12]
900198d0:	f7fe ff6a 	bl	900187a8 <UTIL_LCD_FillRGBRect>
900198d4:	e04a      	b.n	9001996c <DrawChar+0x294>
    }
    else
    {
      for (j = 0; j < width; j++)
900198d6:	2300      	movs	r3, #0
900198d8:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
900198dc:	e034      	b.n	90019948 <DrawChar+0x270>
      {
        if(line & (1 << (width- j + offset- 1)))
900198de:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
900198e2:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
900198e6:	1ad2      	subs	r2, r2, r3
900198e8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
900198ec:	4413      	add	r3, r2
900198ee:	3b01      	subs	r3, #1
900198f0:	2201      	movs	r2, #1
900198f2:	fa02 f303 	lsl.w	r3, r2, r3
900198f6:	461a      	mov	r2, r3
900198f8:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
900198fc:	4013      	ands	r3, r2
900198fe:	2b00      	cmp	r3, #0
90019900:	d00e      	beq.n	90019920 <DrawChar+0x248>
        {
          argb8888[j] = DrawProp[DrawProp->LcdLayer].TextColor;
90019902:	4b23      	ldr	r3, [pc, #140]	; (90019990 <DrawChar+0x2b8>)
90019904:	68db      	ldr	r3, [r3, #12]
90019906:	4a22      	ldr	r2, [pc, #136]	; (90019990 <DrawChar+0x2b8>)
90019908:	015b      	lsls	r3, r3, #5
9001990a:	4413      	add	r3, r2
9001990c:	681a      	ldr	r2, [r3, #0]
9001990e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
90019912:	009b      	lsls	r3, r3, #2
90019914:	f107 01c0 	add.w	r1, r7, #192	; 0xc0
90019918:	440b      	add	r3, r1
9001991a:	f843 2cac 	str.w	r2, [r3, #-172]
9001991e:	e00e      	b.n	9001993e <DrawChar+0x266>
        }
        else
        {
          argb8888[j] = DrawProp[DrawProp->LcdLayer].BackColor;
90019920:	4b1b      	ldr	r3, [pc, #108]	; (90019990 <DrawChar+0x2b8>)
90019922:	68db      	ldr	r3, [r3, #12]
90019924:	4a1a      	ldr	r2, [pc, #104]	; (90019990 <DrawChar+0x2b8>)
90019926:	015b      	lsls	r3, r3, #5
90019928:	4413      	add	r3, r2
9001992a:	3304      	adds	r3, #4
9001992c:	681a      	ldr	r2, [r3, #0]
9001992e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
90019932:	009b      	lsls	r3, r3, #2
90019934:	f107 01c0 	add.w	r1, r7, #192	; 0xc0
90019938:	440b      	add	r3, r1
9001993a:	f843 2cac 	str.w	r2, [r3, #-172]
      for (j = 0; j < width; j++)
9001993e:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
90019942:	3301      	adds	r3, #1
90019944:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
90019948:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
9001994c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
90019950:	429a      	cmp	r2, r3
90019952:	d3c4      	bcc.n	900198de <DrawChar+0x206>
        }
      }
      UTIL_LCD_FillRGBRect(Xpos,  Ypos++, (uint8_t*)&argb8888[0], width, 1);
90019954:	68b9      	ldr	r1, [r7, #8]
90019956:	1c4b      	adds	r3, r1, #1
90019958:	60bb      	str	r3, [r7, #8]
9001995a:	f107 0214 	add.w	r2, r7, #20
9001995e:	2301      	movs	r3, #1
90019960:	9300      	str	r3, [sp, #0]
90019962:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
90019966:	68f8      	ldr	r0, [r7, #12]
90019968:	f7fe ff1e 	bl	900187a8 <UTIL_LCD_FillRGBRect>
  for(i = 0; i < height; i++)
9001996c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
90019970:	3301      	adds	r3, #1
90019972:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
90019976:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
9001997a:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
9001997e:	429a      	cmp	r2, r3
90019980:	f4ff aed8 	bcc.w	90019734 <DrawChar+0x5c>
    }
  }
}
90019984:	bf00      	nop
90019986:	bf00      	nop
90019988:	37c0      	adds	r7, #192	; 0xc0
9001998a:	46bd      	mov	sp, r7
9001998c:	bd80      	pop	{r7, pc}
9001998e:	bf00      	nop
90019990:	2400286c 	.word	0x2400286c

90019994 <FillTriangle>:
  * @brief  Fills a triangle (between 3 points).
  * @param  Positions  pointer to riangle coordinates
  * @param  Color      Draw color
  */
static void FillTriangle(Triangle_Positions_t *Positions, uint32_t Color)
{
90019994:	b590      	push	{r4, r7, lr}
90019996:	b08f      	sub	sp, #60	; 0x3c
90019998:	af02      	add	r7, sp, #8
9001999a:	6078      	str	r0, [r7, #4]
9001999c:	6039      	str	r1, [r7, #0]
  int16_t deltax = 0, deltay = 0, x = 0, y = 0, xinc1 = 0, xinc2 = 0,
9001999e:	2300      	movs	r3, #0
900199a0:	833b      	strh	r3, [r7, #24]
900199a2:	2300      	movs	r3, #0
900199a4:	82fb      	strh	r3, [r7, #22]
900199a6:	2300      	movs	r3, #0
900199a8:	85fb      	strh	r3, [r7, #46]	; 0x2e
900199aa:	2300      	movs	r3, #0
900199ac:	85bb      	strh	r3, [r7, #44]	; 0x2c
900199ae:	2300      	movs	r3, #0
900199b0:	857b      	strh	r3, [r7, #42]	; 0x2a
900199b2:	2300      	movs	r3, #0
900199b4:	853b      	strh	r3, [r7, #40]	; 0x28
  yinc1 = 0, yinc2 = 0, den = 0, num = 0, numadd = 0, numpixels = 0,
900199b6:	2300      	movs	r3, #0
900199b8:	84fb      	strh	r3, [r7, #38]	; 0x26
900199ba:	2300      	movs	r3, #0
900199bc:	84bb      	strh	r3, [r7, #36]	; 0x24
900199be:	2300      	movs	r3, #0
900199c0:	847b      	strh	r3, [r7, #34]	; 0x22
900199c2:	2300      	movs	r3, #0
900199c4:	843b      	strh	r3, [r7, #32]
900199c6:	2300      	movs	r3, #0
900199c8:	83fb      	strh	r3, [r7, #30]
900199ca:	2300      	movs	r3, #0
900199cc:	83bb      	strh	r3, [r7, #28]
  curpixel = 0;
900199ce:	2300      	movs	r3, #0
900199d0:	837b      	strh	r3, [r7, #26]
  int32_t x_diff, y_diff;

  x_diff = Positions->x2 - Positions->x1;
900199d2:	687b      	ldr	r3, [r7, #4]
900199d4:	689a      	ldr	r2, [r3, #8]
900199d6:	687b      	ldr	r3, [r7, #4]
900199d8:	681b      	ldr	r3, [r3, #0]
900199da:	1ad3      	subs	r3, r2, r3
900199dc:	613b      	str	r3, [r7, #16]
  y_diff = Positions->y2 - Positions->y1;
900199de:	687b      	ldr	r3, [r7, #4]
900199e0:	68da      	ldr	r2, [r3, #12]
900199e2:	687b      	ldr	r3, [r7, #4]
900199e4:	685b      	ldr	r3, [r3, #4]
900199e6:	1ad3      	subs	r3, r2, r3
900199e8:	60fb      	str	r3, [r7, #12]

  deltax = ABS(x_diff);         /* The absolute difference between the x's */
900199ea:	693b      	ldr	r3, [r7, #16]
900199ec:	2b00      	cmp	r3, #0
900199ee:	bfb8      	it	lt
900199f0:	425b      	neglt	r3, r3
900199f2:	833b      	strh	r3, [r7, #24]
  deltay = ABS(y_diff);         /* The absolute difference between the y's */
900199f4:	68fb      	ldr	r3, [r7, #12]
900199f6:	2b00      	cmp	r3, #0
900199f8:	bfb8      	it	lt
900199fa:	425b      	neglt	r3, r3
900199fc:	82fb      	strh	r3, [r7, #22]
  x = Positions->x1;                       /* Start x off at the first pixel */
900199fe:	687b      	ldr	r3, [r7, #4]
90019a00:	681b      	ldr	r3, [r3, #0]
90019a02:	85fb      	strh	r3, [r7, #46]	; 0x2e
  y = Positions->y1;                       /* Start y off at the first pixel */
90019a04:	687b      	ldr	r3, [r7, #4]
90019a06:	685b      	ldr	r3, [r3, #4]
90019a08:	85bb      	strh	r3, [r7, #44]	; 0x2c

  if (Positions->x2 >= Positions->x1)                 /* The x-values are increasing */
90019a0a:	687b      	ldr	r3, [r7, #4]
90019a0c:	689a      	ldr	r2, [r3, #8]
90019a0e:	687b      	ldr	r3, [r7, #4]
90019a10:	681b      	ldr	r3, [r3, #0]
90019a12:	429a      	cmp	r2, r3
90019a14:	d304      	bcc.n	90019a20 <FillTriangle+0x8c>
  {
    xinc1 = 1;
90019a16:	2301      	movs	r3, #1
90019a18:	857b      	strh	r3, [r7, #42]	; 0x2a
    xinc2 = 1;
90019a1a:	2301      	movs	r3, #1
90019a1c:	853b      	strh	r3, [r7, #40]	; 0x28
90019a1e:	e005      	b.n	90019a2c <FillTriangle+0x98>
  }
  else                          /* The x-values are decreasing */
  {
    xinc1 = -1;
90019a20:	f64f 73ff 	movw	r3, #65535	; 0xffff
90019a24:	857b      	strh	r3, [r7, #42]	; 0x2a
    xinc2 = -1;
90019a26:	f64f 73ff 	movw	r3, #65535	; 0xffff
90019a2a:	853b      	strh	r3, [r7, #40]	; 0x28
  }

  if (Positions->y2 >= Positions->y1)                 /* The y-values are increasing */
90019a2c:	687b      	ldr	r3, [r7, #4]
90019a2e:	68da      	ldr	r2, [r3, #12]
90019a30:	687b      	ldr	r3, [r7, #4]
90019a32:	685b      	ldr	r3, [r3, #4]
90019a34:	429a      	cmp	r2, r3
90019a36:	d304      	bcc.n	90019a42 <FillTriangle+0xae>
  {
    yinc1 = 1;
90019a38:	2301      	movs	r3, #1
90019a3a:	84fb      	strh	r3, [r7, #38]	; 0x26
    yinc2 = 1;
90019a3c:	2301      	movs	r3, #1
90019a3e:	84bb      	strh	r3, [r7, #36]	; 0x24
90019a40:	e005      	b.n	90019a4e <FillTriangle+0xba>
  }
  else                          /* The y-values are decreasing */
  {
    yinc1 = -1;
90019a42:	f64f 73ff 	movw	r3, #65535	; 0xffff
90019a46:	84fb      	strh	r3, [r7, #38]	; 0x26
    yinc2 = -1;
90019a48:	f64f 73ff 	movw	r3, #65535	; 0xffff
90019a4c:	84bb      	strh	r3, [r7, #36]	; 0x24
  }

  if (deltax >= deltay)         /* There is at least one x-value for every y-value */
90019a4e:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
90019a52:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
90019a56:	429a      	cmp	r2, r3
90019a58:	db11      	blt.n	90019a7e <FillTriangle+0xea>
  {
    xinc1 = 0;                  /* Don't change the x when numerator >= denominator */
90019a5a:	2300      	movs	r3, #0
90019a5c:	857b      	strh	r3, [r7, #42]	; 0x2a
    yinc2 = 0;                  /* Don't change the y for every iteration */
90019a5e:	2300      	movs	r3, #0
90019a60:	84bb      	strh	r3, [r7, #36]	; 0x24
    den = deltax;
90019a62:	8b3b      	ldrh	r3, [r7, #24]
90019a64:	847b      	strh	r3, [r7, #34]	; 0x22
    num = deltax / 2;
90019a66:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
90019a6a:	2b00      	cmp	r3, #0
90019a6c:	da00      	bge.n	90019a70 <FillTriangle+0xdc>
90019a6e:	3301      	adds	r3, #1
90019a70:	105b      	asrs	r3, r3, #1
90019a72:	843b      	strh	r3, [r7, #32]
    numadd = deltay;
90019a74:	8afb      	ldrh	r3, [r7, #22]
90019a76:	83fb      	strh	r3, [r7, #30]
    numpixels = deltax;         /* There are more x-values than y-values */
90019a78:	8b3b      	ldrh	r3, [r7, #24]
90019a7a:	83bb      	strh	r3, [r7, #28]
90019a7c:	e010      	b.n	90019aa0 <FillTriangle+0x10c>
  }
  else                          /* There is at least one y-value for every x-value */
  {
    xinc2 = 0;                  /* Don't change the x for every iteration */
90019a7e:	2300      	movs	r3, #0
90019a80:	853b      	strh	r3, [r7, #40]	; 0x28
    yinc1 = 0;                  /* Don't change the y when numerator >= denominator */
90019a82:	2300      	movs	r3, #0
90019a84:	84fb      	strh	r3, [r7, #38]	; 0x26
    den = deltay;
90019a86:	8afb      	ldrh	r3, [r7, #22]
90019a88:	847b      	strh	r3, [r7, #34]	; 0x22
    num = deltay / 2;
90019a8a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
90019a8e:	2b00      	cmp	r3, #0
90019a90:	da00      	bge.n	90019a94 <FillTriangle+0x100>
90019a92:	3301      	adds	r3, #1
90019a94:	105b      	asrs	r3, r3, #1
90019a96:	843b      	strh	r3, [r7, #32]
    numadd = deltax;
90019a98:	8b3b      	ldrh	r3, [r7, #24]
90019a9a:	83fb      	strh	r3, [r7, #30]
    numpixels = deltay;         /* There are more y-values than x-values */
90019a9c:	8afb      	ldrh	r3, [r7, #22]
90019a9e:	83bb      	strh	r3, [r7, #28]
  }

  for (curpixel = 0; curpixel <= numpixels; curpixel++)
90019aa0:	2300      	movs	r3, #0
90019aa2:	837b      	strh	r3, [r7, #26]
90019aa4:	e036      	b.n	90019b14 <FillTriangle+0x180>
  {
    UTIL_LCD_DrawLine(x, y, Positions->x3, Positions->y3, Color);
90019aa6:	f9b7 002e 	ldrsh.w	r0, [r7, #46]	; 0x2e
90019aaa:	f9b7 102c 	ldrsh.w	r1, [r7, #44]	; 0x2c
90019aae:	687b      	ldr	r3, [r7, #4]
90019ab0:	691a      	ldr	r2, [r3, #16]
90019ab2:	687b      	ldr	r3, [r7, #4]
90019ab4:	695c      	ldr	r4, [r3, #20]
90019ab6:	683b      	ldr	r3, [r7, #0]
90019ab8:	9300      	str	r3, [sp, #0]
90019aba:	4623      	mov	r3, r4
90019abc:	f7ff f82a 	bl	90018b14 <UTIL_LCD_DrawLine>

    num += numadd;              /* Increase the numerator by the top of the fraction */
90019ac0:	8c3a      	ldrh	r2, [r7, #32]
90019ac2:	8bfb      	ldrh	r3, [r7, #30]
90019ac4:	4413      	add	r3, r2
90019ac6:	b29b      	uxth	r3, r3
90019ac8:	843b      	strh	r3, [r7, #32]
    if (num >= den)             /* Check if numerator >= denominator */
90019aca:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
90019ace:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
90019ad2:	429a      	cmp	r2, r3
90019ad4:	db0e      	blt.n	90019af4 <FillTriangle+0x160>
    {
      num -= den;               /* Calculate the new numerator value */
90019ad6:	8c3a      	ldrh	r2, [r7, #32]
90019ad8:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
90019ada:	1ad3      	subs	r3, r2, r3
90019adc:	b29b      	uxth	r3, r3
90019ade:	843b      	strh	r3, [r7, #32]
      x += xinc1;               /* Change the x as appropriate */
90019ae0:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
90019ae2:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
90019ae4:	4413      	add	r3, r2
90019ae6:	b29b      	uxth	r3, r3
90019ae8:	85fb      	strh	r3, [r7, #46]	; 0x2e
      y += yinc1;               /* Change the y as appropriate */
90019aea:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
90019aec:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
90019aee:	4413      	add	r3, r2
90019af0:	b29b      	uxth	r3, r3
90019af2:	85bb      	strh	r3, [r7, #44]	; 0x2c
    }
    x += xinc2;                 /* Change the x as appropriate */
90019af4:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
90019af6:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
90019af8:	4413      	add	r3, r2
90019afa:	b29b      	uxth	r3, r3
90019afc:	85fb      	strh	r3, [r7, #46]	; 0x2e
    y += yinc2;                 /* Change the y as appropriate */
90019afe:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
90019b00:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
90019b02:	4413      	add	r3, r2
90019b04:	b29b      	uxth	r3, r3
90019b06:	85bb      	strh	r3, [r7, #44]	; 0x2c
  for (curpixel = 0; curpixel <= numpixels; curpixel++)
90019b08:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
90019b0c:	b29b      	uxth	r3, r3
90019b0e:	3301      	adds	r3, #1
90019b10:	b29b      	uxth	r3, r3
90019b12:	837b      	strh	r3, [r7, #26]
90019b14:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
90019b18:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
90019b1c:	429a      	cmp	r2, r3
90019b1e:	ddc2      	ble.n	90019aa6 <FillTriangle+0x112>
  }
}
90019b20:	bf00      	nop
90019b22:	bf00      	nop
90019b24:	3734      	adds	r7, #52	; 0x34
90019b26:	46bd      	mov	sp, r7
90019b28:	bd90      	pop	{r4, r7, pc}

90019b2a <__aeabi_memclr>:
90019b2a:	2200      	movs	r2, #0
90019b2c:	f7e8 bb00 	b.w	90002130 <__aeabi_memset>

90019b30 <__errno>:
90019b30:	4b01      	ldr	r3, [pc, #4]	; (90019b38 <__errno+0x8>)
90019b32:	6818      	ldr	r0, [r3, #0]
90019b34:	4770      	bx	lr
90019b36:	bf00      	nop
90019b38:	240007b4 	.word	0x240007b4

90019b3c <__libc_init_array>:
90019b3c:	b570      	push	{r4, r5, r6, lr}
90019b3e:	4d0d      	ldr	r5, [pc, #52]	; (90019b74 <__libc_init_array+0x38>)
90019b40:	4c0d      	ldr	r4, [pc, #52]	; (90019b78 <__libc_init_array+0x3c>)
90019b42:	1b64      	subs	r4, r4, r5
90019b44:	10a4      	asrs	r4, r4, #2
90019b46:	2600      	movs	r6, #0
90019b48:	42a6      	cmp	r6, r4
90019b4a:	d109      	bne.n	90019b60 <__libc_init_array+0x24>
90019b4c:	4d0b      	ldr	r5, [pc, #44]	; (90019b7c <__libc_init_array+0x40>)
90019b4e:	4c0c      	ldr	r4, [pc, #48]	; (90019b80 <__libc_init_array+0x44>)
90019b50:	f004 fe2c 	bl	9001e7ac <_init>
90019b54:	1b64      	subs	r4, r4, r5
90019b56:	10a4      	asrs	r4, r4, #2
90019b58:	2600      	movs	r6, #0
90019b5a:	42a6      	cmp	r6, r4
90019b5c:	d105      	bne.n	90019b6a <__libc_init_array+0x2e>
90019b5e:	bd70      	pop	{r4, r5, r6, pc}
90019b60:	f855 3b04 	ldr.w	r3, [r5], #4
90019b64:	4798      	blx	r3
90019b66:	3601      	adds	r6, #1
90019b68:	e7ee      	b.n	90019b48 <__libc_init_array+0xc>
90019b6a:	f855 3b04 	ldr.w	r3, [r5], #4
90019b6e:	4798      	blx	r3
90019b70:	3601      	adds	r6, #1
90019b72:	e7f2      	b.n	90019b5a <__libc_init_array+0x1e>
90019b74:	90025958 	.word	0x90025958
90019b78:	90025958 	.word	0x90025958
90019b7c:	90025958 	.word	0x90025958
90019b80:	90025960 	.word	0x90025960

90019b84 <memcpy>:
90019b84:	440a      	add	r2, r1
90019b86:	4291      	cmp	r1, r2
90019b88:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
90019b8c:	d100      	bne.n	90019b90 <memcpy+0xc>
90019b8e:	4770      	bx	lr
90019b90:	b510      	push	{r4, lr}
90019b92:	f811 4b01 	ldrb.w	r4, [r1], #1
90019b96:	f803 4f01 	strb.w	r4, [r3, #1]!
90019b9a:	4291      	cmp	r1, r2
90019b9c:	d1f9      	bne.n	90019b92 <memcpy+0xe>
90019b9e:	bd10      	pop	{r4, pc}

90019ba0 <memset>:
90019ba0:	4402      	add	r2, r0
90019ba2:	4603      	mov	r3, r0
90019ba4:	4293      	cmp	r3, r2
90019ba6:	d100      	bne.n	90019baa <memset+0xa>
90019ba8:	4770      	bx	lr
90019baa:	f803 1b01 	strb.w	r1, [r3], #1
90019bae:	e7f9      	b.n	90019ba4 <memset+0x4>

90019bb0 <sprintf>:
90019bb0:	b40e      	push	{r1, r2, r3}
90019bb2:	b500      	push	{lr}
90019bb4:	b09c      	sub	sp, #112	; 0x70
90019bb6:	ab1d      	add	r3, sp, #116	; 0x74
90019bb8:	9002      	str	r0, [sp, #8]
90019bba:	9006      	str	r0, [sp, #24]
90019bbc:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
90019bc0:	4809      	ldr	r0, [pc, #36]	; (90019be8 <sprintf+0x38>)
90019bc2:	9107      	str	r1, [sp, #28]
90019bc4:	9104      	str	r1, [sp, #16]
90019bc6:	4909      	ldr	r1, [pc, #36]	; (90019bec <sprintf+0x3c>)
90019bc8:	f853 2b04 	ldr.w	r2, [r3], #4
90019bcc:	9105      	str	r1, [sp, #20]
90019bce:	6800      	ldr	r0, [r0, #0]
90019bd0:	9301      	str	r3, [sp, #4]
90019bd2:	a902      	add	r1, sp, #8
90019bd4:	f000 f80c 	bl	90019bf0 <_svfprintf_r>
90019bd8:	9b02      	ldr	r3, [sp, #8]
90019bda:	2200      	movs	r2, #0
90019bdc:	701a      	strb	r2, [r3, #0]
90019bde:	b01c      	add	sp, #112	; 0x70
90019be0:	f85d eb04 	ldr.w	lr, [sp], #4
90019be4:	b003      	add	sp, #12
90019be6:	4770      	bx	lr
90019be8:	240007b4 	.word	0x240007b4
90019bec:	ffff0208 	.word	0xffff0208

90019bf0 <_svfprintf_r>:
90019bf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90019bf4:	ed2d 8b04 	vpush	{d8-d9}
90019bf8:	b0cb      	sub	sp, #300	; 0x12c
90019bfa:	468b      	mov	fp, r1
90019bfc:	4692      	mov	sl, r2
90019bfe:	461e      	mov	r6, r3
90019c00:	4681      	mov	r9, r0
90019c02:	f002 f891 	bl	9001bd28 <_localeconv_r>
90019c06:	6803      	ldr	r3, [r0, #0]
90019c08:	930f      	str	r3, [sp, #60]	; 0x3c
90019c0a:	4618      	mov	r0, r3
90019c0c:	f7e8 fb30 	bl	90002270 <strlen>
90019c10:	f8bb 300c 	ldrh.w	r3, [fp, #12]
90019c14:	900a      	str	r0, [sp, #40]	; 0x28
90019c16:	0618      	lsls	r0, r3, #24
90019c18:	d51a      	bpl.n	90019c50 <_svfprintf_r+0x60>
90019c1a:	f8db 3010 	ldr.w	r3, [fp, #16]
90019c1e:	b9bb      	cbnz	r3, 90019c50 <_svfprintf_r+0x60>
90019c20:	2140      	movs	r1, #64	; 0x40
90019c22:	4648      	mov	r0, r9
90019c24:	f002 f888 	bl	9001bd38 <_malloc_r>
90019c28:	f8cb 0000 	str.w	r0, [fp]
90019c2c:	f8cb 0010 	str.w	r0, [fp, #16]
90019c30:	b958      	cbnz	r0, 90019c4a <_svfprintf_r+0x5a>
90019c32:	230c      	movs	r3, #12
90019c34:	f8c9 3000 	str.w	r3, [r9]
90019c38:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
90019c3c:	930b      	str	r3, [sp, #44]	; 0x2c
90019c3e:	980b      	ldr	r0, [sp, #44]	; 0x2c
90019c40:	b04b      	add	sp, #300	; 0x12c
90019c42:	ecbd 8b04 	vpop	{d8-d9}
90019c46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
90019c4a:	2340      	movs	r3, #64	; 0x40
90019c4c:	f8cb 3014 	str.w	r3, [fp, #20]
90019c50:	2300      	movs	r3, #0
90019c52:	e9cd 331f 	strd	r3, r3, [sp, #124]	; 0x7c
90019c56:	ed9f 8b98 	vldr	d8, [pc, #608]	; 90019eb8 <_svfprintf_r+0x2c8>
90019c5a:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
90019c5e:	ac21      	add	r4, sp, #132	; 0x84
90019c60:	941e      	str	r4, [sp, #120]	; 0x78
90019c62:	9303      	str	r3, [sp, #12]
90019c64:	9308      	str	r3, [sp, #32]
90019c66:	930e      	str	r3, [sp, #56]	; 0x38
90019c68:	9310      	str	r3, [sp, #64]	; 0x40
90019c6a:	930b      	str	r3, [sp, #44]	; 0x2c
90019c6c:	4653      	mov	r3, sl
90019c6e:	461d      	mov	r5, r3
90019c70:	f813 2b01 	ldrb.w	r2, [r3], #1
90019c74:	b10a      	cbz	r2, 90019c7a <_svfprintf_r+0x8a>
90019c76:	2a25      	cmp	r2, #37	; 0x25
90019c78:	d1f9      	bne.n	90019c6e <_svfprintf_r+0x7e>
90019c7a:	ebb5 070a 	subs.w	r7, r5, sl
90019c7e:	d00d      	beq.n	90019c9c <_svfprintf_r+0xac>
90019c80:	9b20      	ldr	r3, [sp, #128]	; 0x80
90019c82:	443b      	add	r3, r7
90019c84:	9320      	str	r3, [sp, #128]	; 0x80
90019c86:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
90019c88:	3301      	adds	r3, #1
90019c8a:	2b07      	cmp	r3, #7
90019c8c:	e9c4 a700 	strd	sl, r7, [r4]
90019c90:	931f      	str	r3, [sp, #124]	; 0x7c
90019c92:	dc77      	bgt.n	90019d84 <_svfprintf_r+0x194>
90019c94:	3408      	adds	r4, #8
90019c96:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
90019c98:	443b      	add	r3, r7
90019c9a:	930b      	str	r3, [sp, #44]	; 0x2c
90019c9c:	782b      	ldrb	r3, [r5, #0]
90019c9e:	2b00      	cmp	r3, #0
90019ca0:	f001 80d6 	beq.w	9001ae50 <_svfprintf_r+0x1260>
90019ca4:	2200      	movs	r2, #0
90019ca6:	1c6b      	adds	r3, r5, #1
90019ca8:	f88d 205b 	strb.w	r2, [sp, #91]	; 0x5b
90019cac:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
90019cb0:	920c      	str	r2, [sp, #48]	; 0x30
90019cb2:	4615      	mov	r5, r2
90019cb4:	272b      	movs	r7, #43	; 0x2b
90019cb6:	461a      	mov	r2, r3
90019cb8:	f812 3b01 	ldrb.w	r3, [r2], #1
90019cbc:	9305      	str	r3, [sp, #20]
90019cbe:	9209      	str	r2, [sp, #36]	; 0x24
90019cc0:	9b05      	ldr	r3, [sp, #20]
90019cc2:	3b20      	subs	r3, #32
90019cc4:	2b5a      	cmp	r3, #90	; 0x5a
90019cc6:	f200 854a 	bhi.w	9001a75e <_svfprintf_r+0xb6e>
90019cca:	e8df f013 	tbh	[pc, r3, lsl #1]
90019cce:	007d      	.short	0x007d
90019cd0:	05480548 	.word	0x05480548
90019cd4:	05480085 	.word	0x05480085
90019cd8:	05480548 	.word	0x05480548
90019cdc:	05480065 	.word	0x05480065
90019ce0:	00880548 	.word	0x00880548
90019ce4:	05480092 	.word	0x05480092
90019ce8:	0095008f 	.word	0x0095008f
90019cec:	00b00548 	.word	0x00b00548
90019cf0:	00b300b3 	.word	0x00b300b3
90019cf4:	00b300b3 	.word	0x00b300b3
90019cf8:	00b300b3 	.word	0x00b300b3
90019cfc:	00b300b3 	.word	0x00b300b3
90019d00:	054800b3 	.word	0x054800b3
90019d04:	05480548 	.word	0x05480548
90019d08:	05480548 	.word	0x05480548
90019d0c:	05480548 	.word	0x05480548
90019d10:	05480125 	.word	0x05480125
90019d14:	00fd00e1 	.word	0x00fd00e1
90019d18:	01250125 	.word	0x01250125
90019d1c:	05480125 	.word	0x05480125
90019d20:	05480548 	.word	0x05480548
90019d24:	00c40548 	.word	0x00c40548
90019d28:	05480548 	.word	0x05480548
90019d2c:	05480435 	.word	0x05480435
90019d30:	05480548 	.word	0x05480548
90019d34:	05480478 	.word	0x05480478
90019d38:	0548049b 	.word	0x0548049b
90019d3c:	04b60548 	.word	0x04b60548
90019d40:	05480548 	.word	0x05480548
90019d44:	05480548 	.word	0x05480548
90019d48:	05480548 	.word	0x05480548
90019d4c:	05480548 	.word	0x05480548
90019d50:	05480125 	.word	0x05480125
90019d54:	00ff00e1 	.word	0x00ff00e1
90019d58:	01250125 	.word	0x01250125
90019d5c:	00c70125 	.word	0x00c70125
90019d60:	00db00ff 	.word	0x00db00ff
90019d64:	00d40548 	.word	0x00d40548
90019d68:	04160548 	.word	0x04160548
90019d6c:	04670437 	.word	0x04670437
90019d70:	054800db 	.word	0x054800db
90019d74:	007b0478 	.word	0x007b0478
90019d78:	0548049d 	.word	0x0548049d
90019d7c:	04d10548 	.word	0x04d10548
90019d80:	007b0548 	.word	0x007b0548
90019d84:	aa1e      	add	r2, sp, #120	; 0x78
90019d86:	4659      	mov	r1, fp
90019d88:	4648      	mov	r0, r9
90019d8a:	f002 fdb4 	bl	9001c8f6 <__ssprint_r>
90019d8e:	2800      	cmp	r0, #0
90019d90:	f040 811f 	bne.w	90019fd2 <_svfprintf_r+0x3e2>
90019d94:	ac21      	add	r4, sp, #132	; 0x84
90019d96:	e77e      	b.n	90019c96 <_svfprintf_r+0xa6>
90019d98:	4648      	mov	r0, r9
90019d9a:	f001 ffc5 	bl	9001bd28 <_localeconv_r>
90019d9e:	6843      	ldr	r3, [r0, #4]
90019da0:	9310      	str	r3, [sp, #64]	; 0x40
90019da2:	4618      	mov	r0, r3
90019da4:	f7e8 fa64 	bl	90002270 <strlen>
90019da8:	900e      	str	r0, [sp, #56]	; 0x38
90019daa:	4648      	mov	r0, r9
90019dac:	f001 ffbc 	bl	9001bd28 <_localeconv_r>
90019db0:	6883      	ldr	r3, [r0, #8]
90019db2:	9308      	str	r3, [sp, #32]
90019db4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
90019db6:	b12b      	cbz	r3, 90019dc4 <_svfprintf_r+0x1d4>
90019db8:	9b08      	ldr	r3, [sp, #32]
90019dba:	b11b      	cbz	r3, 90019dc4 <_svfprintf_r+0x1d4>
90019dbc:	781b      	ldrb	r3, [r3, #0]
90019dbe:	b10b      	cbz	r3, 90019dc4 <_svfprintf_r+0x1d4>
90019dc0:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
90019dc4:	9b09      	ldr	r3, [sp, #36]	; 0x24
90019dc6:	e776      	b.n	90019cb6 <_svfprintf_r+0xc6>
90019dc8:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
90019dcc:	2b00      	cmp	r3, #0
90019dce:	d1f9      	bne.n	90019dc4 <_svfprintf_r+0x1d4>
90019dd0:	2320      	movs	r3, #32
90019dd2:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
90019dd6:	e7f5      	b.n	90019dc4 <_svfprintf_r+0x1d4>
90019dd8:	f045 0501 	orr.w	r5, r5, #1
90019ddc:	e7f2      	b.n	90019dc4 <_svfprintf_r+0x1d4>
90019dde:	f856 3b04 	ldr.w	r3, [r6], #4
90019de2:	930c      	str	r3, [sp, #48]	; 0x30
90019de4:	2b00      	cmp	r3, #0
90019de6:	daed      	bge.n	90019dc4 <_svfprintf_r+0x1d4>
90019de8:	425b      	negs	r3, r3
90019dea:	930c      	str	r3, [sp, #48]	; 0x30
90019dec:	f045 0504 	orr.w	r5, r5, #4
90019df0:	e7e8      	b.n	90019dc4 <_svfprintf_r+0x1d4>
90019df2:	f88d 705b 	strb.w	r7, [sp, #91]	; 0x5b
90019df6:	e7e5      	b.n	90019dc4 <_svfprintf_r+0x1d4>
90019df8:	9a09      	ldr	r2, [sp, #36]	; 0x24
90019dfa:	f812 3b01 	ldrb.w	r3, [r2], #1
90019dfe:	9305      	str	r3, [sp, #20]
90019e00:	2b2a      	cmp	r3, #42	; 0x2a
90019e02:	d111      	bne.n	90019e28 <_svfprintf_r+0x238>
90019e04:	f856 0b04 	ldr.w	r0, [r6], #4
90019e08:	9209      	str	r2, [sp, #36]	; 0x24
90019e0a:	ea40 78e0 	orr.w	r8, r0, r0, asr #31
90019e0e:	e7d9      	b.n	90019dc4 <_svfprintf_r+0x1d4>
90019e10:	210a      	movs	r1, #10
90019e12:	fb01 3808 	mla	r8, r1, r8, r3
90019e16:	f812 3b01 	ldrb.w	r3, [r2], #1
90019e1a:	9305      	str	r3, [sp, #20]
90019e1c:	9b05      	ldr	r3, [sp, #20]
90019e1e:	3b30      	subs	r3, #48	; 0x30
90019e20:	2b09      	cmp	r3, #9
90019e22:	d9f5      	bls.n	90019e10 <_svfprintf_r+0x220>
90019e24:	9209      	str	r2, [sp, #36]	; 0x24
90019e26:	e74b      	b.n	90019cc0 <_svfprintf_r+0xd0>
90019e28:	f04f 0800 	mov.w	r8, #0
90019e2c:	e7f6      	b.n	90019e1c <_svfprintf_r+0x22c>
90019e2e:	f045 0580 	orr.w	r5, r5, #128	; 0x80
90019e32:	e7c7      	b.n	90019dc4 <_svfprintf_r+0x1d4>
90019e34:	2300      	movs	r3, #0
90019e36:	9a09      	ldr	r2, [sp, #36]	; 0x24
90019e38:	930c      	str	r3, [sp, #48]	; 0x30
90019e3a:	9b05      	ldr	r3, [sp, #20]
90019e3c:	990c      	ldr	r1, [sp, #48]	; 0x30
90019e3e:	3b30      	subs	r3, #48	; 0x30
90019e40:	200a      	movs	r0, #10
90019e42:	fb00 3301 	mla	r3, r0, r1, r3
90019e46:	930c      	str	r3, [sp, #48]	; 0x30
90019e48:	f812 3b01 	ldrb.w	r3, [r2], #1
90019e4c:	9305      	str	r3, [sp, #20]
90019e4e:	3b30      	subs	r3, #48	; 0x30
90019e50:	2b09      	cmp	r3, #9
90019e52:	d9f2      	bls.n	90019e3a <_svfprintf_r+0x24a>
90019e54:	e7e6      	b.n	90019e24 <_svfprintf_r+0x234>
90019e56:	f045 0508 	orr.w	r5, r5, #8
90019e5a:	e7b3      	b.n	90019dc4 <_svfprintf_r+0x1d4>
90019e5c:	9b09      	ldr	r3, [sp, #36]	; 0x24
90019e5e:	781b      	ldrb	r3, [r3, #0]
90019e60:	2b68      	cmp	r3, #104	; 0x68
90019e62:	bf01      	itttt	eq
90019e64:	9b09      	ldreq	r3, [sp, #36]	; 0x24
90019e66:	3301      	addeq	r3, #1
90019e68:	9309      	streq	r3, [sp, #36]	; 0x24
90019e6a:	f445 7500 	orreq.w	r5, r5, #512	; 0x200
90019e6e:	bf18      	it	ne
90019e70:	f045 0540 	orrne.w	r5, r5, #64	; 0x40
90019e74:	e7a6      	b.n	90019dc4 <_svfprintf_r+0x1d4>
90019e76:	9b09      	ldr	r3, [sp, #36]	; 0x24
90019e78:	781b      	ldrb	r3, [r3, #0]
90019e7a:	2b6c      	cmp	r3, #108	; 0x6c
90019e7c:	d105      	bne.n	90019e8a <_svfprintf_r+0x29a>
90019e7e:	9b09      	ldr	r3, [sp, #36]	; 0x24
90019e80:	3301      	adds	r3, #1
90019e82:	9309      	str	r3, [sp, #36]	; 0x24
90019e84:	f045 0520 	orr.w	r5, r5, #32
90019e88:	e79c      	b.n	90019dc4 <_svfprintf_r+0x1d4>
90019e8a:	f045 0510 	orr.w	r5, r5, #16
90019e8e:	e799      	b.n	90019dc4 <_svfprintf_r+0x1d4>
90019e90:	4632      	mov	r2, r6
90019e92:	2000      	movs	r0, #0
90019e94:	f852 3b04 	ldr.w	r3, [r2], #4
90019e98:	9204      	str	r2, [sp, #16]
90019e9a:	f88d 30c4 	strb.w	r3, [sp, #196]	; 0xc4
90019e9e:	f88d 005b 	strb.w	r0, [sp, #91]	; 0x5b
90019ea2:	e9cd 0006 	strd	r0, r0, [sp, #24]
90019ea6:	9002      	str	r0, [sp, #8]
90019ea8:	f04f 0801 	mov.w	r8, #1
90019eac:	4607      	mov	r7, r0
90019eae:	4606      	mov	r6, r0
90019eb0:	f10d 0ac4 	add.w	sl, sp, #196	; 0xc4
90019eb4:	e181      	b.n	9001a1ba <_svfprintf_r+0x5ca>
90019eb6:	bf00      	nop
	...
90019ec0:	ffffffff 	.word	0xffffffff
90019ec4:	7fefffff 	.word	0x7fefffff
90019ec8:	f045 0510 	orr.w	r5, r5, #16
90019ecc:	06a9      	lsls	r1, r5, #26
90019ece:	d512      	bpl.n	90019ef6 <_svfprintf_r+0x306>
90019ed0:	3607      	adds	r6, #7
90019ed2:	f026 0307 	bic.w	r3, r6, #7
90019ed6:	e8f3 6702 	ldrd	r6, r7, [r3], #8
90019eda:	9304      	str	r3, [sp, #16]
90019edc:	2e00      	cmp	r6, #0
90019ede:	f177 0300 	sbcs.w	r3, r7, #0
90019ee2:	da06      	bge.n	90019ef2 <_svfprintf_r+0x302>
90019ee4:	4276      	negs	r6, r6
90019ee6:	f04f 032d 	mov.w	r3, #45	; 0x2d
90019eea:	eb67 0747 	sbc.w	r7, r7, r7, lsl #1
90019eee:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
90019ef2:	2301      	movs	r3, #1
90019ef4:	e330      	b.n	9001a558 <_svfprintf_r+0x968>
90019ef6:	1d33      	adds	r3, r6, #4
90019ef8:	06ea      	lsls	r2, r5, #27
90019efa:	9304      	str	r3, [sp, #16]
90019efc:	d502      	bpl.n	90019f04 <_svfprintf_r+0x314>
90019efe:	6836      	ldr	r6, [r6, #0]
90019f00:	17f7      	asrs	r7, r6, #31
90019f02:	e7eb      	b.n	90019edc <_svfprintf_r+0x2ec>
90019f04:	f015 0f40 	tst.w	r5, #64	; 0x40
90019f08:	6836      	ldr	r6, [r6, #0]
90019f0a:	d001      	beq.n	90019f10 <_svfprintf_r+0x320>
90019f0c:	b236      	sxth	r6, r6
90019f0e:	e7f7      	b.n	90019f00 <_svfprintf_r+0x310>
90019f10:	05ab      	lsls	r3, r5, #22
90019f12:	bf48      	it	mi
90019f14:	b276      	sxtbmi	r6, r6
90019f16:	e7f3      	b.n	90019f00 <_svfprintf_r+0x310>
90019f18:	3607      	adds	r6, #7
90019f1a:	f026 0307 	bic.w	r3, r6, #7
90019f1e:	ecb3 8b02 	vldmia	r3!, {d8}
90019f22:	ed1f 7b19 	vldr	d7, [pc, #-100]	; 90019ec0 <_svfprintf_r+0x2d0>
90019f26:	eeb0 6bc8 	vabs.f64	d6, d8
90019f2a:	eeb4 6b47 	vcmp.f64	d6, d7
90019f2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
90019f32:	9304      	str	r3, [sp, #16]
90019f34:	dd19      	ble.n	90019f6a <_svfprintf_r+0x37a>
90019f36:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
90019f3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
90019f3e:	d502      	bpl.n	90019f46 <_svfprintf_r+0x356>
90019f40:	232d      	movs	r3, #45	; 0x2d
90019f42:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
90019f46:	4a27      	ldr	r2, [pc, #156]	; (90019fe4 <_svfprintf_r+0x3f4>)
90019f48:	4827      	ldr	r0, [pc, #156]	; (90019fe8 <_svfprintf_r+0x3f8>)
90019f4a:	9b05      	ldr	r3, [sp, #20]
90019f4c:	2b47      	cmp	r3, #71	; 0x47
90019f4e:	bfd4      	ite	le
90019f50:	4692      	movle	sl, r2
90019f52:	4682      	movgt	sl, r0
90019f54:	2300      	movs	r3, #0
90019f56:	f025 0580 	bic.w	r5, r5, #128	; 0x80
90019f5a:	9302      	str	r3, [sp, #8]
90019f5c:	f04f 0803 	mov.w	r8, #3
90019f60:	461f      	mov	r7, r3
90019f62:	e9cd 3306 	strd	r3, r3, [sp, #24]
90019f66:	461e      	mov	r6, r3
90019f68:	e127      	b.n	9001a1ba <_svfprintf_r+0x5ca>
90019f6a:	eeb4 8b48 	vcmp.f64	d8, d8
90019f6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
90019f72:	d70a      	bvc.n	90019f8a <_svfprintf_r+0x39a>
90019f74:	ee18 3a90 	vmov	r3, s17
90019f78:	2b00      	cmp	r3, #0
90019f7a:	bfb8      	it	lt
90019f7c:	232d      	movlt	r3, #45	; 0x2d
90019f7e:	4a1b      	ldr	r2, [pc, #108]	; (90019fec <_svfprintf_r+0x3fc>)
90019f80:	481b      	ldr	r0, [pc, #108]	; (90019ff0 <_svfprintf_r+0x400>)
90019f82:	bfb8      	it	lt
90019f84:	f88d 305b 	strblt.w	r3, [sp, #91]	; 0x5b
90019f88:	e7df      	b.n	90019f4a <_svfprintf_r+0x35a>
90019f8a:	9b05      	ldr	r3, [sp, #20]
90019f8c:	f023 0720 	bic.w	r7, r3, #32
90019f90:	2f41      	cmp	r7, #65	; 0x41
90019f92:	d12f      	bne.n	90019ff4 <_svfprintf_r+0x404>
90019f94:	2330      	movs	r3, #48	; 0x30
90019f96:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
90019f9a:	9b05      	ldr	r3, [sp, #20]
90019f9c:	2b61      	cmp	r3, #97	; 0x61
90019f9e:	bf0c      	ite	eq
90019fa0:	2378      	moveq	r3, #120	; 0x78
90019fa2:	2358      	movne	r3, #88	; 0x58
90019fa4:	f1b8 0f63 	cmp.w	r8, #99	; 0x63
90019fa8:	f88d 305d 	strb.w	r3, [sp, #93]	; 0x5d
90019fac:	f045 0502 	orr.w	r5, r5, #2
90019fb0:	f340 81d4 	ble.w	9001a35c <_svfprintf_r+0x76c>
90019fb4:	f108 0101 	add.w	r1, r8, #1
90019fb8:	4648      	mov	r0, r9
90019fba:	f001 febd 	bl	9001bd38 <_malloc_r>
90019fbe:	4682      	mov	sl, r0
90019fc0:	2800      	cmp	r0, #0
90019fc2:	f040 81d0 	bne.w	9001a366 <_svfprintf_r+0x776>
90019fc6:	f8bb 300c 	ldrh.w	r3, [fp, #12]
90019fca:	f043 0340 	orr.w	r3, r3, #64	; 0x40
90019fce:	f8ab 300c 	strh.w	r3, [fp, #12]
90019fd2:	f8bb 300c 	ldrh.w	r3, [fp, #12]
90019fd6:	f013 0f40 	tst.w	r3, #64	; 0x40
90019fda:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
90019fdc:	bf18      	it	ne
90019fde:	f04f 33ff 	movne.w	r3, #4294967295	; 0xffffffff
90019fe2:	e62b      	b.n	90019c3c <_svfprintf_r+0x4c>
90019fe4:	90025344 	.word	0x90025344
90019fe8:	90025348 	.word	0x90025348
90019fec:	9002534c 	.word	0x9002534c
90019ff0:	90025350 	.word	0x90025350
90019ff4:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
90019ff8:	f000 81b7 	beq.w	9001a36a <_svfprintf_r+0x77a>
90019ffc:	2f47      	cmp	r7, #71	; 0x47
90019ffe:	f040 81b9 	bne.w	9001a374 <_svfprintf_r+0x784>
9001a002:	f1b8 0f00 	cmp.w	r8, #0
9001a006:	f040 81b5 	bne.w	9001a374 <_svfprintf_r+0x784>
9001a00a:	f8cd 8008 	str.w	r8, [sp, #8]
9001a00e:	f04f 0801 	mov.w	r8, #1
9001a012:	f445 7380 	orr.w	r3, r5, #256	; 0x100
9001a016:	930d      	str	r3, [sp, #52]	; 0x34
9001a018:	ee18 3a90 	vmov	r3, s17
9001a01c:	2b00      	cmp	r3, #0
9001a01e:	f280 81ac 	bge.w	9001a37a <_svfprintf_r+0x78a>
9001a022:	eeb1 9b48 	vneg.f64	d9, d8
9001a026:	232d      	movs	r3, #45	; 0x2d
9001a028:	2f41      	cmp	r7, #65	; 0x41
9001a02a:	9313      	str	r3, [sp, #76]	; 0x4c
9001a02c:	f040 81bc 	bne.w	9001a3a8 <_svfprintf_r+0x7b8>
9001a030:	eeb0 0b49 	vmov.f64	d0, d9
9001a034:	a818      	add	r0, sp, #96	; 0x60
9001a036:	f002 fbff 	bl	9001c838 <frexp>
9001a03a:	eeb4 7b00 	vmov.f64	d7, #64	; 0x3e000000  0.125
9001a03e:	ee20 0b07 	vmul.f64	d0, d0, d7
9001a042:	eeb5 0b40 	vcmp.f64	d0, #0.0
9001a046:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001a04a:	bf08      	it	eq
9001a04c:	2301      	moveq	r3, #1
9001a04e:	9a05      	ldr	r2, [sp, #20]
9001a050:	bf08      	it	eq
9001a052:	9318      	streq	r3, [sp, #96]	; 0x60
9001a054:	49bc      	ldr	r1, [pc, #752]	; (9001a348 <_svfprintf_r+0x758>)
9001a056:	4bbd      	ldr	r3, [pc, #756]	; (9001a34c <_svfprintf_r+0x75c>)
9001a058:	eeb3 7b00 	vmov.f64	d7, #48	; 0x41800000  16.0
9001a05c:	2a61      	cmp	r2, #97	; 0x61
9001a05e:	bf18      	it	ne
9001a060:	4619      	movne	r1, r3
9001a062:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
9001a066:	4653      	mov	r3, sl
9001a068:	ee20 0b07 	vmul.f64	d0, d0, d7
9001a06c:	eefd 6bc0 	vcvt.s32.f64	s13, d0
9001a070:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
9001a074:	ee16 6a90 	vmov	r6, s13
9001a078:	5d88      	ldrb	r0, [r1, r6]
9001a07a:	f803 0b01 	strb.w	r0, [r3], #1
9001a07e:	eeb8 6be6 	vcvt.f64.s32	d6, s13
9001a082:	4610      	mov	r0, r2
9001a084:	ee30 0b46 	vsub.f64	d0, d0, d6
9001a088:	d006      	beq.n	9001a098 <_svfprintf_r+0x4a8>
9001a08a:	eeb5 0b40 	vcmp.f64	d0, #0.0
9001a08e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001a092:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
9001a096:	d1e7      	bne.n	9001a068 <_svfprintf_r+0x478>
9001a098:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
9001a09c:	eeb4 0bc7 	vcmpe.f64	d0, d7
9001a0a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001a0a4:	dc08      	bgt.n	9001a0b8 <_svfprintf_r+0x4c8>
9001a0a6:	eeb4 0b47 	vcmp.f64	d0, d7
9001a0aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001a0ae:	f040 8176 	bne.w	9001a39e <_svfprintf_r+0x7ae>
9001a0b2:	07f2      	lsls	r2, r6, #31
9001a0b4:	f140 8173 	bpl.w	9001a39e <_svfprintf_r+0x7ae>
9001a0b8:	7bce      	ldrb	r6, [r1, #15]
9001a0ba:	931c      	str	r3, [sp, #112]	; 0x70
9001a0bc:	f04f 0c30 	mov.w	ip, #48	; 0x30
9001a0c0:	981c      	ldr	r0, [sp, #112]	; 0x70
9001a0c2:	1e42      	subs	r2, r0, #1
9001a0c4:	921c      	str	r2, [sp, #112]	; 0x70
9001a0c6:	f810 2c01 	ldrb.w	r2, [r0, #-1]
9001a0ca:	42b2      	cmp	r2, r6
9001a0cc:	f000 8159 	beq.w	9001a382 <_svfprintf_r+0x792>
9001a0d0:	2a39      	cmp	r2, #57	; 0x39
9001a0d2:	bf16      	itet	ne
9001a0d4:	3201      	addne	r2, #1
9001a0d6:	7a8a      	ldrbeq	r2, [r1, #10]
9001a0d8:	b2d2      	uxtbne	r2, r2
9001a0da:	f800 2c01 	strb.w	r2, [r0, #-1]
9001a0de:	eba3 030a 	sub.w	r3, r3, sl
9001a0e2:	2f47      	cmp	r7, #71	; 0x47
9001a0e4:	9e18      	ldr	r6, [sp, #96]	; 0x60
9001a0e6:	9303      	str	r3, [sp, #12]
9001a0e8:	f040 819c 	bne.w	9001a424 <_svfprintf_r+0x834>
9001a0ec:	1cf7      	adds	r7, r6, #3
9001a0ee:	db02      	blt.n	9001a0f6 <_svfprintf_r+0x506>
9001a0f0:	45b0      	cmp	r8, r6
9001a0f2:	f280 81bd 	bge.w	9001a470 <_svfprintf_r+0x880>
9001a0f6:	9b05      	ldr	r3, [sp, #20]
9001a0f8:	3b02      	subs	r3, #2
9001a0fa:	9305      	str	r3, [sp, #20]
9001a0fc:	9905      	ldr	r1, [sp, #20]
9001a0fe:	f89d 2014 	ldrb.w	r2, [sp, #20]
9001a102:	f021 0120 	bic.w	r1, r1, #32
9001a106:	2941      	cmp	r1, #65	; 0x41
9001a108:	bf08      	it	eq
9001a10a:	320f      	addeq	r2, #15
9001a10c:	f106 33ff 	add.w	r3, r6, #4294967295	; 0xffffffff
9001a110:	bf06      	itte	eq
9001a112:	b2d2      	uxtbeq	r2, r2
9001a114:	2101      	moveq	r1, #1
9001a116:	2100      	movne	r1, #0
9001a118:	2b00      	cmp	r3, #0
9001a11a:	9318      	str	r3, [sp, #96]	; 0x60
9001a11c:	bfb8      	it	lt
9001a11e:	f1c6 0301 	rsblt	r3, r6, #1
9001a122:	f88d 2068 	strb.w	r2, [sp, #104]	; 0x68
9001a126:	bfb4      	ite	lt
9001a128:	222d      	movlt	r2, #45	; 0x2d
9001a12a:	222b      	movge	r2, #43	; 0x2b
9001a12c:	2b09      	cmp	r3, #9
9001a12e:	f88d 2069 	strb.w	r2, [sp, #105]	; 0x69
9001a132:	f340 818c 	ble.w	9001a44e <_svfprintf_r+0x85e>
9001a136:	f10d 0277 	add.w	r2, sp, #119	; 0x77
9001a13a:	200a      	movs	r0, #10
9001a13c:	4611      	mov	r1, r2
9001a13e:	fb93 f6f0 	sdiv	r6, r3, r0
9001a142:	fb00 3016 	mls	r0, r0, r6, r3
9001a146:	3030      	adds	r0, #48	; 0x30
9001a148:	f801 0c01 	strb.w	r0, [r1, #-1]
9001a14c:	4618      	mov	r0, r3
9001a14e:	2863      	cmp	r0, #99	; 0x63
9001a150:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
9001a154:	4633      	mov	r3, r6
9001a156:	dcf0      	bgt.n	9001a13a <_svfprintf_r+0x54a>
9001a158:	3330      	adds	r3, #48	; 0x30
9001a15a:	1e88      	subs	r0, r1, #2
9001a15c:	f802 3c01 	strb.w	r3, [r2, #-1]
9001a160:	f10d 0677 	add.w	r6, sp, #119	; 0x77
9001a164:	f10d 026a 	add.w	r2, sp, #106	; 0x6a
9001a168:	4603      	mov	r3, r0
9001a16a:	42b3      	cmp	r3, r6
9001a16c:	f0c0 816a 	bcc.w	9001a444 <_svfprintf_r+0x854>
9001a170:	f10d 0279 	add.w	r2, sp, #121	; 0x79
9001a174:	1a52      	subs	r2, r2, r1
9001a176:	42b0      	cmp	r0, r6
9001a178:	bf88      	it	hi
9001a17a:	2200      	movhi	r2, #0
9001a17c:	f10d 036a 	add.w	r3, sp, #106	; 0x6a
9001a180:	441a      	add	r2, r3
9001a182:	ab1a      	add	r3, sp, #104	; 0x68
9001a184:	1ad3      	subs	r3, r2, r3
9001a186:	9a03      	ldr	r2, [sp, #12]
9001a188:	9311      	str	r3, [sp, #68]	; 0x44
9001a18a:	2a01      	cmp	r2, #1
9001a18c:	eb03 0802 	add.w	r8, r3, r2
9001a190:	dc01      	bgt.n	9001a196 <_svfprintf_r+0x5a6>
9001a192:	07e8      	lsls	r0, r5, #31
9001a194:	d501      	bpl.n	9001a19a <_svfprintf_r+0x5aa>
9001a196:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001a198:	4498      	add	r8, r3
9001a19a:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
9001a19e:	f445 7380 	orr.w	r3, r5, #256	; 0x100
9001a1a2:	930d      	str	r3, [sp, #52]	; 0x34
9001a1a4:	2300      	movs	r3, #0
9001a1a6:	e9cd 3306 	strd	r3, r3, [sp, #24]
9001a1aa:	461e      	mov	r6, r3
9001a1ac:	9b13      	ldr	r3, [sp, #76]	; 0x4c
9001a1ae:	b113      	cbz	r3, 9001a1b6 <_svfprintf_r+0x5c6>
9001a1b0:	232d      	movs	r3, #45	; 0x2d
9001a1b2:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
9001a1b6:	9d0d      	ldr	r5, [sp, #52]	; 0x34
9001a1b8:	2700      	movs	r7, #0
9001a1ba:	4547      	cmp	r7, r8
9001a1bc:	463b      	mov	r3, r7
9001a1be:	bfb8      	it	lt
9001a1c0:	4643      	movlt	r3, r8
9001a1c2:	930d      	str	r3, [sp, #52]	; 0x34
9001a1c4:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
9001a1c8:	b113      	cbz	r3, 9001a1d0 <_svfprintf_r+0x5e0>
9001a1ca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
9001a1cc:	3301      	adds	r3, #1
9001a1ce:	930d      	str	r3, [sp, #52]	; 0x34
9001a1d0:	f015 0302 	ands.w	r3, r5, #2
9001a1d4:	9313      	str	r3, [sp, #76]	; 0x4c
9001a1d6:	bf1e      	ittt	ne
9001a1d8:	9b0d      	ldrne	r3, [sp, #52]	; 0x34
9001a1da:	3302      	addne	r3, #2
9001a1dc:	930d      	strne	r3, [sp, #52]	; 0x34
9001a1de:	f015 0384 	ands.w	r3, r5, #132	; 0x84
9001a1e2:	9314      	str	r3, [sp, #80]	; 0x50
9001a1e4:	d120      	bne.n	9001a228 <_svfprintf_r+0x638>
9001a1e6:	e9dd 320c 	ldrd	r3, r2, [sp, #48]	; 0x30
9001a1ea:	1a9b      	subs	r3, r3, r2
9001a1ec:	2b00      	cmp	r3, #0
9001a1ee:	dd1b      	ble.n	9001a228 <_svfprintf_r+0x638>
9001a1f0:	e9dd 2c1f 	ldrd	r2, ip, [sp, #124]	; 0x7c
9001a1f4:	4956      	ldr	r1, [pc, #344]	; (9001a350 <_svfprintf_r+0x760>)
9001a1f6:	6021      	str	r1, [r4, #0]
9001a1f8:	2b10      	cmp	r3, #16
9001a1fa:	f102 0201 	add.w	r2, r2, #1
9001a1fe:	f104 0008 	add.w	r0, r4, #8
9001a202:	f300 82ba 	bgt.w	9001a77a <_svfprintf_r+0xb8a>
9001a206:	eb0c 0103 	add.w	r1, ip, r3
9001a20a:	2a07      	cmp	r2, #7
9001a20c:	e9cd 211f 	strd	r2, r1, [sp, #124]	; 0x7c
9001a210:	6063      	str	r3, [r4, #4]
9001a212:	f340 82c7 	ble.w	9001a7a4 <_svfprintf_r+0xbb4>
9001a216:	aa1e      	add	r2, sp, #120	; 0x78
9001a218:	4659      	mov	r1, fp
9001a21a:	4648      	mov	r0, r9
9001a21c:	f002 fb6b 	bl	9001c8f6 <__ssprint_r>
9001a220:	2800      	cmp	r0, #0
9001a222:	f040 85f3 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a226:	ac21      	add	r4, sp, #132	; 0x84
9001a228:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
9001a22c:	b173      	cbz	r3, 9001a24c <_svfprintf_r+0x65c>
9001a22e:	f10d 035b 	add.w	r3, sp, #91	; 0x5b
9001a232:	6023      	str	r3, [r4, #0]
9001a234:	2301      	movs	r3, #1
9001a236:	6063      	str	r3, [r4, #4]
9001a238:	9b20      	ldr	r3, [sp, #128]	; 0x80
9001a23a:	3301      	adds	r3, #1
9001a23c:	9320      	str	r3, [sp, #128]	; 0x80
9001a23e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001a240:	3301      	adds	r3, #1
9001a242:	2b07      	cmp	r3, #7
9001a244:	931f      	str	r3, [sp, #124]	; 0x7c
9001a246:	f300 82af 	bgt.w	9001a7a8 <_svfprintf_r+0xbb8>
9001a24a:	3408      	adds	r4, #8
9001a24c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
9001a24e:	b16b      	cbz	r3, 9001a26c <_svfprintf_r+0x67c>
9001a250:	ab17      	add	r3, sp, #92	; 0x5c
9001a252:	6023      	str	r3, [r4, #0]
9001a254:	2302      	movs	r3, #2
9001a256:	6063      	str	r3, [r4, #4]
9001a258:	9b20      	ldr	r3, [sp, #128]	; 0x80
9001a25a:	3302      	adds	r3, #2
9001a25c:	9320      	str	r3, [sp, #128]	; 0x80
9001a25e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001a260:	3301      	adds	r3, #1
9001a262:	2b07      	cmp	r3, #7
9001a264:	931f      	str	r3, [sp, #124]	; 0x7c
9001a266:	f300 82a9 	bgt.w	9001a7bc <_svfprintf_r+0xbcc>
9001a26a:	3408      	adds	r4, #8
9001a26c:	9b14      	ldr	r3, [sp, #80]	; 0x50
9001a26e:	2b80      	cmp	r3, #128	; 0x80
9001a270:	d120      	bne.n	9001a2b4 <_svfprintf_r+0x6c4>
9001a272:	e9dd 320c 	ldrd	r3, r2, [sp, #48]	; 0x30
9001a276:	1a9b      	subs	r3, r3, r2
9001a278:	2b00      	cmp	r3, #0
9001a27a:	dd1b      	ble.n	9001a2b4 <_svfprintf_r+0x6c4>
9001a27c:	e9dd 2c1f 	ldrd	r2, ip, [sp, #124]	; 0x7c
9001a280:	4934      	ldr	r1, [pc, #208]	; (9001a354 <_svfprintf_r+0x764>)
9001a282:	6021      	str	r1, [r4, #0]
9001a284:	2b10      	cmp	r3, #16
9001a286:	f102 0201 	add.w	r2, r2, #1
9001a28a:	f104 0008 	add.w	r0, r4, #8
9001a28e:	f300 829f 	bgt.w	9001a7d0 <_svfprintf_r+0xbe0>
9001a292:	eb0c 0103 	add.w	r1, ip, r3
9001a296:	2a07      	cmp	r2, #7
9001a298:	e9cd 211f 	strd	r2, r1, [sp, #124]	; 0x7c
9001a29c:	6063      	str	r3, [r4, #4]
9001a29e:	f340 82ac 	ble.w	9001a7fa <_svfprintf_r+0xc0a>
9001a2a2:	aa1e      	add	r2, sp, #120	; 0x78
9001a2a4:	4659      	mov	r1, fp
9001a2a6:	4648      	mov	r0, r9
9001a2a8:	f002 fb25 	bl	9001c8f6 <__ssprint_r>
9001a2ac:	2800      	cmp	r0, #0
9001a2ae:	f040 85ad 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a2b2:	ac21      	add	r4, sp, #132	; 0x84
9001a2b4:	eba7 0708 	sub.w	r7, r7, r8
9001a2b8:	2f00      	cmp	r7, #0
9001a2ba:	dd1a      	ble.n	9001a2f2 <_svfprintf_r+0x702>
9001a2bc:	e9dd 321f 	ldrd	r3, r2, [sp, #124]	; 0x7c
9001a2c0:	4824      	ldr	r0, [pc, #144]	; (9001a354 <_svfprintf_r+0x764>)
9001a2c2:	6020      	str	r0, [r4, #0]
9001a2c4:	2f10      	cmp	r7, #16
9001a2c6:	f103 0301 	add.w	r3, r3, #1
9001a2ca:	f104 0108 	add.w	r1, r4, #8
9001a2ce:	f300 8296 	bgt.w	9001a7fe <_svfprintf_r+0xc0e>
9001a2d2:	6067      	str	r7, [r4, #4]
9001a2d4:	2b07      	cmp	r3, #7
9001a2d6:	4417      	add	r7, r2
9001a2d8:	e9cd 371f 	strd	r3, r7, [sp, #124]	; 0x7c
9001a2dc:	f340 82a2 	ble.w	9001a824 <_svfprintf_r+0xc34>
9001a2e0:	aa1e      	add	r2, sp, #120	; 0x78
9001a2e2:	4659      	mov	r1, fp
9001a2e4:	4648      	mov	r0, r9
9001a2e6:	f002 fb06 	bl	9001c8f6 <__ssprint_r>
9001a2ea:	2800      	cmp	r0, #0
9001a2ec:	f040 858e 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a2f0:	ac21      	add	r4, sp, #132	; 0x84
9001a2f2:	05ea      	lsls	r2, r5, #23
9001a2f4:	9820      	ldr	r0, [sp, #128]	; 0x80
9001a2f6:	f100 829b 	bmi.w	9001a830 <_svfprintf_r+0xc40>
9001a2fa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001a2fc:	3301      	adds	r3, #1
9001a2fe:	4440      	add	r0, r8
9001a300:	2b07      	cmp	r3, #7
9001a302:	e9c4 a800 	strd	sl, r8, [r4]
9001a306:	9020      	str	r0, [sp, #128]	; 0x80
9001a308:	931f      	str	r3, [sp, #124]	; 0x7c
9001a30a:	f300 82d3 	bgt.w	9001a8b4 <_svfprintf_r+0xcc4>
9001a30e:	3408      	adds	r4, #8
9001a310:	076b      	lsls	r3, r5, #29
9001a312:	f100 855d 	bmi.w	9001add0 <_svfprintf_r+0x11e0>
9001a316:	e9dd 320b 	ldrd	r3, r2, [sp, #44]	; 0x2c
9001a31a:	990d      	ldr	r1, [sp, #52]	; 0x34
9001a31c:	428a      	cmp	r2, r1
9001a31e:	bfac      	ite	ge
9001a320:	189b      	addge	r3, r3, r2
9001a322:	185b      	addlt	r3, r3, r1
9001a324:	930b      	str	r3, [sp, #44]	; 0x2c
9001a326:	9b20      	ldr	r3, [sp, #128]	; 0x80
9001a328:	b13b      	cbz	r3, 9001a33a <_svfprintf_r+0x74a>
9001a32a:	aa1e      	add	r2, sp, #120	; 0x78
9001a32c:	4659      	mov	r1, fp
9001a32e:	4648      	mov	r0, r9
9001a330:	f002 fae1 	bl	9001c8f6 <__ssprint_r>
9001a334:	2800      	cmp	r0, #0
9001a336:	f040 8569 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a33a:	2300      	movs	r3, #0
9001a33c:	931f      	str	r3, [sp, #124]	; 0x7c
9001a33e:	9b02      	ldr	r3, [sp, #8]
9001a340:	2b00      	cmp	r3, #0
9001a342:	f040 857f 	bne.w	9001ae44 <_svfprintf_r+0x1254>
9001a346:	e007      	b.n	9001a358 <_svfprintf_r+0x768>
9001a348:	90025354 	.word	0x90025354
9001a34c:	90025365 	.word	0x90025365
9001a350:	90025378 	.word	0x90025378
9001a354:	90025388 	.word	0x90025388
9001a358:	ac21      	add	r4, sp, #132	; 0x84
9001a35a:	e0d9      	b.n	9001a510 <_svfprintf_r+0x920>
9001a35c:	2300      	movs	r3, #0
9001a35e:	9302      	str	r3, [sp, #8]
9001a360:	f10d 0ac4 	add.w	sl, sp, #196	; 0xc4
9001a364:	e655      	b.n	9001a012 <_svfprintf_r+0x422>
9001a366:	9002      	str	r0, [sp, #8]
9001a368:	e653      	b.n	9001a012 <_svfprintf_r+0x422>
9001a36a:	2300      	movs	r3, #0
9001a36c:	9302      	str	r3, [sp, #8]
9001a36e:	f04f 0806 	mov.w	r8, #6
9001a372:	e64e      	b.n	9001a012 <_svfprintf_r+0x422>
9001a374:	2300      	movs	r3, #0
9001a376:	9302      	str	r3, [sp, #8]
9001a378:	e64b      	b.n	9001a012 <_svfprintf_r+0x422>
9001a37a:	2300      	movs	r3, #0
9001a37c:	eeb0 9b48 	vmov.f64	d9, d8
9001a380:	e652      	b.n	9001a028 <_svfprintf_r+0x438>
9001a382:	f800 cc01 	strb.w	ip, [r0, #-1]
9001a386:	e69b      	b.n	9001a0c0 <_svfprintf_r+0x4d0>
9001a388:	f802 cb01 	strb.w	ip, [r2], #1
9001a38c:	1ab1      	subs	r1, r6, r2
9001a38e:	2900      	cmp	r1, #0
9001a390:	dafa      	bge.n	9001a388 <_svfprintf_r+0x798>
9001a392:	1c42      	adds	r2, r0, #1
9001a394:	3001      	adds	r0, #1
9001a396:	bfb8      	it	lt
9001a398:	2200      	movlt	r2, #0
9001a39a:	4413      	add	r3, r2
9001a39c:	e69f      	b.n	9001a0de <_svfprintf_r+0x4ee>
9001a39e:	461a      	mov	r2, r3
9001a3a0:	181e      	adds	r6, r3, r0
9001a3a2:	f04f 0c30 	mov.w	ip, #48	; 0x30
9001a3a6:	e7f1      	b.n	9001a38c <_svfprintf_r+0x79c>
9001a3a8:	2f46      	cmp	r7, #70	; 0x46
9001a3aa:	d005      	beq.n	9001a3b8 <_svfprintf_r+0x7c8>
9001a3ac:	2f45      	cmp	r7, #69	; 0x45
9001a3ae:	d117      	bne.n	9001a3e0 <_svfprintf_r+0x7f0>
9001a3b0:	f108 0601 	add.w	r6, r8, #1
9001a3b4:	2102      	movs	r1, #2
9001a3b6:	e001      	b.n	9001a3bc <_svfprintf_r+0x7cc>
9001a3b8:	4646      	mov	r6, r8
9001a3ba:	2103      	movs	r1, #3
9001a3bc:	ab1c      	add	r3, sp, #112	; 0x70
9001a3be:	9301      	str	r3, [sp, #4]
9001a3c0:	ab19      	add	r3, sp, #100	; 0x64
9001a3c2:	9300      	str	r3, [sp, #0]
9001a3c4:	4632      	mov	r2, r6
9001a3c6:	ab18      	add	r3, sp, #96	; 0x60
9001a3c8:	4648      	mov	r0, r9
9001a3ca:	eeb0 0b49 	vmov.f64	d0, d9
9001a3ce:	f000 fe1b 	bl	9001b008 <_dtoa_r>
9001a3d2:	2f47      	cmp	r7, #71	; 0x47
9001a3d4:	4682      	mov	sl, r0
9001a3d6:	d105      	bne.n	9001a3e4 <_svfprintf_r+0x7f4>
9001a3d8:	07eb      	lsls	r3, r5, #31
9001a3da:	d403      	bmi.n	9001a3e4 <_svfprintf_r+0x7f4>
9001a3dc:	9b1c      	ldr	r3, [sp, #112]	; 0x70
9001a3de:	e67e      	b.n	9001a0de <_svfprintf_r+0x4ee>
9001a3e0:	4646      	mov	r6, r8
9001a3e2:	e7e7      	b.n	9001a3b4 <_svfprintf_r+0x7c4>
9001a3e4:	2f46      	cmp	r7, #70	; 0x46
9001a3e6:	eb0a 0306 	add.w	r3, sl, r6
9001a3ea:	d10d      	bne.n	9001a408 <_svfprintf_r+0x818>
9001a3ec:	f89a 2000 	ldrb.w	r2, [sl]
9001a3f0:	2a30      	cmp	r2, #48	; 0x30
9001a3f2:	d107      	bne.n	9001a404 <_svfprintf_r+0x814>
9001a3f4:	eeb5 9b40 	vcmp.f64	d9, #0.0
9001a3f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001a3fc:	bf1c      	itt	ne
9001a3fe:	f1c6 0601 	rsbne	r6, r6, #1
9001a402:	9618      	strne	r6, [sp, #96]	; 0x60
9001a404:	9a18      	ldr	r2, [sp, #96]	; 0x60
9001a406:	4413      	add	r3, r2
9001a408:	eeb5 9b40 	vcmp.f64	d9, #0.0
9001a40c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001a410:	bf08      	it	eq
9001a412:	931c      	streq	r3, [sp, #112]	; 0x70
9001a414:	2130      	movs	r1, #48	; 0x30
9001a416:	9a1c      	ldr	r2, [sp, #112]	; 0x70
9001a418:	4293      	cmp	r3, r2
9001a41a:	d9df      	bls.n	9001a3dc <_svfprintf_r+0x7ec>
9001a41c:	1c50      	adds	r0, r2, #1
9001a41e:	901c      	str	r0, [sp, #112]	; 0x70
9001a420:	7011      	strb	r1, [r2, #0]
9001a422:	e7f8      	b.n	9001a416 <_svfprintf_r+0x826>
9001a424:	2f46      	cmp	r7, #70	; 0x46
9001a426:	f47f ae69 	bne.w	9001a0fc <_svfprintf_r+0x50c>
9001a42a:	f005 0301 	and.w	r3, r5, #1
9001a42e:	2e00      	cmp	r6, #0
9001a430:	ea43 0308 	orr.w	r3, r3, r8
9001a434:	dd18      	ble.n	9001a468 <_svfprintf_r+0x878>
9001a436:	b37b      	cbz	r3, 9001a498 <_svfprintf_r+0x8a8>
9001a438:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001a43a:	18f3      	adds	r3, r6, r3
9001a43c:	4498      	add	r8, r3
9001a43e:	2366      	movs	r3, #102	; 0x66
9001a440:	9305      	str	r3, [sp, #20]
9001a442:	e02f      	b.n	9001a4a4 <_svfprintf_r+0x8b4>
9001a444:	f813 7b01 	ldrb.w	r7, [r3], #1
9001a448:	f802 7b01 	strb.w	r7, [r2], #1
9001a44c:	e68d      	b.n	9001a16a <_svfprintf_r+0x57a>
9001a44e:	b941      	cbnz	r1, 9001a462 <_svfprintf_r+0x872>
9001a450:	2230      	movs	r2, #48	; 0x30
9001a452:	f88d 206a 	strb.w	r2, [sp, #106]	; 0x6a
9001a456:	f10d 026b 	add.w	r2, sp, #107	; 0x6b
9001a45a:	3330      	adds	r3, #48	; 0x30
9001a45c:	f802 3b01 	strb.w	r3, [r2], #1
9001a460:	e68f      	b.n	9001a182 <_svfprintf_r+0x592>
9001a462:	f10d 026a 	add.w	r2, sp, #106	; 0x6a
9001a466:	e7f8      	b.n	9001a45a <_svfprintf_r+0x86a>
9001a468:	b1c3      	cbz	r3, 9001a49c <_svfprintf_r+0x8ac>
9001a46a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001a46c:	3301      	adds	r3, #1
9001a46e:	e7e5      	b.n	9001a43c <_svfprintf_r+0x84c>
9001a470:	9b03      	ldr	r3, [sp, #12]
9001a472:	429e      	cmp	r6, r3
9001a474:	db06      	blt.n	9001a484 <_svfprintf_r+0x894>
9001a476:	07e9      	lsls	r1, r5, #31
9001a478:	d529      	bpl.n	9001a4ce <_svfprintf_r+0x8de>
9001a47a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001a47c:	eb06 0803 	add.w	r8, r6, r3
9001a480:	2367      	movs	r3, #103	; 0x67
9001a482:	e7dd      	b.n	9001a440 <_svfprintf_r+0x850>
9001a484:	9b03      	ldr	r3, [sp, #12]
9001a486:	9a0a      	ldr	r2, [sp, #40]	; 0x28
9001a488:	2e00      	cmp	r6, #0
9001a48a:	eb03 0802 	add.w	r8, r3, r2
9001a48e:	dcf7      	bgt.n	9001a480 <_svfprintf_r+0x890>
9001a490:	f1c6 0301 	rsb	r3, r6, #1
9001a494:	4498      	add	r8, r3
9001a496:	e7f3      	b.n	9001a480 <_svfprintf_r+0x890>
9001a498:	46b0      	mov	r8, r6
9001a49a:	e7d0      	b.n	9001a43e <_svfprintf_r+0x84e>
9001a49c:	2366      	movs	r3, #102	; 0x66
9001a49e:	9305      	str	r3, [sp, #20]
9001a4a0:	f04f 0801 	mov.w	r8, #1
9001a4a4:	f415 6380 	ands.w	r3, r5, #1024	; 0x400
9001a4a8:	9307      	str	r3, [sp, #28]
9001a4aa:	d023      	beq.n	9001a4f4 <_svfprintf_r+0x904>
9001a4ac:	2300      	movs	r3, #0
9001a4ae:	2e00      	cmp	r6, #0
9001a4b0:	e9cd 3306 	strd	r3, r3, [sp, #24]
9001a4b4:	f77f ae7a 	ble.w	9001a1ac <_svfprintf_r+0x5bc>
9001a4b8:	9b08      	ldr	r3, [sp, #32]
9001a4ba:	781b      	ldrb	r3, [r3, #0]
9001a4bc:	2bff      	cmp	r3, #255	; 0xff
9001a4be:	d108      	bne.n	9001a4d2 <_svfprintf_r+0x8e2>
9001a4c0:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
9001a4c4:	4413      	add	r3, r2
9001a4c6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
9001a4c8:	fb02 8803 	mla	r8, r2, r3, r8
9001a4cc:	e66e      	b.n	9001a1ac <_svfprintf_r+0x5bc>
9001a4ce:	46b0      	mov	r8, r6
9001a4d0:	e7d6      	b.n	9001a480 <_svfprintf_r+0x890>
9001a4d2:	42b3      	cmp	r3, r6
9001a4d4:	daf4      	bge.n	9001a4c0 <_svfprintf_r+0x8d0>
9001a4d6:	1af6      	subs	r6, r6, r3
9001a4d8:	9b08      	ldr	r3, [sp, #32]
9001a4da:	785b      	ldrb	r3, [r3, #1]
9001a4dc:	b133      	cbz	r3, 9001a4ec <_svfprintf_r+0x8fc>
9001a4de:	9b07      	ldr	r3, [sp, #28]
9001a4e0:	3301      	adds	r3, #1
9001a4e2:	9307      	str	r3, [sp, #28]
9001a4e4:	9b08      	ldr	r3, [sp, #32]
9001a4e6:	3301      	adds	r3, #1
9001a4e8:	9308      	str	r3, [sp, #32]
9001a4ea:	e7e5      	b.n	9001a4b8 <_svfprintf_r+0x8c8>
9001a4ec:	9b06      	ldr	r3, [sp, #24]
9001a4ee:	3301      	adds	r3, #1
9001a4f0:	9306      	str	r3, [sp, #24]
9001a4f2:	e7e1      	b.n	9001a4b8 <_svfprintf_r+0x8c8>
9001a4f4:	9b07      	ldr	r3, [sp, #28]
9001a4f6:	9306      	str	r3, [sp, #24]
9001a4f8:	e658      	b.n	9001a1ac <_svfprintf_r+0x5bc>
9001a4fa:	4632      	mov	r2, r6
9001a4fc:	f852 3b04 	ldr.w	r3, [r2], #4
9001a500:	9204      	str	r2, [sp, #16]
9001a502:	06aa      	lsls	r2, r5, #26
9001a504:	d509      	bpl.n	9001a51a <_svfprintf_r+0x92a>
9001a506:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
9001a508:	4610      	mov	r0, r2
9001a50a:	17d1      	asrs	r1, r2, #31
9001a50c:	e9c3 0100 	strd	r0, r1, [r3]
9001a510:	9e04      	ldr	r6, [sp, #16]
9001a512:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
9001a516:	f7ff bba9 	b.w	90019c6c <_svfprintf_r+0x7c>
9001a51a:	06ef      	lsls	r7, r5, #27
9001a51c:	d502      	bpl.n	9001a524 <_svfprintf_r+0x934>
9001a51e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
9001a520:	601a      	str	r2, [r3, #0]
9001a522:	e7f5      	b.n	9001a510 <_svfprintf_r+0x920>
9001a524:	066e      	lsls	r6, r5, #25
9001a526:	d502      	bpl.n	9001a52e <_svfprintf_r+0x93e>
9001a528:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
9001a52a:	801a      	strh	r2, [r3, #0]
9001a52c:	e7f0      	b.n	9001a510 <_svfprintf_r+0x920>
9001a52e:	05a8      	lsls	r0, r5, #22
9001a530:	d5f5      	bpl.n	9001a51e <_svfprintf_r+0x92e>
9001a532:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
9001a534:	701a      	strb	r2, [r3, #0]
9001a536:	e7eb      	b.n	9001a510 <_svfprintf_r+0x920>
9001a538:	f045 0510 	orr.w	r5, r5, #16
9001a53c:	06a9      	lsls	r1, r5, #26
9001a53e:	d51e      	bpl.n	9001a57e <_svfprintf_r+0x98e>
9001a540:	3607      	adds	r6, #7
9001a542:	f026 0307 	bic.w	r3, r6, #7
9001a546:	e8f3 6702 	ldrd	r6, r7, [r3], #8
9001a54a:	9304      	str	r3, [sp, #16]
9001a54c:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
9001a550:	2300      	movs	r3, #0
9001a552:	2200      	movs	r2, #0
9001a554:	f88d 205b 	strb.w	r2, [sp, #91]	; 0x5b
9001a558:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
9001a55c:	f000 8483 	beq.w	9001ae66 <_svfprintf_r+0x1276>
9001a560:	f025 0280 	bic.w	r2, r5, #128	; 0x80
9001a564:	9202      	str	r2, [sp, #8]
9001a566:	ea56 0207 	orrs.w	r2, r6, r7
9001a56a:	f040 8481 	bne.w	9001ae70 <_svfprintf_r+0x1280>
9001a56e:	f1b8 0f00 	cmp.w	r8, #0
9001a572:	f000 80ea 	beq.w	9001a74a <_svfprintf_r+0xb5a>
9001a576:	2b01      	cmp	r3, #1
9001a578:	f040 847d 	bne.w	9001ae76 <_svfprintf_r+0x1286>
9001a57c:	e08d      	b.n	9001a69a <_svfprintf_r+0xaaa>
9001a57e:	1d33      	adds	r3, r6, #4
9001a580:	06ea      	lsls	r2, r5, #27
9001a582:	9304      	str	r3, [sp, #16]
9001a584:	d501      	bpl.n	9001a58a <_svfprintf_r+0x99a>
9001a586:	6836      	ldr	r6, [r6, #0]
9001a588:	e002      	b.n	9001a590 <_svfprintf_r+0x9a0>
9001a58a:	066b      	lsls	r3, r5, #25
9001a58c:	d502      	bpl.n	9001a594 <_svfprintf_r+0x9a4>
9001a58e:	8836      	ldrh	r6, [r6, #0]
9001a590:	2700      	movs	r7, #0
9001a592:	e7db      	b.n	9001a54c <_svfprintf_r+0x95c>
9001a594:	05af      	lsls	r7, r5, #22
9001a596:	d5f6      	bpl.n	9001a586 <_svfprintf_r+0x996>
9001a598:	7836      	ldrb	r6, [r6, #0]
9001a59a:	e7f9      	b.n	9001a590 <_svfprintf_r+0x9a0>
9001a59c:	4633      	mov	r3, r6
9001a59e:	2278      	movs	r2, #120	; 0x78
9001a5a0:	f853 6b04 	ldr.w	r6, [r3], #4
9001a5a4:	9304      	str	r3, [sp, #16]
9001a5a6:	f647 0330 	movw	r3, #30768	; 0x7830
9001a5aa:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
9001a5ae:	4b9e      	ldr	r3, [pc, #632]	; (9001a828 <_svfprintf_r+0xc38>)
9001a5b0:	9312      	str	r3, [sp, #72]	; 0x48
9001a5b2:	2700      	movs	r7, #0
9001a5b4:	f045 0502 	orr.w	r5, r5, #2
9001a5b8:	2302      	movs	r3, #2
9001a5ba:	9205      	str	r2, [sp, #20]
9001a5bc:	e7c9      	b.n	9001a552 <_svfprintf_r+0x962>
9001a5be:	4633      	mov	r3, r6
9001a5c0:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
9001a5c4:	f853 ab04 	ldr.w	sl, [r3], #4
9001a5c8:	9304      	str	r3, [sp, #16]
9001a5ca:	f04f 0600 	mov.w	r6, #0
9001a5ce:	f88d 605b 	strb.w	r6, [sp, #91]	; 0x5b
9001a5d2:	d00f      	beq.n	9001a5f4 <_svfprintf_r+0xa04>
9001a5d4:	4642      	mov	r2, r8
9001a5d6:	4631      	mov	r1, r6
9001a5d8:	4650      	mov	r0, sl
9001a5da:	f7e7 fdf9 	bl	900021d0 <memchr>
9001a5de:	9002      	str	r0, [sp, #8]
9001a5e0:	2800      	cmp	r0, #0
9001a5e2:	f000 80c8 	beq.w	9001a776 <_svfprintf_r+0xb86>
9001a5e6:	e9cd 6606 	strd	r6, r6, [sp, #24]
9001a5ea:	eba0 080a 	sub.w	r8, r0, sl
9001a5ee:	9602      	str	r6, [sp, #8]
9001a5f0:	4637      	mov	r7, r6
9001a5f2:	e5e2      	b.n	9001a1ba <_svfprintf_r+0x5ca>
9001a5f4:	4650      	mov	r0, sl
9001a5f6:	f7e7 fe3b 	bl	90002270 <strlen>
9001a5fa:	4637      	mov	r7, r6
9001a5fc:	4680      	mov	r8, r0
9001a5fe:	9602      	str	r6, [sp, #8]
9001a600:	463b      	mov	r3, r7
9001a602:	e4ae      	b.n	90019f62 <_svfprintf_r+0x372>
9001a604:	f045 0510 	orr.w	r5, r5, #16
9001a608:	06a8      	lsls	r0, r5, #26
9001a60a:	d507      	bpl.n	9001a61c <_svfprintf_r+0xa2c>
9001a60c:	3607      	adds	r6, #7
9001a60e:	f026 0307 	bic.w	r3, r6, #7
9001a612:	e8f3 6702 	ldrd	r6, r7, [r3], #8
9001a616:	9304      	str	r3, [sp, #16]
9001a618:	2301      	movs	r3, #1
9001a61a:	e79a      	b.n	9001a552 <_svfprintf_r+0x962>
9001a61c:	1d33      	adds	r3, r6, #4
9001a61e:	06e9      	lsls	r1, r5, #27
9001a620:	9304      	str	r3, [sp, #16]
9001a622:	d501      	bpl.n	9001a628 <_svfprintf_r+0xa38>
9001a624:	6836      	ldr	r6, [r6, #0]
9001a626:	e002      	b.n	9001a62e <_svfprintf_r+0xa3e>
9001a628:	066a      	lsls	r2, r5, #25
9001a62a:	d502      	bpl.n	9001a632 <_svfprintf_r+0xa42>
9001a62c:	8836      	ldrh	r6, [r6, #0]
9001a62e:	2700      	movs	r7, #0
9001a630:	e7f2      	b.n	9001a618 <_svfprintf_r+0xa28>
9001a632:	05ab      	lsls	r3, r5, #22
9001a634:	d5f6      	bpl.n	9001a624 <_svfprintf_r+0xa34>
9001a636:	7836      	ldrb	r6, [r6, #0]
9001a638:	e7f9      	b.n	9001a62e <_svfprintf_r+0xa3e>
9001a63a:	4b7c      	ldr	r3, [pc, #496]	; (9001a82c <_svfprintf_r+0xc3c>)
9001a63c:	9312      	str	r3, [sp, #72]	; 0x48
9001a63e:	06af      	lsls	r7, r5, #26
9001a640:	d518      	bpl.n	9001a674 <_svfprintf_r+0xa84>
9001a642:	3607      	adds	r6, #7
9001a644:	f026 0307 	bic.w	r3, r6, #7
9001a648:	e8f3 6702 	ldrd	r6, r7, [r3], #8
9001a64c:	9304      	str	r3, [sp, #16]
9001a64e:	07eb      	lsls	r3, r5, #31
9001a650:	d50a      	bpl.n	9001a668 <_svfprintf_r+0xa78>
9001a652:	ea56 0307 	orrs.w	r3, r6, r7
9001a656:	d007      	beq.n	9001a668 <_svfprintf_r+0xa78>
9001a658:	2330      	movs	r3, #48	; 0x30
9001a65a:	f88d 305c 	strb.w	r3, [sp, #92]	; 0x5c
9001a65e:	9b05      	ldr	r3, [sp, #20]
9001a660:	f88d 305d 	strb.w	r3, [sp, #93]	; 0x5d
9001a664:	f045 0502 	orr.w	r5, r5, #2
9001a668:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
9001a66c:	2302      	movs	r3, #2
9001a66e:	e770      	b.n	9001a552 <_svfprintf_r+0x962>
9001a670:	4b6d      	ldr	r3, [pc, #436]	; (9001a828 <_svfprintf_r+0xc38>)
9001a672:	e7e3      	b.n	9001a63c <_svfprintf_r+0xa4c>
9001a674:	1d33      	adds	r3, r6, #4
9001a676:	06e8      	lsls	r0, r5, #27
9001a678:	9304      	str	r3, [sp, #16]
9001a67a:	d501      	bpl.n	9001a680 <_svfprintf_r+0xa90>
9001a67c:	6836      	ldr	r6, [r6, #0]
9001a67e:	e002      	b.n	9001a686 <_svfprintf_r+0xa96>
9001a680:	0669      	lsls	r1, r5, #25
9001a682:	d502      	bpl.n	9001a68a <_svfprintf_r+0xa9a>
9001a684:	8836      	ldrh	r6, [r6, #0]
9001a686:	2700      	movs	r7, #0
9001a688:	e7e1      	b.n	9001a64e <_svfprintf_r+0xa5e>
9001a68a:	05aa      	lsls	r2, r5, #22
9001a68c:	d5f6      	bpl.n	9001a67c <_svfprintf_r+0xa8c>
9001a68e:	7836      	ldrb	r6, [r6, #0]
9001a690:	e7f9      	b.n	9001a686 <_svfprintf_r+0xa96>
9001a692:	2f00      	cmp	r7, #0
9001a694:	bf08      	it	eq
9001a696:	2e0a      	cmpeq	r6, #10
9001a698:	d206      	bcs.n	9001a6a8 <_svfprintf_r+0xab8>
9001a69a:	3630      	adds	r6, #48	; 0x30
9001a69c:	f88d 6127 	strb.w	r6, [sp, #295]	; 0x127
9001a6a0:	f20d 1a27 	addw	sl, sp, #295	; 0x127
9001a6a4:	f000 bc05 	b.w	9001aeb2 <_svfprintf_r+0x12c2>
9001a6a8:	2300      	movs	r3, #0
9001a6aa:	9303      	str	r3, [sp, #12]
9001a6ac:	9b02      	ldr	r3, [sp, #8]
9001a6ae:	f403 6380 	and.w	r3, r3, #1024	; 0x400
9001a6b2:	ad4a      	add	r5, sp, #296	; 0x128
9001a6b4:	9306      	str	r3, [sp, #24]
9001a6b6:	220a      	movs	r2, #10
9001a6b8:	2300      	movs	r3, #0
9001a6ba:	4630      	mov	r0, r6
9001a6bc:	4639      	mov	r1, r7
9001a6be:	f7e7 fddf 	bl	90002280 <__aeabi_uldivmod>
9001a6c2:	9b03      	ldr	r3, [sp, #12]
9001a6c4:	3301      	adds	r3, #1
9001a6c6:	9303      	str	r3, [sp, #12]
9001a6c8:	9b06      	ldr	r3, [sp, #24]
9001a6ca:	3230      	adds	r2, #48	; 0x30
9001a6cc:	f105 3aff 	add.w	sl, r5, #4294967295	; 0xffffffff
9001a6d0:	f805 2c01 	strb.w	r2, [r5, #-1]
9001a6d4:	b1d3      	cbz	r3, 9001a70c <_svfprintf_r+0xb1c>
9001a6d6:	9b08      	ldr	r3, [sp, #32]
9001a6d8:	9a03      	ldr	r2, [sp, #12]
9001a6da:	781b      	ldrb	r3, [r3, #0]
9001a6dc:	429a      	cmp	r2, r3
9001a6de:	d115      	bne.n	9001a70c <_svfprintf_r+0xb1c>
9001a6e0:	2aff      	cmp	r2, #255	; 0xff
9001a6e2:	d013      	beq.n	9001a70c <_svfprintf_r+0xb1c>
9001a6e4:	2f00      	cmp	r7, #0
9001a6e6:	bf08      	it	eq
9001a6e8:	2e0a      	cmpeq	r6, #10
9001a6ea:	d30f      	bcc.n	9001a70c <_svfprintf_r+0xb1c>
9001a6ec:	9b0e      	ldr	r3, [sp, #56]	; 0x38
9001a6ee:	9910      	ldr	r1, [sp, #64]	; 0x40
9001a6f0:	ebaa 0a03 	sub.w	sl, sl, r3
9001a6f4:	461a      	mov	r2, r3
9001a6f6:	4650      	mov	r0, sl
9001a6f8:	f002 f8ea 	bl	9001c8d0 <strncpy>
9001a6fc:	9b08      	ldr	r3, [sp, #32]
9001a6fe:	785b      	ldrb	r3, [r3, #1]
9001a700:	b11b      	cbz	r3, 9001a70a <_svfprintf_r+0xb1a>
9001a702:	9b08      	ldr	r3, [sp, #32]
9001a704:	3301      	adds	r3, #1
9001a706:	9308      	str	r3, [sp, #32]
9001a708:	2300      	movs	r3, #0
9001a70a:	9303      	str	r3, [sp, #12]
9001a70c:	220a      	movs	r2, #10
9001a70e:	2300      	movs	r3, #0
9001a710:	4630      	mov	r0, r6
9001a712:	4639      	mov	r1, r7
9001a714:	f7e7 fdb4 	bl	90002280 <__aeabi_uldivmod>
9001a718:	2f00      	cmp	r7, #0
9001a71a:	bf08      	it	eq
9001a71c:	2e0a      	cmpeq	r6, #10
9001a71e:	f0c0 83c8 	bcc.w	9001aeb2 <_svfprintf_r+0x12c2>
9001a722:	4606      	mov	r6, r0
9001a724:	460f      	mov	r7, r1
9001a726:	4655      	mov	r5, sl
9001a728:	e7c5      	b.n	9001a6b6 <_svfprintf_r+0xac6>
9001a72a:	9a12      	ldr	r2, [sp, #72]	; 0x48
9001a72c:	f006 030f 	and.w	r3, r6, #15
9001a730:	5cd3      	ldrb	r3, [r2, r3]
9001a732:	f80a 3d01 	strb.w	r3, [sl, #-1]!
9001a736:	0933      	lsrs	r3, r6, #4
9001a738:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
9001a73c:	093a      	lsrs	r2, r7, #4
9001a73e:	461e      	mov	r6, r3
9001a740:	4617      	mov	r7, r2
9001a742:	ea56 0307 	orrs.w	r3, r6, r7
9001a746:	d1f0      	bne.n	9001a72a <_svfprintf_r+0xb3a>
9001a748:	e3b3      	b.n	9001aeb2 <_svfprintf_r+0x12c2>
9001a74a:	b92b      	cbnz	r3, 9001a758 <_svfprintf_r+0xb68>
9001a74c:	07e9      	lsls	r1, r5, #31
9001a74e:	d503      	bpl.n	9001a758 <_svfprintf_r+0xb68>
9001a750:	2330      	movs	r3, #48	; 0x30
9001a752:	f88d 3127 	strb.w	r3, [sp, #295]	; 0x127
9001a756:	e7a3      	b.n	9001a6a0 <_svfprintf_r+0xab0>
9001a758:	f50d 7a94 	add.w	sl, sp, #296	; 0x128
9001a75c:	e3a9      	b.n	9001aeb2 <_svfprintf_r+0x12c2>
9001a75e:	9b05      	ldr	r3, [sp, #20]
9001a760:	2b00      	cmp	r3, #0
9001a762:	f000 8375 	beq.w	9001ae50 <_svfprintf_r+0x1260>
9001a766:	2000      	movs	r0, #0
9001a768:	f88d 30c4 	strb.w	r3, [sp, #196]	; 0xc4
9001a76c:	f88d 005b 	strb.w	r0, [sp, #91]	; 0x5b
9001a770:	9604      	str	r6, [sp, #16]
9001a772:	f7ff bb96 	b.w	90019ea2 <_svfprintf_r+0x2b2>
9001a776:	9f02      	ldr	r7, [sp, #8]
9001a778:	e742      	b.n	9001a600 <_svfprintf_r+0xa10>
9001a77a:	2110      	movs	r1, #16
9001a77c:	6061      	str	r1, [r4, #4]
9001a77e:	2a07      	cmp	r2, #7
9001a780:	4461      	add	r1, ip
9001a782:	e9cd 211f 	strd	r2, r1, [sp, #124]	; 0x7c
9001a786:	dd0a      	ble.n	9001a79e <_svfprintf_r+0xbae>
9001a788:	aa1e      	add	r2, sp, #120	; 0x78
9001a78a:	4659      	mov	r1, fp
9001a78c:	4648      	mov	r0, r9
9001a78e:	9315      	str	r3, [sp, #84]	; 0x54
9001a790:	f002 f8b1 	bl	9001c8f6 <__ssprint_r>
9001a794:	2800      	cmp	r0, #0
9001a796:	f040 8339 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a79a:	9b15      	ldr	r3, [sp, #84]	; 0x54
9001a79c:	a821      	add	r0, sp, #132	; 0x84
9001a79e:	3b10      	subs	r3, #16
9001a7a0:	4604      	mov	r4, r0
9001a7a2:	e525      	b.n	9001a1f0 <_svfprintf_r+0x600>
9001a7a4:	4604      	mov	r4, r0
9001a7a6:	e53f      	b.n	9001a228 <_svfprintf_r+0x638>
9001a7a8:	aa1e      	add	r2, sp, #120	; 0x78
9001a7aa:	4659      	mov	r1, fp
9001a7ac:	4648      	mov	r0, r9
9001a7ae:	f002 f8a2 	bl	9001c8f6 <__ssprint_r>
9001a7b2:	2800      	cmp	r0, #0
9001a7b4:	f040 832a 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a7b8:	ac21      	add	r4, sp, #132	; 0x84
9001a7ba:	e547      	b.n	9001a24c <_svfprintf_r+0x65c>
9001a7bc:	aa1e      	add	r2, sp, #120	; 0x78
9001a7be:	4659      	mov	r1, fp
9001a7c0:	4648      	mov	r0, r9
9001a7c2:	f002 f898 	bl	9001c8f6 <__ssprint_r>
9001a7c6:	2800      	cmp	r0, #0
9001a7c8:	f040 8320 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a7cc:	ac21      	add	r4, sp, #132	; 0x84
9001a7ce:	e54d      	b.n	9001a26c <_svfprintf_r+0x67c>
9001a7d0:	2110      	movs	r1, #16
9001a7d2:	6061      	str	r1, [r4, #4]
9001a7d4:	2a07      	cmp	r2, #7
9001a7d6:	4461      	add	r1, ip
9001a7d8:	e9cd 211f 	strd	r2, r1, [sp, #124]	; 0x7c
9001a7dc:	dd0a      	ble.n	9001a7f4 <_svfprintf_r+0xc04>
9001a7de:	aa1e      	add	r2, sp, #120	; 0x78
9001a7e0:	4659      	mov	r1, fp
9001a7e2:	4648      	mov	r0, r9
9001a7e4:	9313      	str	r3, [sp, #76]	; 0x4c
9001a7e6:	f002 f886 	bl	9001c8f6 <__ssprint_r>
9001a7ea:	2800      	cmp	r0, #0
9001a7ec:	f040 830e 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a7f0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
9001a7f2:	a821      	add	r0, sp, #132	; 0x84
9001a7f4:	3b10      	subs	r3, #16
9001a7f6:	4604      	mov	r4, r0
9001a7f8:	e540      	b.n	9001a27c <_svfprintf_r+0x68c>
9001a7fa:	4604      	mov	r4, r0
9001a7fc:	e55a      	b.n	9001a2b4 <_svfprintf_r+0x6c4>
9001a7fe:	2010      	movs	r0, #16
9001a800:	4402      	add	r2, r0
9001a802:	2b07      	cmp	r3, #7
9001a804:	e9cd 321f 	strd	r3, r2, [sp, #124]	; 0x7c
9001a808:	6060      	str	r0, [r4, #4]
9001a80a:	dd08      	ble.n	9001a81e <_svfprintf_r+0xc2e>
9001a80c:	aa1e      	add	r2, sp, #120	; 0x78
9001a80e:	4659      	mov	r1, fp
9001a810:	4648      	mov	r0, r9
9001a812:	f002 f870 	bl	9001c8f6 <__ssprint_r>
9001a816:	2800      	cmp	r0, #0
9001a818:	f040 82f8 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a81c:	a921      	add	r1, sp, #132	; 0x84
9001a81e:	3f10      	subs	r7, #16
9001a820:	460c      	mov	r4, r1
9001a822:	e54b      	b.n	9001a2bc <_svfprintf_r+0x6cc>
9001a824:	460c      	mov	r4, r1
9001a826:	e564      	b.n	9001a2f2 <_svfprintf_r+0x702>
9001a828:	90025354 	.word	0x90025354
9001a82c:	90025365 	.word	0x90025365
9001a830:	9b05      	ldr	r3, [sp, #20]
9001a832:	2b65      	cmp	r3, #101	; 0x65
9001a834:	f340 8240 	ble.w	9001acb8 <_svfprintf_r+0x10c8>
9001a838:	eeb5 8b40 	vcmp.f64	d8, #0.0
9001a83c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001a840:	d169      	bne.n	9001a916 <_svfprintf_r+0xd26>
9001a842:	4b72      	ldr	r3, [pc, #456]	; (9001aa0c <_svfprintf_r+0xe1c>)
9001a844:	6023      	str	r3, [r4, #0]
9001a846:	2301      	movs	r3, #1
9001a848:	4418      	add	r0, r3
9001a84a:	6063      	str	r3, [r4, #4]
9001a84c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001a84e:	9020      	str	r0, [sp, #128]	; 0x80
9001a850:	3301      	adds	r3, #1
9001a852:	2b07      	cmp	r3, #7
9001a854:	931f      	str	r3, [sp, #124]	; 0x7c
9001a856:	dc37      	bgt.n	9001a8c8 <_svfprintf_r+0xcd8>
9001a858:	3408      	adds	r4, #8
9001a85a:	9b18      	ldr	r3, [sp, #96]	; 0x60
9001a85c:	9a03      	ldr	r2, [sp, #12]
9001a85e:	4293      	cmp	r3, r2
9001a860:	db02      	blt.n	9001a868 <_svfprintf_r+0xc78>
9001a862:	07eb      	lsls	r3, r5, #31
9001a864:	f57f ad54 	bpl.w	9001a310 <_svfprintf_r+0x720>
9001a868:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
9001a86a:	6023      	str	r3, [r4, #0]
9001a86c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001a86e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
9001a870:	6063      	str	r3, [r4, #4]
9001a872:	9b20      	ldr	r3, [sp, #128]	; 0x80
9001a874:	4413      	add	r3, r2
9001a876:	9320      	str	r3, [sp, #128]	; 0x80
9001a878:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001a87a:	3301      	adds	r3, #1
9001a87c:	2b07      	cmp	r3, #7
9001a87e:	931f      	str	r3, [sp, #124]	; 0x7c
9001a880:	dc2c      	bgt.n	9001a8dc <_svfprintf_r+0xcec>
9001a882:	3408      	adds	r4, #8
9001a884:	9b03      	ldr	r3, [sp, #12]
9001a886:	1e5e      	subs	r6, r3, #1
9001a888:	2e00      	cmp	r6, #0
9001a88a:	f77f ad41 	ble.w	9001a310 <_svfprintf_r+0x720>
9001a88e:	4f60      	ldr	r7, [pc, #384]	; (9001aa10 <_svfprintf_r+0xe20>)
9001a890:	f04f 0810 	mov.w	r8, #16
9001a894:	e9dd 321f 	ldrd	r3, r2, [sp, #124]	; 0x7c
9001a898:	2e10      	cmp	r6, #16
9001a89a:	f103 0301 	add.w	r3, r3, #1
9001a89e:	f104 0108 	add.w	r1, r4, #8
9001a8a2:	6027      	str	r7, [r4, #0]
9001a8a4:	dc24      	bgt.n	9001a8f0 <_svfprintf_r+0xd00>
9001a8a6:	6066      	str	r6, [r4, #4]
9001a8a8:	2b07      	cmp	r3, #7
9001a8aa:	4416      	add	r6, r2
9001a8ac:	e9cd 361f 	strd	r3, r6, [sp, #124]	; 0x7c
9001a8b0:	f340 828b 	ble.w	9001adca <_svfprintf_r+0x11da>
9001a8b4:	aa1e      	add	r2, sp, #120	; 0x78
9001a8b6:	4659      	mov	r1, fp
9001a8b8:	4648      	mov	r0, r9
9001a8ba:	f002 f81c 	bl	9001c8f6 <__ssprint_r>
9001a8be:	2800      	cmp	r0, #0
9001a8c0:	f040 82a4 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a8c4:	ac21      	add	r4, sp, #132	; 0x84
9001a8c6:	e523      	b.n	9001a310 <_svfprintf_r+0x720>
9001a8c8:	aa1e      	add	r2, sp, #120	; 0x78
9001a8ca:	4659      	mov	r1, fp
9001a8cc:	4648      	mov	r0, r9
9001a8ce:	f002 f812 	bl	9001c8f6 <__ssprint_r>
9001a8d2:	2800      	cmp	r0, #0
9001a8d4:	f040 829a 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a8d8:	ac21      	add	r4, sp, #132	; 0x84
9001a8da:	e7be      	b.n	9001a85a <_svfprintf_r+0xc6a>
9001a8dc:	aa1e      	add	r2, sp, #120	; 0x78
9001a8de:	4659      	mov	r1, fp
9001a8e0:	4648      	mov	r0, r9
9001a8e2:	f002 f808 	bl	9001c8f6 <__ssprint_r>
9001a8e6:	2800      	cmp	r0, #0
9001a8e8:	f040 8290 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a8ec:	ac21      	add	r4, sp, #132	; 0x84
9001a8ee:	e7c9      	b.n	9001a884 <_svfprintf_r+0xc94>
9001a8f0:	3210      	adds	r2, #16
9001a8f2:	2b07      	cmp	r3, #7
9001a8f4:	e9cd 321f 	strd	r3, r2, [sp, #124]	; 0x7c
9001a8f8:	f8c4 8004 	str.w	r8, [r4, #4]
9001a8fc:	dd08      	ble.n	9001a910 <_svfprintf_r+0xd20>
9001a8fe:	aa1e      	add	r2, sp, #120	; 0x78
9001a900:	4659      	mov	r1, fp
9001a902:	4648      	mov	r0, r9
9001a904:	f001 fff7 	bl	9001c8f6 <__ssprint_r>
9001a908:	2800      	cmp	r0, #0
9001a90a:	f040 827f 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a90e:	a921      	add	r1, sp, #132	; 0x84
9001a910:	3e10      	subs	r6, #16
9001a912:	460c      	mov	r4, r1
9001a914:	e7be      	b.n	9001a894 <_svfprintf_r+0xca4>
9001a916:	9b18      	ldr	r3, [sp, #96]	; 0x60
9001a918:	2b00      	cmp	r3, #0
9001a91a:	dc7b      	bgt.n	9001aa14 <_svfprintf_r+0xe24>
9001a91c:	4b3b      	ldr	r3, [pc, #236]	; (9001aa0c <_svfprintf_r+0xe1c>)
9001a91e:	6023      	str	r3, [r4, #0]
9001a920:	2301      	movs	r3, #1
9001a922:	4418      	add	r0, r3
9001a924:	6063      	str	r3, [r4, #4]
9001a926:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001a928:	9020      	str	r0, [sp, #128]	; 0x80
9001a92a:	3301      	adds	r3, #1
9001a92c:	2b07      	cmp	r3, #7
9001a92e:	931f      	str	r3, [sp, #124]	; 0x7c
9001a930:	dc46      	bgt.n	9001a9c0 <_svfprintf_r+0xdd0>
9001a932:	3408      	adds	r4, #8
9001a934:	9903      	ldr	r1, [sp, #12]
9001a936:	9a18      	ldr	r2, [sp, #96]	; 0x60
9001a938:	9b20      	ldr	r3, [sp, #128]	; 0x80
9001a93a:	430a      	orrs	r2, r1
9001a93c:	f005 0101 	and.w	r1, r5, #1
9001a940:	430a      	orrs	r2, r1
9001a942:	f43f ace5 	beq.w	9001a310 <_svfprintf_r+0x720>
9001a946:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
9001a948:	6022      	str	r2, [r4, #0]
9001a94a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
9001a94c:	6062      	str	r2, [r4, #4]
9001a94e:	4413      	add	r3, r2
9001a950:	9320      	str	r3, [sp, #128]	; 0x80
9001a952:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001a954:	3301      	adds	r3, #1
9001a956:	2b07      	cmp	r3, #7
9001a958:	931f      	str	r3, [sp, #124]	; 0x7c
9001a95a:	dc3b      	bgt.n	9001a9d4 <_svfprintf_r+0xde4>
9001a95c:	f104 0308 	add.w	r3, r4, #8
9001a960:	9e18      	ldr	r6, [sp, #96]	; 0x60
9001a962:	2e00      	cmp	r6, #0
9001a964:	da1b      	bge.n	9001a99e <_svfprintf_r+0xdae>
9001a966:	4f2a      	ldr	r7, [pc, #168]	; (9001aa10 <_svfprintf_r+0xe20>)
9001a968:	4276      	negs	r6, r6
9001a96a:	461a      	mov	r2, r3
9001a96c:	2410      	movs	r4, #16
9001a96e:	e9dd 101f 	ldrd	r1, r0, [sp, #124]	; 0x7c
9001a972:	2e10      	cmp	r6, #16
9001a974:	f101 0101 	add.w	r1, r1, #1
9001a978:	f103 0308 	add.w	r3, r3, #8
9001a97c:	6017      	str	r7, [r2, #0]
9001a97e:	dc33      	bgt.n	9001a9e8 <_svfprintf_r+0xdf8>
9001a980:	6056      	str	r6, [r2, #4]
9001a982:	2907      	cmp	r1, #7
9001a984:	4406      	add	r6, r0
9001a986:	e9cd 161f 	strd	r1, r6, [sp, #124]	; 0x7c
9001a98a:	dd08      	ble.n	9001a99e <_svfprintf_r+0xdae>
9001a98c:	aa1e      	add	r2, sp, #120	; 0x78
9001a98e:	4659      	mov	r1, fp
9001a990:	4648      	mov	r0, r9
9001a992:	f001 ffb0 	bl	9001c8f6 <__ssprint_r>
9001a996:	2800      	cmp	r0, #0
9001a998:	f040 8238 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a99c:	ab21      	add	r3, sp, #132	; 0x84
9001a99e:	9a03      	ldr	r2, [sp, #12]
9001a9a0:	605a      	str	r2, [r3, #4]
9001a9a2:	9903      	ldr	r1, [sp, #12]
9001a9a4:	9a20      	ldr	r2, [sp, #128]	; 0x80
9001a9a6:	f8c3 a000 	str.w	sl, [r3]
9001a9aa:	440a      	add	r2, r1
9001a9ac:	9220      	str	r2, [sp, #128]	; 0x80
9001a9ae:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
9001a9b0:	3201      	adds	r2, #1
9001a9b2:	2a07      	cmp	r2, #7
9001a9b4:	921f      	str	r2, [sp, #124]	; 0x7c
9001a9b6:	f73f af7d 	bgt.w	9001a8b4 <_svfprintf_r+0xcc4>
9001a9ba:	f103 0408 	add.w	r4, r3, #8
9001a9be:	e4a7      	b.n	9001a310 <_svfprintf_r+0x720>
9001a9c0:	aa1e      	add	r2, sp, #120	; 0x78
9001a9c2:	4659      	mov	r1, fp
9001a9c4:	4648      	mov	r0, r9
9001a9c6:	f001 ff96 	bl	9001c8f6 <__ssprint_r>
9001a9ca:	2800      	cmp	r0, #0
9001a9cc:	f040 821e 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a9d0:	ac21      	add	r4, sp, #132	; 0x84
9001a9d2:	e7af      	b.n	9001a934 <_svfprintf_r+0xd44>
9001a9d4:	aa1e      	add	r2, sp, #120	; 0x78
9001a9d6:	4659      	mov	r1, fp
9001a9d8:	4648      	mov	r0, r9
9001a9da:	f001 ff8c 	bl	9001c8f6 <__ssprint_r>
9001a9de:	2800      	cmp	r0, #0
9001a9e0:	f040 8214 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001a9e4:	ab21      	add	r3, sp, #132	; 0x84
9001a9e6:	e7bb      	b.n	9001a960 <_svfprintf_r+0xd70>
9001a9e8:	3010      	adds	r0, #16
9001a9ea:	2907      	cmp	r1, #7
9001a9ec:	e9cd 101f 	strd	r1, r0, [sp, #124]	; 0x7c
9001a9f0:	6054      	str	r4, [r2, #4]
9001a9f2:	dd08      	ble.n	9001aa06 <_svfprintf_r+0xe16>
9001a9f4:	aa1e      	add	r2, sp, #120	; 0x78
9001a9f6:	4659      	mov	r1, fp
9001a9f8:	4648      	mov	r0, r9
9001a9fa:	f001 ff7c 	bl	9001c8f6 <__ssprint_r>
9001a9fe:	2800      	cmp	r0, #0
9001aa00:	f040 8204 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001aa04:	ab21      	add	r3, sp, #132	; 0x84
9001aa06:	3e10      	subs	r6, #16
9001aa08:	461a      	mov	r2, r3
9001aa0a:	e7b0      	b.n	9001a96e <_svfprintf_r+0xd7e>
9001aa0c:	90025376 	.word	0x90025376
9001aa10:	90025388 	.word	0x90025388
9001aa14:	9b03      	ldr	r3, [sp, #12]
9001aa16:	42b3      	cmp	r3, r6
9001aa18:	bfa8      	it	ge
9001aa1a:	4633      	movge	r3, r6
9001aa1c:	2b00      	cmp	r3, #0
9001aa1e:	461f      	mov	r7, r3
9001aa20:	dd0a      	ble.n	9001aa38 <_svfprintf_r+0xe48>
9001aa22:	4418      	add	r0, r3
9001aa24:	e9c4 a300 	strd	sl, r3, [r4]
9001aa28:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001aa2a:	9020      	str	r0, [sp, #128]	; 0x80
9001aa2c:	3301      	adds	r3, #1
9001aa2e:	2b07      	cmp	r3, #7
9001aa30:	931f      	str	r3, [sp, #124]	; 0x7c
9001aa32:	f300 8088 	bgt.w	9001ab46 <_svfprintf_r+0xf56>
9001aa36:	3408      	adds	r4, #8
9001aa38:	2f00      	cmp	r7, #0
9001aa3a:	bfac      	ite	ge
9001aa3c:	1bf7      	subge	r7, r6, r7
9001aa3e:	4637      	movlt	r7, r6
9001aa40:	2f00      	cmp	r7, #0
9001aa42:	dd1b      	ble.n	9001aa7c <_svfprintf_r+0xe8c>
9001aa44:	f8df 826c 	ldr.w	r8, [pc, #620]	; 9001acb4 <_svfprintf_r+0x10c4>
9001aa48:	f8c4 8000 	str.w	r8, [r4]
9001aa4c:	e9dd 321f 	ldrd	r3, r2, [sp, #124]	; 0x7c
9001aa50:	2f10      	cmp	r7, #16
9001aa52:	f103 0301 	add.w	r3, r3, #1
9001aa56:	f104 0108 	add.w	r1, r4, #8
9001aa5a:	dc7e      	bgt.n	9001ab5a <_svfprintf_r+0xf6a>
9001aa5c:	6067      	str	r7, [r4, #4]
9001aa5e:	2b07      	cmp	r3, #7
9001aa60:	4417      	add	r7, r2
9001aa62:	e9cd 371f 	strd	r3, r7, [sp, #124]	; 0x7c
9001aa66:	f340 808b 	ble.w	9001ab80 <_svfprintf_r+0xf90>
9001aa6a:	aa1e      	add	r2, sp, #120	; 0x78
9001aa6c:	4659      	mov	r1, fp
9001aa6e:	4648      	mov	r0, r9
9001aa70:	f001 ff41 	bl	9001c8f6 <__ssprint_r>
9001aa74:	2800      	cmp	r0, #0
9001aa76:	f040 81c9 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001aa7a:	ac21      	add	r4, sp, #132	; 0x84
9001aa7c:	056f      	lsls	r7, r5, #21
9001aa7e:	4456      	add	r6, sl
9001aa80:	d50b      	bpl.n	9001aa9a <_svfprintf_r+0xeaa>
9001aa82:	4f8c      	ldr	r7, [pc, #560]	; (9001acb4 <_svfprintf_r+0x10c4>)
9001aa84:	9b07      	ldr	r3, [sp, #28]
9001aa86:	2b00      	cmp	r3, #0
9001aa88:	d17c      	bne.n	9001ab84 <_svfprintf_r+0xf94>
9001aa8a:	9b06      	ldr	r3, [sp, #24]
9001aa8c:	2b00      	cmp	r3, #0
9001aa8e:	d17c      	bne.n	9001ab8a <_svfprintf_r+0xf9a>
9001aa90:	9b03      	ldr	r3, [sp, #12]
9001aa92:	4453      	add	r3, sl
9001aa94:	429e      	cmp	r6, r3
9001aa96:	bf28      	it	cs
9001aa98:	461e      	movcs	r6, r3
9001aa9a:	9b18      	ldr	r3, [sp, #96]	; 0x60
9001aa9c:	9a03      	ldr	r2, [sp, #12]
9001aa9e:	4293      	cmp	r3, r2
9001aaa0:	db01      	blt.n	9001aaa6 <_svfprintf_r+0xeb6>
9001aaa2:	07e8      	lsls	r0, r5, #31
9001aaa4:	d50e      	bpl.n	9001aac4 <_svfprintf_r+0xed4>
9001aaa6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
9001aaa8:	6023      	str	r3, [r4, #0]
9001aaaa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001aaac:	9a0a      	ldr	r2, [sp, #40]	; 0x28
9001aaae:	6063      	str	r3, [r4, #4]
9001aab0:	9b20      	ldr	r3, [sp, #128]	; 0x80
9001aab2:	4413      	add	r3, r2
9001aab4:	9320      	str	r3, [sp, #128]	; 0x80
9001aab6:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001aab8:	3301      	adds	r3, #1
9001aaba:	2b07      	cmp	r3, #7
9001aabc:	931f      	str	r3, [sp, #124]	; 0x7c
9001aabe:	f300 80e5 	bgt.w	9001ac8c <_svfprintf_r+0x109c>
9001aac2:	3408      	adds	r4, #8
9001aac4:	9b03      	ldr	r3, [sp, #12]
9001aac6:	9f18      	ldr	r7, [sp, #96]	; 0x60
9001aac8:	eb0a 0203 	add.w	r2, sl, r3
9001aacc:	1bdf      	subs	r7, r3, r7
9001aace:	1b92      	subs	r2, r2, r6
9001aad0:	4297      	cmp	r7, r2
9001aad2:	bfa8      	it	ge
9001aad4:	4617      	movge	r7, r2
9001aad6:	2f00      	cmp	r7, #0
9001aad8:	dd0b      	ble.n	9001aaf2 <_svfprintf_r+0xf02>
9001aada:	9b20      	ldr	r3, [sp, #128]	; 0x80
9001aadc:	443b      	add	r3, r7
9001aade:	9320      	str	r3, [sp, #128]	; 0x80
9001aae0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001aae2:	3301      	adds	r3, #1
9001aae4:	2b07      	cmp	r3, #7
9001aae6:	e9c4 6700 	strd	r6, r7, [r4]
9001aaea:	931f      	str	r3, [sp, #124]	; 0x7c
9001aaec:	f300 80d8 	bgt.w	9001aca0 <_svfprintf_r+0x10b0>
9001aaf0:	3408      	adds	r4, #8
9001aaf2:	9e18      	ldr	r6, [sp, #96]	; 0x60
9001aaf4:	9b03      	ldr	r3, [sp, #12]
9001aaf6:	2f00      	cmp	r7, #0
9001aaf8:	eba3 0606 	sub.w	r6, r3, r6
9001aafc:	bfa8      	it	ge
9001aafe:	1bf6      	subge	r6, r6, r7
9001ab00:	2e00      	cmp	r6, #0
9001ab02:	f77f ac05 	ble.w	9001a310 <_svfprintf_r+0x720>
9001ab06:	4f6b      	ldr	r7, [pc, #428]	; (9001acb4 <_svfprintf_r+0x10c4>)
9001ab08:	f04f 0810 	mov.w	r8, #16
9001ab0c:	e9dd 321f 	ldrd	r3, r2, [sp, #124]	; 0x7c
9001ab10:	2e10      	cmp	r6, #16
9001ab12:	f103 0301 	add.w	r3, r3, #1
9001ab16:	f104 0108 	add.w	r1, r4, #8
9001ab1a:	6027      	str	r7, [r4, #0]
9001ab1c:	f77f aec3 	ble.w	9001a8a6 <_svfprintf_r+0xcb6>
9001ab20:	3210      	adds	r2, #16
9001ab22:	2b07      	cmp	r3, #7
9001ab24:	e9cd 321f 	strd	r3, r2, [sp, #124]	; 0x7c
9001ab28:	f8c4 8004 	str.w	r8, [r4, #4]
9001ab2c:	dd08      	ble.n	9001ab40 <_svfprintf_r+0xf50>
9001ab2e:	aa1e      	add	r2, sp, #120	; 0x78
9001ab30:	4659      	mov	r1, fp
9001ab32:	4648      	mov	r0, r9
9001ab34:	f001 fedf 	bl	9001c8f6 <__ssprint_r>
9001ab38:	2800      	cmp	r0, #0
9001ab3a:	f040 8167 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001ab3e:	a921      	add	r1, sp, #132	; 0x84
9001ab40:	3e10      	subs	r6, #16
9001ab42:	460c      	mov	r4, r1
9001ab44:	e7e2      	b.n	9001ab0c <_svfprintf_r+0xf1c>
9001ab46:	aa1e      	add	r2, sp, #120	; 0x78
9001ab48:	4659      	mov	r1, fp
9001ab4a:	4648      	mov	r0, r9
9001ab4c:	f001 fed3 	bl	9001c8f6 <__ssprint_r>
9001ab50:	2800      	cmp	r0, #0
9001ab52:	f040 815b 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001ab56:	ac21      	add	r4, sp, #132	; 0x84
9001ab58:	e76e      	b.n	9001aa38 <_svfprintf_r+0xe48>
9001ab5a:	2010      	movs	r0, #16
9001ab5c:	4402      	add	r2, r0
9001ab5e:	2b07      	cmp	r3, #7
9001ab60:	e9cd 321f 	strd	r3, r2, [sp, #124]	; 0x7c
9001ab64:	6060      	str	r0, [r4, #4]
9001ab66:	dd08      	ble.n	9001ab7a <_svfprintf_r+0xf8a>
9001ab68:	aa1e      	add	r2, sp, #120	; 0x78
9001ab6a:	4659      	mov	r1, fp
9001ab6c:	4648      	mov	r0, r9
9001ab6e:	f001 fec2 	bl	9001c8f6 <__ssprint_r>
9001ab72:	2800      	cmp	r0, #0
9001ab74:	f040 814a 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001ab78:	a921      	add	r1, sp, #132	; 0x84
9001ab7a:	3f10      	subs	r7, #16
9001ab7c:	460c      	mov	r4, r1
9001ab7e:	e763      	b.n	9001aa48 <_svfprintf_r+0xe58>
9001ab80:	460c      	mov	r4, r1
9001ab82:	e77b      	b.n	9001aa7c <_svfprintf_r+0xe8c>
9001ab84:	9b06      	ldr	r3, [sp, #24]
9001ab86:	2b00      	cmp	r3, #0
9001ab88:	d04f      	beq.n	9001ac2a <_svfprintf_r+0x103a>
9001ab8a:	9b06      	ldr	r3, [sp, #24]
9001ab8c:	3b01      	subs	r3, #1
9001ab8e:	9306      	str	r3, [sp, #24]
9001ab90:	9b10      	ldr	r3, [sp, #64]	; 0x40
9001ab92:	6023      	str	r3, [r4, #0]
9001ab94:	9b0e      	ldr	r3, [sp, #56]	; 0x38
9001ab96:	9a0e      	ldr	r2, [sp, #56]	; 0x38
9001ab98:	6063      	str	r3, [r4, #4]
9001ab9a:	9b20      	ldr	r3, [sp, #128]	; 0x80
9001ab9c:	4413      	add	r3, r2
9001ab9e:	9320      	str	r3, [sp, #128]	; 0x80
9001aba0:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001aba2:	3301      	adds	r3, #1
9001aba4:	2b07      	cmp	r3, #7
9001aba6:	931f      	str	r3, [sp, #124]	; 0x7c
9001aba8:	dc46      	bgt.n	9001ac38 <_svfprintf_r+0x1048>
9001abaa:	3408      	adds	r4, #8
9001abac:	9b03      	ldr	r3, [sp, #12]
9001abae:	4453      	add	r3, sl
9001abb0:	1b9a      	subs	r2, r3, r6
9001abb2:	9b08      	ldr	r3, [sp, #32]
9001abb4:	781b      	ldrb	r3, [r3, #0]
9001abb6:	4293      	cmp	r3, r2
9001abb8:	bfa8      	it	ge
9001abba:	4613      	movge	r3, r2
9001abbc:	2b00      	cmp	r3, #0
9001abbe:	4698      	mov	r8, r3
9001abc0:	dd0a      	ble.n	9001abd8 <_svfprintf_r+0xfe8>
9001abc2:	e9c4 6300 	strd	r6, r3, [r4]
9001abc6:	9b20      	ldr	r3, [sp, #128]	; 0x80
9001abc8:	4443      	add	r3, r8
9001abca:	9320      	str	r3, [sp, #128]	; 0x80
9001abcc:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001abce:	3301      	adds	r3, #1
9001abd0:	2b07      	cmp	r3, #7
9001abd2:	931f      	str	r3, [sp, #124]	; 0x7c
9001abd4:	dc3a      	bgt.n	9001ac4c <_svfprintf_r+0x105c>
9001abd6:	3408      	adds	r4, #8
9001abd8:	9b08      	ldr	r3, [sp, #32]
9001abda:	781b      	ldrb	r3, [r3, #0]
9001abdc:	f1b8 0f00 	cmp.w	r8, #0
9001abe0:	bfac      	ite	ge
9001abe2:	eba3 0808 	subge.w	r8, r3, r8
9001abe6:	4698      	movlt	r8, r3
9001abe8:	f1b8 0f00 	cmp.w	r8, #0
9001abec:	dd19      	ble.n	9001ac22 <_svfprintf_r+0x1032>
9001abee:	e9dd 231f 	ldrd	r2, r3, [sp, #124]	; 0x7c
9001abf2:	f1b8 0f10 	cmp.w	r8, #16
9001abf6:	f102 0201 	add.w	r2, r2, #1
9001abfa:	f104 0108 	add.w	r1, r4, #8
9001abfe:	6027      	str	r7, [r4, #0]
9001ac00:	dc2e      	bgt.n	9001ac60 <_svfprintf_r+0x1070>
9001ac02:	4443      	add	r3, r8
9001ac04:	2a07      	cmp	r2, #7
9001ac06:	e9cd 231f 	strd	r2, r3, [sp, #124]	; 0x7c
9001ac0a:	f8c4 8004 	str.w	r8, [r4, #4]
9001ac0e:	dd3b      	ble.n	9001ac88 <_svfprintf_r+0x1098>
9001ac10:	aa1e      	add	r2, sp, #120	; 0x78
9001ac12:	4659      	mov	r1, fp
9001ac14:	4648      	mov	r0, r9
9001ac16:	f001 fe6e 	bl	9001c8f6 <__ssprint_r>
9001ac1a:	2800      	cmp	r0, #0
9001ac1c:	f040 80f6 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001ac20:	ac21      	add	r4, sp, #132	; 0x84
9001ac22:	9b08      	ldr	r3, [sp, #32]
9001ac24:	781b      	ldrb	r3, [r3, #0]
9001ac26:	441e      	add	r6, r3
9001ac28:	e72c      	b.n	9001aa84 <_svfprintf_r+0xe94>
9001ac2a:	9b08      	ldr	r3, [sp, #32]
9001ac2c:	3b01      	subs	r3, #1
9001ac2e:	9308      	str	r3, [sp, #32]
9001ac30:	9b07      	ldr	r3, [sp, #28]
9001ac32:	3b01      	subs	r3, #1
9001ac34:	9307      	str	r3, [sp, #28]
9001ac36:	e7ab      	b.n	9001ab90 <_svfprintf_r+0xfa0>
9001ac38:	aa1e      	add	r2, sp, #120	; 0x78
9001ac3a:	4659      	mov	r1, fp
9001ac3c:	4648      	mov	r0, r9
9001ac3e:	f001 fe5a 	bl	9001c8f6 <__ssprint_r>
9001ac42:	2800      	cmp	r0, #0
9001ac44:	f040 80e2 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001ac48:	ac21      	add	r4, sp, #132	; 0x84
9001ac4a:	e7af      	b.n	9001abac <_svfprintf_r+0xfbc>
9001ac4c:	aa1e      	add	r2, sp, #120	; 0x78
9001ac4e:	4659      	mov	r1, fp
9001ac50:	4648      	mov	r0, r9
9001ac52:	f001 fe50 	bl	9001c8f6 <__ssprint_r>
9001ac56:	2800      	cmp	r0, #0
9001ac58:	f040 80d8 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001ac5c:	ac21      	add	r4, sp, #132	; 0x84
9001ac5e:	e7bb      	b.n	9001abd8 <_svfprintf_r+0xfe8>
9001ac60:	2010      	movs	r0, #16
9001ac62:	4403      	add	r3, r0
9001ac64:	2a07      	cmp	r2, #7
9001ac66:	e9cd 231f 	strd	r2, r3, [sp, #124]	; 0x7c
9001ac6a:	6060      	str	r0, [r4, #4]
9001ac6c:	dd08      	ble.n	9001ac80 <_svfprintf_r+0x1090>
9001ac6e:	aa1e      	add	r2, sp, #120	; 0x78
9001ac70:	4659      	mov	r1, fp
9001ac72:	4648      	mov	r0, r9
9001ac74:	f001 fe3f 	bl	9001c8f6 <__ssprint_r>
9001ac78:	2800      	cmp	r0, #0
9001ac7a:	f040 80c7 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001ac7e:	a921      	add	r1, sp, #132	; 0x84
9001ac80:	f1a8 0810 	sub.w	r8, r8, #16
9001ac84:	460c      	mov	r4, r1
9001ac86:	e7b2      	b.n	9001abee <_svfprintf_r+0xffe>
9001ac88:	460c      	mov	r4, r1
9001ac8a:	e7ca      	b.n	9001ac22 <_svfprintf_r+0x1032>
9001ac8c:	aa1e      	add	r2, sp, #120	; 0x78
9001ac8e:	4659      	mov	r1, fp
9001ac90:	4648      	mov	r0, r9
9001ac92:	f001 fe30 	bl	9001c8f6 <__ssprint_r>
9001ac96:	2800      	cmp	r0, #0
9001ac98:	f040 80b8 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001ac9c:	ac21      	add	r4, sp, #132	; 0x84
9001ac9e:	e711      	b.n	9001aac4 <_svfprintf_r+0xed4>
9001aca0:	aa1e      	add	r2, sp, #120	; 0x78
9001aca2:	4659      	mov	r1, fp
9001aca4:	4648      	mov	r0, r9
9001aca6:	f001 fe26 	bl	9001c8f6 <__ssprint_r>
9001acaa:	2800      	cmp	r0, #0
9001acac:	f040 80ae 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001acb0:	ac21      	add	r4, sp, #132	; 0x84
9001acb2:	e71e      	b.n	9001aaf2 <_svfprintf_r+0xf02>
9001acb4:	90025388 	.word	0x90025388
9001acb8:	9903      	ldr	r1, [sp, #12]
9001acba:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
9001acbc:	2901      	cmp	r1, #1
9001acbe:	f100 0001 	add.w	r0, r0, #1
9001acc2:	f102 0201 	add.w	r2, r2, #1
9001acc6:	f104 0308 	add.w	r3, r4, #8
9001acca:	dc01      	bgt.n	9001acd0 <_svfprintf_r+0x10e0>
9001accc:	07e9      	lsls	r1, r5, #31
9001acce:	d571      	bpl.n	9001adb4 <_svfprintf_r+0x11c4>
9001acd0:	2101      	movs	r1, #1
9001acd2:	2a07      	cmp	r2, #7
9001acd4:	e9cd 201f 	strd	r2, r0, [sp, #124]	; 0x7c
9001acd8:	f8c4 a000 	str.w	sl, [r4]
9001acdc:	6061      	str	r1, [r4, #4]
9001acde:	dd08      	ble.n	9001acf2 <_svfprintf_r+0x1102>
9001ace0:	aa1e      	add	r2, sp, #120	; 0x78
9001ace2:	4659      	mov	r1, fp
9001ace4:	4648      	mov	r0, r9
9001ace6:	f001 fe06 	bl	9001c8f6 <__ssprint_r>
9001acea:	2800      	cmp	r0, #0
9001acec:	f040 808e 	bne.w	9001ae0c <_svfprintf_r+0x121c>
9001acf0:	ab21      	add	r3, sp, #132	; 0x84
9001acf2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
9001acf4:	601a      	str	r2, [r3, #0]
9001acf6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
9001acf8:	990a      	ldr	r1, [sp, #40]	; 0x28
9001acfa:	605a      	str	r2, [r3, #4]
9001acfc:	9a20      	ldr	r2, [sp, #128]	; 0x80
9001acfe:	440a      	add	r2, r1
9001ad00:	9220      	str	r2, [sp, #128]	; 0x80
9001ad02:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
9001ad04:	3201      	adds	r2, #1
9001ad06:	2a07      	cmp	r2, #7
9001ad08:	921f      	str	r2, [sp, #124]	; 0x7c
9001ad0a:	dc25      	bgt.n	9001ad58 <_svfprintf_r+0x1168>
9001ad0c:	3308      	adds	r3, #8
9001ad0e:	9a03      	ldr	r2, [sp, #12]
9001ad10:	eeb5 8b40 	vcmp.f64	d8, #0.0
9001ad14:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001ad18:	f102 34ff 	add.w	r4, r2, #4294967295	; 0xffffffff
9001ad1c:	d025      	beq.n	9001ad6a <_svfprintf_r+0x117a>
9001ad1e:	991f      	ldr	r1, [sp, #124]	; 0x7c
9001ad20:	9a20      	ldr	r2, [sp, #128]	; 0x80
9001ad22:	f10a 0001 	add.w	r0, sl, #1
9001ad26:	e9c3 0400 	strd	r0, r4, [r3]
9001ad2a:	9803      	ldr	r0, [sp, #12]
9001ad2c:	3101      	adds	r1, #1
9001ad2e:	3a01      	subs	r2, #1
9001ad30:	4402      	add	r2, r0
9001ad32:	2907      	cmp	r1, #7
9001ad34:	e9cd 121f 	strd	r1, r2, [sp, #124]	; 0x7c
9001ad38:	dd45      	ble.n	9001adc6 <_svfprintf_r+0x11d6>
9001ad3a:	aa1e      	add	r2, sp, #120	; 0x78
9001ad3c:	4659      	mov	r1, fp
9001ad3e:	4648      	mov	r0, r9
9001ad40:	f001 fdd9 	bl	9001c8f6 <__ssprint_r>
9001ad44:	2800      	cmp	r0, #0
9001ad46:	d161      	bne.n	9001ae0c <_svfprintf_r+0x121c>
9001ad48:	ab21      	add	r3, sp, #132	; 0x84
9001ad4a:	aa1a      	add	r2, sp, #104	; 0x68
9001ad4c:	601a      	str	r2, [r3, #0]
9001ad4e:	9a11      	ldr	r2, [sp, #68]	; 0x44
9001ad50:	605a      	str	r2, [r3, #4]
9001ad52:	9911      	ldr	r1, [sp, #68]	; 0x44
9001ad54:	9a20      	ldr	r2, [sp, #128]	; 0x80
9001ad56:	e628      	b.n	9001a9aa <_svfprintf_r+0xdba>
9001ad58:	aa1e      	add	r2, sp, #120	; 0x78
9001ad5a:	4659      	mov	r1, fp
9001ad5c:	4648      	mov	r0, r9
9001ad5e:	f001 fdca 	bl	9001c8f6 <__ssprint_r>
9001ad62:	2800      	cmp	r0, #0
9001ad64:	d152      	bne.n	9001ae0c <_svfprintf_r+0x121c>
9001ad66:	ab21      	add	r3, sp, #132	; 0x84
9001ad68:	e7d1      	b.n	9001ad0e <_svfprintf_r+0x111e>
9001ad6a:	2c00      	cmp	r4, #0
9001ad6c:	dded      	ble.n	9001ad4a <_svfprintf_r+0x115a>
9001ad6e:	4e55      	ldr	r6, [pc, #340]	; (9001aec4 <_svfprintf_r+0x12d4>)
9001ad70:	2710      	movs	r7, #16
9001ad72:	e9dd 211f 	ldrd	r2, r1, [sp, #124]	; 0x7c
9001ad76:	2c10      	cmp	r4, #16
9001ad78:	f102 0201 	add.w	r2, r2, #1
9001ad7c:	f103 0008 	add.w	r0, r3, #8
9001ad80:	601e      	str	r6, [r3, #0]
9001ad82:	dc07      	bgt.n	9001ad94 <_svfprintf_r+0x11a4>
9001ad84:	605c      	str	r4, [r3, #4]
9001ad86:	2a07      	cmp	r2, #7
9001ad88:	440c      	add	r4, r1
9001ad8a:	e9cd 241f 	strd	r2, r4, [sp, #124]	; 0x7c
9001ad8e:	dcd4      	bgt.n	9001ad3a <_svfprintf_r+0x114a>
9001ad90:	4603      	mov	r3, r0
9001ad92:	e7da      	b.n	9001ad4a <_svfprintf_r+0x115a>
9001ad94:	3110      	adds	r1, #16
9001ad96:	2a07      	cmp	r2, #7
9001ad98:	e9cd 211f 	strd	r2, r1, [sp, #124]	; 0x7c
9001ad9c:	605f      	str	r7, [r3, #4]
9001ad9e:	dd06      	ble.n	9001adae <_svfprintf_r+0x11be>
9001ada0:	aa1e      	add	r2, sp, #120	; 0x78
9001ada2:	4659      	mov	r1, fp
9001ada4:	4648      	mov	r0, r9
9001ada6:	f001 fda6 	bl	9001c8f6 <__ssprint_r>
9001adaa:	bb78      	cbnz	r0, 9001ae0c <_svfprintf_r+0x121c>
9001adac:	a821      	add	r0, sp, #132	; 0x84
9001adae:	3c10      	subs	r4, #16
9001adb0:	4603      	mov	r3, r0
9001adb2:	e7de      	b.n	9001ad72 <_svfprintf_r+0x1182>
9001adb4:	2101      	movs	r1, #1
9001adb6:	2a07      	cmp	r2, #7
9001adb8:	e9cd 201f 	strd	r2, r0, [sp, #124]	; 0x7c
9001adbc:	f8c4 a000 	str.w	sl, [r4]
9001adc0:	6061      	str	r1, [r4, #4]
9001adc2:	ddc2      	ble.n	9001ad4a <_svfprintf_r+0x115a>
9001adc4:	e7b9      	b.n	9001ad3a <_svfprintf_r+0x114a>
9001adc6:	3308      	adds	r3, #8
9001adc8:	e7bf      	b.n	9001ad4a <_svfprintf_r+0x115a>
9001adca:	460c      	mov	r4, r1
9001adcc:	f7ff baa0 	b.w	9001a310 <_svfprintf_r+0x720>
9001add0:	e9dd 320c 	ldrd	r3, r2, [sp, #48]	; 0x30
9001add4:	1a9d      	subs	r5, r3, r2
9001add6:	2d00      	cmp	r5, #0
9001add8:	f77f aa9d 	ble.w	9001a316 <_svfprintf_r+0x726>
9001addc:	4e3a      	ldr	r6, [pc, #232]	; (9001aec8 <_svfprintf_r+0x12d8>)
9001adde:	2710      	movs	r7, #16
9001ade0:	e9dd 321f 	ldrd	r3, r2, [sp, #124]	; 0x7c
9001ade4:	2d10      	cmp	r5, #16
9001ade6:	f103 0301 	add.w	r3, r3, #1
9001adea:	6026      	str	r6, [r4, #0]
9001adec:	dc18      	bgt.n	9001ae20 <_svfprintf_r+0x1230>
9001adee:	6065      	str	r5, [r4, #4]
9001adf0:	2b07      	cmp	r3, #7
9001adf2:	4415      	add	r5, r2
9001adf4:	e9cd 351f 	strd	r3, r5, [sp, #124]	; 0x7c
9001adf8:	f77f aa8d 	ble.w	9001a316 <_svfprintf_r+0x726>
9001adfc:	aa1e      	add	r2, sp, #120	; 0x78
9001adfe:	4659      	mov	r1, fp
9001ae00:	4648      	mov	r0, r9
9001ae02:	f001 fd78 	bl	9001c8f6 <__ssprint_r>
9001ae06:	2800      	cmp	r0, #0
9001ae08:	f43f aa85 	beq.w	9001a316 <_svfprintf_r+0x726>
9001ae0c:	9b02      	ldr	r3, [sp, #8]
9001ae0e:	2b00      	cmp	r3, #0
9001ae10:	f43f a8df 	beq.w	90019fd2 <_svfprintf_r+0x3e2>
9001ae14:	4619      	mov	r1, r3
9001ae16:	4648      	mov	r0, r9
9001ae18:	f000 fec6 	bl	9001bba8 <_free_r>
9001ae1c:	f7ff b8d9 	b.w	90019fd2 <_svfprintf_r+0x3e2>
9001ae20:	3210      	adds	r2, #16
9001ae22:	2b07      	cmp	r3, #7
9001ae24:	e9cd 321f 	strd	r3, r2, [sp, #124]	; 0x7c
9001ae28:	6067      	str	r7, [r4, #4]
9001ae2a:	dc02      	bgt.n	9001ae32 <_svfprintf_r+0x1242>
9001ae2c:	3408      	adds	r4, #8
9001ae2e:	3d10      	subs	r5, #16
9001ae30:	e7d6      	b.n	9001ade0 <_svfprintf_r+0x11f0>
9001ae32:	aa1e      	add	r2, sp, #120	; 0x78
9001ae34:	4659      	mov	r1, fp
9001ae36:	4648      	mov	r0, r9
9001ae38:	f001 fd5d 	bl	9001c8f6 <__ssprint_r>
9001ae3c:	2800      	cmp	r0, #0
9001ae3e:	d1e5      	bne.n	9001ae0c <_svfprintf_r+0x121c>
9001ae40:	ac21      	add	r4, sp, #132	; 0x84
9001ae42:	e7f4      	b.n	9001ae2e <_svfprintf_r+0x123e>
9001ae44:	9902      	ldr	r1, [sp, #8]
9001ae46:	4648      	mov	r0, r9
9001ae48:	f000 feae 	bl	9001bba8 <_free_r>
9001ae4c:	f7ff ba84 	b.w	9001a358 <_svfprintf_r+0x768>
9001ae50:	9b20      	ldr	r3, [sp, #128]	; 0x80
9001ae52:	2b00      	cmp	r3, #0
9001ae54:	f43f a8bd 	beq.w	90019fd2 <_svfprintf_r+0x3e2>
9001ae58:	aa1e      	add	r2, sp, #120	; 0x78
9001ae5a:	4659      	mov	r1, fp
9001ae5c:	4648      	mov	r0, r9
9001ae5e:	f001 fd4a 	bl	9001c8f6 <__ssprint_r>
9001ae62:	f7ff b8b6 	b.w	90019fd2 <_svfprintf_r+0x3e2>
9001ae66:	ea56 0207 	orrs.w	r2, r6, r7
9001ae6a:	9502      	str	r5, [sp, #8]
9001ae6c:	f43f ab83 	beq.w	9001a576 <_svfprintf_r+0x986>
9001ae70:	2b01      	cmp	r3, #1
9001ae72:	f43f ac0e 	beq.w	9001a692 <_svfprintf_r+0xaa2>
9001ae76:	2b02      	cmp	r3, #2
9001ae78:	f50d 7a94 	add.w	sl, sp, #296	; 0x128
9001ae7c:	f43f ac55 	beq.w	9001a72a <_svfprintf_r+0xb3a>
9001ae80:	08f2      	lsrs	r2, r6, #3
9001ae82:	ea42 7247 	orr.w	r2, r2, r7, lsl #29
9001ae86:	08f8      	lsrs	r0, r7, #3
9001ae88:	f006 0307 	and.w	r3, r6, #7
9001ae8c:	4607      	mov	r7, r0
9001ae8e:	4616      	mov	r6, r2
9001ae90:	3330      	adds	r3, #48	; 0x30
9001ae92:	ea56 0207 	orrs.w	r2, r6, r7
9001ae96:	4651      	mov	r1, sl
9001ae98:	f80a 3d01 	strb.w	r3, [sl, #-1]!
9001ae9c:	d1f0      	bne.n	9001ae80 <_svfprintf_r+0x1290>
9001ae9e:	9a02      	ldr	r2, [sp, #8]
9001aea0:	07d0      	lsls	r0, r2, #31
9001aea2:	d506      	bpl.n	9001aeb2 <_svfprintf_r+0x12c2>
9001aea4:	2b30      	cmp	r3, #48	; 0x30
9001aea6:	d004      	beq.n	9001aeb2 <_svfprintf_r+0x12c2>
9001aea8:	2330      	movs	r3, #48	; 0x30
9001aeaa:	f80a 3c01 	strb.w	r3, [sl, #-1]
9001aeae:	f1a1 0a02 	sub.w	sl, r1, #2
9001aeb2:	ab4a      	add	r3, sp, #296	; 0x128
9001aeb4:	4647      	mov	r7, r8
9001aeb6:	eba3 080a 	sub.w	r8, r3, sl
9001aeba:	2300      	movs	r3, #0
9001aebc:	9d02      	ldr	r5, [sp, #8]
9001aebe:	9302      	str	r3, [sp, #8]
9001aec0:	f7ff b84f 	b.w	90019f62 <_svfprintf_r+0x372>
9001aec4:	90025388 	.word	0x90025388
9001aec8:	90025378 	.word	0x90025378

9001aecc <register_fini>:
9001aecc:	4b02      	ldr	r3, [pc, #8]	; (9001aed8 <register_fini+0xc>)
9001aece:	b113      	cbz	r3, 9001aed6 <register_fini+0xa>
9001aed0:	4802      	ldr	r0, [pc, #8]	; (9001aedc <register_fini+0x10>)
9001aed2:	f000 b805 	b.w	9001aee0 <atexit>
9001aed6:	4770      	bx	lr
9001aed8:	00000000 	.word	0x00000000
9001aedc:	9001bad9 	.word	0x9001bad9

9001aee0 <atexit>:
9001aee0:	2300      	movs	r3, #0
9001aee2:	4601      	mov	r1, r0
9001aee4:	461a      	mov	r2, r3
9001aee6:	4618      	mov	r0, r3
9001aee8:	f001 bd8e 	b.w	9001ca08 <__register_exitproc>

9001aeec <quorem>:
9001aeec:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001aef0:	6903      	ldr	r3, [r0, #16]
9001aef2:	690c      	ldr	r4, [r1, #16]
9001aef4:	42a3      	cmp	r3, r4
9001aef6:	4607      	mov	r7, r0
9001aef8:	f2c0 8081 	blt.w	9001affe <quorem+0x112>
9001aefc:	3c01      	subs	r4, #1
9001aefe:	f101 0814 	add.w	r8, r1, #20
9001af02:	f100 0514 	add.w	r5, r0, #20
9001af06:	eb05 0384 	add.w	r3, r5, r4, lsl #2
9001af0a:	9301      	str	r3, [sp, #4]
9001af0c:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
9001af10:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
9001af14:	3301      	adds	r3, #1
9001af16:	429a      	cmp	r2, r3
9001af18:	ea4f 0b84 	mov.w	fp, r4, lsl #2
9001af1c:	eb08 0984 	add.w	r9, r8, r4, lsl #2
9001af20:	fbb2 f6f3 	udiv	r6, r2, r3
9001af24:	d331      	bcc.n	9001af8a <quorem+0x9e>
9001af26:	f04f 0e00 	mov.w	lr, #0
9001af2a:	4640      	mov	r0, r8
9001af2c:	46ac      	mov	ip, r5
9001af2e:	46f2      	mov	sl, lr
9001af30:	f850 2b04 	ldr.w	r2, [r0], #4
9001af34:	b293      	uxth	r3, r2
9001af36:	fb06 e303 	mla	r3, r6, r3, lr
9001af3a:	ea4f 4e13 	mov.w	lr, r3, lsr #16
9001af3e:	b29b      	uxth	r3, r3
9001af40:	ebaa 0303 	sub.w	r3, sl, r3
9001af44:	0c12      	lsrs	r2, r2, #16
9001af46:	f8dc a000 	ldr.w	sl, [ip]
9001af4a:	fb06 e202 	mla	r2, r6, r2, lr
9001af4e:	fa13 f38a 	uxtah	r3, r3, sl
9001af52:	ea4f 4e12 	mov.w	lr, r2, lsr #16
9001af56:	fa1f fa82 	uxth.w	sl, r2
9001af5a:	f8dc 2000 	ldr.w	r2, [ip]
9001af5e:	ebca 4212 	rsb	r2, sl, r2, lsr #16
9001af62:	eb02 4223 	add.w	r2, r2, r3, asr #16
9001af66:	b29b      	uxth	r3, r3
9001af68:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
9001af6c:	4581      	cmp	r9, r0
9001af6e:	f84c 3b04 	str.w	r3, [ip], #4
9001af72:	ea4f 4a22 	mov.w	sl, r2, asr #16
9001af76:	d2db      	bcs.n	9001af30 <quorem+0x44>
9001af78:	f855 300b 	ldr.w	r3, [r5, fp]
9001af7c:	b92b      	cbnz	r3, 9001af8a <quorem+0x9e>
9001af7e:	9b01      	ldr	r3, [sp, #4]
9001af80:	3b04      	subs	r3, #4
9001af82:	429d      	cmp	r5, r3
9001af84:	461a      	mov	r2, r3
9001af86:	d32e      	bcc.n	9001afe6 <quorem+0xfa>
9001af88:	613c      	str	r4, [r7, #16]
9001af8a:	4638      	mov	r0, r7
9001af8c:	f001 fb52 	bl	9001c634 <__mcmp>
9001af90:	2800      	cmp	r0, #0
9001af92:	db24      	blt.n	9001afde <quorem+0xf2>
9001af94:	3601      	adds	r6, #1
9001af96:	4628      	mov	r0, r5
9001af98:	f04f 0c00 	mov.w	ip, #0
9001af9c:	f858 2b04 	ldr.w	r2, [r8], #4
9001afa0:	f8d0 e000 	ldr.w	lr, [r0]
9001afa4:	b293      	uxth	r3, r2
9001afa6:	ebac 0303 	sub.w	r3, ip, r3
9001afaa:	0c12      	lsrs	r2, r2, #16
9001afac:	fa13 f38e 	uxtah	r3, r3, lr
9001afb0:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
9001afb4:	eb02 4223 	add.w	r2, r2, r3, asr #16
9001afb8:	b29b      	uxth	r3, r3
9001afba:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
9001afbe:	45c1      	cmp	r9, r8
9001afc0:	f840 3b04 	str.w	r3, [r0], #4
9001afc4:	ea4f 4c22 	mov.w	ip, r2, asr #16
9001afc8:	d2e8      	bcs.n	9001af9c <quorem+0xb0>
9001afca:	f855 2024 	ldr.w	r2, [r5, r4, lsl #2]
9001afce:	eb05 0384 	add.w	r3, r5, r4, lsl #2
9001afd2:	b922      	cbnz	r2, 9001afde <quorem+0xf2>
9001afd4:	3b04      	subs	r3, #4
9001afd6:	429d      	cmp	r5, r3
9001afd8:	461a      	mov	r2, r3
9001afda:	d30a      	bcc.n	9001aff2 <quorem+0x106>
9001afdc:	613c      	str	r4, [r7, #16]
9001afde:	4630      	mov	r0, r6
9001afe0:	b003      	add	sp, #12
9001afe2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
9001afe6:	6812      	ldr	r2, [r2, #0]
9001afe8:	3b04      	subs	r3, #4
9001afea:	2a00      	cmp	r2, #0
9001afec:	d1cc      	bne.n	9001af88 <quorem+0x9c>
9001afee:	3c01      	subs	r4, #1
9001aff0:	e7c7      	b.n	9001af82 <quorem+0x96>
9001aff2:	6812      	ldr	r2, [r2, #0]
9001aff4:	3b04      	subs	r3, #4
9001aff6:	2a00      	cmp	r2, #0
9001aff8:	d1f0      	bne.n	9001afdc <quorem+0xf0>
9001affa:	3c01      	subs	r4, #1
9001affc:	e7eb      	b.n	9001afd6 <quorem+0xea>
9001affe:	2000      	movs	r0, #0
9001b000:	e7ee      	b.n	9001afe0 <quorem+0xf4>
9001b002:	0000      	movs	r0, r0
9001b004:	0000      	movs	r0, r0
	...

9001b008 <_dtoa_r>:
9001b008:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001b00c:	b095      	sub	sp, #84	; 0x54
9001b00e:	ec59 8b10 	vmov	r8, r9, d0
9001b012:	9107      	str	r1, [sp, #28]
9001b014:	6c01      	ldr	r1, [r0, #64]	; 0x40
9001b016:	9c1e      	ldr	r4, [sp, #120]	; 0x78
9001b018:	9209      	str	r2, [sp, #36]	; 0x24
9001b01a:	e9cd 8902 	strd	r8, r9, [sp, #8]
9001b01e:	4606      	mov	r6, r0
9001b020:	9310      	str	r3, [sp, #64]	; 0x40
9001b022:	b141      	cbz	r1, 9001b036 <_dtoa_r+0x2e>
9001b024:	6c42      	ldr	r2, [r0, #68]	; 0x44
9001b026:	604a      	str	r2, [r1, #4]
9001b028:	2301      	movs	r3, #1
9001b02a:	4093      	lsls	r3, r2
9001b02c:	608b      	str	r3, [r1, #8]
9001b02e:	f001 f8f6 	bl	9001c21e <_Bfree>
9001b032:	2300      	movs	r3, #0
9001b034:	6433      	str	r3, [r6, #64]	; 0x40
9001b036:	f1b9 0300 	subs.w	r3, r9, #0
9001b03a:	bfbb      	ittet	lt
9001b03c:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
9001b040:	9303      	strlt	r3, [sp, #12]
9001b042:	2300      	movge	r3, #0
9001b044:	2201      	movlt	r2, #1
9001b046:	bfac      	ite	ge
9001b048:	6023      	strge	r3, [r4, #0]
9001b04a:	6022      	strlt	r2, [r4, #0]
9001b04c:	4b9a      	ldr	r3, [pc, #616]	; (9001b2b8 <_dtoa_r+0x2b0>)
9001b04e:	9c03      	ldr	r4, [sp, #12]
9001b050:	43a3      	bics	r3, r4
9001b052:	d11a      	bne.n	9001b08a <_dtoa_r+0x82>
9001b054:	9a10      	ldr	r2, [sp, #64]	; 0x40
9001b056:	f242 730f 	movw	r3, #9999	; 0x270f
9001b05a:	6013      	str	r3, [r2, #0]
9001b05c:	f3c4 0313 	ubfx	r3, r4, #0, #20
9001b060:	ea53 0308 	orrs.w	r3, r3, r8
9001b064:	f000 850d 	beq.w	9001ba82 <_dtoa_r+0xa7a>
9001b068:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001b06a:	b90b      	cbnz	r3, 9001b070 <_dtoa_r+0x68>
9001b06c:	4b93      	ldr	r3, [pc, #588]	; (9001b2bc <_dtoa_r+0x2b4>)
9001b06e:	e01f      	b.n	9001b0b0 <_dtoa_r+0xa8>
9001b070:	4b92      	ldr	r3, [pc, #584]	; (9001b2bc <_dtoa_r+0x2b4>)
9001b072:	9300      	str	r3, [sp, #0]
9001b074:	3303      	adds	r3, #3
9001b076:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
9001b078:	6013      	str	r3, [r2, #0]
9001b07a:	9800      	ldr	r0, [sp, #0]
9001b07c:	b015      	add	sp, #84	; 0x54
9001b07e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
9001b082:	4b8f      	ldr	r3, [pc, #572]	; (9001b2c0 <_dtoa_r+0x2b8>)
9001b084:	9300      	str	r3, [sp, #0]
9001b086:	3308      	adds	r3, #8
9001b088:	e7f5      	b.n	9001b076 <_dtoa_r+0x6e>
9001b08a:	ed9d 7b02 	vldr	d7, [sp, #8]
9001b08e:	eeb5 7b40 	vcmp.f64	d7, #0.0
9001b092:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b096:	ed8d 7b0a 	vstr	d7, [sp, #40]	; 0x28
9001b09a:	d10b      	bne.n	9001b0b4 <_dtoa_r+0xac>
9001b09c:	9a10      	ldr	r2, [sp, #64]	; 0x40
9001b09e:	2301      	movs	r3, #1
9001b0a0:	6013      	str	r3, [r2, #0]
9001b0a2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001b0a4:	2b00      	cmp	r3, #0
9001b0a6:	f000 84e9 	beq.w	9001ba7c <_dtoa_r+0xa74>
9001b0aa:	4886      	ldr	r0, [pc, #536]	; (9001b2c4 <_dtoa_r+0x2bc>)
9001b0ac:	6018      	str	r0, [r3, #0]
9001b0ae:	1e43      	subs	r3, r0, #1
9001b0b0:	9300      	str	r3, [sp, #0]
9001b0b2:	e7e2      	b.n	9001b07a <_dtoa_r+0x72>
9001b0b4:	a913      	add	r1, sp, #76	; 0x4c
9001b0b6:	ed9d 0b0a 	vldr	d0, [sp, #40]	; 0x28
9001b0ba:	aa12      	add	r2, sp, #72	; 0x48
9001b0bc:	4630      	mov	r0, r6
9001b0be:	f001 fb5d 	bl	9001c77c <__d2b>
9001b0c2:	f3c4 510a 	ubfx	r1, r4, #20, #11
9001b0c6:	4605      	mov	r5, r0
9001b0c8:	9812      	ldr	r0, [sp, #72]	; 0x48
9001b0ca:	2900      	cmp	r1, #0
9001b0cc:	d047      	beq.n	9001b15e <_dtoa_r+0x156>
9001b0ce:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
9001b0d0:	f3c4 0413 	ubfx	r4, r4, #0, #20
9001b0d4:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
9001b0d8:	f044 537f 	orr.w	r3, r4, #1069547520	; 0x3fc00000
9001b0dc:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
9001b0e0:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
9001b0e4:	2400      	movs	r4, #0
9001b0e6:	ec43 2b16 	vmov	d6, r2, r3
9001b0ea:	eeb7 7b08 	vmov.f64	d7, #120	; 0x3fc00000  1.5
9001b0ee:	ed9f 5b6c 	vldr	d5, [pc, #432]	; 9001b2a0 <_dtoa_r+0x298>
9001b0f2:	ee36 7b47 	vsub.f64	d7, d6, d7
9001b0f6:	ed9f 6b6c 	vldr	d6, [pc, #432]	; 9001b2a8 <_dtoa_r+0x2a0>
9001b0fa:	eea7 6b05 	vfma.f64	d6, d7, d5
9001b0fe:	eeb0 7b46 	vmov.f64	d7, d6
9001b102:	ee06 1a90 	vmov	s13, r1
9001b106:	eeb8 5be6 	vcvt.f64.s32	d5, s13
9001b10a:	ed9f 6b69 	vldr	d6, [pc, #420]	; 9001b2b0 <_dtoa_r+0x2a8>
9001b10e:	eea5 7b06 	vfma.f64	d7, d5, d6
9001b112:	eefd 6bc7 	vcvt.s32.f64	s13, d7
9001b116:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
9001b11a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b11e:	ee16 ba90 	vmov	fp, s13
9001b122:	9411      	str	r4, [sp, #68]	; 0x44
9001b124:	d508      	bpl.n	9001b138 <_dtoa_r+0x130>
9001b126:	eeb8 6be6 	vcvt.f64.s32	d6, s13
9001b12a:	eeb4 6b47 	vcmp.f64	d6, d7
9001b12e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b132:	bf18      	it	ne
9001b134:	f10b 3bff 	addne.w	fp, fp, #4294967295	; 0xffffffff
9001b138:	f1bb 0f16 	cmp.w	fp, #22
9001b13c:	d832      	bhi.n	9001b1a4 <_dtoa_r+0x19c>
9001b13e:	4b62      	ldr	r3, [pc, #392]	; (9001b2c8 <_dtoa_r+0x2c0>)
9001b140:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
9001b144:	ed93 7b00 	vldr	d7, [r3]
9001b148:	ed9d 6b0a 	vldr	d6, [sp, #40]	; 0x28
9001b14c:	eeb4 6bc7 	vcmpe.f64	d6, d7
9001b150:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b154:	d501      	bpl.n	9001b15a <_dtoa_r+0x152>
9001b156:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
9001b15a:	2300      	movs	r3, #0
9001b15c:	e023      	b.n	9001b1a6 <_dtoa_r+0x19e>
9001b15e:	9913      	ldr	r1, [sp, #76]	; 0x4c
9001b160:	4401      	add	r1, r0
9001b162:	f201 4332 	addw	r3, r1, #1074	; 0x432
9001b166:	2b20      	cmp	r3, #32
9001b168:	bfc3      	ittte	gt
9001b16a:	f1c3 0340 	rsbgt	r3, r3, #64	; 0x40
9001b16e:	fa04 f303 	lslgt.w	r3, r4, r3
9001b172:	f201 4412 	addwgt	r4, r1, #1042	; 0x412
9001b176:	f1c3 0320 	rsble	r3, r3, #32
9001b17a:	bfc6      	itte	gt
9001b17c:	fa28 f804 	lsrgt.w	r8, r8, r4
9001b180:	ea43 0308 	orrgt.w	r3, r3, r8
9001b184:	fa08 f303 	lslle.w	r3, r8, r3
9001b188:	ee07 3a90 	vmov	s15, r3
9001b18c:	eeb8 7b67 	vcvt.f64.u32	d7, s15
9001b190:	3901      	subs	r1, #1
9001b192:	ed8d 7b00 	vstr	d7, [sp]
9001b196:	9c01      	ldr	r4, [sp, #4]
9001b198:	e9dd 2300 	ldrd	r2, r3, [sp]
9001b19c:	f1a4 73f8 	sub.w	r3, r4, #32505856	; 0x1f00000
9001b1a0:	2401      	movs	r4, #1
9001b1a2:	e7a0      	b.n	9001b0e6 <_dtoa_r+0xde>
9001b1a4:	2301      	movs	r3, #1
9001b1a6:	930f      	str	r3, [sp, #60]	; 0x3c
9001b1a8:	1a43      	subs	r3, r0, r1
9001b1aa:	1e5a      	subs	r2, r3, #1
9001b1ac:	bf45      	ittet	mi
9001b1ae:	f1c3 0301 	rsbmi	r3, r3, #1
9001b1b2:	9305      	strmi	r3, [sp, #20]
9001b1b4:	2300      	movpl	r3, #0
9001b1b6:	2300      	movmi	r3, #0
9001b1b8:	9206      	str	r2, [sp, #24]
9001b1ba:	bf54      	ite	pl
9001b1bc:	9305      	strpl	r3, [sp, #20]
9001b1be:	9306      	strmi	r3, [sp, #24]
9001b1c0:	f1bb 0f00 	cmp.w	fp, #0
9001b1c4:	db18      	blt.n	9001b1f8 <_dtoa_r+0x1f0>
9001b1c6:	9b06      	ldr	r3, [sp, #24]
9001b1c8:	f8cd b038 	str.w	fp, [sp, #56]	; 0x38
9001b1cc:	445b      	add	r3, fp
9001b1ce:	9306      	str	r3, [sp, #24]
9001b1d0:	2300      	movs	r3, #0
9001b1d2:	9a07      	ldr	r2, [sp, #28]
9001b1d4:	2a09      	cmp	r2, #9
9001b1d6:	d84a      	bhi.n	9001b26e <_dtoa_r+0x266>
9001b1d8:	2a05      	cmp	r2, #5
9001b1da:	bfc4      	itt	gt
9001b1dc:	3a04      	subgt	r2, #4
9001b1de:	9207      	strgt	r2, [sp, #28]
9001b1e0:	9a07      	ldr	r2, [sp, #28]
9001b1e2:	f1a2 0202 	sub.w	r2, r2, #2
9001b1e6:	bfcc      	ite	gt
9001b1e8:	2400      	movgt	r4, #0
9001b1ea:	2401      	movle	r4, #1
9001b1ec:	2a03      	cmp	r2, #3
9001b1ee:	d849      	bhi.n	9001b284 <_dtoa_r+0x27c>
9001b1f0:	e8df f002 	tbb	[pc, r2]
9001b1f4:	3b2d2f0b 	.word	0x3b2d2f0b
9001b1f8:	9b05      	ldr	r3, [sp, #20]
9001b1fa:	2200      	movs	r2, #0
9001b1fc:	eba3 030b 	sub.w	r3, r3, fp
9001b200:	9305      	str	r3, [sp, #20]
9001b202:	920e      	str	r2, [sp, #56]	; 0x38
9001b204:	f1cb 0300 	rsb	r3, fp, #0
9001b208:	e7e3      	b.n	9001b1d2 <_dtoa_r+0x1ca>
9001b20a:	2200      	movs	r2, #0
9001b20c:	9208      	str	r2, [sp, #32]
9001b20e:	9a09      	ldr	r2, [sp, #36]	; 0x24
9001b210:	2a00      	cmp	r2, #0
9001b212:	dc3a      	bgt.n	9001b28a <_dtoa_r+0x282>
9001b214:	f04f 0a01 	mov.w	sl, #1
9001b218:	46d1      	mov	r9, sl
9001b21a:	4652      	mov	r2, sl
9001b21c:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
9001b220:	2100      	movs	r1, #0
9001b222:	6471      	str	r1, [r6, #68]	; 0x44
9001b224:	2004      	movs	r0, #4
9001b226:	f100 0714 	add.w	r7, r0, #20
9001b22a:	4297      	cmp	r7, r2
9001b22c:	6c71      	ldr	r1, [r6, #68]	; 0x44
9001b22e:	d931      	bls.n	9001b294 <_dtoa_r+0x28c>
9001b230:	4630      	mov	r0, r6
9001b232:	930c      	str	r3, [sp, #48]	; 0x30
9001b234:	f000 ffce 	bl	9001c1d4 <_Balloc>
9001b238:	9b0c      	ldr	r3, [sp, #48]	; 0x30
9001b23a:	9000      	str	r0, [sp, #0]
9001b23c:	4602      	mov	r2, r0
9001b23e:	2800      	cmp	r0, #0
9001b240:	d148      	bne.n	9001b2d4 <_dtoa_r+0x2cc>
9001b242:	4b22      	ldr	r3, [pc, #136]	; (9001b2cc <_dtoa_r+0x2c4>)
9001b244:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
9001b248:	4821      	ldr	r0, [pc, #132]	; (9001b2d0 <_dtoa_r+0x2c8>)
9001b24a:	f001 fc1d 	bl	9001ca88 <__assert_func>
9001b24e:	2201      	movs	r2, #1
9001b250:	e7dc      	b.n	9001b20c <_dtoa_r+0x204>
9001b252:	2200      	movs	r2, #0
9001b254:	9208      	str	r2, [sp, #32]
9001b256:	9a09      	ldr	r2, [sp, #36]	; 0x24
9001b258:	eb0b 0a02 	add.w	sl, fp, r2
9001b25c:	f10a 0901 	add.w	r9, sl, #1
9001b260:	464a      	mov	r2, r9
9001b262:	2a01      	cmp	r2, #1
9001b264:	bfb8      	it	lt
9001b266:	2201      	movlt	r2, #1
9001b268:	e7da      	b.n	9001b220 <_dtoa_r+0x218>
9001b26a:	2201      	movs	r2, #1
9001b26c:	e7f2      	b.n	9001b254 <_dtoa_r+0x24c>
9001b26e:	2401      	movs	r4, #1
9001b270:	2200      	movs	r2, #0
9001b272:	e9cd 2407 	strd	r2, r4, [sp, #28]
9001b276:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
9001b27a:	2100      	movs	r1, #0
9001b27c:	46d1      	mov	r9, sl
9001b27e:	2212      	movs	r2, #18
9001b280:	9109      	str	r1, [sp, #36]	; 0x24
9001b282:	e7cd      	b.n	9001b220 <_dtoa_r+0x218>
9001b284:	2201      	movs	r2, #1
9001b286:	9208      	str	r2, [sp, #32]
9001b288:	e7f5      	b.n	9001b276 <_dtoa_r+0x26e>
9001b28a:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
9001b28e:	46d1      	mov	r9, sl
9001b290:	4652      	mov	r2, sl
9001b292:	e7c5      	b.n	9001b220 <_dtoa_r+0x218>
9001b294:	3101      	adds	r1, #1
9001b296:	6471      	str	r1, [r6, #68]	; 0x44
9001b298:	0040      	lsls	r0, r0, #1
9001b29a:	e7c4      	b.n	9001b226 <_dtoa_r+0x21e>
9001b29c:	f3af 8000 	nop.w
9001b2a0:	636f4361 	.word	0x636f4361
9001b2a4:	3fd287a7 	.word	0x3fd287a7
9001b2a8:	8b60c8b3 	.word	0x8b60c8b3
9001b2ac:	3fc68a28 	.word	0x3fc68a28
9001b2b0:	509f79fb 	.word	0x509f79fb
9001b2b4:	3fd34413 	.word	0x3fd34413
9001b2b8:	7ff00000 	.word	0x7ff00000
9001b2bc:	90025398 	.word	0x90025398
9001b2c0:	9002539c 	.word	0x9002539c
9001b2c4:	90025377 	.word	0x90025377
9001b2c8:	900254a0 	.word	0x900254a0
9001b2cc:	900253a5 	.word	0x900253a5
9001b2d0:	900253b6 	.word	0x900253b6
9001b2d4:	9a00      	ldr	r2, [sp, #0]
9001b2d6:	6432      	str	r2, [r6, #64]	; 0x40
9001b2d8:	f1b9 0f0e 	cmp.w	r9, #14
9001b2dc:	d872      	bhi.n	9001b3c4 <_dtoa_r+0x3bc>
9001b2de:	2c00      	cmp	r4, #0
9001b2e0:	d070      	beq.n	9001b3c4 <_dtoa_r+0x3bc>
9001b2e2:	f1bb 0f00 	cmp.w	fp, #0
9001b2e6:	f340 80a6 	ble.w	9001b436 <_dtoa_r+0x42e>
9001b2ea:	49ca      	ldr	r1, [pc, #808]	; (9001b614 <_dtoa_r+0x60c>)
9001b2ec:	f00b 020f 	and.w	r2, fp, #15
9001b2f0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
9001b2f4:	f41b 7f80 	tst.w	fp, #256	; 0x100
9001b2f8:	ed92 7b00 	vldr	d7, [r2]
9001b2fc:	ea4f 112b 	mov.w	r1, fp, asr #4
9001b300:	f000 808d 	beq.w	9001b41e <_dtoa_r+0x416>
9001b304:	4ac4      	ldr	r2, [pc, #784]	; (9001b618 <_dtoa_r+0x610>)
9001b306:	ed9d 5b0a 	vldr	d5, [sp, #40]	; 0x28
9001b30a:	ed92 6b08 	vldr	d6, [r2, #32]
9001b30e:	ee85 6b06 	vdiv.f64	d6, d5, d6
9001b312:	ed8d 6b02 	vstr	d6, [sp, #8]
9001b316:	f001 010f 	and.w	r1, r1, #15
9001b31a:	2203      	movs	r2, #3
9001b31c:	48be      	ldr	r0, [pc, #760]	; (9001b618 <_dtoa_r+0x610>)
9001b31e:	2900      	cmp	r1, #0
9001b320:	d17f      	bne.n	9001b422 <_dtoa_r+0x41a>
9001b322:	ed9d 6b02 	vldr	d6, [sp, #8]
9001b326:	ee86 7b07 	vdiv.f64	d7, d6, d7
9001b32a:	ed8d 7b02 	vstr	d7, [sp, #8]
9001b32e:	990f      	ldr	r1, [sp, #60]	; 0x3c
9001b330:	2900      	cmp	r1, #0
9001b332:	f000 80b2 	beq.w	9001b49a <_dtoa_r+0x492>
9001b336:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
9001b33a:	ed9d 7b02 	vldr	d7, [sp, #8]
9001b33e:	eeb4 7bc6 	vcmpe.f64	d7, d6
9001b342:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b346:	f140 80a8 	bpl.w	9001b49a <_dtoa_r+0x492>
9001b34a:	f1b9 0f00 	cmp.w	r9, #0
9001b34e:	f000 80a4 	beq.w	9001b49a <_dtoa_r+0x492>
9001b352:	f1ba 0f00 	cmp.w	sl, #0
9001b356:	dd31      	ble.n	9001b3bc <_dtoa_r+0x3b4>
9001b358:	eeb2 6b04 	vmov.f64	d6, #36	; 0x41200000  10.0
9001b35c:	ee27 7b06 	vmul.f64	d7, d7, d6
9001b360:	ed8d 7b02 	vstr	d7, [sp, #8]
9001b364:	f10b 37ff 	add.w	r7, fp, #4294967295	; 0xffffffff
9001b368:	3201      	adds	r2, #1
9001b36a:	4650      	mov	r0, sl
9001b36c:	ed9d 6b02 	vldr	d6, [sp, #8]
9001b370:	eeb1 5b0c 	vmov.f64	d5, #28	; 0x40e00000  7.0
9001b374:	ee07 2a90 	vmov	s15, r2
9001b378:	eeb8 7be7 	vcvt.f64.s32	d7, s15
9001b37c:	eea7 5b06 	vfma.f64	d5, d7, d6
9001b380:	ed8d 5b02 	vstr	d5, [sp, #8]
9001b384:	9c03      	ldr	r4, [sp, #12]
9001b386:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
9001b38a:	f1a4 7250 	sub.w	r2, r4, #54525952	; 0x3400000
9001b38e:	2800      	cmp	r0, #0
9001b390:	f040 8086 	bne.w	9001b4a0 <_dtoa_r+0x498>
9001b394:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
9001b398:	ee36 6b47 	vsub.f64	d6, d6, d7
9001b39c:	ec42 1b17 	vmov	d7, r1, r2
9001b3a0:	eeb4 6bc7 	vcmpe.f64	d6, d7
9001b3a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b3a8:	f300 8271 	bgt.w	9001b88e <_dtoa_r+0x886>
9001b3ac:	eeb1 7b47 	vneg.f64	d7, d7
9001b3b0:	eeb4 6bc7 	vcmpe.f64	d6, d7
9001b3b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b3b8:	f100 8266 	bmi.w	9001b888 <_dtoa_r+0x880>
9001b3bc:	e9dd 120a 	ldrd	r1, r2, [sp, #40]	; 0x28
9001b3c0:	e9cd 1202 	strd	r1, r2, [sp, #8]
9001b3c4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
9001b3c6:	2a00      	cmp	r2, #0
9001b3c8:	f2c0 8128 	blt.w	9001b61c <_dtoa_r+0x614>
9001b3cc:	f1bb 0f0e 	cmp.w	fp, #14
9001b3d0:	f300 8124 	bgt.w	9001b61c <_dtoa_r+0x614>
9001b3d4:	4b8f      	ldr	r3, [pc, #572]	; (9001b614 <_dtoa_r+0x60c>)
9001b3d6:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
9001b3da:	ed93 6b00 	vldr	d6, [r3]
9001b3de:	9b09      	ldr	r3, [sp, #36]	; 0x24
9001b3e0:	2b00      	cmp	r3, #0
9001b3e2:	f280 80c3 	bge.w	9001b56c <_dtoa_r+0x564>
9001b3e6:	f1b9 0f00 	cmp.w	r9, #0
9001b3ea:	f300 80bf 	bgt.w	9001b56c <_dtoa_r+0x564>
9001b3ee:	f040 824b 	bne.w	9001b888 <_dtoa_r+0x880>
9001b3f2:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
9001b3f6:	ee26 6b07 	vmul.f64	d6, d6, d7
9001b3fa:	ed9d 7b02 	vldr	d7, [sp, #8]
9001b3fe:	eeb4 6bc7 	vcmpe.f64	d6, d7
9001b402:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b406:	464c      	mov	r4, r9
9001b408:	464f      	mov	r7, r9
9001b40a:	f280 8221 	bge.w	9001b850 <_dtoa_r+0x848>
9001b40e:	f8dd 8000 	ldr.w	r8, [sp]
9001b412:	2331      	movs	r3, #49	; 0x31
9001b414:	f808 3b01 	strb.w	r3, [r8], #1
9001b418:	f10b 0b01 	add.w	fp, fp, #1
9001b41c:	e21d      	b.n	9001b85a <_dtoa_r+0x852>
9001b41e:	2202      	movs	r2, #2
9001b420:	e77c      	b.n	9001b31c <_dtoa_r+0x314>
9001b422:	07cc      	lsls	r4, r1, #31
9001b424:	d504      	bpl.n	9001b430 <_dtoa_r+0x428>
9001b426:	ed90 6b00 	vldr	d6, [r0]
9001b42a:	3201      	adds	r2, #1
9001b42c:	ee27 7b06 	vmul.f64	d7, d7, d6
9001b430:	1049      	asrs	r1, r1, #1
9001b432:	3008      	adds	r0, #8
9001b434:	e773      	b.n	9001b31e <_dtoa_r+0x316>
9001b436:	d02e      	beq.n	9001b496 <_dtoa_r+0x48e>
9001b438:	f1cb 0100 	rsb	r1, fp, #0
9001b43c:	4a75      	ldr	r2, [pc, #468]	; (9001b614 <_dtoa_r+0x60c>)
9001b43e:	f001 000f 	and.w	r0, r1, #15
9001b442:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
9001b446:	ed92 7b00 	vldr	d7, [r2]
9001b44a:	ed9d 6b0a 	vldr	d6, [sp, #40]	; 0x28
9001b44e:	ee26 7b07 	vmul.f64	d7, d6, d7
9001b452:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
9001b456:	e9dd 780c 	ldrd	r7, r8, [sp, #48]	; 0x30
9001b45a:	e9cd 7802 	strd	r7, r8, [sp, #8]
9001b45e:	486e      	ldr	r0, [pc, #440]	; (9001b618 <_dtoa_r+0x610>)
9001b460:	1109      	asrs	r1, r1, #4
9001b462:	2400      	movs	r4, #0
9001b464:	2202      	movs	r2, #2
9001b466:	b939      	cbnz	r1, 9001b478 <_dtoa_r+0x470>
9001b468:	2c00      	cmp	r4, #0
9001b46a:	f43f af60 	beq.w	9001b32e <_dtoa_r+0x326>
9001b46e:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
9001b472:	e9cd 0102 	strd	r0, r1, [sp, #8]
9001b476:	e75a      	b.n	9001b32e <_dtoa_r+0x326>
9001b478:	07cf      	lsls	r7, r1, #31
9001b47a:	d509      	bpl.n	9001b490 <_dtoa_r+0x488>
9001b47c:	ed9d 6b0c 	vldr	d6, [sp, #48]	; 0x30
9001b480:	ed90 7b00 	vldr	d7, [r0]
9001b484:	ee26 7b07 	vmul.f64	d7, d6, d7
9001b488:	ed8d 7b0c 	vstr	d7, [sp, #48]	; 0x30
9001b48c:	3201      	adds	r2, #1
9001b48e:	2401      	movs	r4, #1
9001b490:	1049      	asrs	r1, r1, #1
9001b492:	3008      	adds	r0, #8
9001b494:	e7e7      	b.n	9001b466 <_dtoa_r+0x45e>
9001b496:	2202      	movs	r2, #2
9001b498:	e749      	b.n	9001b32e <_dtoa_r+0x326>
9001b49a:	465f      	mov	r7, fp
9001b49c:	4648      	mov	r0, r9
9001b49e:	e765      	b.n	9001b36c <_dtoa_r+0x364>
9001b4a0:	ec42 1b17 	vmov	d7, r1, r2
9001b4a4:	4a5b      	ldr	r2, [pc, #364]	; (9001b614 <_dtoa_r+0x60c>)
9001b4a6:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
9001b4aa:	ed12 4b02 	vldr	d4, [r2, #-8]
9001b4ae:	9a00      	ldr	r2, [sp, #0]
9001b4b0:	1814      	adds	r4, r2, r0
9001b4b2:	9a08      	ldr	r2, [sp, #32]
9001b4b4:	b352      	cbz	r2, 9001b50c <_dtoa_r+0x504>
9001b4b6:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
9001b4ba:	eeb7 2b00 	vmov.f64	d2, #112	; 0x3f800000  1.0
9001b4be:	f8dd 8000 	ldr.w	r8, [sp]
9001b4c2:	ee83 5b04 	vdiv.f64	d5, d3, d4
9001b4c6:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
9001b4ca:	ee35 7b47 	vsub.f64	d7, d5, d7
9001b4ce:	eefd 4bc6 	vcvt.s32.f64	s9, d6
9001b4d2:	ee14 2a90 	vmov	r2, s9
9001b4d6:	eeb8 5be4 	vcvt.f64.s32	d5, s9
9001b4da:	3230      	adds	r2, #48	; 0x30
9001b4dc:	ee36 6b45 	vsub.f64	d6, d6, d5
9001b4e0:	eeb4 6bc7 	vcmpe.f64	d6, d7
9001b4e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b4e8:	f808 2b01 	strb.w	r2, [r8], #1
9001b4ec:	d439      	bmi.n	9001b562 <_dtoa_r+0x55a>
9001b4ee:	ee32 5b46 	vsub.f64	d5, d2, d6
9001b4f2:	eeb4 5bc7 	vcmpe.f64	d5, d7
9001b4f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b4fa:	d472      	bmi.n	9001b5e2 <_dtoa_r+0x5da>
9001b4fc:	45a0      	cmp	r8, r4
9001b4fe:	f43f af5d 	beq.w	9001b3bc <_dtoa_r+0x3b4>
9001b502:	ee27 7b03 	vmul.f64	d7, d7, d3
9001b506:	ee26 6b03 	vmul.f64	d6, d6, d3
9001b50a:	e7e0      	b.n	9001b4ce <_dtoa_r+0x4c6>
9001b50c:	f8dd 8000 	ldr.w	r8, [sp]
9001b510:	ee27 7b04 	vmul.f64	d7, d7, d4
9001b514:	4621      	mov	r1, r4
9001b516:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
9001b51a:	eefd 4bc6 	vcvt.s32.f64	s9, d6
9001b51e:	ee14 2a90 	vmov	r2, s9
9001b522:	3230      	adds	r2, #48	; 0x30
9001b524:	f808 2b01 	strb.w	r2, [r8], #1
9001b528:	45a0      	cmp	r8, r4
9001b52a:	eeb8 5be4 	vcvt.f64.s32	d5, s9
9001b52e:	ee36 6b45 	vsub.f64	d6, d6, d5
9001b532:	d118      	bne.n	9001b566 <_dtoa_r+0x55e>
9001b534:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
9001b538:	ee37 4b05 	vadd.f64	d4, d7, d5
9001b53c:	eeb4 6bc4 	vcmpe.f64	d6, d4
9001b540:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b544:	dc4d      	bgt.n	9001b5e2 <_dtoa_r+0x5da>
9001b546:	ee35 7b47 	vsub.f64	d7, d5, d7
9001b54a:	eeb4 6bc7 	vcmpe.f64	d6, d7
9001b54e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b552:	f57f af33 	bpl.w	9001b3bc <_dtoa_r+0x3b4>
9001b556:	4688      	mov	r8, r1
9001b558:	3901      	subs	r1, #1
9001b55a:	f818 3c01 	ldrb.w	r3, [r8, #-1]
9001b55e:	2b30      	cmp	r3, #48	; 0x30
9001b560:	d0f9      	beq.n	9001b556 <_dtoa_r+0x54e>
9001b562:	46bb      	mov	fp, r7
9001b564:	e02a      	b.n	9001b5bc <_dtoa_r+0x5b4>
9001b566:	ee26 6b03 	vmul.f64	d6, d6, d3
9001b56a:	e7d6      	b.n	9001b51a <_dtoa_r+0x512>
9001b56c:	ed9d 7b02 	vldr	d7, [sp, #8]
9001b570:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
9001b574:	f8dd 8000 	ldr.w	r8, [sp]
9001b578:	ee87 5b06 	vdiv.f64	d5, d7, d6
9001b57c:	eebd 5bc5 	vcvt.s32.f64	s10, d5
9001b580:	ee15 3a10 	vmov	r3, s10
9001b584:	3330      	adds	r3, #48	; 0x30
9001b586:	f808 3b01 	strb.w	r3, [r8], #1
9001b58a:	9b00      	ldr	r3, [sp, #0]
9001b58c:	eba8 0303 	sub.w	r3, r8, r3
9001b590:	4599      	cmp	r9, r3
9001b592:	eeb8 3bc5 	vcvt.f64.s32	d3, s10
9001b596:	eea3 7b46 	vfms.f64	d7, d3, d6
9001b59a:	d133      	bne.n	9001b604 <_dtoa_r+0x5fc>
9001b59c:	ee37 7b07 	vadd.f64	d7, d7, d7
9001b5a0:	eeb4 7bc6 	vcmpe.f64	d7, d6
9001b5a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b5a8:	dc1a      	bgt.n	9001b5e0 <_dtoa_r+0x5d8>
9001b5aa:	eeb4 7b46 	vcmp.f64	d7, d6
9001b5ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b5b2:	d103      	bne.n	9001b5bc <_dtoa_r+0x5b4>
9001b5b4:	ee15 3a10 	vmov	r3, s10
9001b5b8:	07d9      	lsls	r1, r3, #31
9001b5ba:	d411      	bmi.n	9001b5e0 <_dtoa_r+0x5d8>
9001b5bc:	4629      	mov	r1, r5
9001b5be:	4630      	mov	r0, r6
9001b5c0:	f000 fe2d 	bl	9001c21e <_Bfree>
9001b5c4:	2300      	movs	r3, #0
9001b5c6:	9a10      	ldr	r2, [sp, #64]	; 0x40
9001b5c8:	f888 3000 	strb.w	r3, [r8]
9001b5cc:	f10b 0301 	add.w	r3, fp, #1
9001b5d0:	6013      	str	r3, [r2, #0]
9001b5d2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001b5d4:	2b00      	cmp	r3, #0
9001b5d6:	f43f ad50 	beq.w	9001b07a <_dtoa_r+0x72>
9001b5da:	f8c3 8000 	str.w	r8, [r3]
9001b5de:	e54c      	b.n	9001b07a <_dtoa_r+0x72>
9001b5e0:	465f      	mov	r7, fp
9001b5e2:	4643      	mov	r3, r8
9001b5e4:	4698      	mov	r8, r3
9001b5e6:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
9001b5ea:	2a39      	cmp	r2, #57	; 0x39
9001b5ec:	d106      	bne.n	9001b5fc <_dtoa_r+0x5f4>
9001b5ee:	9a00      	ldr	r2, [sp, #0]
9001b5f0:	429a      	cmp	r2, r3
9001b5f2:	d1f7      	bne.n	9001b5e4 <_dtoa_r+0x5dc>
9001b5f4:	9900      	ldr	r1, [sp, #0]
9001b5f6:	2230      	movs	r2, #48	; 0x30
9001b5f8:	3701      	adds	r7, #1
9001b5fa:	700a      	strb	r2, [r1, #0]
9001b5fc:	781a      	ldrb	r2, [r3, #0]
9001b5fe:	3201      	adds	r2, #1
9001b600:	701a      	strb	r2, [r3, #0]
9001b602:	e7ae      	b.n	9001b562 <_dtoa_r+0x55a>
9001b604:	ee27 7b04 	vmul.f64	d7, d7, d4
9001b608:	eeb5 7b40 	vcmp.f64	d7, #0.0
9001b60c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001b610:	d1b2      	bne.n	9001b578 <_dtoa_r+0x570>
9001b612:	e7d3      	b.n	9001b5bc <_dtoa_r+0x5b4>
9001b614:	900254a0 	.word	0x900254a0
9001b618:	90025478 	.word	0x90025478
9001b61c:	9908      	ldr	r1, [sp, #32]
9001b61e:	2900      	cmp	r1, #0
9001b620:	f000 80d1 	beq.w	9001b7c6 <_dtoa_r+0x7be>
9001b624:	9907      	ldr	r1, [sp, #28]
9001b626:	2901      	cmp	r1, #1
9001b628:	f300 80b4 	bgt.w	9001b794 <_dtoa_r+0x78c>
9001b62c:	9911      	ldr	r1, [sp, #68]	; 0x44
9001b62e:	2900      	cmp	r1, #0
9001b630:	f000 80ac 	beq.w	9001b78c <_dtoa_r+0x784>
9001b634:	f202 4233 	addw	r2, r2, #1075	; 0x433
9001b638:	f8dd 8014 	ldr.w	r8, [sp, #20]
9001b63c:	461c      	mov	r4, r3
9001b63e:	930a      	str	r3, [sp, #40]	; 0x28
9001b640:	9b05      	ldr	r3, [sp, #20]
9001b642:	4413      	add	r3, r2
9001b644:	9305      	str	r3, [sp, #20]
9001b646:	9b06      	ldr	r3, [sp, #24]
9001b648:	2101      	movs	r1, #1
9001b64a:	4413      	add	r3, r2
9001b64c:	4630      	mov	r0, r6
9001b64e:	9306      	str	r3, [sp, #24]
9001b650:	f000 fe88 	bl	9001c364 <__i2b>
9001b654:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001b656:	4607      	mov	r7, r0
9001b658:	f1b8 0f00 	cmp.w	r8, #0
9001b65c:	dd0d      	ble.n	9001b67a <_dtoa_r+0x672>
9001b65e:	9a06      	ldr	r2, [sp, #24]
9001b660:	2a00      	cmp	r2, #0
9001b662:	dd0a      	ble.n	9001b67a <_dtoa_r+0x672>
9001b664:	4542      	cmp	r2, r8
9001b666:	9905      	ldr	r1, [sp, #20]
9001b668:	bfa8      	it	ge
9001b66a:	4642      	movge	r2, r8
9001b66c:	1a89      	subs	r1, r1, r2
9001b66e:	9105      	str	r1, [sp, #20]
9001b670:	9906      	ldr	r1, [sp, #24]
9001b672:	eba8 0802 	sub.w	r8, r8, r2
9001b676:	1a8a      	subs	r2, r1, r2
9001b678:	9206      	str	r2, [sp, #24]
9001b67a:	b303      	cbz	r3, 9001b6be <_dtoa_r+0x6b6>
9001b67c:	9a08      	ldr	r2, [sp, #32]
9001b67e:	2a00      	cmp	r2, #0
9001b680:	f000 80a6 	beq.w	9001b7d0 <_dtoa_r+0x7c8>
9001b684:	2c00      	cmp	r4, #0
9001b686:	dd13      	ble.n	9001b6b0 <_dtoa_r+0x6a8>
9001b688:	4639      	mov	r1, r7
9001b68a:	4622      	mov	r2, r4
9001b68c:	4630      	mov	r0, r6
9001b68e:	930c      	str	r3, [sp, #48]	; 0x30
9001b690:	f000 ff24 	bl	9001c4dc <__pow5mult>
9001b694:	462a      	mov	r2, r5
9001b696:	4601      	mov	r1, r0
9001b698:	4607      	mov	r7, r0
9001b69a:	4630      	mov	r0, r6
9001b69c:	f000 fe78 	bl	9001c390 <__multiply>
9001b6a0:	4629      	mov	r1, r5
9001b6a2:	900a      	str	r0, [sp, #40]	; 0x28
9001b6a4:	4630      	mov	r0, r6
9001b6a6:	f000 fdba 	bl	9001c21e <_Bfree>
9001b6aa:	9a0a      	ldr	r2, [sp, #40]	; 0x28
9001b6ac:	9b0c      	ldr	r3, [sp, #48]	; 0x30
9001b6ae:	4615      	mov	r5, r2
9001b6b0:	1b1a      	subs	r2, r3, r4
9001b6b2:	d004      	beq.n	9001b6be <_dtoa_r+0x6b6>
9001b6b4:	4629      	mov	r1, r5
9001b6b6:	4630      	mov	r0, r6
9001b6b8:	f000 ff10 	bl	9001c4dc <__pow5mult>
9001b6bc:	4605      	mov	r5, r0
9001b6be:	2101      	movs	r1, #1
9001b6c0:	4630      	mov	r0, r6
9001b6c2:	f000 fe4f 	bl	9001c364 <__i2b>
9001b6c6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
9001b6c8:	2b00      	cmp	r3, #0
9001b6ca:	4604      	mov	r4, r0
9001b6cc:	f340 8082 	ble.w	9001b7d4 <_dtoa_r+0x7cc>
9001b6d0:	461a      	mov	r2, r3
9001b6d2:	4601      	mov	r1, r0
9001b6d4:	4630      	mov	r0, r6
9001b6d6:	f000 ff01 	bl	9001c4dc <__pow5mult>
9001b6da:	9b07      	ldr	r3, [sp, #28]
9001b6dc:	2b01      	cmp	r3, #1
9001b6de:	4604      	mov	r4, r0
9001b6e0:	dd7b      	ble.n	9001b7da <_dtoa_r+0x7d2>
9001b6e2:	2300      	movs	r3, #0
9001b6e4:	930a      	str	r3, [sp, #40]	; 0x28
9001b6e6:	6922      	ldr	r2, [r4, #16]
9001b6e8:	eb04 0282 	add.w	r2, r4, r2, lsl #2
9001b6ec:	6910      	ldr	r0, [r2, #16]
9001b6ee:	f000 fde9 	bl	9001c2c4 <__hi0bits>
9001b6f2:	f1c0 0020 	rsb	r0, r0, #32
9001b6f6:	9b06      	ldr	r3, [sp, #24]
9001b6f8:	4418      	add	r0, r3
9001b6fa:	f010 001f 	ands.w	r0, r0, #31
9001b6fe:	f000 808d 	beq.w	9001b81c <_dtoa_r+0x814>
9001b702:	f1c0 0220 	rsb	r2, r0, #32
9001b706:	2a04      	cmp	r2, #4
9001b708:	f340 8086 	ble.w	9001b818 <_dtoa_r+0x810>
9001b70c:	f1c0 001c 	rsb	r0, r0, #28
9001b710:	9b05      	ldr	r3, [sp, #20]
9001b712:	4403      	add	r3, r0
9001b714:	9305      	str	r3, [sp, #20]
9001b716:	9b06      	ldr	r3, [sp, #24]
9001b718:	4403      	add	r3, r0
9001b71a:	4480      	add	r8, r0
9001b71c:	9306      	str	r3, [sp, #24]
9001b71e:	9b05      	ldr	r3, [sp, #20]
9001b720:	2b00      	cmp	r3, #0
9001b722:	dd05      	ble.n	9001b730 <_dtoa_r+0x728>
9001b724:	4629      	mov	r1, r5
9001b726:	461a      	mov	r2, r3
9001b728:	4630      	mov	r0, r6
9001b72a:	f000 ff17 	bl	9001c55c <__lshift>
9001b72e:	4605      	mov	r5, r0
9001b730:	9b06      	ldr	r3, [sp, #24]
9001b732:	2b00      	cmp	r3, #0
9001b734:	dd05      	ble.n	9001b742 <_dtoa_r+0x73a>
9001b736:	4621      	mov	r1, r4
9001b738:	461a      	mov	r2, r3
9001b73a:	4630      	mov	r0, r6
9001b73c:	f000 ff0e 	bl	9001c55c <__lshift>
9001b740:	4604      	mov	r4, r0
9001b742:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
9001b744:	2b00      	cmp	r3, #0
9001b746:	d06b      	beq.n	9001b820 <_dtoa_r+0x818>
9001b748:	4621      	mov	r1, r4
9001b74a:	4628      	mov	r0, r5
9001b74c:	f000 ff72 	bl	9001c634 <__mcmp>
9001b750:	2800      	cmp	r0, #0
9001b752:	da65      	bge.n	9001b820 <_dtoa_r+0x818>
9001b754:	2300      	movs	r3, #0
9001b756:	4629      	mov	r1, r5
9001b758:	220a      	movs	r2, #10
9001b75a:	4630      	mov	r0, r6
9001b75c:	f000 fd68 	bl	9001c230 <__multadd>
9001b760:	9b08      	ldr	r3, [sp, #32]
9001b762:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
9001b766:	4605      	mov	r5, r0
9001b768:	2b00      	cmp	r3, #0
9001b76a:	f000 8191 	beq.w	9001ba90 <_dtoa_r+0xa88>
9001b76e:	4639      	mov	r1, r7
9001b770:	2300      	movs	r3, #0
9001b772:	220a      	movs	r2, #10
9001b774:	4630      	mov	r0, r6
9001b776:	f000 fd5b 	bl	9001c230 <__multadd>
9001b77a:	f1ba 0f00 	cmp.w	sl, #0
9001b77e:	4607      	mov	r7, r0
9001b780:	f300 808e 	bgt.w	9001b8a0 <_dtoa_r+0x898>
9001b784:	9b07      	ldr	r3, [sp, #28]
9001b786:	2b02      	cmp	r3, #2
9001b788:	dc51      	bgt.n	9001b82e <_dtoa_r+0x826>
9001b78a:	e089      	b.n	9001b8a0 <_dtoa_r+0x898>
9001b78c:	9a12      	ldr	r2, [sp, #72]	; 0x48
9001b78e:	f1c2 0236 	rsb	r2, r2, #54	; 0x36
9001b792:	e751      	b.n	9001b638 <_dtoa_r+0x630>
9001b794:	f109 34ff 	add.w	r4, r9, #4294967295	; 0xffffffff
9001b798:	42a3      	cmp	r3, r4
9001b79a:	bfbf      	itttt	lt
9001b79c:	9a0e      	ldrlt	r2, [sp, #56]	; 0x38
9001b79e:	1ae3      	sublt	r3, r4, r3
9001b7a0:	18d2      	addlt	r2, r2, r3
9001b7a2:	4613      	movlt	r3, r2
9001b7a4:	bfb7      	itett	lt
9001b7a6:	930e      	strlt	r3, [sp, #56]	; 0x38
9001b7a8:	1b1c      	subge	r4, r3, r4
9001b7aa:	4623      	movlt	r3, r4
9001b7ac:	2400      	movlt	r4, #0
9001b7ae:	f1b9 0f00 	cmp.w	r9, #0
9001b7b2:	bfb5      	itete	lt
9001b7b4:	9a05      	ldrlt	r2, [sp, #20]
9001b7b6:	f8dd 8014 	ldrge.w	r8, [sp, #20]
9001b7ba:	eba2 0809 	sublt.w	r8, r2, r9
9001b7be:	464a      	movge	r2, r9
9001b7c0:	bfb8      	it	lt
9001b7c2:	2200      	movlt	r2, #0
9001b7c4:	e73b      	b.n	9001b63e <_dtoa_r+0x636>
9001b7c6:	f8dd 8014 	ldr.w	r8, [sp, #20]
9001b7ca:	9f08      	ldr	r7, [sp, #32]
9001b7cc:	461c      	mov	r4, r3
9001b7ce:	e743      	b.n	9001b658 <_dtoa_r+0x650>
9001b7d0:	461a      	mov	r2, r3
9001b7d2:	e76f      	b.n	9001b6b4 <_dtoa_r+0x6ac>
9001b7d4:	9b07      	ldr	r3, [sp, #28]
9001b7d6:	2b01      	cmp	r3, #1
9001b7d8:	dc18      	bgt.n	9001b80c <_dtoa_r+0x804>
9001b7da:	9b02      	ldr	r3, [sp, #8]
9001b7dc:	b9b3      	cbnz	r3, 9001b80c <_dtoa_r+0x804>
9001b7de:	9b03      	ldr	r3, [sp, #12]
9001b7e0:	f3c3 0213 	ubfx	r2, r3, #0, #20
9001b7e4:	b9a2      	cbnz	r2, 9001b810 <_dtoa_r+0x808>
9001b7e6:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
9001b7ea:	0d12      	lsrs	r2, r2, #20
9001b7ec:	0512      	lsls	r2, r2, #20
9001b7ee:	b18a      	cbz	r2, 9001b814 <_dtoa_r+0x80c>
9001b7f0:	9b05      	ldr	r3, [sp, #20]
9001b7f2:	3301      	adds	r3, #1
9001b7f4:	9305      	str	r3, [sp, #20]
9001b7f6:	9b06      	ldr	r3, [sp, #24]
9001b7f8:	3301      	adds	r3, #1
9001b7fa:	9306      	str	r3, [sp, #24]
9001b7fc:	2301      	movs	r3, #1
9001b7fe:	930a      	str	r3, [sp, #40]	; 0x28
9001b800:	9b0e      	ldr	r3, [sp, #56]	; 0x38
9001b802:	2b00      	cmp	r3, #0
9001b804:	f47f af6f 	bne.w	9001b6e6 <_dtoa_r+0x6de>
9001b808:	2001      	movs	r0, #1
9001b80a:	e774      	b.n	9001b6f6 <_dtoa_r+0x6ee>
9001b80c:	2300      	movs	r3, #0
9001b80e:	e7f6      	b.n	9001b7fe <_dtoa_r+0x7f6>
9001b810:	9b02      	ldr	r3, [sp, #8]
9001b812:	e7f4      	b.n	9001b7fe <_dtoa_r+0x7f6>
9001b814:	920a      	str	r2, [sp, #40]	; 0x28
9001b816:	e7f3      	b.n	9001b800 <_dtoa_r+0x7f8>
9001b818:	d081      	beq.n	9001b71e <_dtoa_r+0x716>
9001b81a:	4610      	mov	r0, r2
9001b81c:	301c      	adds	r0, #28
9001b81e:	e777      	b.n	9001b710 <_dtoa_r+0x708>
9001b820:	f1b9 0f00 	cmp.w	r9, #0
9001b824:	dc37      	bgt.n	9001b896 <_dtoa_r+0x88e>
9001b826:	9b07      	ldr	r3, [sp, #28]
9001b828:	2b02      	cmp	r3, #2
9001b82a:	dd34      	ble.n	9001b896 <_dtoa_r+0x88e>
9001b82c:	46ca      	mov	sl, r9
9001b82e:	f1ba 0f00 	cmp.w	sl, #0
9001b832:	d10d      	bne.n	9001b850 <_dtoa_r+0x848>
9001b834:	4621      	mov	r1, r4
9001b836:	4653      	mov	r3, sl
9001b838:	2205      	movs	r2, #5
9001b83a:	4630      	mov	r0, r6
9001b83c:	f000 fcf8 	bl	9001c230 <__multadd>
9001b840:	4601      	mov	r1, r0
9001b842:	4604      	mov	r4, r0
9001b844:	4628      	mov	r0, r5
9001b846:	f000 fef5 	bl	9001c634 <__mcmp>
9001b84a:	2800      	cmp	r0, #0
9001b84c:	f73f addf 	bgt.w	9001b40e <_dtoa_r+0x406>
9001b850:	9b09      	ldr	r3, [sp, #36]	; 0x24
9001b852:	f8dd 8000 	ldr.w	r8, [sp]
9001b856:	ea6f 0b03 	mvn.w	fp, r3
9001b85a:	f04f 0900 	mov.w	r9, #0
9001b85e:	4621      	mov	r1, r4
9001b860:	4630      	mov	r0, r6
9001b862:	f000 fcdc 	bl	9001c21e <_Bfree>
9001b866:	2f00      	cmp	r7, #0
9001b868:	f43f aea8 	beq.w	9001b5bc <_dtoa_r+0x5b4>
9001b86c:	f1b9 0f00 	cmp.w	r9, #0
9001b870:	d005      	beq.n	9001b87e <_dtoa_r+0x876>
9001b872:	45b9      	cmp	r9, r7
9001b874:	d003      	beq.n	9001b87e <_dtoa_r+0x876>
9001b876:	4649      	mov	r1, r9
9001b878:	4630      	mov	r0, r6
9001b87a:	f000 fcd0 	bl	9001c21e <_Bfree>
9001b87e:	4639      	mov	r1, r7
9001b880:	4630      	mov	r0, r6
9001b882:	f000 fccc 	bl	9001c21e <_Bfree>
9001b886:	e699      	b.n	9001b5bc <_dtoa_r+0x5b4>
9001b888:	2400      	movs	r4, #0
9001b88a:	4627      	mov	r7, r4
9001b88c:	e7e0      	b.n	9001b850 <_dtoa_r+0x848>
9001b88e:	46bb      	mov	fp, r7
9001b890:	4604      	mov	r4, r0
9001b892:	4607      	mov	r7, r0
9001b894:	e5bb      	b.n	9001b40e <_dtoa_r+0x406>
9001b896:	9b08      	ldr	r3, [sp, #32]
9001b898:	46ca      	mov	sl, r9
9001b89a:	2b00      	cmp	r3, #0
9001b89c:	f000 80ff 	beq.w	9001ba9e <_dtoa_r+0xa96>
9001b8a0:	f1b8 0f00 	cmp.w	r8, #0
9001b8a4:	dd05      	ble.n	9001b8b2 <_dtoa_r+0x8aa>
9001b8a6:	4639      	mov	r1, r7
9001b8a8:	4642      	mov	r2, r8
9001b8aa:	4630      	mov	r0, r6
9001b8ac:	f000 fe56 	bl	9001c55c <__lshift>
9001b8b0:	4607      	mov	r7, r0
9001b8b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001b8b4:	2b00      	cmp	r3, #0
9001b8b6:	d05c      	beq.n	9001b972 <_dtoa_r+0x96a>
9001b8b8:	6879      	ldr	r1, [r7, #4]
9001b8ba:	4630      	mov	r0, r6
9001b8bc:	f000 fc8a 	bl	9001c1d4 <_Balloc>
9001b8c0:	4680      	mov	r8, r0
9001b8c2:	b920      	cbnz	r0, 9001b8ce <_dtoa_r+0x8c6>
9001b8c4:	4b81      	ldr	r3, [pc, #516]	; (9001bacc <_dtoa_r+0xac4>)
9001b8c6:	4602      	mov	r2, r0
9001b8c8:	f240 21ea 	movw	r1, #746	; 0x2ea
9001b8cc:	e4bc      	b.n	9001b248 <_dtoa_r+0x240>
9001b8ce:	693a      	ldr	r2, [r7, #16]
9001b8d0:	3202      	adds	r2, #2
9001b8d2:	0092      	lsls	r2, r2, #2
9001b8d4:	f107 010c 	add.w	r1, r7, #12
9001b8d8:	300c      	adds	r0, #12
9001b8da:	f7fe f953 	bl	90019b84 <memcpy>
9001b8de:	2201      	movs	r2, #1
9001b8e0:	4641      	mov	r1, r8
9001b8e2:	4630      	mov	r0, r6
9001b8e4:	f000 fe3a 	bl	9001c55c <__lshift>
9001b8e8:	9b00      	ldr	r3, [sp, #0]
9001b8ea:	3301      	adds	r3, #1
9001b8ec:	9305      	str	r3, [sp, #20]
9001b8ee:	9b00      	ldr	r3, [sp, #0]
9001b8f0:	4453      	add	r3, sl
9001b8f2:	9309      	str	r3, [sp, #36]	; 0x24
9001b8f4:	9b02      	ldr	r3, [sp, #8]
9001b8f6:	f003 0301 	and.w	r3, r3, #1
9001b8fa:	46b9      	mov	r9, r7
9001b8fc:	9308      	str	r3, [sp, #32]
9001b8fe:	4607      	mov	r7, r0
9001b900:	9b05      	ldr	r3, [sp, #20]
9001b902:	4621      	mov	r1, r4
9001b904:	3b01      	subs	r3, #1
9001b906:	4628      	mov	r0, r5
9001b908:	9302      	str	r3, [sp, #8]
9001b90a:	f7ff faef 	bl	9001aeec <quorem>
9001b90e:	4603      	mov	r3, r0
9001b910:	3330      	adds	r3, #48	; 0x30
9001b912:	9006      	str	r0, [sp, #24]
9001b914:	4649      	mov	r1, r9
9001b916:	4628      	mov	r0, r5
9001b918:	930a      	str	r3, [sp, #40]	; 0x28
9001b91a:	f000 fe8b 	bl	9001c634 <__mcmp>
9001b91e:	463a      	mov	r2, r7
9001b920:	4682      	mov	sl, r0
9001b922:	4621      	mov	r1, r4
9001b924:	4630      	mov	r0, r6
9001b926:	f000 fea1 	bl	9001c66c <__mdiff>
9001b92a:	68c2      	ldr	r2, [r0, #12]
9001b92c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001b92e:	4680      	mov	r8, r0
9001b930:	bb0a      	cbnz	r2, 9001b976 <_dtoa_r+0x96e>
9001b932:	4601      	mov	r1, r0
9001b934:	4628      	mov	r0, r5
9001b936:	f000 fe7d 	bl	9001c634 <__mcmp>
9001b93a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001b93c:	4602      	mov	r2, r0
9001b93e:	4641      	mov	r1, r8
9001b940:	4630      	mov	r0, r6
9001b942:	920e      	str	r2, [sp, #56]	; 0x38
9001b944:	930a      	str	r3, [sp, #40]	; 0x28
9001b946:	f000 fc6a 	bl	9001c21e <_Bfree>
9001b94a:	9b07      	ldr	r3, [sp, #28]
9001b94c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
9001b94e:	f8dd 8014 	ldr.w	r8, [sp, #20]
9001b952:	ea43 0102 	orr.w	r1, r3, r2
9001b956:	9b08      	ldr	r3, [sp, #32]
9001b958:	430b      	orrs	r3, r1
9001b95a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
9001b95c:	d10d      	bne.n	9001b97a <_dtoa_r+0x972>
9001b95e:	2b39      	cmp	r3, #57	; 0x39
9001b960:	d029      	beq.n	9001b9b6 <_dtoa_r+0x9ae>
9001b962:	f1ba 0f00 	cmp.w	sl, #0
9001b966:	dd01      	ble.n	9001b96c <_dtoa_r+0x964>
9001b968:	9b06      	ldr	r3, [sp, #24]
9001b96a:	3331      	adds	r3, #49	; 0x31
9001b96c:	9a02      	ldr	r2, [sp, #8]
9001b96e:	7013      	strb	r3, [r2, #0]
9001b970:	e775      	b.n	9001b85e <_dtoa_r+0x856>
9001b972:	4638      	mov	r0, r7
9001b974:	e7b8      	b.n	9001b8e8 <_dtoa_r+0x8e0>
9001b976:	2201      	movs	r2, #1
9001b978:	e7e1      	b.n	9001b93e <_dtoa_r+0x936>
9001b97a:	f1ba 0f00 	cmp.w	sl, #0
9001b97e:	db06      	blt.n	9001b98e <_dtoa_r+0x986>
9001b980:	9907      	ldr	r1, [sp, #28]
9001b982:	ea41 0a0a 	orr.w	sl, r1, sl
9001b986:	9908      	ldr	r1, [sp, #32]
9001b988:	ea5a 0101 	orrs.w	r1, sl, r1
9001b98c:	d120      	bne.n	9001b9d0 <_dtoa_r+0x9c8>
9001b98e:	2a00      	cmp	r2, #0
9001b990:	ddec      	ble.n	9001b96c <_dtoa_r+0x964>
9001b992:	4629      	mov	r1, r5
9001b994:	2201      	movs	r2, #1
9001b996:	4630      	mov	r0, r6
9001b998:	9305      	str	r3, [sp, #20]
9001b99a:	f000 fddf 	bl	9001c55c <__lshift>
9001b99e:	4621      	mov	r1, r4
9001b9a0:	4605      	mov	r5, r0
9001b9a2:	f000 fe47 	bl	9001c634 <__mcmp>
9001b9a6:	2800      	cmp	r0, #0
9001b9a8:	9b05      	ldr	r3, [sp, #20]
9001b9aa:	dc02      	bgt.n	9001b9b2 <_dtoa_r+0x9aa>
9001b9ac:	d1de      	bne.n	9001b96c <_dtoa_r+0x964>
9001b9ae:	07da      	lsls	r2, r3, #31
9001b9b0:	d5dc      	bpl.n	9001b96c <_dtoa_r+0x964>
9001b9b2:	2b39      	cmp	r3, #57	; 0x39
9001b9b4:	d1d8      	bne.n	9001b968 <_dtoa_r+0x960>
9001b9b6:	9a02      	ldr	r2, [sp, #8]
9001b9b8:	2339      	movs	r3, #57	; 0x39
9001b9ba:	7013      	strb	r3, [r2, #0]
9001b9bc:	4643      	mov	r3, r8
9001b9be:	4698      	mov	r8, r3
9001b9c0:	3b01      	subs	r3, #1
9001b9c2:	f818 2c01 	ldrb.w	r2, [r8, #-1]
9001b9c6:	2a39      	cmp	r2, #57	; 0x39
9001b9c8:	d051      	beq.n	9001ba6e <_dtoa_r+0xa66>
9001b9ca:	3201      	adds	r2, #1
9001b9cc:	701a      	strb	r2, [r3, #0]
9001b9ce:	e746      	b.n	9001b85e <_dtoa_r+0x856>
9001b9d0:	2a00      	cmp	r2, #0
9001b9d2:	dd03      	ble.n	9001b9dc <_dtoa_r+0x9d4>
9001b9d4:	2b39      	cmp	r3, #57	; 0x39
9001b9d6:	d0ee      	beq.n	9001b9b6 <_dtoa_r+0x9ae>
9001b9d8:	3301      	adds	r3, #1
9001b9da:	e7c7      	b.n	9001b96c <_dtoa_r+0x964>
9001b9dc:	9a05      	ldr	r2, [sp, #20]
9001b9de:	9909      	ldr	r1, [sp, #36]	; 0x24
9001b9e0:	f802 3c01 	strb.w	r3, [r2, #-1]
9001b9e4:	428a      	cmp	r2, r1
9001b9e6:	d02b      	beq.n	9001ba40 <_dtoa_r+0xa38>
9001b9e8:	4629      	mov	r1, r5
9001b9ea:	2300      	movs	r3, #0
9001b9ec:	220a      	movs	r2, #10
9001b9ee:	4630      	mov	r0, r6
9001b9f0:	f000 fc1e 	bl	9001c230 <__multadd>
9001b9f4:	45b9      	cmp	r9, r7
9001b9f6:	4605      	mov	r5, r0
9001b9f8:	f04f 0300 	mov.w	r3, #0
9001b9fc:	f04f 020a 	mov.w	r2, #10
9001ba00:	4649      	mov	r1, r9
9001ba02:	4630      	mov	r0, r6
9001ba04:	d107      	bne.n	9001ba16 <_dtoa_r+0xa0e>
9001ba06:	f000 fc13 	bl	9001c230 <__multadd>
9001ba0a:	4681      	mov	r9, r0
9001ba0c:	4607      	mov	r7, r0
9001ba0e:	9b05      	ldr	r3, [sp, #20]
9001ba10:	3301      	adds	r3, #1
9001ba12:	9305      	str	r3, [sp, #20]
9001ba14:	e774      	b.n	9001b900 <_dtoa_r+0x8f8>
9001ba16:	f000 fc0b 	bl	9001c230 <__multadd>
9001ba1a:	4639      	mov	r1, r7
9001ba1c:	4681      	mov	r9, r0
9001ba1e:	2300      	movs	r3, #0
9001ba20:	220a      	movs	r2, #10
9001ba22:	4630      	mov	r0, r6
9001ba24:	f000 fc04 	bl	9001c230 <__multadd>
9001ba28:	4607      	mov	r7, r0
9001ba2a:	e7f0      	b.n	9001ba0e <_dtoa_r+0xa06>
9001ba2c:	f1ba 0f00 	cmp.w	sl, #0
9001ba30:	9a00      	ldr	r2, [sp, #0]
9001ba32:	bfcc      	ite	gt
9001ba34:	46d0      	movgt	r8, sl
9001ba36:	f04f 0801 	movle.w	r8, #1
9001ba3a:	4490      	add	r8, r2
9001ba3c:	f04f 0900 	mov.w	r9, #0
9001ba40:	4629      	mov	r1, r5
9001ba42:	2201      	movs	r2, #1
9001ba44:	4630      	mov	r0, r6
9001ba46:	9302      	str	r3, [sp, #8]
9001ba48:	f000 fd88 	bl	9001c55c <__lshift>
9001ba4c:	4621      	mov	r1, r4
9001ba4e:	4605      	mov	r5, r0
9001ba50:	f000 fdf0 	bl	9001c634 <__mcmp>
9001ba54:	2800      	cmp	r0, #0
9001ba56:	dcb1      	bgt.n	9001b9bc <_dtoa_r+0x9b4>
9001ba58:	d102      	bne.n	9001ba60 <_dtoa_r+0xa58>
9001ba5a:	9b02      	ldr	r3, [sp, #8]
9001ba5c:	07db      	lsls	r3, r3, #31
9001ba5e:	d4ad      	bmi.n	9001b9bc <_dtoa_r+0x9b4>
9001ba60:	4643      	mov	r3, r8
9001ba62:	4698      	mov	r8, r3
9001ba64:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
9001ba68:	2a30      	cmp	r2, #48	; 0x30
9001ba6a:	d0fa      	beq.n	9001ba62 <_dtoa_r+0xa5a>
9001ba6c:	e6f7      	b.n	9001b85e <_dtoa_r+0x856>
9001ba6e:	9a00      	ldr	r2, [sp, #0]
9001ba70:	429a      	cmp	r2, r3
9001ba72:	d1a4      	bne.n	9001b9be <_dtoa_r+0x9b6>
9001ba74:	f10b 0b01 	add.w	fp, fp, #1
9001ba78:	2331      	movs	r3, #49	; 0x31
9001ba7a:	e778      	b.n	9001b96e <_dtoa_r+0x966>
9001ba7c:	4b14      	ldr	r3, [pc, #80]	; (9001bad0 <_dtoa_r+0xac8>)
9001ba7e:	f7ff bb17 	b.w	9001b0b0 <_dtoa_r+0xa8>
9001ba82:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9001ba84:	2b00      	cmp	r3, #0
9001ba86:	f47f aafc 	bne.w	9001b082 <_dtoa_r+0x7a>
9001ba8a:	4b12      	ldr	r3, [pc, #72]	; (9001bad4 <_dtoa_r+0xacc>)
9001ba8c:	f7ff bb10 	b.w	9001b0b0 <_dtoa_r+0xa8>
9001ba90:	f1ba 0f00 	cmp.w	sl, #0
9001ba94:	dc03      	bgt.n	9001ba9e <_dtoa_r+0xa96>
9001ba96:	9b07      	ldr	r3, [sp, #28]
9001ba98:	2b02      	cmp	r3, #2
9001ba9a:	f73f aec8 	bgt.w	9001b82e <_dtoa_r+0x826>
9001ba9e:	f8dd 8000 	ldr.w	r8, [sp]
9001baa2:	4621      	mov	r1, r4
9001baa4:	4628      	mov	r0, r5
9001baa6:	f7ff fa21 	bl	9001aeec <quorem>
9001baaa:	f100 0330 	add.w	r3, r0, #48	; 0x30
9001baae:	f808 3b01 	strb.w	r3, [r8], #1
9001bab2:	9a00      	ldr	r2, [sp, #0]
9001bab4:	eba8 0202 	sub.w	r2, r8, r2
9001bab8:	4592      	cmp	sl, r2
9001baba:	ddb7      	ble.n	9001ba2c <_dtoa_r+0xa24>
9001babc:	4629      	mov	r1, r5
9001babe:	2300      	movs	r3, #0
9001bac0:	220a      	movs	r2, #10
9001bac2:	4630      	mov	r0, r6
9001bac4:	f000 fbb4 	bl	9001c230 <__multadd>
9001bac8:	4605      	mov	r5, r0
9001baca:	e7ea      	b.n	9001baa2 <_dtoa_r+0xa9a>
9001bacc:	900253a5 	.word	0x900253a5
9001bad0:	90025376 	.word	0x90025376
9001bad4:	9002539c 	.word	0x9002539c

9001bad8 <__libc_fini_array>:
9001bad8:	b538      	push	{r3, r4, r5, lr}
9001bada:	4d07      	ldr	r5, [pc, #28]	; (9001baf8 <__libc_fini_array+0x20>)
9001badc:	4c07      	ldr	r4, [pc, #28]	; (9001bafc <__libc_fini_array+0x24>)
9001bade:	1b64      	subs	r4, r4, r5
9001bae0:	10a4      	asrs	r4, r4, #2
9001bae2:	b91c      	cbnz	r4, 9001baec <__libc_fini_array+0x14>
9001bae4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
9001bae8:	f002 be66 	b.w	9001e7b8 <_fini>
9001baec:	3c01      	subs	r4, #1
9001baee:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
9001baf2:	4798      	blx	r3
9001baf4:	e7f5      	b.n	9001bae2 <__libc_fini_array+0xa>
9001baf6:	bf00      	nop
9001baf8:	90025960 	.word	0x90025960
9001bafc:	90025964 	.word	0x90025964

9001bb00 <_malloc_trim_r>:
9001bb00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
9001bb04:	4606      	mov	r6, r0
9001bb06:	2008      	movs	r0, #8
9001bb08:	460c      	mov	r4, r1
9001bb0a:	f000 ff6f 	bl	9001c9ec <sysconf>
9001bb0e:	4f23      	ldr	r7, [pc, #140]	; (9001bb9c <_malloc_trim_r+0x9c>)
9001bb10:	4680      	mov	r8, r0
9001bb12:	4630      	mov	r0, r6
9001bb14:	f000 fb52 	bl	9001c1bc <__malloc_lock>
9001bb18:	68bb      	ldr	r3, [r7, #8]
9001bb1a:	685d      	ldr	r5, [r3, #4]
9001bb1c:	f025 0503 	bic.w	r5, r5, #3
9001bb20:	1b2c      	subs	r4, r5, r4
9001bb22:	3c11      	subs	r4, #17
9001bb24:	4444      	add	r4, r8
9001bb26:	fbb4 f4f8 	udiv	r4, r4, r8
9001bb2a:	3c01      	subs	r4, #1
9001bb2c:	fb08 f404 	mul.w	r4, r8, r4
9001bb30:	45a0      	cmp	r8, r4
9001bb32:	dd05      	ble.n	9001bb40 <_malloc_trim_r+0x40>
9001bb34:	4630      	mov	r0, r6
9001bb36:	f000 fb47 	bl	9001c1c8 <__malloc_unlock>
9001bb3a:	2000      	movs	r0, #0
9001bb3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
9001bb40:	2100      	movs	r1, #0
9001bb42:	4630      	mov	r0, r6
9001bb44:	f000 feb4 	bl	9001c8b0 <_sbrk_r>
9001bb48:	68bb      	ldr	r3, [r7, #8]
9001bb4a:	442b      	add	r3, r5
9001bb4c:	4298      	cmp	r0, r3
9001bb4e:	d1f1      	bne.n	9001bb34 <_malloc_trim_r+0x34>
9001bb50:	4261      	negs	r1, r4
9001bb52:	4630      	mov	r0, r6
9001bb54:	f000 feac 	bl	9001c8b0 <_sbrk_r>
9001bb58:	3001      	adds	r0, #1
9001bb5a:	d110      	bne.n	9001bb7e <_malloc_trim_r+0x7e>
9001bb5c:	2100      	movs	r1, #0
9001bb5e:	4630      	mov	r0, r6
9001bb60:	f000 fea6 	bl	9001c8b0 <_sbrk_r>
9001bb64:	68ba      	ldr	r2, [r7, #8]
9001bb66:	1a83      	subs	r3, r0, r2
9001bb68:	2b0f      	cmp	r3, #15
9001bb6a:	dde3      	ble.n	9001bb34 <_malloc_trim_r+0x34>
9001bb6c:	490c      	ldr	r1, [pc, #48]	; (9001bba0 <_malloc_trim_r+0xa0>)
9001bb6e:	6809      	ldr	r1, [r1, #0]
9001bb70:	1a40      	subs	r0, r0, r1
9001bb72:	490c      	ldr	r1, [pc, #48]	; (9001bba4 <_malloc_trim_r+0xa4>)
9001bb74:	f043 0301 	orr.w	r3, r3, #1
9001bb78:	6008      	str	r0, [r1, #0]
9001bb7a:	6053      	str	r3, [r2, #4]
9001bb7c:	e7da      	b.n	9001bb34 <_malloc_trim_r+0x34>
9001bb7e:	68bb      	ldr	r3, [r7, #8]
9001bb80:	4a08      	ldr	r2, [pc, #32]	; (9001bba4 <_malloc_trim_r+0xa4>)
9001bb82:	1b2d      	subs	r5, r5, r4
9001bb84:	f045 0501 	orr.w	r5, r5, #1
9001bb88:	605d      	str	r5, [r3, #4]
9001bb8a:	6813      	ldr	r3, [r2, #0]
9001bb8c:	4630      	mov	r0, r6
9001bb8e:	1b1c      	subs	r4, r3, r4
9001bb90:	6014      	str	r4, [r2, #0]
9001bb92:	f000 fb19 	bl	9001c1c8 <__malloc_unlock>
9001bb96:	2001      	movs	r0, #1
9001bb98:	e7d0      	b.n	9001bb3c <_malloc_trim_r+0x3c>
9001bb9a:	bf00      	nop
9001bb9c:	24000be4 	.word	0x24000be4
9001bba0:	24000fec 	.word	0x24000fec
9001bba4:	240028d8 	.word	0x240028d8

9001bba8 <_free_r>:
9001bba8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9001bbaa:	4605      	mov	r5, r0
9001bbac:	460f      	mov	r7, r1
9001bbae:	2900      	cmp	r1, #0
9001bbb0:	f000 80b1 	beq.w	9001bd16 <_free_r+0x16e>
9001bbb4:	f000 fb02 	bl	9001c1bc <__malloc_lock>
9001bbb8:	f857 2c04 	ldr.w	r2, [r7, #-4]
9001bbbc:	4856      	ldr	r0, [pc, #344]	; (9001bd18 <_free_r+0x170>)
9001bbbe:	f022 0401 	bic.w	r4, r2, #1
9001bbc2:	f1a7 0308 	sub.w	r3, r7, #8
9001bbc6:	eb03 0c04 	add.w	ip, r3, r4
9001bbca:	6881      	ldr	r1, [r0, #8]
9001bbcc:	f8dc 6004 	ldr.w	r6, [ip, #4]
9001bbd0:	4561      	cmp	r1, ip
9001bbd2:	f026 0603 	bic.w	r6, r6, #3
9001bbd6:	f002 0201 	and.w	r2, r2, #1
9001bbda:	d11b      	bne.n	9001bc14 <_free_r+0x6c>
9001bbdc:	4434      	add	r4, r6
9001bbde:	b93a      	cbnz	r2, 9001bbf0 <_free_r+0x48>
9001bbe0:	f857 2c08 	ldr.w	r2, [r7, #-8]
9001bbe4:	1a9b      	subs	r3, r3, r2
9001bbe6:	4414      	add	r4, r2
9001bbe8:	e9d3 1202 	ldrd	r1, r2, [r3, #8]
9001bbec:	60ca      	str	r2, [r1, #12]
9001bbee:	6091      	str	r1, [r2, #8]
9001bbf0:	f044 0201 	orr.w	r2, r4, #1
9001bbf4:	605a      	str	r2, [r3, #4]
9001bbf6:	6083      	str	r3, [r0, #8]
9001bbf8:	4b48      	ldr	r3, [pc, #288]	; (9001bd1c <_free_r+0x174>)
9001bbfa:	681b      	ldr	r3, [r3, #0]
9001bbfc:	42a3      	cmp	r3, r4
9001bbfe:	d804      	bhi.n	9001bc0a <_free_r+0x62>
9001bc00:	4b47      	ldr	r3, [pc, #284]	; (9001bd20 <_free_r+0x178>)
9001bc02:	4628      	mov	r0, r5
9001bc04:	6819      	ldr	r1, [r3, #0]
9001bc06:	f7ff ff7b 	bl	9001bb00 <_malloc_trim_r>
9001bc0a:	4628      	mov	r0, r5
9001bc0c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
9001bc10:	f000 bada 	b.w	9001c1c8 <__malloc_unlock>
9001bc14:	f8cc 6004 	str.w	r6, [ip, #4]
9001bc18:	2a00      	cmp	r2, #0
9001bc1a:	d138      	bne.n	9001bc8e <_free_r+0xe6>
9001bc1c:	f857 1c08 	ldr.w	r1, [r7, #-8]
9001bc20:	1a5b      	subs	r3, r3, r1
9001bc22:	440c      	add	r4, r1
9001bc24:	6899      	ldr	r1, [r3, #8]
9001bc26:	f100 0708 	add.w	r7, r0, #8
9001bc2a:	42b9      	cmp	r1, r7
9001bc2c:	d031      	beq.n	9001bc92 <_free_r+0xea>
9001bc2e:	68df      	ldr	r7, [r3, #12]
9001bc30:	60cf      	str	r7, [r1, #12]
9001bc32:	60b9      	str	r1, [r7, #8]
9001bc34:	eb0c 0106 	add.w	r1, ip, r6
9001bc38:	6849      	ldr	r1, [r1, #4]
9001bc3a:	07c9      	lsls	r1, r1, #31
9001bc3c:	d40b      	bmi.n	9001bc56 <_free_r+0xae>
9001bc3e:	f8dc 1008 	ldr.w	r1, [ip, #8]
9001bc42:	4434      	add	r4, r6
9001bc44:	bb3a      	cbnz	r2, 9001bc96 <_free_r+0xee>
9001bc46:	4e37      	ldr	r6, [pc, #220]	; (9001bd24 <_free_r+0x17c>)
9001bc48:	42b1      	cmp	r1, r6
9001bc4a:	d124      	bne.n	9001bc96 <_free_r+0xee>
9001bc4c:	e9c0 3304 	strd	r3, r3, [r0, #16]
9001bc50:	e9c3 1102 	strd	r1, r1, [r3, #8]
9001bc54:	2201      	movs	r2, #1
9001bc56:	f044 0101 	orr.w	r1, r4, #1
9001bc5a:	6059      	str	r1, [r3, #4]
9001bc5c:	511c      	str	r4, [r3, r4]
9001bc5e:	2a00      	cmp	r2, #0
9001bc60:	d1d3      	bne.n	9001bc0a <_free_r+0x62>
9001bc62:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
9001bc66:	d21b      	bcs.n	9001bca0 <_free_r+0xf8>
9001bc68:	0961      	lsrs	r1, r4, #5
9001bc6a:	08e2      	lsrs	r2, r4, #3
9001bc6c:	2401      	movs	r4, #1
9001bc6e:	408c      	lsls	r4, r1
9001bc70:	6841      	ldr	r1, [r0, #4]
9001bc72:	3201      	adds	r2, #1
9001bc74:	430c      	orrs	r4, r1
9001bc76:	6044      	str	r4, [r0, #4]
9001bc78:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
9001bc7c:	f850 4032 	ldr.w	r4, [r0, r2, lsl #3]
9001bc80:	3908      	subs	r1, #8
9001bc82:	e9c3 4102 	strd	r4, r1, [r3, #8]
9001bc86:	f840 3032 	str.w	r3, [r0, r2, lsl #3]
9001bc8a:	60e3      	str	r3, [r4, #12]
9001bc8c:	e7bd      	b.n	9001bc0a <_free_r+0x62>
9001bc8e:	2200      	movs	r2, #0
9001bc90:	e7d0      	b.n	9001bc34 <_free_r+0x8c>
9001bc92:	2201      	movs	r2, #1
9001bc94:	e7ce      	b.n	9001bc34 <_free_r+0x8c>
9001bc96:	f8dc 600c 	ldr.w	r6, [ip, #12]
9001bc9a:	60ce      	str	r6, [r1, #12]
9001bc9c:	60b1      	str	r1, [r6, #8]
9001bc9e:	e7da      	b.n	9001bc56 <_free_r+0xae>
9001bca0:	f5b4 6f20 	cmp.w	r4, #2560	; 0xa00
9001bca4:	ea4f 2254 	mov.w	r2, r4, lsr #9
9001bca8:	d214      	bcs.n	9001bcd4 <_free_r+0x12c>
9001bcaa:	09a2      	lsrs	r2, r4, #6
9001bcac:	3238      	adds	r2, #56	; 0x38
9001bcae:	1c51      	adds	r1, r2, #1
9001bcb0:	eb00 06c2 	add.w	r6, r0, r2, lsl #3
9001bcb4:	f850 1031 	ldr.w	r1, [r0, r1, lsl #3]
9001bcb8:	428e      	cmp	r6, r1
9001bcba:	d125      	bne.n	9001bd08 <_free_r+0x160>
9001bcbc:	2401      	movs	r4, #1
9001bcbe:	1092      	asrs	r2, r2, #2
9001bcc0:	fa04 f202 	lsl.w	r2, r4, r2
9001bcc4:	6844      	ldr	r4, [r0, #4]
9001bcc6:	4322      	orrs	r2, r4
9001bcc8:	6042      	str	r2, [r0, #4]
9001bcca:	e9c3 1602 	strd	r1, r6, [r3, #8]
9001bcce:	60b3      	str	r3, [r6, #8]
9001bcd0:	60cb      	str	r3, [r1, #12]
9001bcd2:	e79a      	b.n	9001bc0a <_free_r+0x62>
9001bcd4:	2a14      	cmp	r2, #20
9001bcd6:	d801      	bhi.n	9001bcdc <_free_r+0x134>
9001bcd8:	325b      	adds	r2, #91	; 0x5b
9001bcda:	e7e8      	b.n	9001bcae <_free_r+0x106>
9001bcdc:	2a54      	cmp	r2, #84	; 0x54
9001bcde:	d802      	bhi.n	9001bce6 <_free_r+0x13e>
9001bce0:	0b22      	lsrs	r2, r4, #12
9001bce2:	326e      	adds	r2, #110	; 0x6e
9001bce4:	e7e3      	b.n	9001bcae <_free_r+0x106>
9001bce6:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
9001bcea:	d802      	bhi.n	9001bcf2 <_free_r+0x14a>
9001bcec:	0be2      	lsrs	r2, r4, #15
9001bcee:	3277      	adds	r2, #119	; 0x77
9001bcf0:	e7dd      	b.n	9001bcae <_free_r+0x106>
9001bcf2:	f240 5154 	movw	r1, #1364	; 0x554
9001bcf6:	428a      	cmp	r2, r1
9001bcf8:	bf9a      	itte	ls
9001bcfa:	0ca2      	lsrls	r2, r4, #18
9001bcfc:	327c      	addls	r2, #124	; 0x7c
9001bcfe:	227e      	movhi	r2, #126	; 0x7e
9001bd00:	e7d5      	b.n	9001bcae <_free_r+0x106>
9001bd02:	6889      	ldr	r1, [r1, #8]
9001bd04:	428e      	cmp	r6, r1
9001bd06:	d004      	beq.n	9001bd12 <_free_r+0x16a>
9001bd08:	684a      	ldr	r2, [r1, #4]
9001bd0a:	f022 0203 	bic.w	r2, r2, #3
9001bd0e:	42a2      	cmp	r2, r4
9001bd10:	d8f7      	bhi.n	9001bd02 <_free_r+0x15a>
9001bd12:	68ce      	ldr	r6, [r1, #12]
9001bd14:	e7d9      	b.n	9001bcca <_free_r+0x122>
9001bd16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
9001bd18:	24000be4 	.word	0x24000be4
9001bd1c:	24000ff0 	.word	0x24000ff0
9001bd20:	24002908 	.word	0x24002908
9001bd24:	24000bec 	.word	0x24000bec

9001bd28 <_localeconv_r>:
9001bd28:	4800      	ldr	r0, [pc, #0]	; (9001bd2c <_localeconv_r+0x4>)
9001bd2a:	4770      	bx	lr
9001bd2c:	240010e4 	.word	0x240010e4

9001bd30 <__retarget_lock_init_recursive>:
9001bd30:	4770      	bx	lr

9001bd32 <__retarget_lock_close_recursive>:
9001bd32:	4770      	bx	lr

9001bd34 <__retarget_lock_acquire_recursive>:
9001bd34:	4770      	bx	lr

9001bd36 <__retarget_lock_release_recursive>:
9001bd36:	4770      	bx	lr

9001bd38 <_malloc_r>:
9001bd38:	f101 030b 	add.w	r3, r1, #11
9001bd3c:	2b16      	cmp	r3, #22
9001bd3e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001bd42:	4605      	mov	r5, r0
9001bd44:	d906      	bls.n	9001bd54 <_malloc_r+0x1c>
9001bd46:	f033 0707 	bics.w	r7, r3, #7
9001bd4a:	d504      	bpl.n	9001bd56 <_malloc_r+0x1e>
9001bd4c:	230c      	movs	r3, #12
9001bd4e:	602b      	str	r3, [r5, #0]
9001bd50:	2400      	movs	r4, #0
9001bd52:	e1ae      	b.n	9001c0b2 <_malloc_r+0x37a>
9001bd54:	2710      	movs	r7, #16
9001bd56:	42b9      	cmp	r1, r7
9001bd58:	d8f8      	bhi.n	9001bd4c <_malloc_r+0x14>
9001bd5a:	4628      	mov	r0, r5
9001bd5c:	f000 fa2e 	bl	9001c1bc <__malloc_lock>
9001bd60:	f5b7 7ffc 	cmp.w	r7, #504	; 0x1f8
9001bd64:	4ec3      	ldr	r6, [pc, #780]	; (9001c074 <_malloc_r+0x33c>)
9001bd66:	d238      	bcs.n	9001bdda <_malloc_r+0xa2>
9001bd68:	f107 0208 	add.w	r2, r7, #8
9001bd6c:	4432      	add	r2, r6
9001bd6e:	f1a2 0108 	sub.w	r1, r2, #8
9001bd72:	6854      	ldr	r4, [r2, #4]
9001bd74:	428c      	cmp	r4, r1
9001bd76:	ea4f 03d7 	mov.w	r3, r7, lsr #3
9001bd7a:	d102      	bne.n	9001bd82 <_malloc_r+0x4a>
9001bd7c:	68d4      	ldr	r4, [r2, #12]
9001bd7e:	42a2      	cmp	r2, r4
9001bd80:	d010      	beq.n	9001bda4 <_malloc_r+0x6c>
9001bd82:	6863      	ldr	r3, [r4, #4]
9001bd84:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
9001bd88:	f023 0303 	bic.w	r3, r3, #3
9001bd8c:	60ca      	str	r2, [r1, #12]
9001bd8e:	4423      	add	r3, r4
9001bd90:	6091      	str	r1, [r2, #8]
9001bd92:	685a      	ldr	r2, [r3, #4]
9001bd94:	f042 0201 	orr.w	r2, r2, #1
9001bd98:	605a      	str	r2, [r3, #4]
9001bd9a:	4628      	mov	r0, r5
9001bd9c:	f000 fa14 	bl	9001c1c8 <__malloc_unlock>
9001bda0:	3408      	adds	r4, #8
9001bda2:	e186      	b.n	9001c0b2 <_malloc_r+0x37a>
9001bda4:	3302      	adds	r3, #2
9001bda6:	4ab4      	ldr	r2, [pc, #720]	; (9001c078 <_malloc_r+0x340>)
9001bda8:	6934      	ldr	r4, [r6, #16]
9001bdaa:	4294      	cmp	r4, r2
9001bdac:	4611      	mov	r1, r2
9001bdae:	d077      	beq.n	9001bea0 <_malloc_r+0x168>
9001bdb0:	6860      	ldr	r0, [r4, #4]
9001bdb2:	f020 0c03 	bic.w	ip, r0, #3
9001bdb6:	ebac 0007 	sub.w	r0, ip, r7
9001bdba:	280f      	cmp	r0, #15
9001bdbc:	dd48      	ble.n	9001be50 <_malloc_r+0x118>
9001bdbe:	19e1      	adds	r1, r4, r7
9001bdc0:	f040 0301 	orr.w	r3, r0, #1
9001bdc4:	f047 0701 	orr.w	r7, r7, #1
9001bdc8:	6067      	str	r7, [r4, #4]
9001bdca:	e9c6 1104 	strd	r1, r1, [r6, #16]
9001bdce:	e9c1 2202 	strd	r2, r2, [r1, #8]
9001bdd2:	604b      	str	r3, [r1, #4]
9001bdd4:	f844 000c 	str.w	r0, [r4, ip]
9001bdd8:	e7df      	b.n	9001bd9a <_malloc_r+0x62>
9001bdda:	0a7b      	lsrs	r3, r7, #9
9001bddc:	d02a      	beq.n	9001be34 <_malloc_r+0xfc>
9001bdde:	2b04      	cmp	r3, #4
9001bde0:	d812      	bhi.n	9001be08 <_malloc_r+0xd0>
9001bde2:	09bb      	lsrs	r3, r7, #6
9001bde4:	3338      	adds	r3, #56	; 0x38
9001bde6:	1c5a      	adds	r2, r3, #1
9001bde8:	eb06 02c2 	add.w	r2, r6, r2, lsl #3
9001bdec:	f1a2 0c08 	sub.w	ip, r2, #8
9001bdf0:	6854      	ldr	r4, [r2, #4]
9001bdf2:	4564      	cmp	r4, ip
9001bdf4:	d006      	beq.n	9001be04 <_malloc_r+0xcc>
9001bdf6:	6862      	ldr	r2, [r4, #4]
9001bdf8:	f022 0203 	bic.w	r2, r2, #3
9001bdfc:	1bd0      	subs	r0, r2, r7
9001bdfe:	280f      	cmp	r0, #15
9001be00:	dd1c      	ble.n	9001be3c <_malloc_r+0x104>
9001be02:	3b01      	subs	r3, #1
9001be04:	3301      	adds	r3, #1
9001be06:	e7ce      	b.n	9001bda6 <_malloc_r+0x6e>
9001be08:	2b14      	cmp	r3, #20
9001be0a:	d801      	bhi.n	9001be10 <_malloc_r+0xd8>
9001be0c:	335b      	adds	r3, #91	; 0x5b
9001be0e:	e7ea      	b.n	9001bde6 <_malloc_r+0xae>
9001be10:	2b54      	cmp	r3, #84	; 0x54
9001be12:	d802      	bhi.n	9001be1a <_malloc_r+0xe2>
9001be14:	0b3b      	lsrs	r3, r7, #12
9001be16:	336e      	adds	r3, #110	; 0x6e
9001be18:	e7e5      	b.n	9001bde6 <_malloc_r+0xae>
9001be1a:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
9001be1e:	d802      	bhi.n	9001be26 <_malloc_r+0xee>
9001be20:	0bfb      	lsrs	r3, r7, #15
9001be22:	3377      	adds	r3, #119	; 0x77
9001be24:	e7df      	b.n	9001bde6 <_malloc_r+0xae>
9001be26:	f240 5254 	movw	r2, #1364	; 0x554
9001be2a:	4293      	cmp	r3, r2
9001be2c:	d804      	bhi.n	9001be38 <_malloc_r+0x100>
9001be2e:	0cbb      	lsrs	r3, r7, #18
9001be30:	337c      	adds	r3, #124	; 0x7c
9001be32:	e7d8      	b.n	9001bde6 <_malloc_r+0xae>
9001be34:	233f      	movs	r3, #63	; 0x3f
9001be36:	e7d6      	b.n	9001bde6 <_malloc_r+0xae>
9001be38:	237e      	movs	r3, #126	; 0x7e
9001be3a:	e7d4      	b.n	9001bde6 <_malloc_r+0xae>
9001be3c:	2800      	cmp	r0, #0
9001be3e:	68e1      	ldr	r1, [r4, #12]
9001be40:	db04      	blt.n	9001be4c <_malloc_r+0x114>
9001be42:	68a3      	ldr	r3, [r4, #8]
9001be44:	60d9      	str	r1, [r3, #12]
9001be46:	608b      	str	r3, [r1, #8]
9001be48:	18a3      	adds	r3, r4, r2
9001be4a:	e7a2      	b.n	9001bd92 <_malloc_r+0x5a>
9001be4c:	460c      	mov	r4, r1
9001be4e:	e7d0      	b.n	9001bdf2 <_malloc_r+0xba>
9001be50:	2800      	cmp	r0, #0
9001be52:	e9c6 2204 	strd	r2, r2, [r6, #16]
9001be56:	db07      	blt.n	9001be68 <_malloc_r+0x130>
9001be58:	44a4      	add	ip, r4
9001be5a:	f8dc 3004 	ldr.w	r3, [ip, #4]
9001be5e:	f043 0301 	orr.w	r3, r3, #1
9001be62:	f8cc 3004 	str.w	r3, [ip, #4]
9001be66:	e798      	b.n	9001bd9a <_malloc_r+0x62>
9001be68:	f5bc 7f00 	cmp.w	ip, #512	; 0x200
9001be6c:	6870      	ldr	r0, [r6, #4]
9001be6e:	f080 809e 	bcs.w	9001bfae <_malloc_r+0x276>
9001be72:	ea4f 02dc 	mov.w	r2, ip, lsr #3
9001be76:	ea4f 1e5c 	mov.w	lr, ip, lsr #5
9001be7a:	f04f 0c01 	mov.w	ip, #1
9001be7e:	3201      	adds	r2, #1
9001be80:	fa0c fc0e 	lsl.w	ip, ip, lr
9001be84:	ea4c 0000 	orr.w	r0, ip, r0
9001be88:	6070      	str	r0, [r6, #4]
9001be8a:	f856 c032 	ldr.w	ip, [r6, r2, lsl #3]
9001be8e:	eb06 00c2 	add.w	r0, r6, r2, lsl #3
9001be92:	3808      	subs	r0, #8
9001be94:	e9c4 c002 	strd	ip, r0, [r4, #8]
9001be98:	f846 4032 	str.w	r4, [r6, r2, lsl #3]
9001be9c:	f8cc 400c 	str.w	r4, [ip, #12]
9001bea0:	2001      	movs	r0, #1
9001bea2:	109a      	asrs	r2, r3, #2
9001bea4:	fa00 f202 	lsl.w	r2, r0, r2
9001bea8:	6870      	ldr	r0, [r6, #4]
9001beaa:	4290      	cmp	r0, r2
9001beac:	d326      	bcc.n	9001befc <_malloc_r+0x1c4>
9001beae:	4210      	tst	r0, r2
9001beb0:	d106      	bne.n	9001bec0 <_malloc_r+0x188>
9001beb2:	f023 0303 	bic.w	r3, r3, #3
9001beb6:	0052      	lsls	r2, r2, #1
9001beb8:	4210      	tst	r0, r2
9001beba:	f103 0304 	add.w	r3, r3, #4
9001bebe:	d0fa      	beq.n	9001beb6 <_malloc_r+0x17e>
9001bec0:	eb06 08c3 	add.w	r8, r6, r3, lsl #3
9001bec4:	46c1      	mov	r9, r8
9001bec6:	469e      	mov	lr, r3
9001bec8:	f8d9 400c 	ldr.w	r4, [r9, #12]
9001becc:	454c      	cmp	r4, r9
9001bece:	f040 80b3 	bne.w	9001c038 <_malloc_r+0x300>
9001bed2:	f10e 0e01 	add.w	lr, lr, #1
9001bed6:	f01e 0f03 	tst.w	lr, #3
9001beda:	f109 0908 	add.w	r9, r9, #8
9001bede:	d1f3      	bne.n	9001bec8 <_malloc_r+0x190>
9001bee0:	0798      	lsls	r0, r3, #30
9001bee2:	f040 80ec 	bne.w	9001c0be <_malloc_r+0x386>
9001bee6:	6873      	ldr	r3, [r6, #4]
9001bee8:	ea23 0302 	bic.w	r3, r3, r2
9001beec:	6073      	str	r3, [r6, #4]
9001beee:	6870      	ldr	r0, [r6, #4]
9001bef0:	0052      	lsls	r2, r2, #1
9001bef2:	4290      	cmp	r0, r2
9001bef4:	d302      	bcc.n	9001befc <_malloc_r+0x1c4>
9001bef6:	2a00      	cmp	r2, #0
9001bef8:	f040 80ee 	bne.w	9001c0d8 <_malloc_r+0x3a0>
9001befc:	f8d6 b008 	ldr.w	fp, [r6, #8]
9001bf00:	f8db 1004 	ldr.w	r1, [fp, #4]
9001bf04:	f021 0903 	bic.w	r9, r1, #3
9001bf08:	45b9      	cmp	r9, r7
9001bf0a:	d304      	bcc.n	9001bf16 <_malloc_r+0x1de>
9001bf0c:	eba9 0207 	sub.w	r2, r9, r7
9001bf10:	2a0f      	cmp	r2, #15
9001bf12:	f300 8149 	bgt.w	9001c1a8 <_malloc_r+0x470>
9001bf16:	4a59      	ldr	r2, [pc, #356]	; (9001c07c <_malloc_r+0x344>)
9001bf18:	6811      	ldr	r1, [r2, #0]
9001bf1a:	3110      	adds	r1, #16
9001bf1c:	eb0b 0309 	add.w	r3, fp, r9
9001bf20:	4439      	add	r1, r7
9001bf22:	2008      	movs	r0, #8
9001bf24:	9301      	str	r3, [sp, #4]
9001bf26:	9100      	str	r1, [sp, #0]
9001bf28:	f000 fd60 	bl	9001c9ec <sysconf>
9001bf2c:	4a54      	ldr	r2, [pc, #336]	; (9001c080 <_malloc_r+0x348>)
9001bf2e:	e9dd 1300 	ldrd	r1, r3, [sp]
9001bf32:	4680      	mov	r8, r0
9001bf34:	6810      	ldr	r0, [r2, #0]
9001bf36:	3001      	adds	r0, #1
9001bf38:	bf1f      	itttt	ne
9001bf3a:	f101 31ff 	addne.w	r1, r1, #4294967295	; 0xffffffff
9001bf3e:	4441      	addne	r1, r8
9001bf40:	f1c8 0000 	rsbne	r0, r8, #0
9001bf44:	4001      	andne	r1, r0
9001bf46:	4628      	mov	r0, r5
9001bf48:	e9cd 1300 	strd	r1, r3, [sp]
9001bf4c:	f000 fcb0 	bl	9001c8b0 <_sbrk_r>
9001bf50:	1c42      	adds	r2, r0, #1
9001bf52:	4604      	mov	r4, r0
9001bf54:	f000 80fc 	beq.w	9001c150 <_malloc_r+0x418>
9001bf58:	9b01      	ldr	r3, [sp, #4]
9001bf5a:	9900      	ldr	r1, [sp, #0]
9001bf5c:	4a48      	ldr	r2, [pc, #288]	; (9001c080 <_malloc_r+0x348>)
9001bf5e:	4283      	cmp	r3, r0
9001bf60:	d902      	bls.n	9001bf68 <_malloc_r+0x230>
9001bf62:	45b3      	cmp	fp, r6
9001bf64:	f040 80f4 	bne.w	9001c150 <_malloc_r+0x418>
9001bf68:	f8df a120 	ldr.w	sl, [pc, #288]	; 9001c08c <_malloc_r+0x354>
9001bf6c:	f8da 0000 	ldr.w	r0, [sl]
9001bf70:	42a3      	cmp	r3, r4
9001bf72:	eb00 0e01 	add.w	lr, r0, r1
9001bf76:	f8ca e000 	str.w	lr, [sl]
9001bf7a:	f108 3cff 	add.w	ip, r8, #4294967295	; 0xffffffff
9001bf7e:	f040 80ad 	bne.w	9001c0dc <_malloc_r+0x3a4>
9001bf82:	ea13 0f0c 	tst.w	r3, ip
9001bf86:	f040 80a9 	bne.w	9001c0dc <_malloc_r+0x3a4>
9001bf8a:	68b3      	ldr	r3, [r6, #8]
9001bf8c:	4449      	add	r1, r9
9001bf8e:	f041 0101 	orr.w	r1, r1, #1
9001bf92:	6059      	str	r1, [r3, #4]
9001bf94:	4a3b      	ldr	r2, [pc, #236]	; (9001c084 <_malloc_r+0x34c>)
9001bf96:	f8da 3000 	ldr.w	r3, [sl]
9001bf9a:	6811      	ldr	r1, [r2, #0]
9001bf9c:	428b      	cmp	r3, r1
9001bf9e:	bf88      	it	hi
9001bfa0:	6013      	strhi	r3, [r2, #0]
9001bfa2:	4a39      	ldr	r2, [pc, #228]	; (9001c088 <_malloc_r+0x350>)
9001bfa4:	6811      	ldr	r1, [r2, #0]
9001bfa6:	428b      	cmp	r3, r1
9001bfa8:	bf88      	it	hi
9001bfaa:	6013      	strhi	r3, [r2, #0]
9001bfac:	e0d0      	b.n	9001c150 <_malloc_r+0x418>
9001bfae:	f5bc 6f20 	cmp.w	ip, #2560	; 0xa00
9001bfb2:	ea4f 225c 	mov.w	r2, ip, lsr #9
9001bfb6:	d218      	bcs.n	9001bfea <_malloc_r+0x2b2>
9001bfb8:	ea4f 129c 	mov.w	r2, ip, lsr #6
9001bfbc:	3238      	adds	r2, #56	; 0x38
9001bfbe:	f102 0e01 	add.w	lr, r2, #1
9001bfc2:	eb06 08c2 	add.w	r8, r6, r2, lsl #3
9001bfc6:	f856 e03e 	ldr.w	lr, [r6, lr, lsl #3]
9001bfca:	45f0      	cmp	r8, lr
9001bfcc:	d12b      	bne.n	9001c026 <_malloc_r+0x2ee>
9001bfce:	1092      	asrs	r2, r2, #2
9001bfd0:	f04f 0c01 	mov.w	ip, #1
9001bfd4:	fa0c f202 	lsl.w	r2, ip, r2
9001bfd8:	4310      	orrs	r0, r2
9001bfda:	6070      	str	r0, [r6, #4]
9001bfdc:	e9c4 e802 	strd	lr, r8, [r4, #8]
9001bfe0:	f8c8 4008 	str.w	r4, [r8, #8]
9001bfe4:	f8ce 400c 	str.w	r4, [lr, #12]
9001bfe8:	e75a      	b.n	9001bea0 <_malloc_r+0x168>
9001bfea:	2a14      	cmp	r2, #20
9001bfec:	d801      	bhi.n	9001bff2 <_malloc_r+0x2ba>
9001bfee:	325b      	adds	r2, #91	; 0x5b
9001bff0:	e7e5      	b.n	9001bfbe <_malloc_r+0x286>
9001bff2:	2a54      	cmp	r2, #84	; 0x54
9001bff4:	d803      	bhi.n	9001bffe <_malloc_r+0x2c6>
9001bff6:	ea4f 321c 	mov.w	r2, ip, lsr #12
9001bffa:	326e      	adds	r2, #110	; 0x6e
9001bffc:	e7df      	b.n	9001bfbe <_malloc_r+0x286>
9001bffe:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
9001c002:	d803      	bhi.n	9001c00c <_malloc_r+0x2d4>
9001c004:	ea4f 32dc 	mov.w	r2, ip, lsr #15
9001c008:	3277      	adds	r2, #119	; 0x77
9001c00a:	e7d8      	b.n	9001bfbe <_malloc_r+0x286>
9001c00c:	f240 5e54 	movw	lr, #1364	; 0x554
9001c010:	4572      	cmp	r2, lr
9001c012:	bf9a      	itte	ls
9001c014:	ea4f 429c 	movls.w	r2, ip, lsr #18
9001c018:	327c      	addls	r2, #124	; 0x7c
9001c01a:	227e      	movhi	r2, #126	; 0x7e
9001c01c:	e7cf      	b.n	9001bfbe <_malloc_r+0x286>
9001c01e:	f8de e008 	ldr.w	lr, [lr, #8]
9001c022:	45f0      	cmp	r8, lr
9001c024:	d005      	beq.n	9001c032 <_malloc_r+0x2fa>
9001c026:	f8de 2004 	ldr.w	r2, [lr, #4]
9001c02a:	f022 0203 	bic.w	r2, r2, #3
9001c02e:	4562      	cmp	r2, ip
9001c030:	d8f5      	bhi.n	9001c01e <_malloc_r+0x2e6>
9001c032:	f8de 800c 	ldr.w	r8, [lr, #12]
9001c036:	e7d1      	b.n	9001bfdc <_malloc_r+0x2a4>
9001c038:	6860      	ldr	r0, [r4, #4]
9001c03a:	f8d4 c00c 	ldr.w	ip, [r4, #12]
9001c03e:	f020 0003 	bic.w	r0, r0, #3
9001c042:	eba0 0a07 	sub.w	sl, r0, r7
9001c046:	f1ba 0f0f 	cmp.w	sl, #15
9001c04a:	dd21      	ble.n	9001c090 <_malloc_r+0x358>
9001c04c:	68a3      	ldr	r3, [r4, #8]
9001c04e:	19e2      	adds	r2, r4, r7
9001c050:	f047 0701 	orr.w	r7, r7, #1
9001c054:	6067      	str	r7, [r4, #4]
9001c056:	f8c3 c00c 	str.w	ip, [r3, #12]
9001c05a:	f8cc 3008 	str.w	r3, [ip, #8]
9001c05e:	f04a 0301 	orr.w	r3, sl, #1
9001c062:	e9c6 2204 	strd	r2, r2, [r6, #16]
9001c066:	e9c2 1102 	strd	r1, r1, [r2, #8]
9001c06a:	6053      	str	r3, [r2, #4]
9001c06c:	f844 a000 	str.w	sl, [r4, r0]
9001c070:	e693      	b.n	9001bd9a <_malloc_r+0x62>
9001c072:	bf00      	nop
9001c074:	24000be4 	.word	0x24000be4
9001c078:	24000bec 	.word	0x24000bec
9001c07c:	24002908 	.word	0x24002908
9001c080:	24000fec 	.word	0x24000fec
9001c084:	24002900 	.word	0x24002900
9001c088:	24002904 	.word	0x24002904
9001c08c:	240028d8 	.word	0x240028d8
9001c090:	f1ba 0f00 	cmp.w	sl, #0
9001c094:	db11      	blt.n	9001c0ba <_malloc_r+0x382>
9001c096:	4420      	add	r0, r4
9001c098:	6843      	ldr	r3, [r0, #4]
9001c09a:	f043 0301 	orr.w	r3, r3, #1
9001c09e:	6043      	str	r3, [r0, #4]
9001c0a0:	f854 3f08 	ldr.w	r3, [r4, #8]!
9001c0a4:	4628      	mov	r0, r5
9001c0a6:	f8c3 c00c 	str.w	ip, [r3, #12]
9001c0aa:	f8cc 3008 	str.w	r3, [ip, #8]
9001c0ae:	f000 f88b 	bl	9001c1c8 <__malloc_unlock>
9001c0b2:	4620      	mov	r0, r4
9001c0b4:	b003      	add	sp, #12
9001c0b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
9001c0ba:	4664      	mov	r4, ip
9001c0bc:	e706      	b.n	9001becc <_malloc_r+0x194>
9001c0be:	f858 0908 	ldr.w	r0, [r8], #-8
9001c0c2:	4540      	cmp	r0, r8
9001c0c4:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
9001c0c8:	f43f af0a 	beq.w	9001bee0 <_malloc_r+0x1a8>
9001c0cc:	e70f      	b.n	9001beee <_malloc_r+0x1b6>
9001c0ce:	3304      	adds	r3, #4
9001c0d0:	0052      	lsls	r2, r2, #1
9001c0d2:	4210      	tst	r0, r2
9001c0d4:	d0fb      	beq.n	9001c0ce <_malloc_r+0x396>
9001c0d6:	e6f3      	b.n	9001bec0 <_malloc_r+0x188>
9001c0d8:	4673      	mov	r3, lr
9001c0da:	e7fa      	b.n	9001c0d2 <_malloc_r+0x39a>
9001c0dc:	6810      	ldr	r0, [r2, #0]
9001c0de:	3001      	adds	r0, #1
9001c0e0:	bf1b      	ittet	ne
9001c0e2:	1ae3      	subne	r3, r4, r3
9001c0e4:	4473      	addne	r3, lr
9001c0e6:	6014      	streq	r4, [r2, #0]
9001c0e8:	f8ca 3000 	strne.w	r3, [sl]
9001c0ec:	f014 0307 	ands.w	r3, r4, #7
9001c0f0:	bf1a      	itte	ne
9001c0f2:	f1c3 0008 	rsbne	r0, r3, #8
9001c0f6:	1824      	addne	r4, r4, r0
9001c0f8:	4618      	moveq	r0, r3
9001c0fa:	1862      	adds	r2, r4, r1
9001c0fc:	ea02 010c 	and.w	r1, r2, ip
9001c100:	4480      	add	r8, r0
9001c102:	eba8 0801 	sub.w	r8, r8, r1
9001c106:	ea08 080c 	and.w	r8, r8, ip
9001c10a:	4641      	mov	r1, r8
9001c10c:	4628      	mov	r0, r5
9001c10e:	9301      	str	r3, [sp, #4]
9001c110:	9200      	str	r2, [sp, #0]
9001c112:	f000 fbcd 	bl	9001c8b0 <_sbrk_r>
9001c116:	1c43      	adds	r3, r0, #1
9001c118:	e9dd 2300 	ldrd	r2, r3, [sp]
9001c11c:	d105      	bne.n	9001c12a <_malloc_r+0x3f2>
9001c11e:	b32b      	cbz	r3, 9001c16c <_malloc_r+0x434>
9001c120:	f1a3 0008 	sub.w	r0, r3, #8
9001c124:	4410      	add	r0, r2
9001c126:	f04f 0800 	mov.w	r8, #0
9001c12a:	f8da 2000 	ldr.w	r2, [sl]
9001c12e:	60b4      	str	r4, [r6, #8]
9001c130:	1b00      	subs	r0, r0, r4
9001c132:	4440      	add	r0, r8
9001c134:	4442      	add	r2, r8
9001c136:	f040 0001 	orr.w	r0, r0, #1
9001c13a:	45b3      	cmp	fp, r6
9001c13c:	f8ca 2000 	str.w	r2, [sl]
9001c140:	6060      	str	r0, [r4, #4]
9001c142:	f43f af27 	beq.w	9001bf94 <_malloc_r+0x25c>
9001c146:	f1b9 0f0f 	cmp.w	r9, #15
9001c14a:	d812      	bhi.n	9001c172 <_malloc_r+0x43a>
9001c14c:	2301      	movs	r3, #1
9001c14e:	6063      	str	r3, [r4, #4]
9001c150:	68b3      	ldr	r3, [r6, #8]
9001c152:	685b      	ldr	r3, [r3, #4]
9001c154:	f023 0303 	bic.w	r3, r3, #3
9001c158:	42bb      	cmp	r3, r7
9001c15a:	eba3 0207 	sub.w	r2, r3, r7
9001c15e:	d301      	bcc.n	9001c164 <_malloc_r+0x42c>
9001c160:	2a0f      	cmp	r2, #15
9001c162:	dc21      	bgt.n	9001c1a8 <_malloc_r+0x470>
9001c164:	4628      	mov	r0, r5
9001c166:	f000 f82f 	bl	9001c1c8 <__malloc_unlock>
9001c16a:	e5f1      	b.n	9001bd50 <_malloc_r+0x18>
9001c16c:	4610      	mov	r0, r2
9001c16e:	4698      	mov	r8, r3
9001c170:	e7db      	b.n	9001c12a <_malloc_r+0x3f2>
9001c172:	f8db 3004 	ldr.w	r3, [fp, #4]
9001c176:	f1a9 090c 	sub.w	r9, r9, #12
9001c17a:	f029 0907 	bic.w	r9, r9, #7
9001c17e:	f003 0301 	and.w	r3, r3, #1
9001c182:	ea43 0309 	orr.w	r3, r3, r9
9001c186:	f8cb 3004 	str.w	r3, [fp, #4]
9001c18a:	2205      	movs	r2, #5
9001c18c:	eb0b 0309 	add.w	r3, fp, r9
9001c190:	f1b9 0f0f 	cmp.w	r9, #15
9001c194:	e9c3 2201 	strd	r2, r2, [r3, #4]
9001c198:	f67f aefc 	bls.w	9001bf94 <_malloc_r+0x25c>
9001c19c:	f10b 0108 	add.w	r1, fp, #8
9001c1a0:	4628      	mov	r0, r5
9001c1a2:	f7ff fd01 	bl	9001bba8 <_free_r>
9001c1a6:	e6f5      	b.n	9001bf94 <_malloc_r+0x25c>
9001c1a8:	68b4      	ldr	r4, [r6, #8]
9001c1aa:	f047 0301 	orr.w	r3, r7, #1
9001c1ae:	4427      	add	r7, r4
9001c1b0:	f042 0201 	orr.w	r2, r2, #1
9001c1b4:	6063      	str	r3, [r4, #4]
9001c1b6:	60b7      	str	r7, [r6, #8]
9001c1b8:	607a      	str	r2, [r7, #4]
9001c1ba:	e5ee      	b.n	9001bd9a <_malloc_r+0x62>

9001c1bc <__malloc_lock>:
9001c1bc:	4801      	ldr	r0, [pc, #4]	; (9001c1c4 <__malloc_lock+0x8>)
9001c1be:	f7ff bdb9 	b.w	9001bd34 <__retarget_lock_acquire_recursive>
9001c1c2:	bf00      	nop
9001c1c4:	2400b438 	.word	0x2400b438

9001c1c8 <__malloc_unlock>:
9001c1c8:	4801      	ldr	r0, [pc, #4]	; (9001c1d0 <__malloc_unlock+0x8>)
9001c1ca:	f7ff bdb4 	b.w	9001bd36 <__retarget_lock_release_recursive>
9001c1ce:	bf00      	nop
9001c1d0:	2400b438 	.word	0x2400b438

9001c1d4 <_Balloc>:
9001c1d4:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
9001c1d6:	b570      	push	{r4, r5, r6, lr}
9001c1d8:	4605      	mov	r5, r0
9001c1da:	460c      	mov	r4, r1
9001c1dc:	b17b      	cbz	r3, 9001c1fe <_Balloc+0x2a>
9001c1de:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
9001c1e0:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
9001c1e4:	b9a0      	cbnz	r0, 9001c210 <_Balloc+0x3c>
9001c1e6:	2101      	movs	r1, #1
9001c1e8:	fa01 f604 	lsl.w	r6, r1, r4
9001c1ec:	1d72      	adds	r2, r6, #5
9001c1ee:	0092      	lsls	r2, r2, #2
9001c1f0:	4628      	mov	r0, r5
9001c1f2:	f000 fc67 	bl	9001cac4 <_calloc_r>
9001c1f6:	b148      	cbz	r0, 9001c20c <_Balloc+0x38>
9001c1f8:	e9c0 4601 	strd	r4, r6, [r0, #4]
9001c1fc:	e00b      	b.n	9001c216 <_Balloc+0x42>
9001c1fe:	2221      	movs	r2, #33	; 0x21
9001c200:	2104      	movs	r1, #4
9001c202:	f000 fc5f 	bl	9001cac4 <_calloc_r>
9001c206:	64e8      	str	r0, [r5, #76]	; 0x4c
9001c208:	2800      	cmp	r0, #0
9001c20a:	d1e8      	bne.n	9001c1de <_Balloc+0xa>
9001c20c:	2000      	movs	r0, #0
9001c20e:	bd70      	pop	{r4, r5, r6, pc}
9001c210:	6802      	ldr	r2, [r0, #0]
9001c212:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
9001c216:	2300      	movs	r3, #0
9001c218:	e9c0 3303 	strd	r3, r3, [r0, #12]
9001c21c:	e7f7      	b.n	9001c20e <_Balloc+0x3a>

9001c21e <_Bfree>:
9001c21e:	b131      	cbz	r1, 9001c22e <_Bfree+0x10>
9001c220:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
9001c222:	684a      	ldr	r2, [r1, #4]
9001c224:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
9001c228:	6008      	str	r0, [r1, #0]
9001c22a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
9001c22e:	4770      	bx	lr

9001c230 <__multadd>:
9001c230:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
9001c234:	690e      	ldr	r6, [r1, #16]
9001c236:	4607      	mov	r7, r0
9001c238:	4698      	mov	r8, r3
9001c23a:	460c      	mov	r4, r1
9001c23c:	f101 0014 	add.w	r0, r1, #20
9001c240:	2300      	movs	r3, #0
9001c242:	6805      	ldr	r5, [r0, #0]
9001c244:	b2a9      	uxth	r1, r5
9001c246:	fb02 8101 	mla	r1, r2, r1, r8
9001c24a:	ea4f 4c11 	mov.w	ip, r1, lsr #16
9001c24e:	0c2d      	lsrs	r5, r5, #16
9001c250:	fb02 c505 	mla	r5, r2, r5, ip
9001c254:	b289      	uxth	r1, r1
9001c256:	3301      	adds	r3, #1
9001c258:	eb01 4105 	add.w	r1, r1, r5, lsl #16
9001c25c:	429e      	cmp	r6, r3
9001c25e:	f840 1b04 	str.w	r1, [r0], #4
9001c262:	ea4f 4815 	mov.w	r8, r5, lsr #16
9001c266:	dcec      	bgt.n	9001c242 <__multadd+0x12>
9001c268:	f1b8 0f00 	cmp.w	r8, #0
9001c26c:	d022      	beq.n	9001c2b4 <__multadd+0x84>
9001c26e:	68a3      	ldr	r3, [r4, #8]
9001c270:	42b3      	cmp	r3, r6
9001c272:	dc19      	bgt.n	9001c2a8 <__multadd+0x78>
9001c274:	6861      	ldr	r1, [r4, #4]
9001c276:	4638      	mov	r0, r7
9001c278:	3101      	adds	r1, #1
9001c27a:	f7ff ffab 	bl	9001c1d4 <_Balloc>
9001c27e:	4605      	mov	r5, r0
9001c280:	b928      	cbnz	r0, 9001c28e <__multadd+0x5e>
9001c282:	4602      	mov	r2, r0
9001c284:	4b0d      	ldr	r3, [pc, #52]	; (9001c2bc <__multadd+0x8c>)
9001c286:	480e      	ldr	r0, [pc, #56]	; (9001c2c0 <__multadd+0x90>)
9001c288:	21b5      	movs	r1, #181	; 0xb5
9001c28a:	f000 fbfd 	bl	9001ca88 <__assert_func>
9001c28e:	6922      	ldr	r2, [r4, #16]
9001c290:	3202      	adds	r2, #2
9001c292:	f104 010c 	add.w	r1, r4, #12
9001c296:	0092      	lsls	r2, r2, #2
9001c298:	300c      	adds	r0, #12
9001c29a:	f7fd fc73 	bl	90019b84 <memcpy>
9001c29e:	4621      	mov	r1, r4
9001c2a0:	4638      	mov	r0, r7
9001c2a2:	f7ff ffbc 	bl	9001c21e <_Bfree>
9001c2a6:	462c      	mov	r4, r5
9001c2a8:	eb04 0386 	add.w	r3, r4, r6, lsl #2
9001c2ac:	3601      	adds	r6, #1
9001c2ae:	f8c3 8014 	str.w	r8, [r3, #20]
9001c2b2:	6126      	str	r6, [r4, #16]
9001c2b4:	4620      	mov	r0, r4
9001c2b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
9001c2ba:	bf00      	nop
9001c2bc:	900253a5 	.word	0x900253a5
9001c2c0:	90025415 	.word	0x90025415

9001c2c4 <__hi0bits>:
9001c2c4:	0c03      	lsrs	r3, r0, #16
9001c2c6:	041b      	lsls	r3, r3, #16
9001c2c8:	b9d3      	cbnz	r3, 9001c300 <__hi0bits+0x3c>
9001c2ca:	0400      	lsls	r0, r0, #16
9001c2cc:	2310      	movs	r3, #16
9001c2ce:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
9001c2d2:	bf04      	itt	eq
9001c2d4:	0200      	lsleq	r0, r0, #8
9001c2d6:	3308      	addeq	r3, #8
9001c2d8:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
9001c2dc:	bf04      	itt	eq
9001c2de:	0100      	lsleq	r0, r0, #4
9001c2e0:	3304      	addeq	r3, #4
9001c2e2:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
9001c2e6:	bf04      	itt	eq
9001c2e8:	0080      	lsleq	r0, r0, #2
9001c2ea:	3302      	addeq	r3, #2
9001c2ec:	2800      	cmp	r0, #0
9001c2ee:	db05      	blt.n	9001c2fc <__hi0bits+0x38>
9001c2f0:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
9001c2f4:	f103 0301 	add.w	r3, r3, #1
9001c2f8:	bf08      	it	eq
9001c2fa:	2320      	moveq	r3, #32
9001c2fc:	4618      	mov	r0, r3
9001c2fe:	4770      	bx	lr
9001c300:	2300      	movs	r3, #0
9001c302:	e7e4      	b.n	9001c2ce <__hi0bits+0xa>

9001c304 <__lo0bits>:
9001c304:	6803      	ldr	r3, [r0, #0]
9001c306:	f013 0207 	ands.w	r2, r3, #7
9001c30a:	4601      	mov	r1, r0
9001c30c:	d00b      	beq.n	9001c326 <__lo0bits+0x22>
9001c30e:	07da      	lsls	r2, r3, #31
9001c310:	d424      	bmi.n	9001c35c <__lo0bits+0x58>
9001c312:	0798      	lsls	r0, r3, #30
9001c314:	bf49      	itett	mi
9001c316:	085b      	lsrmi	r3, r3, #1
9001c318:	089b      	lsrpl	r3, r3, #2
9001c31a:	2001      	movmi	r0, #1
9001c31c:	600b      	strmi	r3, [r1, #0]
9001c31e:	bf5c      	itt	pl
9001c320:	600b      	strpl	r3, [r1, #0]
9001c322:	2002      	movpl	r0, #2
9001c324:	4770      	bx	lr
9001c326:	b298      	uxth	r0, r3
9001c328:	b9b0      	cbnz	r0, 9001c358 <__lo0bits+0x54>
9001c32a:	0c1b      	lsrs	r3, r3, #16
9001c32c:	2010      	movs	r0, #16
9001c32e:	f013 0fff 	tst.w	r3, #255	; 0xff
9001c332:	bf04      	itt	eq
9001c334:	0a1b      	lsreq	r3, r3, #8
9001c336:	3008      	addeq	r0, #8
9001c338:	071a      	lsls	r2, r3, #28
9001c33a:	bf04      	itt	eq
9001c33c:	091b      	lsreq	r3, r3, #4
9001c33e:	3004      	addeq	r0, #4
9001c340:	079a      	lsls	r2, r3, #30
9001c342:	bf04      	itt	eq
9001c344:	089b      	lsreq	r3, r3, #2
9001c346:	3002      	addeq	r0, #2
9001c348:	07da      	lsls	r2, r3, #31
9001c34a:	d403      	bmi.n	9001c354 <__lo0bits+0x50>
9001c34c:	085b      	lsrs	r3, r3, #1
9001c34e:	f100 0001 	add.w	r0, r0, #1
9001c352:	d005      	beq.n	9001c360 <__lo0bits+0x5c>
9001c354:	600b      	str	r3, [r1, #0]
9001c356:	4770      	bx	lr
9001c358:	4610      	mov	r0, r2
9001c35a:	e7e8      	b.n	9001c32e <__lo0bits+0x2a>
9001c35c:	2000      	movs	r0, #0
9001c35e:	4770      	bx	lr
9001c360:	2020      	movs	r0, #32
9001c362:	4770      	bx	lr

9001c364 <__i2b>:
9001c364:	b510      	push	{r4, lr}
9001c366:	460c      	mov	r4, r1
9001c368:	2101      	movs	r1, #1
9001c36a:	f7ff ff33 	bl	9001c1d4 <_Balloc>
9001c36e:	4602      	mov	r2, r0
9001c370:	b928      	cbnz	r0, 9001c37e <__i2b+0x1a>
9001c372:	4b05      	ldr	r3, [pc, #20]	; (9001c388 <__i2b+0x24>)
9001c374:	4805      	ldr	r0, [pc, #20]	; (9001c38c <__i2b+0x28>)
9001c376:	f44f 71a0 	mov.w	r1, #320	; 0x140
9001c37a:	f000 fb85 	bl	9001ca88 <__assert_func>
9001c37e:	2301      	movs	r3, #1
9001c380:	6144      	str	r4, [r0, #20]
9001c382:	6103      	str	r3, [r0, #16]
9001c384:	bd10      	pop	{r4, pc}
9001c386:	bf00      	nop
9001c388:	900253a5 	.word	0x900253a5
9001c38c:	90025415 	.word	0x90025415

9001c390 <__multiply>:
9001c390:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001c394:	4614      	mov	r4, r2
9001c396:	690a      	ldr	r2, [r1, #16]
9001c398:	6923      	ldr	r3, [r4, #16]
9001c39a:	429a      	cmp	r2, r3
9001c39c:	bfb8      	it	lt
9001c39e:	460b      	movlt	r3, r1
9001c3a0:	460d      	mov	r5, r1
9001c3a2:	bfbc      	itt	lt
9001c3a4:	4625      	movlt	r5, r4
9001c3a6:	461c      	movlt	r4, r3
9001c3a8:	f8d5 a010 	ldr.w	sl, [r5, #16]
9001c3ac:	f8d4 9010 	ldr.w	r9, [r4, #16]
9001c3b0:	68ab      	ldr	r3, [r5, #8]
9001c3b2:	6869      	ldr	r1, [r5, #4]
9001c3b4:	eb0a 0709 	add.w	r7, sl, r9
9001c3b8:	42bb      	cmp	r3, r7
9001c3ba:	b085      	sub	sp, #20
9001c3bc:	bfb8      	it	lt
9001c3be:	3101      	addlt	r1, #1
9001c3c0:	f7ff ff08 	bl	9001c1d4 <_Balloc>
9001c3c4:	b930      	cbnz	r0, 9001c3d4 <__multiply+0x44>
9001c3c6:	4602      	mov	r2, r0
9001c3c8:	4b42      	ldr	r3, [pc, #264]	; (9001c4d4 <__multiply+0x144>)
9001c3ca:	4843      	ldr	r0, [pc, #268]	; (9001c4d8 <__multiply+0x148>)
9001c3cc:	f240 115d 	movw	r1, #349	; 0x15d
9001c3d0:	f000 fb5a 	bl	9001ca88 <__assert_func>
9001c3d4:	f100 0614 	add.w	r6, r0, #20
9001c3d8:	eb06 0887 	add.w	r8, r6, r7, lsl #2
9001c3dc:	4633      	mov	r3, r6
9001c3de:	2200      	movs	r2, #0
9001c3e0:	4543      	cmp	r3, r8
9001c3e2:	d31e      	bcc.n	9001c422 <__multiply+0x92>
9001c3e4:	f105 0c14 	add.w	ip, r5, #20
9001c3e8:	f104 0314 	add.w	r3, r4, #20
9001c3ec:	eb0c 0c8a 	add.w	ip, ip, sl, lsl #2
9001c3f0:	eb03 0289 	add.w	r2, r3, r9, lsl #2
9001c3f4:	9202      	str	r2, [sp, #8]
9001c3f6:	ebac 0205 	sub.w	r2, ip, r5
9001c3fa:	3a15      	subs	r2, #21
9001c3fc:	f022 0203 	bic.w	r2, r2, #3
9001c400:	3204      	adds	r2, #4
9001c402:	f105 0115 	add.w	r1, r5, #21
9001c406:	458c      	cmp	ip, r1
9001c408:	bf38      	it	cc
9001c40a:	2204      	movcc	r2, #4
9001c40c:	9201      	str	r2, [sp, #4]
9001c40e:	9a02      	ldr	r2, [sp, #8]
9001c410:	9303      	str	r3, [sp, #12]
9001c412:	429a      	cmp	r2, r3
9001c414:	d808      	bhi.n	9001c428 <__multiply+0x98>
9001c416:	2f00      	cmp	r7, #0
9001c418:	dc55      	bgt.n	9001c4c6 <__multiply+0x136>
9001c41a:	6107      	str	r7, [r0, #16]
9001c41c:	b005      	add	sp, #20
9001c41e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
9001c422:	f843 2b04 	str.w	r2, [r3], #4
9001c426:	e7db      	b.n	9001c3e0 <__multiply+0x50>
9001c428:	f8b3 a000 	ldrh.w	sl, [r3]
9001c42c:	f1ba 0f00 	cmp.w	sl, #0
9001c430:	d020      	beq.n	9001c474 <__multiply+0xe4>
9001c432:	f105 0e14 	add.w	lr, r5, #20
9001c436:	46b1      	mov	r9, r6
9001c438:	2200      	movs	r2, #0
9001c43a:	f85e 4b04 	ldr.w	r4, [lr], #4
9001c43e:	f8d9 b000 	ldr.w	fp, [r9]
9001c442:	b2a1      	uxth	r1, r4
9001c444:	fa1f fb8b 	uxth.w	fp, fp
9001c448:	fb0a b101 	mla	r1, sl, r1, fp
9001c44c:	4411      	add	r1, r2
9001c44e:	f8d9 2000 	ldr.w	r2, [r9]
9001c452:	0c24      	lsrs	r4, r4, #16
9001c454:	0c12      	lsrs	r2, r2, #16
9001c456:	fb0a 2404 	mla	r4, sl, r4, r2
9001c45a:	eb04 4411 	add.w	r4, r4, r1, lsr #16
9001c45e:	b289      	uxth	r1, r1
9001c460:	ea41 4104 	orr.w	r1, r1, r4, lsl #16
9001c464:	45f4      	cmp	ip, lr
9001c466:	f849 1b04 	str.w	r1, [r9], #4
9001c46a:	ea4f 4214 	mov.w	r2, r4, lsr #16
9001c46e:	d8e4      	bhi.n	9001c43a <__multiply+0xaa>
9001c470:	9901      	ldr	r1, [sp, #4]
9001c472:	5072      	str	r2, [r6, r1]
9001c474:	9a03      	ldr	r2, [sp, #12]
9001c476:	f8b2 9002 	ldrh.w	r9, [r2, #2]
9001c47a:	3304      	adds	r3, #4
9001c47c:	f1b9 0f00 	cmp.w	r9, #0
9001c480:	d01f      	beq.n	9001c4c2 <__multiply+0x132>
9001c482:	6834      	ldr	r4, [r6, #0]
9001c484:	f105 0114 	add.w	r1, r5, #20
9001c488:	46b6      	mov	lr, r6
9001c48a:	f04f 0a00 	mov.w	sl, #0
9001c48e:	880a      	ldrh	r2, [r1, #0]
9001c490:	f8be b002 	ldrh.w	fp, [lr, #2]
9001c494:	fb09 b202 	mla	r2, r9, r2, fp
9001c498:	4492      	add	sl, r2
9001c49a:	b2a4      	uxth	r4, r4
9001c49c:	ea44 440a 	orr.w	r4, r4, sl, lsl #16
9001c4a0:	f84e 4b04 	str.w	r4, [lr], #4
9001c4a4:	f851 4b04 	ldr.w	r4, [r1], #4
9001c4a8:	f8be 2000 	ldrh.w	r2, [lr]
9001c4ac:	0c24      	lsrs	r4, r4, #16
9001c4ae:	fb09 2404 	mla	r4, r9, r4, r2
9001c4b2:	eb04 441a 	add.w	r4, r4, sl, lsr #16
9001c4b6:	458c      	cmp	ip, r1
9001c4b8:	ea4f 4a14 	mov.w	sl, r4, lsr #16
9001c4bc:	d8e7      	bhi.n	9001c48e <__multiply+0xfe>
9001c4be:	9a01      	ldr	r2, [sp, #4]
9001c4c0:	50b4      	str	r4, [r6, r2]
9001c4c2:	3604      	adds	r6, #4
9001c4c4:	e7a3      	b.n	9001c40e <__multiply+0x7e>
9001c4c6:	f858 3d04 	ldr.w	r3, [r8, #-4]!
9001c4ca:	2b00      	cmp	r3, #0
9001c4cc:	d1a5      	bne.n	9001c41a <__multiply+0x8a>
9001c4ce:	3f01      	subs	r7, #1
9001c4d0:	e7a1      	b.n	9001c416 <__multiply+0x86>
9001c4d2:	bf00      	nop
9001c4d4:	900253a5 	.word	0x900253a5
9001c4d8:	90025415 	.word	0x90025415

9001c4dc <__pow5mult>:
9001c4dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
9001c4e0:	4615      	mov	r5, r2
9001c4e2:	f012 0203 	ands.w	r2, r2, #3
9001c4e6:	4606      	mov	r6, r0
9001c4e8:	460f      	mov	r7, r1
9001c4ea:	d007      	beq.n	9001c4fc <__pow5mult+0x20>
9001c4ec:	4c1a      	ldr	r4, [pc, #104]	; (9001c558 <__pow5mult+0x7c>)
9001c4ee:	3a01      	subs	r2, #1
9001c4f0:	2300      	movs	r3, #0
9001c4f2:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
9001c4f6:	f7ff fe9b 	bl	9001c230 <__multadd>
9001c4fa:	4607      	mov	r7, r0
9001c4fc:	10ad      	asrs	r5, r5, #2
9001c4fe:	d027      	beq.n	9001c550 <__pow5mult+0x74>
9001c500:	6cb4      	ldr	r4, [r6, #72]	; 0x48
9001c502:	b944      	cbnz	r4, 9001c516 <__pow5mult+0x3a>
9001c504:	f240 2171 	movw	r1, #625	; 0x271
9001c508:	4630      	mov	r0, r6
9001c50a:	f7ff ff2b 	bl	9001c364 <__i2b>
9001c50e:	2300      	movs	r3, #0
9001c510:	64b0      	str	r0, [r6, #72]	; 0x48
9001c512:	4604      	mov	r4, r0
9001c514:	6003      	str	r3, [r0, #0]
9001c516:	f04f 0900 	mov.w	r9, #0
9001c51a:	07eb      	lsls	r3, r5, #31
9001c51c:	d50a      	bpl.n	9001c534 <__pow5mult+0x58>
9001c51e:	4639      	mov	r1, r7
9001c520:	4622      	mov	r2, r4
9001c522:	4630      	mov	r0, r6
9001c524:	f7ff ff34 	bl	9001c390 <__multiply>
9001c528:	4639      	mov	r1, r7
9001c52a:	4680      	mov	r8, r0
9001c52c:	4630      	mov	r0, r6
9001c52e:	f7ff fe76 	bl	9001c21e <_Bfree>
9001c532:	4647      	mov	r7, r8
9001c534:	106d      	asrs	r5, r5, #1
9001c536:	d00b      	beq.n	9001c550 <__pow5mult+0x74>
9001c538:	6820      	ldr	r0, [r4, #0]
9001c53a:	b938      	cbnz	r0, 9001c54c <__pow5mult+0x70>
9001c53c:	4622      	mov	r2, r4
9001c53e:	4621      	mov	r1, r4
9001c540:	4630      	mov	r0, r6
9001c542:	f7ff ff25 	bl	9001c390 <__multiply>
9001c546:	6020      	str	r0, [r4, #0]
9001c548:	f8c0 9000 	str.w	r9, [r0]
9001c54c:	4604      	mov	r4, r0
9001c54e:	e7e4      	b.n	9001c51a <__pow5mult+0x3e>
9001c550:	4638      	mov	r0, r7
9001c552:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
9001c556:	bf00      	nop
9001c558:	90025568 	.word	0x90025568

9001c55c <__lshift>:
9001c55c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
9001c560:	460c      	mov	r4, r1
9001c562:	6849      	ldr	r1, [r1, #4]
9001c564:	6923      	ldr	r3, [r4, #16]
9001c566:	eb03 1862 	add.w	r8, r3, r2, asr #5
9001c56a:	68a3      	ldr	r3, [r4, #8]
9001c56c:	4607      	mov	r7, r0
9001c56e:	4691      	mov	r9, r2
9001c570:	ea4f 1a62 	mov.w	sl, r2, asr #5
9001c574:	f108 0601 	add.w	r6, r8, #1
9001c578:	42b3      	cmp	r3, r6
9001c57a:	db0b      	blt.n	9001c594 <__lshift+0x38>
9001c57c:	4638      	mov	r0, r7
9001c57e:	f7ff fe29 	bl	9001c1d4 <_Balloc>
9001c582:	4605      	mov	r5, r0
9001c584:	b948      	cbnz	r0, 9001c59a <__lshift+0x3e>
9001c586:	4602      	mov	r2, r0
9001c588:	4b28      	ldr	r3, [pc, #160]	; (9001c62c <__lshift+0xd0>)
9001c58a:	4829      	ldr	r0, [pc, #164]	; (9001c630 <__lshift+0xd4>)
9001c58c:	f240 11d9 	movw	r1, #473	; 0x1d9
9001c590:	f000 fa7a 	bl	9001ca88 <__assert_func>
9001c594:	3101      	adds	r1, #1
9001c596:	005b      	lsls	r3, r3, #1
9001c598:	e7ee      	b.n	9001c578 <__lshift+0x1c>
9001c59a:	2300      	movs	r3, #0
9001c59c:	f100 0114 	add.w	r1, r0, #20
9001c5a0:	f100 0210 	add.w	r2, r0, #16
9001c5a4:	4618      	mov	r0, r3
9001c5a6:	4553      	cmp	r3, sl
9001c5a8:	db33      	blt.n	9001c612 <__lshift+0xb6>
9001c5aa:	6920      	ldr	r0, [r4, #16]
9001c5ac:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
9001c5b0:	f104 0314 	add.w	r3, r4, #20
9001c5b4:	f019 091f 	ands.w	r9, r9, #31
9001c5b8:	eb01 018a 	add.w	r1, r1, sl, lsl #2
9001c5bc:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
9001c5c0:	d02b      	beq.n	9001c61a <__lshift+0xbe>
9001c5c2:	f1c9 0e20 	rsb	lr, r9, #32
9001c5c6:	468a      	mov	sl, r1
9001c5c8:	2200      	movs	r2, #0
9001c5ca:	6818      	ldr	r0, [r3, #0]
9001c5cc:	fa00 f009 	lsl.w	r0, r0, r9
9001c5d0:	4302      	orrs	r2, r0
9001c5d2:	f84a 2b04 	str.w	r2, [sl], #4
9001c5d6:	f853 2b04 	ldr.w	r2, [r3], #4
9001c5da:	459c      	cmp	ip, r3
9001c5dc:	fa22 f20e 	lsr.w	r2, r2, lr
9001c5e0:	d8f3      	bhi.n	9001c5ca <__lshift+0x6e>
9001c5e2:	ebac 0304 	sub.w	r3, ip, r4
9001c5e6:	3b15      	subs	r3, #21
9001c5e8:	f023 0303 	bic.w	r3, r3, #3
9001c5ec:	3304      	adds	r3, #4
9001c5ee:	f104 0015 	add.w	r0, r4, #21
9001c5f2:	4584      	cmp	ip, r0
9001c5f4:	bf38      	it	cc
9001c5f6:	2304      	movcc	r3, #4
9001c5f8:	50ca      	str	r2, [r1, r3]
9001c5fa:	b10a      	cbz	r2, 9001c600 <__lshift+0xa4>
9001c5fc:	f108 0602 	add.w	r6, r8, #2
9001c600:	3e01      	subs	r6, #1
9001c602:	4638      	mov	r0, r7
9001c604:	612e      	str	r6, [r5, #16]
9001c606:	4621      	mov	r1, r4
9001c608:	f7ff fe09 	bl	9001c21e <_Bfree>
9001c60c:	4628      	mov	r0, r5
9001c60e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
9001c612:	f842 0f04 	str.w	r0, [r2, #4]!
9001c616:	3301      	adds	r3, #1
9001c618:	e7c5      	b.n	9001c5a6 <__lshift+0x4a>
9001c61a:	3904      	subs	r1, #4
9001c61c:	f853 2b04 	ldr.w	r2, [r3], #4
9001c620:	f841 2f04 	str.w	r2, [r1, #4]!
9001c624:	459c      	cmp	ip, r3
9001c626:	d8f9      	bhi.n	9001c61c <__lshift+0xc0>
9001c628:	e7ea      	b.n	9001c600 <__lshift+0xa4>
9001c62a:	bf00      	nop
9001c62c:	900253a5 	.word	0x900253a5
9001c630:	90025415 	.word	0x90025415

9001c634 <__mcmp>:
9001c634:	b530      	push	{r4, r5, lr}
9001c636:	6902      	ldr	r2, [r0, #16]
9001c638:	690c      	ldr	r4, [r1, #16]
9001c63a:	1b12      	subs	r2, r2, r4
9001c63c:	d10e      	bne.n	9001c65c <__mcmp+0x28>
9001c63e:	f100 0314 	add.w	r3, r0, #20
9001c642:	3114      	adds	r1, #20
9001c644:	eb03 0084 	add.w	r0, r3, r4, lsl #2
9001c648:	eb01 0184 	add.w	r1, r1, r4, lsl #2
9001c64c:	f850 5d04 	ldr.w	r5, [r0, #-4]!
9001c650:	f851 4d04 	ldr.w	r4, [r1, #-4]!
9001c654:	42a5      	cmp	r5, r4
9001c656:	d003      	beq.n	9001c660 <__mcmp+0x2c>
9001c658:	d305      	bcc.n	9001c666 <__mcmp+0x32>
9001c65a:	2201      	movs	r2, #1
9001c65c:	4610      	mov	r0, r2
9001c65e:	bd30      	pop	{r4, r5, pc}
9001c660:	4283      	cmp	r3, r0
9001c662:	d3f3      	bcc.n	9001c64c <__mcmp+0x18>
9001c664:	e7fa      	b.n	9001c65c <__mcmp+0x28>
9001c666:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
9001c66a:	e7f7      	b.n	9001c65c <__mcmp+0x28>

9001c66c <__mdiff>:
9001c66c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001c670:	460c      	mov	r4, r1
9001c672:	4606      	mov	r6, r0
9001c674:	4611      	mov	r1, r2
9001c676:	4620      	mov	r0, r4
9001c678:	4617      	mov	r7, r2
9001c67a:	f7ff ffdb 	bl	9001c634 <__mcmp>
9001c67e:	1e05      	subs	r5, r0, #0
9001c680:	d110      	bne.n	9001c6a4 <__mdiff+0x38>
9001c682:	4629      	mov	r1, r5
9001c684:	4630      	mov	r0, r6
9001c686:	f7ff fda5 	bl	9001c1d4 <_Balloc>
9001c68a:	b930      	cbnz	r0, 9001c69a <__mdiff+0x2e>
9001c68c:	4b39      	ldr	r3, [pc, #228]	; (9001c774 <__mdiff+0x108>)
9001c68e:	4602      	mov	r2, r0
9001c690:	f240 2132 	movw	r1, #562	; 0x232
9001c694:	4838      	ldr	r0, [pc, #224]	; (9001c778 <__mdiff+0x10c>)
9001c696:	f000 f9f7 	bl	9001ca88 <__assert_func>
9001c69a:	2301      	movs	r3, #1
9001c69c:	e9c0 3504 	strd	r3, r5, [r0, #16]
9001c6a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
9001c6a4:	bfa4      	itt	ge
9001c6a6:	463b      	movge	r3, r7
9001c6a8:	4627      	movge	r7, r4
9001c6aa:	4630      	mov	r0, r6
9001c6ac:	6879      	ldr	r1, [r7, #4]
9001c6ae:	bfa6      	itte	ge
9001c6b0:	461c      	movge	r4, r3
9001c6b2:	2500      	movge	r5, #0
9001c6b4:	2501      	movlt	r5, #1
9001c6b6:	f7ff fd8d 	bl	9001c1d4 <_Balloc>
9001c6ba:	b920      	cbnz	r0, 9001c6c6 <__mdiff+0x5a>
9001c6bc:	4b2d      	ldr	r3, [pc, #180]	; (9001c774 <__mdiff+0x108>)
9001c6be:	4602      	mov	r2, r0
9001c6c0:	f44f 7110 	mov.w	r1, #576	; 0x240
9001c6c4:	e7e6      	b.n	9001c694 <__mdiff+0x28>
9001c6c6:	693e      	ldr	r6, [r7, #16]
9001c6c8:	60c5      	str	r5, [r0, #12]
9001c6ca:	6925      	ldr	r5, [r4, #16]
9001c6cc:	f107 0114 	add.w	r1, r7, #20
9001c6d0:	f104 0914 	add.w	r9, r4, #20
9001c6d4:	f100 0e14 	add.w	lr, r0, #20
9001c6d8:	f107 0210 	add.w	r2, r7, #16
9001c6dc:	eb01 0c86 	add.w	ip, r1, r6, lsl #2
9001c6e0:	eb09 0585 	add.w	r5, r9, r5, lsl #2
9001c6e4:	46f2      	mov	sl, lr
9001c6e6:	2700      	movs	r7, #0
9001c6e8:	f859 3b04 	ldr.w	r3, [r9], #4
9001c6ec:	f852 bf04 	ldr.w	fp, [r2, #4]!
9001c6f0:	fa1f f883 	uxth.w	r8, r3
9001c6f4:	fa17 f78b 	uxtah	r7, r7, fp
9001c6f8:	0c1b      	lsrs	r3, r3, #16
9001c6fa:	eba7 0808 	sub.w	r8, r7, r8
9001c6fe:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
9001c702:	eb03 4328 	add.w	r3, r3, r8, asr #16
9001c706:	fa1f f888 	uxth.w	r8, r8
9001c70a:	141f      	asrs	r7, r3, #16
9001c70c:	454d      	cmp	r5, r9
9001c70e:	ea48 4303 	orr.w	r3, r8, r3, lsl #16
9001c712:	f84a 3b04 	str.w	r3, [sl], #4
9001c716:	d8e7      	bhi.n	9001c6e8 <__mdiff+0x7c>
9001c718:	1b2b      	subs	r3, r5, r4
9001c71a:	3b15      	subs	r3, #21
9001c71c:	f023 0303 	bic.w	r3, r3, #3
9001c720:	3304      	adds	r3, #4
9001c722:	3415      	adds	r4, #21
9001c724:	42a5      	cmp	r5, r4
9001c726:	bf38      	it	cc
9001c728:	2304      	movcc	r3, #4
9001c72a:	4419      	add	r1, r3
9001c72c:	4473      	add	r3, lr
9001c72e:	469e      	mov	lr, r3
9001c730:	460d      	mov	r5, r1
9001c732:	4565      	cmp	r5, ip
9001c734:	d30e      	bcc.n	9001c754 <__mdiff+0xe8>
9001c736:	f10c 0203 	add.w	r2, ip, #3
9001c73a:	1a52      	subs	r2, r2, r1
9001c73c:	f022 0203 	bic.w	r2, r2, #3
9001c740:	3903      	subs	r1, #3
9001c742:	458c      	cmp	ip, r1
9001c744:	bf38      	it	cc
9001c746:	2200      	movcc	r2, #0
9001c748:	441a      	add	r2, r3
9001c74a:	f852 3d04 	ldr.w	r3, [r2, #-4]!
9001c74e:	b17b      	cbz	r3, 9001c770 <__mdiff+0x104>
9001c750:	6106      	str	r6, [r0, #16]
9001c752:	e7a5      	b.n	9001c6a0 <__mdiff+0x34>
9001c754:	f855 8b04 	ldr.w	r8, [r5], #4
9001c758:	fa17 f488 	uxtah	r4, r7, r8
9001c75c:	1422      	asrs	r2, r4, #16
9001c75e:	eb02 4218 	add.w	r2, r2, r8, lsr #16
9001c762:	b2a4      	uxth	r4, r4
9001c764:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
9001c768:	f84e 4b04 	str.w	r4, [lr], #4
9001c76c:	1417      	asrs	r7, r2, #16
9001c76e:	e7e0      	b.n	9001c732 <__mdiff+0xc6>
9001c770:	3e01      	subs	r6, #1
9001c772:	e7ea      	b.n	9001c74a <__mdiff+0xde>
9001c774:	900253a5 	.word	0x900253a5
9001c778:	90025415 	.word	0x90025415

9001c77c <__d2b>:
9001c77c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
9001c780:	4689      	mov	r9, r1
9001c782:	2101      	movs	r1, #1
9001c784:	ec57 6b10 	vmov	r6, r7, d0
9001c788:	4690      	mov	r8, r2
9001c78a:	f7ff fd23 	bl	9001c1d4 <_Balloc>
9001c78e:	4604      	mov	r4, r0
9001c790:	b930      	cbnz	r0, 9001c7a0 <__d2b+0x24>
9001c792:	4602      	mov	r2, r0
9001c794:	4b25      	ldr	r3, [pc, #148]	; (9001c82c <__d2b+0xb0>)
9001c796:	4826      	ldr	r0, [pc, #152]	; (9001c830 <__d2b+0xb4>)
9001c798:	f240 310a 	movw	r1, #778	; 0x30a
9001c79c:	f000 f974 	bl	9001ca88 <__assert_func>
9001c7a0:	f3c7 550a 	ubfx	r5, r7, #20, #11
9001c7a4:	f3c7 0313 	ubfx	r3, r7, #0, #20
9001c7a8:	bb35      	cbnz	r5, 9001c7f8 <__d2b+0x7c>
9001c7aa:	2e00      	cmp	r6, #0
9001c7ac:	9301      	str	r3, [sp, #4]
9001c7ae:	d028      	beq.n	9001c802 <__d2b+0x86>
9001c7b0:	4668      	mov	r0, sp
9001c7b2:	9600      	str	r6, [sp, #0]
9001c7b4:	f7ff fda6 	bl	9001c304 <__lo0bits>
9001c7b8:	9900      	ldr	r1, [sp, #0]
9001c7ba:	b300      	cbz	r0, 9001c7fe <__d2b+0x82>
9001c7bc:	9a01      	ldr	r2, [sp, #4]
9001c7be:	f1c0 0320 	rsb	r3, r0, #32
9001c7c2:	fa02 f303 	lsl.w	r3, r2, r3
9001c7c6:	430b      	orrs	r3, r1
9001c7c8:	40c2      	lsrs	r2, r0
9001c7ca:	6163      	str	r3, [r4, #20]
9001c7cc:	9201      	str	r2, [sp, #4]
9001c7ce:	9b01      	ldr	r3, [sp, #4]
9001c7d0:	61a3      	str	r3, [r4, #24]
9001c7d2:	2b00      	cmp	r3, #0
9001c7d4:	bf14      	ite	ne
9001c7d6:	2202      	movne	r2, #2
9001c7d8:	2201      	moveq	r2, #1
9001c7da:	6122      	str	r2, [r4, #16]
9001c7dc:	b1d5      	cbz	r5, 9001c814 <__d2b+0x98>
9001c7de:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
9001c7e2:	4405      	add	r5, r0
9001c7e4:	f8c9 5000 	str.w	r5, [r9]
9001c7e8:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
9001c7ec:	f8c8 0000 	str.w	r0, [r8]
9001c7f0:	4620      	mov	r0, r4
9001c7f2:	b003      	add	sp, #12
9001c7f4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
9001c7f8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
9001c7fc:	e7d5      	b.n	9001c7aa <__d2b+0x2e>
9001c7fe:	6161      	str	r1, [r4, #20]
9001c800:	e7e5      	b.n	9001c7ce <__d2b+0x52>
9001c802:	a801      	add	r0, sp, #4
9001c804:	f7ff fd7e 	bl	9001c304 <__lo0bits>
9001c808:	9b01      	ldr	r3, [sp, #4]
9001c80a:	6163      	str	r3, [r4, #20]
9001c80c:	2201      	movs	r2, #1
9001c80e:	6122      	str	r2, [r4, #16]
9001c810:	3020      	adds	r0, #32
9001c812:	e7e3      	b.n	9001c7dc <__d2b+0x60>
9001c814:	eb04 0382 	add.w	r3, r4, r2, lsl #2
9001c818:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
9001c81c:	f8c9 0000 	str.w	r0, [r9]
9001c820:	6918      	ldr	r0, [r3, #16]
9001c822:	f7ff fd4f 	bl	9001c2c4 <__hi0bits>
9001c826:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
9001c82a:	e7df      	b.n	9001c7ec <__d2b+0x70>
9001c82c:	900253a5 	.word	0x900253a5
9001c830:	90025415 	.word	0x90025415
9001c834:	00000000 	.word	0x00000000

9001c838 <frexp>:
9001c838:	b082      	sub	sp, #8
9001c83a:	ed8d 0b00 	vstr	d0, [sp]
9001c83e:	2100      	movs	r1, #0
9001c840:	9b01      	ldr	r3, [sp, #4]
9001c842:	6001      	str	r1, [r0, #0]
9001c844:	4918      	ldr	r1, [pc, #96]	; (9001c8a8 <frexp+0x70>)
9001c846:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
9001c84a:	428a      	cmp	r2, r1
9001c84c:	dc23      	bgt.n	9001c896 <frexp+0x5e>
9001c84e:	9900      	ldr	r1, [sp, #0]
9001c850:	4311      	orrs	r1, r2
9001c852:	d020      	beq.n	9001c896 <frexp+0x5e>
9001c854:	4915      	ldr	r1, [pc, #84]	; (9001c8ac <frexp+0x74>)
9001c856:	4019      	ands	r1, r3
9001c858:	b959      	cbnz	r1, 9001c872 <frexp+0x3a>
9001c85a:	ed9f 7b11 	vldr	d7, [pc, #68]	; 9001c8a0 <frexp+0x68>
9001c85e:	ee20 7b07 	vmul.f64	d7, d0, d7
9001c862:	ed8d 7b00 	vstr	d7, [sp]
9001c866:	9b01      	ldr	r3, [sp, #4]
9001c868:	f06f 0135 	mvn.w	r1, #53	; 0x35
9001c86c:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
9001c870:	6001      	str	r1, [r0, #0]
9001c872:	6801      	ldr	r1, [r0, #0]
9001c874:	1512      	asrs	r2, r2, #20
9001c876:	f2a2 32fe 	subw	r2, r2, #1022	; 0x3fe
9001c87a:	440a      	add	r2, r1
9001c87c:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
9001c880:	6002      	str	r2, [r0, #0]
9001c882:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
9001c886:	e9dd 0100 	ldrd	r0, r1, [sp]
9001c88a:	f043 517f 	orr.w	r1, r3, #1069547520	; 0x3fc00000
9001c88e:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
9001c892:	e9cd 0100 	strd	r0, r1, [sp]
9001c896:	ed9d 0b00 	vldr	d0, [sp]
9001c89a:	b002      	add	sp, #8
9001c89c:	4770      	bx	lr
9001c89e:	bf00      	nop
9001c8a0:	00000000 	.word	0x00000000
9001c8a4:	43500000 	.word	0x43500000
9001c8a8:	7fefffff 	.word	0x7fefffff
9001c8ac:	7ff00000 	.word	0x7ff00000

9001c8b0 <_sbrk_r>:
9001c8b0:	b538      	push	{r3, r4, r5, lr}
9001c8b2:	4d06      	ldr	r5, [pc, #24]	; (9001c8cc <_sbrk_r+0x1c>)
9001c8b4:	2300      	movs	r3, #0
9001c8b6:	4604      	mov	r4, r0
9001c8b8:	4608      	mov	r0, r1
9001c8ba:	602b      	str	r3, [r5, #0]
9001c8bc:	f7f9 f832 	bl	90015924 <_sbrk>
9001c8c0:	1c43      	adds	r3, r0, #1
9001c8c2:	d102      	bne.n	9001c8ca <_sbrk_r+0x1a>
9001c8c4:	682b      	ldr	r3, [r5, #0]
9001c8c6:	b103      	cbz	r3, 9001c8ca <_sbrk_r+0x1a>
9001c8c8:	6023      	str	r3, [r4, #0]
9001c8ca:	bd38      	pop	{r3, r4, r5, pc}
9001c8cc:	2400b440 	.word	0x2400b440

9001c8d0 <strncpy>:
9001c8d0:	b510      	push	{r4, lr}
9001c8d2:	3901      	subs	r1, #1
9001c8d4:	4603      	mov	r3, r0
9001c8d6:	b132      	cbz	r2, 9001c8e6 <strncpy+0x16>
9001c8d8:	f811 4f01 	ldrb.w	r4, [r1, #1]!
9001c8dc:	f803 4b01 	strb.w	r4, [r3], #1
9001c8e0:	3a01      	subs	r2, #1
9001c8e2:	2c00      	cmp	r4, #0
9001c8e4:	d1f7      	bne.n	9001c8d6 <strncpy+0x6>
9001c8e6:	441a      	add	r2, r3
9001c8e8:	2100      	movs	r1, #0
9001c8ea:	4293      	cmp	r3, r2
9001c8ec:	d100      	bne.n	9001c8f0 <strncpy+0x20>
9001c8ee:	bd10      	pop	{r4, pc}
9001c8f0:	f803 1b01 	strb.w	r1, [r3], #1
9001c8f4:	e7f9      	b.n	9001c8ea <strncpy+0x1a>

9001c8f6 <__ssprint_r>:
9001c8f6:	6893      	ldr	r3, [r2, #8]
9001c8f8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001c8fc:	4680      	mov	r8, r0
9001c8fe:	460c      	mov	r4, r1
9001c900:	4617      	mov	r7, r2
9001c902:	2b00      	cmp	r3, #0
9001c904:	d061      	beq.n	9001c9ca <__ssprint_r+0xd4>
9001c906:	2300      	movs	r3, #0
9001c908:	f8d2 a000 	ldr.w	sl, [r2]
9001c90c:	9301      	str	r3, [sp, #4]
9001c90e:	469b      	mov	fp, r3
9001c910:	f1bb 0f00 	cmp.w	fp, #0
9001c914:	d02b      	beq.n	9001c96e <__ssprint_r+0x78>
9001c916:	68a6      	ldr	r6, [r4, #8]
9001c918:	45b3      	cmp	fp, r6
9001c91a:	d342      	bcc.n	9001c9a2 <__ssprint_r+0xac>
9001c91c:	89a2      	ldrh	r2, [r4, #12]
9001c91e:	f412 6f90 	tst.w	r2, #1152	; 0x480
9001c922:	d03e      	beq.n	9001c9a2 <__ssprint_r+0xac>
9001c924:	6825      	ldr	r5, [r4, #0]
9001c926:	6921      	ldr	r1, [r4, #16]
9001c928:	eba5 0901 	sub.w	r9, r5, r1
9001c92c:	6965      	ldr	r5, [r4, #20]
9001c92e:	eb05 0545 	add.w	r5, r5, r5, lsl #1
9001c932:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
9001c936:	f109 0001 	add.w	r0, r9, #1
9001c93a:	106d      	asrs	r5, r5, #1
9001c93c:	4458      	add	r0, fp
9001c93e:	4285      	cmp	r5, r0
9001c940:	bf38      	it	cc
9001c942:	4605      	movcc	r5, r0
9001c944:	0553      	lsls	r3, r2, #21
9001c946:	d545      	bpl.n	9001c9d4 <__ssprint_r+0xde>
9001c948:	4629      	mov	r1, r5
9001c94a:	4640      	mov	r0, r8
9001c94c:	f7ff f9f4 	bl	9001bd38 <_malloc_r>
9001c950:	4606      	mov	r6, r0
9001c952:	b9a0      	cbnz	r0, 9001c97e <__ssprint_r+0x88>
9001c954:	230c      	movs	r3, #12
9001c956:	f8c8 3000 	str.w	r3, [r8]
9001c95a:	89a3      	ldrh	r3, [r4, #12]
9001c95c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
9001c960:	81a3      	strh	r3, [r4, #12]
9001c962:	2300      	movs	r3, #0
9001c964:	e9c7 3301 	strd	r3, r3, [r7, #4]
9001c968:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
9001c96c:	e02f      	b.n	9001c9ce <__ssprint_r+0xd8>
9001c96e:	f8da 3000 	ldr.w	r3, [sl]
9001c972:	f8da b004 	ldr.w	fp, [sl, #4]
9001c976:	9301      	str	r3, [sp, #4]
9001c978:	f10a 0a08 	add.w	sl, sl, #8
9001c97c:	e7c8      	b.n	9001c910 <__ssprint_r+0x1a>
9001c97e:	464a      	mov	r2, r9
9001c980:	6921      	ldr	r1, [r4, #16]
9001c982:	f7fd f8ff 	bl	90019b84 <memcpy>
9001c986:	89a2      	ldrh	r2, [r4, #12]
9001c988:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
9001c98c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
9001c990:	81a2      	strh	r2, [r4, #12]
9001c992:	6126      	str	r6, [r4, #16]
9001c994:	6165      	str	r5, [r4, #20]
9001c996:	444e      	add	r6, r9
9001c998:	eba5 0509 	sub.w	r5, r5, r9
9001c99c:	6026      	str	r6, [r4, #0]
9001c99e:	60a5      	str	r5, [r4, #8]
9001c9a0:	465e      	mov	r6, fp
9001c9a2:	455e      	cmp	r6, fp
9001c9a4:	bf28      	it	cs
9001c9a6:	465e      	movcs	r6, fp
9001c9a8:	4632      	mov	r2, r6
9001c9aa:	9901      	ldr	r1, [sp, #4]
9001c9ac:	6820      	ldr	r0, [r4, #0]
9001c9ae:	f000 f8e1 	bl	9001cb74 <memmove>
9001c9b2:	68a2      	ldr	r2, [r4, #8]
9001c9b4:	1b92      	subs	r2, r2, r6
9001c9b6:	60a2      	str	r2, [r4, #8]
9001c9b8:	6822      	ldr	r2, [r4, #0]
9001c9ba:	4432      	add	r2, r6
9001c9bc:	6022      	str	r2, [r4, #0]
9001c9be:	68ba      	ldr	r2, [r7, #8]
9001c9c0:	eba2 030b 	sub.w	r3, r2, fp
9001c9c4:	60bb      	str	r3, [r7, #8]
9001c9c6:	2b00      	cmp	r3, #0
9001c9c8:	d1d1      	bne.n	9001c96e <__ssprint_r+0x78>
9001c9ca:	2000      	movs	r0, #0
9001c9cc:	6078      	str	r0, [r7, #4]
9001c9ce:	b003      	add	sp, #12
9001c9d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
9001c9d4:	462a      	mov	r2, r5
9001c9d6:	4640      	mov	r0, r8
9001c9d8:	f000 f8e6 	bl	9001cba8 <_realloc_r>
9001c9dc:	4606      	mov	r6, r0
9001c9de:	2800      	cmp	r0, #0
9001c9e0:	d1d7      	bne.n	9001c992 <__ssprint_r+0x9c>
9001c9e2:	6921      	ldr	r1, [r4, #16]
9001c9e4:	4640      	mov	r0, r8
9001c9e6:	f7ff f8df 	bl	9001bba8 <_free_r>
9001c9ea:	e7b3      	b.n	9001c954 <__ssprint_r+0x5e>

9001c9ec <sysconf>:
9001c9ec:	2808      	cmp	r0, #8
9001c9ee:	b508      	push	{r3, lr}
9001c9f0:	d006      	beq.n	9001ca00 <sysconf+0x14>
9001c9f2:	f7fd f89d 	bl	90019b30 <__errno>
9001c9f6:	2316      	movs	r3, #22
9001c9f8:	6003      	str	r3, [r0, #0]
9001c9fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
9001c9fe:	bd08      	pop	{r3, pc}
9001ca00:	f44f 5080 	mov.w	r0, #4096	; 0x1000
9001ca04:	e7fb      	b.n	9001c9fe <sysconf+0x12>
	...

9001ca08 <__register_exitproc>:
9001ca08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
9001ca0c:	4d1c      	ldr	r5, [pc, #112]	; (9001ca80 <__register_exitproc+0x78>)
9001ca0e:	4606      	mov	r6, r0
9001ca10:	6828      	ldr	r0, [r5, #0]
9001ca12:	4698      	mov	r8, r3
9001ca14:	460f      	mov	r7, r1
9001ca16:	4691      	mov	r9, r2
9001ca18:	f7ff f98c 	bl	9001bd34 <__retarget_lock_acquire_recursive>
9001ca1c:	4b19      	ldr	r3, [pc, #100]	; (9001ca84 <__register_exitproc+0x7c>)
9001ca1e:	681b      	ldr	r3, [r3, #0]
9001ca20:	f8d3 4148 	ldr.w	r4, [r3, #328]	; 0x148
9001ca24:	4628      	mov	r0, r5
9001ca26:	b91c      	cbnz	r4, 9001ca30 <__register_exitproc+0x28>
9001ca28:	f503 74a6 	add.w	r4, r3, #332	; 0x14c
9001ca2c:	f8c3 4148 	str.w	r4, [r3, #328]	; 0x148
9001ca30:	6865      	ldr	r5, [r4, #4]
9001ca32:	6800      	ldr	r0, [r0, #0]
9001ca34:	2d1f      	cmp	r5, #31
9001ca36:	dd05      	ble.n	9001ca44 <__register_exitproc+0x3c>
9001ca38:	f7ff f97d 	bl	9001bd36 <__retarget_lock_release_recursive>
9001ca3c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
9001ca40:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
9001ca44:	b19e      	cbz	r6, 9001ca6e <__register_exitproc+0x66>
9001ca46:	eb04 0185 	add.w	r1, r4, r5, lsl #2
9001ca4a:	2201      	movs	r2, #1
9001ca4c:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
9001ca50:	f8d4 3188 	ldr.w	r3, [r4, #392]	; 0x188
9001ca54:	40aa      	lsls	r2, r5
9001ca56:	4313      	orrs	r3, r2
9001ca58:	2e02      	cmp	r6, #2
9001ca5a:	f8c4 3188 	str.w	r3, [r4, #392]	; 0x188
9001ca5e:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
9001ca62:	bf02      	ittt	eq
9001ca64:	f8d4 318c 	ldreq.w	r3, [r4, #396]	; 0x18c
9001ca68:	431a      	orreq	r2, r3
9001ca6a:	f8c4 218c 	streq.w	r2, [r4, #396]	; 0x18c
9001ca6e:	1c6b      	adds	r3, r5, #1
9001ca70:	3502      	adds	r5, #2
9001ca72:	6063      	str	r3, [r4, #4]
9001ca74:	f844 7025 	str.w	r7, [r4, r5, lsl #2]
9001ca78:	f7ff f95d 	bl	9001bd36 <__retarget_lock_release_recursive>
9001ca7c:	2000      	movs	r0, #0
9001ca7e:	e7df      	b.n	9001ca40 <__register_exitproc+0x38>
9001ca80:	24000be0 	.word	0x24000be0
9001ca84:	90025340 	.word	0x90025340

9001ca88 <__assert_func>:
9001ca88:	b51f      	push	{r0, r1, r2, r3, r4, lr}
9001ca8a:	4614      	mov	r4, r2
9001ca8c:	461a      	mov	r2, r3
9001ca8e:	4b09      	ldr	r3, [pc, #36]	; (9001cab4 <__assert_func+0x2c>)
9001ca90:	681b      	ldr	r3, [r3, #0]
9001ca92:	4605      	mov	r5, r0
9001ca94:	68d8      	ldr	r0, [r3, #12]
9001ca96:	b14c      	cbz	r4, 9001caac <__assert_func+0x24>
9001ca98:	4b07      	ldr	r3, [pc, #28]	; (9001cab8 <__assert_func+0x30>)
9001ca9a:	9100      	str	r1, [sp, #0]
9001ca9c:	e9cd 3401 	strd	r3, r4, [sp, #4]
9001caa0:	4906      	ldr	r1, [pc, #24]	; (9001cabc <__assert_func+0x34>)
9001caa2:	462b      	mov	r3, r5
9001caa4:	f000 f83c 	bl	9001cb20 <fiprintf>
9001caa8:	f000 ff84 	bl	9001d9b4 <abort>
9001caac:	4b04      	ldr	r3, [pc, #16]	; (9001cac0 <__assert_func+0x38>)
9001caae:	461c      	mov	r4, r3
9001cab0:	e7f3      	b.n	9001ca9a <__assert_func+0x12>
9001cab2:	bf00      	nop
9001cab4:	240007b4 	.word	0x240007b4
9001cab8:	90025574 	.word	0x90025574
9001cabc:	90025581 	.word	0x90025581
9001cac0:	900255af 	.word	0x900255af

9001cac4 <_calloc_r>:
9001cac4:	b510      	push	{r4, lr}
9001cac6:	4351      	muls	r1, r2
9001cac8:	f7ff f936 	bl	9001bd38 <_malloc_r>
9001cacc:	4604      	mov	r4, r0
9001cace:	b198      	cbz	r0, 9001caf8 <_calloc_r+0x34>
9001cad0:	f850 2c04 	ldr.w	r2, [r0, #-4]
9001cad4:	f022 0203 	bic.w	r2, r2, #3
9001cad8:	3a04      	subs	r2, #4
9001cada:	2a24      	cmp	r2, #36	; 0x24
9001cadc:	d81b      	bhi.n	9001cb16 <_calloc_r+0x52>
9001cade:	2a13      	cmp	r2, #19
9001cae0:	d917      	bls.n	9001cb12 <_calloc_r+0x4e>
9001cae2:	2100      	movs	r1, #0
9001cae4:	2a1b      	cmp	r2, #27
9001cae6:	e9c0 1100 	strd	r1, r1, [r0]
9001caea:	d807      	bhi.n	9001cafc <_calloc_r+0x38>
9001caec:	f100 0308 	add.w	r3, r0, #8
9001caf0:	2200      	movs	r2, #0
9001caf2:	e9c3 2200 	strd	r2, r2, [r3]
9001caf6:	609a      	str	r2, [r3, #8]
9001caf8:	4620      	mov	r0, r4
9001cafa:	bd10      	pop	{r4, pc}
9001cafc:	2a24      	cmp	r2, #36	; 0x24
9001cafe:	e9c0 1102 	strd	r1, r1, [r0, #8]
9001cb02:	bf11      	iteee	ne
9001cb04:	f100 0310 	addne.w	r3, r0, #16
9001cb08:	6101      	streq	r1, [r0, #16]
9001cb0a:	f100 0318 	addeq.w	r3, r0, #24
9001cb0e:	6141      	streq	r1, [r0, #20]
9001cb10:	e7ee      	b.n	9001caf0 <_calloc_r+0x2c>
9001cb12:	4603      	mov	r3, r0
9001cb14:	e7ec      	b.n	9001caf0 <_calloc_r+0x2c>
9001cb16:	2100      	movs	r1, #0
9001cb18:	f7fd f842 	bl	90019ba0 <memset>
9001cb1c:	e7ec      	b.n	9001caf8 <_calloc_r+0x34>
	...

9001cb20 <fiprintf>:
9001cb20:	b40e      	push	{r1, r2, r3}
9001cb22:	b503      	push	{r0, r1, lr}
9001cb24:	4601      	mov	r1, r0
9001cb26:	ab03      	add	r3, sp, #12
9001cb28:	4805      	ldr	r0, [pc, #20]	; (9001cb40 <fiprintf+0x20>)
9001cb2a:	f853 2b04 	ldr.w	r2, [r3], #4
9001cb2e:	6800      	ldr	r0, [r0, #0]
9001cb30:	9301      	str	r3, [sp, #4]
9001cb32:	f000 fa11 	bl	9001cf58 <_vfiprintf_r>
9001cb36:	b002      	add	sp, #8
9001cb38:	f85d eb04 	ldr.w	lr, [sp], #4
9001cb3c:	b003      	add	sp, #12
9001cb3e:	4770      	bx	lr
9001cb40:	240007b4 	.word	0x240007b4

9001cb44 <__locale_mb_cur_max>:
9001cb44:	4b01      	ldr	r3, [pc, #4]	; (9001cb4c <__locale_mb_cur_max+0x8>)
9001cb46:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
9001cb4a:	4770      	bx	lr
9001cb4c:	24000ff4 	.word	0x24000ff4

9001cb50 <__ascii_mbtowc>:
9001cb50:	b082      	sub	sp, #8
9001cb52:	b901      	cbnz	r1, 9001cb56 <__ascii_mbtowc+0x6>
9001cb54:	a901      	add	r1, sp, #4
9001cb56:	b142      	cbz	r2, 9001cb6a <__ascii_mbtowc+0x1a>
9001cb58:	b14b      	cbz	r3, 9001cb6e <__ascii_mbtowc+0x1e>
9001cb5a:	7813      	ldrb	r3, [r2, #0]
9001cb5c:	600b      	str	r3, [r1, #0]
9001cb5e:	7812      	ldrb	r2, [r2, #0]
9001cb60:	1e10      	subs	r0, r2, #0
9001cb62:	bf18      	it	ne
9001cb64:	2001      	movne	r0, #1
9001cb66:	b002      	add	sp, #8
9001cb68:	4770      	bx	lr
9001cb6a:	4610      	mov	r0, r2
9001cb6c:	e7fb      	b.n	9001cb66 <__ascii_mbtowc+0x16>
9001cb6e:	f06f 0001 	mvn.w	r0, #1
9001cb72:	e7f8      	b.n	9001cb66 <__ascii_mbtowc+0x16>

9001cb74 <memmove>:
9001cb74:	4288      	cmp	r0, r1
9001cb76:	b510      	push	{r4, lr}
9001cb78:	eb01 0402 	add.w	r4, r1, r2
9001cb7c:	d902      	bls.n	9001cb84 <memmove+0x10>
9001cb7e:	4284      	cmp	r4, r0
9001cb80:	4623      	mov	r3, r4
9001cb82:	d807      	bhi.n	9001cb94 <memmove+0x20>
9001cb84:	1e43      	subs	r3, r0, #1
9001cb86:	42a1      	cmp	r1, r4
9001cb88:	d008      	beq.n	9001cb9c <memmove+0x28>
9001cb8a:	f811 2b01 	ldrb.w	r2, [r1], #1
9001cb8e:	f803 2f01 	strb.w	r2, [r3, #1]!
9001cb92:	e7f8      	b.n	9001cb86 <memmove+0x12>
9001cb94:	4402      	add	r2, r0
9001cb96:	4601      	mov	r1, r0
9001cb98:	428a      	cmp	r2, r1
9001cb9a:	d100      	bne.n	9001cb9e <memmove+0x2a>
9001cb9c:	bd10      	pop	{r4, pc}
9001cb9e:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
9001cba2:	f802 4d01 	strb.w	r4, [r2, #-1]!
9001cba6:	e7f7      	b.n	9001cb98 <memmove+0x24>

9001cba8 <_realloc_r>:
9001cba8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001cbac:	4681      	mov	r9, r0
9001cbae:	460c      	mov	r4, r1
9001cbb0:	b929      	cbnz	r1, 9001cbbe <_realloc_r+0x16>
9001cbb2:	4611      	mov	r1, r2
9001cbb4:	b003      	add	sp, #12
9001cbb6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001cbba:	f7ff b8bd 	b.w	9001bd38 <_malloc_r>
9001cbbe:	9201      	str	r2, [sp, #4]
9001cbc0:	f7ff fafc 	bl	9001c1bc <__malloc_lock>
9001cbc4:	9a01      	ldr	r2, [sp, #4]
9001cbc6:	f102 080b 	add.w	r8, r2, #11
9001cbca:	f1b8 0f16 	cmp.w	r8, #22
9001cbce:	d90b      	bls.n	9001cbe8 <_realloc_r+0x40>
9001cbd0:	f038 0807 	bics.w	r8, r8, #7
9001cbd4:	d50a      	bpl.n	9001cbec <_realloc_r+0x44>
9001cbd6:	230c      	movs	r3, #12
9001cbd8:	f8c9 3000 	str.w	r3, [r9]
9001cbdc:	f04f 0b00 	mov.w	fp, #0
9001cbe0:	4658      	mov	r0, fp
9001cbe2:	b003      	add	sp, #12
9001cbe4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
9001cbe8:	f04f 0810 	mov.w	r8, #16
9001cbec:	4590      	cmp	r8, r2
9001cbee:	d3f2      	bcc.n	9001cbd6 <_realloc_r+0x2e>
9001cbf0:	f854 5c04 	ldr.w	r5, [r4, #-4]
9001cbf4:	f025 0603 	bic.w	r6, r5, #3
9001cbf8:	45b0      	cmp	r8, r6
9001cbfa:	f1a4 0a08 	sub.w	sl, r4, #8
9001cbfe:	f340 8170 	ble.w	9001cee2 <_realloc_r+0x33a>
9001cc02:	48a9      	ldr	r0, [pc, #676]	; (9001cea8 <_realloc_r+0x300>)
9001cc04:	9001      	str	r0, [sp, #4]
9001cc06:	f8d0 c008 	ldr.w	ip, [r0, #8]
9001cc0a:	eb0a 0306 	add.w	r3, sl, r6
9001cc0e:	459c      	cmp	ip, r3
9001cc10:	6859      	ldr	r1, [r3, #4]
9001cc12:	d005      	beq.n	9001cc20 <_realloc_r+0x78>
9001cc14:	f021 0001 	bic.w	r0, r1, #1
9001cc18:	4418      	add	r0, r3
9001cc1a:	6840      	ldr	r0, [r0, #4]
9001cc1c:	07c7      	lsls	r7, r0, #31
9001cc1e:	d427      	bmi.n	9001cc70 <_realloc_r+0xc8>
9001cc20:	f021 0103 	bic.w	r1, r1, #3
9001cc24:	459c      	cmp	ip, r3
9001cc26:	eb06 0701 	add.w	r7, r6, r1
9001cc2a:	d119      	bne.n	9001cc60 <_realloc_r+0xb8>
9001cc2c:	f108 0010 	add.w	r0, r8, #16
9001cc30:	42b8      	cmp	r0, r7
9001cc32:	dc1f      	bgt.n	9001cc74 <_realloc_r+0xcc>
9001cc34:	eb0a 0308 	add.w	r3, sl, r8
9001cc38:	9a01      	ldr	r2, [sp, #4]
9001cc3a:	eba7 0708 	sub.w	r7, r7, r8
9001cc3e:	f047 0701 	orr.w	r7, r7, #1
9001cc42:	6093      	str	r3, [r2, #8]
9001cc44:	605f      	str	r7, [r3, #4]
9001cc46:	f854 3c04 	ldr.w	r3, [r4, #-4]
9001cc4a:	f003 0301 	and.w	r3, r3, #1
9001cc4e:	ea43 0308 	orr.w	r3, r3, r8
9001cc52:	f844 3c04 	str.w	r3, [r4, #-4]
9001cc56:	4648      	mov	r0, r9
9001cc58:	f7ff fab6 	bl	9001c1c8 <__malloc_unlock>
9001cc5c:	46a3      	mov	fp, r4
9001cc5e:	e7bf      	b.n	9001cbe0 <_realloc_r+0x38>
9001cc60:	45b8      	cmp	r8, r7
9001cc62:	dc07      	bgt.n	9001cc74 <_realloc_r+0xcc>
9001cc64:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
9001cc68:	60da      	str	r2, [r3, #12]
9001cc6a:	6093      	str	r3, [r2, #8]
9001cc6c:	4655      	mov	r5, sl
9001cc6e:	e07f      	b.n	9001cd70 <_realloc_r+0x1c8>
9001cc70:	2100      	movs	r1, #0
9001cc72:	460b      	mov	r3, r1
9001cc74:	07e8      	lsls	r0, r5, #31
9001cc76:	f100 80e5 	bmi.w	9001ce44 <_realloc_r+0x29c>
9001cc7a:	f854 5c08 	ldr.w	r5, [r4, #-8]
9001cc7e:	ebaa 0505 	sub.w	r5, sl, r5
9001cc82:	6868      	ldr	r0, [r5, #4]
9001cc84:	f020 0003 	bic.w	r0, r0, #3
9001cc88:	eb00 0b06 	add.w	fp, r0, r6
9001cc8c:	2b00      	cmp	r3, #0
9001cc8e:	f000 80a5 	beq.w	9001cddc <_realloc_r+0x234>
9001cc92:	459c      	cmp	ip, r3
9001cc94:	eb01 070b 	add.w	r7, r1, fp
9001cc98:	d14a      	bne.n	9001cd30 <_realloc_r+0x188>
9001cc9a:	f108 0310 	add.w	r3, r8, #16
9001cc9e:	42bb      	cmp	r3, r7
9001cca0:	f300 809c 	bgt.w	9001cddc <_realloc_r+0x234>
9001cca4:	46ab      	mov	fp, r5
9001cca6:	68eb      	ldr	r3, [r5, #12]
9001cca8:	f85b 2f08 	ldr.w	r2, [fp, #8]!
9001ccac:	60d3      	str	r3, [r2, #12]
9001ccae:	609a      	str	r2, [r3, #8]
9001ccb0:	1f32      	subs	r2, r6, #4
9001ccb2:	2a24      	cmp	r2, #36	; 0x24
9001ccb4:	d837      	bhi.n	9001cd26 <_realloc_r+0x17e>
9001ccb6:	2a13      	cmp	r2, #19
9001ccb8:	d933      	bls.n	9001cd22 <_realloc_r+0x17a>
9001ccba:	6823      	ldr	r3, [r4, #0]
9001ccbc:	60ab      	str	r3, [r5, #8]
9001ccbe:	6863      	ldr	r3, [r4, #4]
9001ccc0:	60eb      	str	r3, [r5, #12]
9001ccc2:	2a1b      	cmp	r2, #27
9001ccc4:	d81b      	bhi.n	9001ccfe <_realloc_r+0x156>
9001ccc6:	3408      	adds	r4, #8
9001ccc8:	f105 0310 	add.w	r3, r5, #16
9001cccc:	6822      	ldr	r2, [r4, #0]
9001ccce:	601a      	str	r2, [r3, #0]
9001ccd0:	6862      	ldr	r2, [r4, #4]
9001ccd2:	605a      	str	r2, [r3, #4]
9001ccd4:	68a2      	ldr	r2, [r4, #8]
9001ccd6:	609a      	str	r2, [r3, #8]
9001ccd8:	eb05 0308 	add.w	r3, r5, r8
9001ccdc:	9a01      	ldr	r2, [sp, #4]
9001ccde:	eba7 0708 	sub.w	r7, r7, r8
9001cce2:	f047 0701 	orr.w	r7, r7, #1
9001cce6:	6093      	str	r3, [r2, #8]
9001cce8:	605f      	str	r7, [r3, #4]
9001ccea:	686b      	ldr	r3, [r5, #4]
9001ccec:	f003 0301 	and.w	r3, r3, #1
9001ccf0:	ea43 0308 	orr.w	r3, r3, r8
9001ccf4:	606b      	str	r3, [r5, #4]
9001ccf6:	4648      	mov	r0, r9
9001ccf8:	f7ff fa66 	bl	9001c1c8 <__malloc_unlock>
9001ccfc:	e770      	b.n	9001cbe0 <_realloc_r+0x38>
9001ccfe:	68a3      	ldr	r3, [r4, #8]
9001cd00:	612b      	str	r3, [r5, #16]
9001cd02:	68e3      	ldr	r3, [r4, #12]
9001cd04:	616b      	str	r3, [r5, #20]
9001cd06:	2a24      	cmp	r2, #36	; 0x24
9001cd08:	bf01      	itttt	eq
9001cd0a:	6923      	ldreq	r3, [r4, #16]
9001cd0c:	61ab      	streq	r3, [r5, #24]
9001cd0e:	6962      	ldreq	r2, [r4, #20]
9001cd10:	61ea      	streq	r2, [r5, #28]
9001cd12:	bf19      	ittee	ne
9001cd14:	3410      	addne	r4, #16
9001cd16:	f105 0318 	addne.w	r3, r5, #24
9001cd1a:	f105 0320 	addeq.w	r3, r5, #32
9001cd1e:	3418      	addeq	r4, #24
9001cd20:	e7d4      	b.n	9001cccc <_realloc_r+0x124>
9001cd22:	465b      	mov	r3, fp
9001cd24:	e7d2      	b.n	9001cccc <_realloc_r+0x124>
9001cd26:	4621      	mov	r1, r4
9001cd28:	4658      	mov	r0, fp
9001cd2a:	f7ff ff23 	bl	9001cb74 <memmove>
9001cd2e:	e7d3      	b.n	9001ccd8 <_realloc_r+0x130>
9001cd30:	45b8      	cmp	r8, r7
9001cd32:	dc53      	bgt.n	9001cddc <_realloc_r+0x234>
9001cd34:	e9d3 3202 	ldrd	r3, r2, [r3, #8]
9001cd38:	4628      	mov	r0, r5
9001cd3a:	60da      	str	r2, [r3, #12]
9001cd3c:	6093      	str	r3, [r2, #8]
9001cd3e:	f850 2f08 	ldr.w	r2, [r0, #8]!
9001cd42:	68eb      	ldr	r3, [r5, #12]
9001cd44:	60d3      	str	r3, [r2, #12]
9001cd46:	609a      	str	r2, [r3, #8]
9001cd48:	1f32      	subs	r2, r6, #4
9001cd4a:	2a24      	cmp	r2, #36	; 0x24
9001cd4c:	d842      	bhi.n	9001cdd4 <_realloc_r+0x22c>
9001cd4e:	2a13      	cmp	r2, #19
9001cd50:	d908      	bls.n	9001cd64 <_realloc_r+0x1bc>
9001cd52:	6823      	ldr	r3, [r4, #0]
9001cd54:	60ab      	str	r3, [r5, #8]
9001cd56:	6863      	ldr	r3, [r4, #4]
9001cd58:	60eb      	str	r3, [r5, #12]
9001cd5a:	2a1b      	cmp	r2, #27
9001cd5c:	d828      	bhi.n	9001cdb0 <_realloc_r+0x208>
9001cd5e:	3408      	adds	r4, #8
9001cd60:	f105 0010 	add.w	r0, r5, #16
9001cd64:	6823      	ldr	r3, [r4, #0]
9001cd66:	6003      	str	r3, [r0, #0]
9001cd68:	6863      	ldr	r3, [r4, #4]
9001cd6a:	6043      	str	r3, [r0, #4]
9001cd6c:	68a3      	ldr	r3, [r4, #8]
9001cd6e:	6083      	str	r3, [r0, #8]
9001cd70:	686a      	ldr	r2, [r5, #4]
9001cd72:	eba7 0008 	sub.w	r0, r7, r8
9001cd76:	280f      	cmp	r0, #15
9001cd78:	f002 0201 	and.w	r2, r2, #1
9001cd7c:	eb05 0307 	add.w	r3, r5, r7
9001cd80:	f240 80b1 	bls.w	9001cee6 <_realloc_r+0x33e>
9001cd84:	eb05 0108 	add.w	r1, r5, r8
9001cd88:	ea48 0202 	orr.w	r2, r8, r2
9001cd8c:	f040 0001 	orr.w	r0, r0, #1
9001cd90:	606a      	str	r2, [r5, #4]
9001cd92:	6048      	str	r0, [r1, #4]
9001cd94:	685a      	ldr	r2, [r3, #4]
9001cd96:	f042 0201 	orr.w	r2, r2, #1
9001cd9a:	605a      	str	r2, [r3, #4]
9001cd9c:	3108      	adds	r1, #8
9001cd9e:	4648      	mov	r0, r9
9001cda0:	f7fe ff02 	bl	9001bba8 <_free_r>
9001cda4:	4648      	mov	r0, r9
9001cda6:	f7ff fa0f 	bl	9001c1c8 <__malloc_unlock>
9001cdaa:	f105 0b08 	add.w	fp, r5, #8
9001cdae:	e717      	b.n	9001cbe0 <_realloc_r+0x38>
9001cdb0:	68a3      	ldr	r3, [r4, #8]
9001cdb2:	612b      	str	r3, [r5, #16]
9001cdb4:	68e3      	ldr	r3, [r4, #12]
9001cdb6:	616b      	str	r3, [r5, #20]
9001cdb8:	2a24      	cmp	r2, #36	; 0x24
9001cdba:	bf01      	itttt	eq
9001cdbc:	6923      	ldreq	r3, [r4, #16]
9001cdbe:	61ab      	streq	r3, [r5, #24]
9001cdc0:	6963      	ldreq	r3, [r4, #20]
9001cdc2:	61eb      	streq	r3, [r5, #28]
9001cdc4:	bf19      	ittee	ne
9001cdc6:	3410      	addne	r4, #16
9001cdc8:	f105 0018 	addne.w	r0, r5, #24
9001cdcc:	f105 0020 	addeq.w	r0, r5, #32
9001cdd0:	3418      	addeq	r4, #24
9001cdd2:	e7c7      	b.n	9001cd64 <_realloc_r+0x1bc>
9001cdd4:	4621      	mov	r1, r4
9001cdd6:	f7ff fecd 	bl	9001cb74 <memmove>
9001cdda:	e7c9      	b.n	9001cd70 <_realloc_r+0x1c8>
9001cddc:	45d8      	cmp	r8, fp
9001cdde:	dc31      	bgt.n	9001ce44 <_realloc_r+0x29c>
9001cde0:	4628      	mov	r0, r5
9001cde2:	68eb      	ldr	r3, [r5, #12]
9001cde4:	f850 2f08 	ldr.w	r2, [r0, #8]!
9001cde8:	60d3      	str	r3, [r2, #12]
9001cdea:	609a      	str	r2, [r3, #8]
9001cdec:	1f32      	subs	r2, r6, #4
9001cdee:	2a24      	cmp	r2, #36	; 0x24
9001cdf0:	d824      	bhi.n	9001ce3c <_realloc_r+0x294>
9001cdf2:	2a13      	cmp	r2, #19
9001cdf4:	d908      	bls.n	9001ce08 <_realloc_r+0x260>
9001cdf6:	6823      	ldr	r3, [r4, #0]
9001cdf8:	60ab      	str	r3, [r5, #8]
9001cdfa:	6863      	ldr	r3, [r4, #4]
9001cdfc:	60eb      	str	r3, [r5, #12]
9001cdfe:	2a1b      	cmp	r2, #27
9001ce00:	d80a      	bhi.n	9001ce18 <_realloc_r+0x270>
9001ce02:	3408      	adds	r4, #8
9001ce04:	f105 0010 	add.w	r0, r5, #16
9001ce08:	6823      	ldr	r3, [r4, #0]
9001ce0a:	6003      	str	r3, [r0, #0]
9001ce0c:	6863      	ldr	r3, [r4, #4]
9001ce0e:	6043      	str	r3, [r0, #4]
9001ce10:	68a3      	ldr	r3, [r4, #8]
9001ce12:	6083      	str	r3, [r0, #8]
9001ce14:	465f      	mov	r7, fp
9001ce16:	e7ab      	b.n	9001cd70 <_realloc_r+0x1c8>
9001ce18:	68a3      	ldr	r3, [r4, #8]
9001ce1a:	612b      	str	r3, [r5, #16]
9001ce1c:	68e3      	ldr	r3, [r4, #12]
9001ce1e:	616b      	str	r3, [r5, #20]
9001ce20:	2a24      	cmp	r2, #36	; 0x24
9001ce22:	bf01      	itttt	eq
9001ce24:	6923      	ldreq	r3, [r4, #16]
9001ce26:	61ab      	streq	r3, [r5, #24]
9001ce28:	6963      	ldreq	r3, [r4, #20]
9001ce2a:	61eb      	streq	r3, [r5, #28]
9001ce2c:	bf19      	ittee	ne
9001ce2e:	3410      	addne	r4, #16
9001ce30:	f105 0018 	addne.w	r0, r5, #24
9001ce34:	f105 0020 	addeq.w	r0, r5, #32
9001ce38:	3418      	addeq	r4, #24
9001ce3a:	e7e5      	b.n	9001ce08 <_realloc_r+0x260>
9001ce3c:	4621      	mov	r1, r4
9001ce3e:	f7ff fe99 	bl	9001cb74 <memmove>
9001ce42:	e7e7      	b.n	9001ce14 <_realloc_r+0x26c>
9001ce44:	4611      	mov	r1, r2
9001ce46:	4648      	mov	r0, r9
9001ce48:	f7fe ff76 	bl	9001bd38 <_malloc_r>
9001ce4c:	4683      	mov	fp, r0
9001ce4e:	2800      	cmp	r0, #0
9001ce50:	f43f af51 	beq.w	9001ccf6 <_realloc_r+0x14e>
9001ce54:	f854 3c04 	ldr.w	r3, [r4, #-4]
9001ce58:	f023 0301 	bic.w	r3, r3, #1
9001ce5c:	4453      	add	r3, sl
9001ce5e:	f1a0 0208 	sub.w	r2, r0, #8
9001ce62:	4293      	cmp	r3, r2
9001ce64:	d105      	bne.n	9001ce72 <_realloc_r+0x2ca>
9001ce66:	f850 7c04 	ldr.w	r7, [r0, #-4]
9001ce6a:	f027 0703 	bic.w	r7, r7, #3
9001ce6e:	4437      	add	r7, r6
9001ce70:	e6fc      	b.n	9001cc6c <_realloc_r+0xc4>
9001ce72:	1f32      	subs	r2, r6, #4
9001ce74:	2a24      	cmp	r2, #36	; 0x24
9001ce76:	d830      	bhi.n	9001ceda <_realloc_r+0x332>
9001ce78:	2a13      	cmp	r2, #19
9001ce7a:	d92b      	bls.n	9001ced4 <_realloc_r+0x32c>
9001ce7c:	6823      	ldr	r3, [r4, #0]
9001ce7e:	6003      	str	r3, [r0, #0]
9001ce80:	6863      	ldr	r3, [r4, #4]
9001ce82:	6043      	str	r3, [r0, #4]
9001ce84:	2a1b      	cmp	r2, #27
9001ce86:	d811      	bhi.n	9001ceac <_realloc_r+0x304>
9001ce88:	f104 0208 	add.w	r2, r4, #8
9001ce8c:	f100 0308 	add.w	r3, r0, #8
9001ce90:	6811      	ldr	r1, [r2, #0]
9001ce92:	6019      	str	r1, [r3, #0]
9001ce94:	6851      	ldr	r1, [r2, #4]
9001ce96:	6059      	str	r1, [r3, #4]
9001ce98:	6892      	ldr	r2, [r2, #8]
9001ce9a:	609a      	str	r2, [r3, #8]
9001ce9c:	4621      	mov	r1, r4
9001ce9e:	4648      	mov	r0, r9
9001cea0:	f7fe fe82 	bl	9001bba8 <_free_r>
9001cea4:	e727      	b.n	9001ccf6 <_realloc_r+0x14e>
9001cea6:	bf00      	nop
9001cea8:	24000be4 	.word	0x24000be4
9001ceac:	68a3      	ldr	r3, [r4, #8]
9001ceae:	6083      	str	r3, [r0, #8]
9001ceb0:	68e3      	ldr	r3, [r4, #12]
9001ceb2:	60c3      	str	r3, [r0, #12]
9001ceb4:	2a24      	cmp	r2, #36	; 0x24
9001ceb6:	bf01      	itttt	eq
9001ceb8:	6923      	ldreq	r3, [r4, #16]
9001ceba:	6103      	streq	r3, [r0, #16]
9001cebc:	6961      	ldreq	r1, [r4, #20]
9001cebe:	6141      	streq	r1, [r0, #20]
9001cec0:	bf19      	ittee	ne
9001cec2:	f104 0210 	addne.w	r2, r4, #16
9001cec6:	f100 0310 	addne.w	r3, r0, #16
9001ceca:	f104 0218 	addeq.w	r2, r4, #24
9001cece:	f100 0318 	addeq.w	r3, r0, #24
9001ced2:	e7dd      	b.n	9001ce90 <_realloc_r+0x2e8>
9001ced4:	4603      	mov	r3, r0
9001ced6:	4622      	mov	r2, r4
9001ced8:	e7da      	b.n	9001ce90 <_realloc_r+0x2e8>
9001ceda:	4621      	mov	r1, r4
9001cedc:	f7ff fe4a 	bl	9001cb74 <memmove>
9001cee0:	e7dc      	b.n	9001ce9c <_realloc_r+0x2f4>
9001cee2:	4637      	mov	r7, r6
9001cee4:	e6c2      	b.n	9001cc6c <_realloc_r+0xc4>
9001cee6:	4317      	orrs	r7, r2
9001cee8:	606f      	str	r7, [r5, #4]
9001ceea:	685a      	ldr	r2, [r3, #4]
9001ceec:	f042 0201 	orr.w	r2, r2, #1
9001cef0:	605a      	str	r2, [r3, #4]
9001cef2:	e757      	b.n	9001cda4 <_realloc_r+0x1fc>

9001cef4 <__sprint_r>:
9001cef4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001cef8:	6893      	ldr	r3, [r2, #8]
9001cefa:	4680      	mov	r8, r0
9001cefc:	460f      	mov	r7, r1
9001cefe:	4614      	mov	r4, r2
9001cf00:	b91b      	cbnz	r3, 9001cf0a <__sprint_r+0x16>
9001cf02:	6053      	str	r3, [r2, #4]
9001cf04:	4618      	mov	r0, r3
9001cf06:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
9001cf0a:	6e4b      	ldr	r3, [r1, #100]	; 0x64
9001cf0c:	049d      	lsls	r5, r3, #18
9001cf0e:	d520      	bpl.n	9001cf52 <__sprint_r+0x5e>
9001cf10:	6815      	ldr	r5, [r2, #0]
9001cf12:	3508      	adds	r5, #8
9001cf14:	e955 b602 	ldrd	fp, r6, [r5, #-8]
9001cf18:	f04f 0900 	mov.w	r9, #0
9001cf1c:	ea4f 0a96 	mov.w	sl, r6, lsr #2
9001cf20:	45ca      	cmp	sl, r9
9001cf22:	dc0b      	bgt.n	9001cf3c <__sprint_r+0x48>
9001cf24:	68a3      	ldr	r3, [r4, #8]
9001cf26:	f026 0003 	bic.w	r0, r6, #3
9001cf2a:	1a18      	subs	r0, r3, r0
9001cf2c:	60a0      	str	r0, [r4, #8]
9001cf2e:	3508      	adds	r5, #8
9001cf30:	2800      	cmp	r0, #0
9001cf32:	d1ef      	bne.n	9001cf14 <__sprint_r+0x20>
9001cf34:	2300      	movs	r3, #0
9001cf36:	e9c4 3301 	strd	r3, r3, [r4, #4]
9001cf3a:	e7e4      	b.n	9001cf06 <__sprint_r+0x12>
9001cf3c:	f85b 1029 	ldr.w	r1, [fp, r9, lsl #2]
9001cf40:	463a      	mov	r2, r7
9001cf42:	4640      	mov	r0, r8
9001cf44:	f000 fea1 	bl	9001dc8a <_fputwc_r>
9001cf48:	1c43      	adds	r3, r0, #1
9001cf4a:	d0f3      	beq.n	9001cf34 <__sprint_r+0x40>
9001cf4c:	f109 0901 	add.w	r9, r9, #1
9001cf50:	e7e6      	b.n	9001cf20 <__sprint_r+0x2c>
9001cf52:	f000 fec5 	bl	9001dce0 <__sfvwrite_r>
9001cf56:	e7ed      	b.n	9001cf34 <__sprint_r+0x40>

9001cf58 <_vfiprintf_r>:
9001cf58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001cf5c:	ed2d 8b02 	vpush	{d8}
9001cf60:	b0b9      	sub	sp, #228	; 0xe4
9001cf62:	460f      	mov	r7, r1
9001cf64:	9201      	str	r2, [sp, #4]
9001cf66:	461d      	mov	r5, r3
9001cf68:	461c      	mov	r4, r3
9001cf6a:	4681      	mov	r9, r0
9001cf6c:	b118      	cbz	r0, 9001cf76 <_vfiprintf_r+0x1e>
9001cf6e:	6b83      	ldr	r3, [r0, #56]	; 0x38
9001cf70:	b90b      	cbnz	r3, 9001cf76 <_vfiprintf_r+0x1e>
9001cf72:	f000 fe21 	bl	9001dbb8 <__sinit>
9001cf76:	6e7b      	ldr	r3, [r7, #100]	; 0x64
9001cf78:	07d8      	lsls	r0, r3, #31
9001cf7a:	d405      	bmi.n	9001cf88 <_vfiprintf_r+0x30>
9001cf7c:	89bb      	ldrh	r3, [r7, #12]
9001cf7e:	0599      	lsls	r1, r3, #22
9001cf80:	d402      	bmi.n	9001cf88 <_vfiprintf_r+0x30>
9001cf82:	6db8      	ldr	r0, [r7, #88]	; 0x58
9001cf84:	f7fe fed6 	bl	9001bd34 <__retarget_lock_acquire_recursive>
9001cf88:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
9001cf8c:	049a      	lsls	r2, r3, #18
9001cf8e:	d406      	bmi.n	9001cf9e <_vfiprintf_r+0x46>
9001cf90:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
9001cf94:	81bb      	strh	r3, [r7, #12]
9001cf96:	6e7b      	ldr	r3, [r7, #100]	; 0x64
9001cf98:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
9001cf9c:	667b      	str	r3, [r7, #100]	; 0x64
9001cf9e:	89bb      	ldrh	r3, [r7, #12]
9001cfa0:	071e      	lsls	r6, r3, #28
9001cfa2:	d501      	bpl.n	9001cfa8 <_vfiprintf_r+0x50>
9001cfa4:	693b      	ldr	r3, [r7, #16]
9001cfa6:	b9bb      	cbnz	r3, 9001cfd8 <_vfiprintf_r+0x80>
9001cfa8:	4639      	mov	r1, r7
9001cfaa:	4648      	mov	r0, r9
9001cfac:	f000 fcaa 	bl	9001d904 <__swsetup_r>
9001cfb0:	b190      	cbz	r0, 9001cfd8 <_vfiprintf_r+0x80>
9001cfb2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
9001cfb4:	07d8      	lsls	r0, r3, #31
9001cfb6:	d508      	bpl.n	9001cfca <_vfiprintf_r+0x72>
9001cfb8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
9001cfbc:	9302      	str	r3, [sp, #8]
9001cfbe:	9802      	ldr	r0, [sp, #8]
9001cfc0:	b039      	add	sp, #228	; 0xe4
9001cfc2:	ecbd 8b02 	vpop	{d8}
9001cfc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
9001cfca:	89bb      	ldrh	r3, [r7, #12]
9001cfcc:	0599      	lsls	r1, r3, #22
9001cfce:	d4f3      	bmi.n	9001cfb8 <_vfiprintf_r+0x60>
9001cfd0:	6db8      	ldr	r0, [r7, #88]	; 0x58
9001cfd2:	f7fe feb0 	bl	9001bd36 <__retarget_lock_release_recursive>
9001cfd6:	e7ef      	b.n	9001cfb8 <_vfiprintf_r+0x60>
9001cfd8:	89bb      	ldrh	r3, [r7, #12]
9001cfda:	f003 021a 	and.w	r2, r3, #26
9001cfde:	2a0a      	cmp	r2, #10
9001cfe0:	d113      	bne.n	9001d00a <_vfiprintf_r+0xb2>
9001cfe2:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
9001cfe6:	2a00      	cmp	r2, #0
9001cfe8:	db0f      	blt.n	9001d00a <_vfiprintf_r+0xb2>
9001cfea:	6e7a      	ldr	r2, [r7, #100]	; 0x64
9001cfec:	07d2      	lsls	r2, r2, #31
9001cfee:	d404      	bmi.n	9001cffa <_vfiprintf_r+0xa2>
9001cff0:	059e      	lsls	r6, r3, #22
9001cff2:	d402      	bmi.n	9001cffa <_vfiprintf_r+0xa2>
9001cff4:	6db8      	ldr	r0, [r7, #88]	; 0x58
9001cff6:	f7fe fe9e 	bl	9001bd36 <__retarget_lock_release_recursive>
9001cffa:	9a01      	ldr	r2, [sp, #4]
9001cffc:	462b      	mov	r3, r5
9001cffe:	4639      	mov	r1, r7
9001d000:	4648      	mov	r0, r9
9001d002:	f000 fc31 	bl	9001d868 <__sbprintf>
9001d006:	9002      	str	r0, [sp, #8]
9001d008:	e7d9      	b.n	9001cfbe <_vfiprintf_r+0x66>
9001d00a:	2300      	movs	r3, #0
9001d00c:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
9001d010:	e9cd 3305 	strd	r3, r3, [sp, #20]
9001d014:	ae0f      	add	r6, sp, #60	; 0x3c
9001d016:	ee08 3a10 	vmov	s16, r3
9001d01a:	960c      	str	r6, [sp, #48]	; 0x30
9001d01c:	9307      	str	r3, [sp, #28]
9001d01e:	9302      	str	r3, [sp, #8]
9001d020:	9b01      	ldr	r3, [sp, #4]
9001d022:	461d      	mov	r5, r3
9001d024:	f813 2b01 	ldrb.w	r2, [r3], #1
9001d028:	b10a      	cbz	r2, 9001d02e <_vfiprintf_r+0xd6>
9001d02a:	2a25      	cmp	r2, #37	; 0x25
9001d02c:	d1f9      	bne.n	9001d022 <_vfiprintf_r+0xca>
9001d02e:	9b01      	ldr	r3, [sp, #4]
9001d030:	ebb5 0803 	subs.w	r8, r5, r3
9001d034:	d00d      	beq.n	9001d052 <_vfiprintf_r+0xfa>
9001d036:	e9c6 3800 	strd	r3, r8, [r6]
9001d03a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
9001d03c:	4443      	add	r3, r8
9001d03e:	930e      	str	r3, [sp, #56]	; 0x38
9001d040:	9b0d      	ldr	r3, [sp, #52]	; 0x34
9001d042:	3301      	adds	r3, #1
9001d044:	2b07      	cmp	r3, #7
9001d046:	930d      	str	r3, [sp, #52]	; 0x34
9001d048:	dc75      	bgt.n	9001d136 <_vfiprintf_r+0x1de>
9001d04a:	3608      	adds	r6, #8
9001d04c:	9b02      	ldr	r3, [sp, #8]
9001d04e:	4443      	add	r3, r8
9001d050:	9302      	str	r3, [sp, #8]
9001d052:	782b      	ldrb	r3, [r5, #0]
9001d054:	2b00      	cmp	r3, #0
9001d056:	f000 83c8 	beq.w	9001d7ea <_vfiprintf_r+0x892>
9001d05a:	2300      	movs	r3, #0
9001d05c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
9001d060:	1c6a      	adds	r2, r5, #1
9001d062:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
9001d066:	9100      	str	r1, [sp, #0]
9001d068:	9303      	str	r3, [sp, #12]
9001d06a:	469a      	mov	sl, r3
9001d06c:	f812 3b01 	ldrb.w	r3, [r2], #1
9001d070:	9201      	str	r2, [sp, #4]
9001d072:	f1a3 0220 	sub.w	r2, r3, #32
9001d076:	2a5a      	cmp	r2, #90	; 0x5a
9001d078:	f200 8310 	bhi.w	9001d69c <_vfiprintf_r+0x744>
9001d07c:	e8df f012 	tbh	[pc, r2, lsl #1]
9001d080:	030e0099 	.word	0x030e0099
9001d084:	00a1030e 	.word	0x00a1030e
9001d088:	030e030e 	.word	0x030e030e
9001d08c:	0080030e 	.word	0x0080030e
9001d090:	030e030e 	.word	0x030e030e
9001d094:	00ae00a4 	.word	0x00ae00a4
9001d098:	00ab030e 	.word	0x00ab030e
9001d09c:	030e00b0 	.word	0x030e00b0
9001d0a0:	00ce00cb 	.word	0x00ce00cb
9001d0a4:	00ce00ce 	.word	0x00ce00ce
9001d0a8:	00ce00ce 	.word	0x00ce00ce
9001d0ac:	00ce00ce 	.word	0x00ce00ce
9001d0b0:	00ce00ce 	.word	0x00ce00ce
9001d0b4:	030e030e 	.word	0x030e030e
9001d0b8:	030e030e 	.word	0x030e030e
9001d0bc:	030e030e 	.word	0x030e030e
9001d0c0:	030e030e 	.word	0x030e030e
9001d0c4:	00f8030e 	.word	0x00f8030e
9001d0c8:	030e0106 	.word	0x030e0106
9001d0cc:	030e030e 	.word	0x030e030e
9001d0d0:	030e030e 	.word	0x030e030e
9001d0d4:	030e030e 	.word	0x030e030e
9001d0d8:	030e030e 	.word	0x030e030e
9001d0dc:	014d030e 	.word	0x014d030e
9001d0e0:	030e030e 	.word	0x030e030e
9001d0e4:	0192030e 	.word	0x0192030e
9001d0e8:	0270030e 	.word	0x0270030e
9001d0ec:	030e030e 	.word	0x030e030e
9001d0f0:	030e028e 	.word	0x030e028e
9001d0f4:	030e030e 	.word	0x030e030e
9001d0f8:	030e030e 	.word	0x030e030e
9001d0fc:	030e030e 	.word	0x030e030e
9001d100:	030e030e 	.word	0x030e030e
9001d104:	00f8030e 	.word	0x00f8030e
9001d108:	030e0108 	.word	0x030e0108
9001d10c:	030e030e 	.word	0x030e030e
9001d110:	010800de 	.word	0x010800de
9001d114:	030e00f2 	.word	0x030e00f2
9001d118:	030e00eb 	.word	0x030e00eb
9001d11c:	014f0130 	.word	0x014f0130
9001d120:	00f20182 	.word	0x00f20182
9001d124:	0192030e 	.word	0x0192030e
9001d128:	02720097 	.word	0x02720097
9001d12c:	030e030e 	.word	0x030e030e
9001d130:	030e0065 	.word	0x030e0065
9001d134:	0097      	.short	0x0097
9001d136:	aa0c      	add	r2, sp, #48	; 0x30
9001d138:	4639      	mov	r1, r7
9001d13a:	4648      	mov	r0, r9
9001d13c:	f7ff feda 	bl	9001cef4 <__sprint_r>
9001d140:	2800      	cmp	r0, #0
9001d142:	f040 8331 	bne.w	9001d7a8 <_vfiprintf_r+0x850>
9001d146:	ae0f      	add	r6, sp, #60	; 0x3c
9001d148:	e780      	b.n	9001d04c <_vfiprintf_r+0xf4>
9001d14a:	4a95      	ldr	r2, [pc, #596]	; (9001d3a0 <_vfiprintf_r+0x448>)
9001d14c:	9205      	str	r2, [sp, #20]
9001d14e:	f01a 0f20 	tst.w	sl, #32
9001d152:	f000 8225 	beq.w	9001d5a0 <_vfiprintf_r+0x648>
9001d156:	3407      	adds	r4, #7
9001d158:	f024 0b07 	bic.w	fp, r4, #7
9001d15c:	e8fb 4502 	ldrd	r4, r5, [fp], #8
9001d160:	f01a 0f01 	tst.w	sl, #1
9001d164:	d009      	beq.n	9001d17a <_vfiprintf_r+0x222>
9001d166:	ea54 0205 	orrs.w	r2, r4, r5
9001d16a:	bf1f      	itttt	ne
9001d16c:	2230      	movne	r2, #48	; 0x30
9001d16e:	f88d 202c 	strbne.w	r2, [sp, #44]	; 0x2c
9001d172:	f88d 302d 	strbne.w	r3, [sp, #45]	; 0x2d
9001d176:	f04a 0a02 	orrne.w	sl, sl, #2
9001d17a:	f42a 6a80 	bic.w	sl, sl, #1024	; 0x400
9001d17e:	e10d      	b.n	9001d39c <_vfiprintf_r+0x444>
9001d180:	4648      	mov	r0, r9
9001d182:	f7fe fdd1 	bl	9001bd28 <_localeconv_r>
9001d186:	6843      	ldr	r3, [r0, #4]
9001d188:	4618      	mov	r0, r3
9001d18a:	ee08 3a10 	vmov	s16, r3
9001d18e:	f7e5 f86f 	bl	90002270 <strlen>
9001d192:	9007      	str	r0, [sp, #28]
9001d194:	4648      	mov	r0, r9
9001d196:	f7fe fdc7 	bl	9001bd28 <_localeconv_r>
9001d19a:	6883      	ldr	r3, [r0, #8]
9001d19c:	9306      	str	r3, [sp, #24]
9001d19e:	9b07      	ldr	r3, [sp, #28]
9001d1a0:	b12b      	cbz	r3, 9001d1ae <_vfiprintf_r+0x256>
9001d1a2:	9b06      	ldr	r3, [sp, #24]
9001d1a4:	b11b      	cbz	r3, 9001d1ae <_vfiprintf_r+0x256>
9001d1a6:	781b      	ldrb	r3, [r3, #0]
9001d1a8:	b10b      	cbz	r3, 9001d1ae <_vfiprintf_r+0x256>
9001d1aa:	f44a 6a80 	orr.w	sl, sl, #1024	; 0x400
9001d1ae:	9a01      	ldr	r2, [sp, #4]
9001d1b0:	e75c      	b.n	9001d06c <_vfiprintf_r+0x114>
9001d1b2:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
9001d1b6:	2b00      	cmp	r3, #0
9001d1b8:	d1f9      	bne.n	9001d1ae <_vfiprintf_r+0x256>
9001d1ba:	2320      	movs	r3, #32
9001d1bc:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
9001d1c0:	e7f5      	b.n	9001d1ae <_vfiprintf_r+0x256>
9001d1c2:	f04a 0a01 	orr.w	sl, sl, #1
9001d1c6:	e7f2      	b.n	9001d1ae <_vfiprintf_r+0x256>
9001d1c8:	f854 3b04 	ldr.w	r3, [r4], #4
9001d1cc:	9303      	str	r3, [sp, #12]
9001d1ce:	2b00      	cmp	r3, #0
9001d1d0:	daed      	bge.n	9001d1ae <_vfiprintf_r+0x256>
9001d1d2:	425b      	negs	r3, r3
9001d1d4:	9303      	str	r3, [sp, #12]
9001d1d6:	f04a 0a04 	orr.w	sl, sl, #4
9001d1da:	e7e8      	b.n	9001d1ae <_vfiprintf_r+0x256>
9001d1dc:	232b      	movs	r3, #43	; 0x2b
9001d1de:	e7ed      	b.n	9001d1bc <_vfiprintf_r+0x264>
9001d1e0:	9a01      	ldr	r2, [sp, #4]
9001d1e2:	f812 3b01 	ldrb.w	r3, [r2], #1
9001d1e6:	2b2a      	cmp	r3, #42	; 0x2a
9001d1e8:	d112      	bne.n	9001d210 <_vfiprintf_r+0x2b8>
9001d1ea:	f854 0b04 	ldr.w	r0, [r4], #4
9001d1ee:	ea40 73e0 	orr.w	r3, r0, r0, asr #31
9001d1f2:	e9cd 3200 	strd	r3, r2, [sp]
9001d1f6:	e7da      	b.n	9001d1ae <_vfiprintf_r+0x256>
9001d1f8:	9b00      	ldr	r3, [sp, #0]
9001d1fa:	200a      	movs	r0, #10
9001d1fc:	fb00 1303 	mla	r3, r0, r3, r1
9001d200:	9300      	str	r3, [sp, #0]
9001d202:	f812 3b01 	ldrb.w	r3, [r2], #1
9001d206:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
9001d20a:	2909      	cmp	r1, #9
9001d20c:	d9f4      	bls.n	9001d1f8 <_vfiprintf_r+0x2a0>
9001d20e:	e72f      	b.n	9001d070 <_vfiprintf_r+0x118>
9001d210:	2100      	movs	r1, #0
9001d212:	9100      	str	r1, [sp, #0]
9001d214:	e7f7      	b.n	9001d206 <_vfiprintf_r+0x2ae>
9001d216:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
9001d21a:	e7c8      	b.n	9001d1ae <_vfiprintf_r+0x256>
9001d21c:	2100      	movs	r1, #0
9001d21e:	9a01      	ldr	r2, [sp, #4]
9001d220:	9103      	str	r1, [sp, #12]
9001d222:	9903      	ldr	r1, [sp, #12]
9001d224:	3b30      	subs	r3, #48	; 0x30
9001d226:	200a      	movs	r0, #10
9001d228:	fb00 3301 	mla	r3, r0, r1, r3
9001d22c:	9303      	str	r3, [sp, #12]
9001d22e:	f812 3b01 	ldrb.w	r3, [r2], #1
9001d232:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
9001d236:	2909      	cmp	r1, #9
9001d238:	d9f3      	bls.n	9001d222 <_vfiprintf_r+0x2ca>
9001d23a:	e719      	b.n	9001d070 <_vfiprintf_r+0x118>
9001d23c:	9b01      	ldr	r3, [sp, #4]
9001d23e:	781b      	ldrb	r3, [r3, #0]
9001d240:	2b68      	cmp	r3, #104	; 0x68
9001d242:	bf01      	itttt	eq
9001d244:	9b01      	ldreq	r3, [sp, #4]
9001d246:	3301      	addeq	r3, #1
9001d248:	9301      	streq	r3, [sp, #4]
9001d24a:	f44a 7a00 	orreq.w	sl, sl, #512	; 0x200
9001d24e:	bf18      	it	ne
9001d250:	f04a 0a40 	orrne.w	sl, sl, #64	; 0x40
9001d254:	e7ab      	b.n	9001d1ae <_vfiprintf_r+0x256>
9001d256:	9b01      	ldr	r3, [sp, #4]
9001d258:	781b      	ldrb	r3, [r3, #0]
9001d25a:	2b6c      	cmp	r3, #108	; 0x6c
9001d25c:	d105      	bne.n	9001d26a <_vfiprintf_r+0x312>
9001d25e:	9b01      	ldr	r3, [sp, #4]
9001d260:	3301      	adds	r3, #1
9001d262:	9301      	str	r3, [sp, #4]
9001d264:	f04a 0a20 	orr.w	sl, sl, #32
9001d268:	e7a1      	b.n	9001d1ae <_vfiprintf_r+0x256>
9001d26a:	f04a 0a10 	orr.w	sl, sl, #16
9001d26e:	e79e      	b.n	9001d1ae <_vfiprintf_r+0x256>
9001d270:	46a3      	mov	fp, r4
9001d272:	2100      	movs	r1, #0
9001d274:	f85b 3b04 	ldr.w	r3, [fp], #4
9001d278:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
9001d27c:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
9001d280:	2301      	movs	r3, #1
9001d282:	9300      	str	r3, [sp, #0]
9001d284:	460d      	mov	r5, r1
9001d286:	f10d 087c 	add.w	r8, sp, #124	; 0x7c
9001d28a:	e0a0      	b.n	9001d3ce <_vfiprintf_r+0x476>
9001d28c:	f04a 0a10 	orr.w	sl, sl, #16
9001d290:	f01a 0f20 	tst.w	sl, #32
9001d294:	d011      	beq.n	9001d2ba <_vfiprintf_r+0x362>
9001d296:	3407      	adds	r4, #7
9001d298:	f024 0b07 	bic.w	fp, r4, #7
9001d29c:	e8fb 4502 	ldrd	r4, r5, [fp], #8
9001d2a0:	2c00      	cmp	r4, #0
9001d2a2:	f175 0300 	sbcs.w	r3, r5, #0
9001d2a6:	da06      	bge.n	9001d2b6 <_vfiprintf_r+0x35e>
9001d2a8:	4264      	negs	r4, r4
9001d2aa:	f04f 032d 	mov.w	r3, #45	; 0x2d
9001d2ae:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
9001d2b2:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
9001d2b6:	2301      	movs	r3, #1
9001d2b8:	e03f      	b.n	9001d33a <_vfiprintf_r+0x3e2>
9001d2ba:	f01a 0f10 	tst.w	sl, #16
9001d2be:	f104 0b04 	add.w	fp, r4, #4
9001d2c2:	d002      	beq.n	9001d2ca <_vfiprintf_r+0x372>
9001d2c4:	6824      	ldr	r4, [r4, #0]
9001d2c6:	17e5      	asrs	r5, r4, #31
9001d2c8:	e7ea      	b.n	9001d2a0 <_vfiprintf_r+0x348>
9001d2ca:	f01a 0f40 	tst.w	sl, #64	; 0x40
9001d2ce:	6824      	ldr	r4, [r4, #0]
9001d2d0:	d001      	beq.n	9001d2d6 <_vfiprintf_r+0x37e>
9001d2d2:	b224      	sxth	r4, r4
9001d2d4:	e7f7      	b.n	9001d2c6 <_vfiprintf_r+0x36e>
9001d2d6:	f41a 7f00 	tst.w	sl, #512	; 0x200
9001d2da:	bf18      	it	ne
9001d2dc:	b264      	sxtbne	r4, r4
9001d2de:	e7f2      	b.n	9001d2c6 <_vfiprintf_r+0x36e>
9001d2e0:	f01a 0f20 	tst.w	sl, #32
9001d2e4:	f854 3b04 	ldr.w	r3, [r4], #4
9001d2e8:	d005      	beq.n	9001d2f6 <_vfiprintf_r+0x39e>
9001d2ea:	9a02      	ldr	r2, [sp, #8]
9001d2ec:	4610      	mov	r0, r2
9001d2ee:	17d1      	asrs	r1, r2, #31
9001d2f0:	e9c3 0100 	strd	r0, r1, [r3]
9001d2f4:	e694      	b.n	9001d020 <_vfiprintf_r+0xc8>
9001d2f6:	f01a 0f10 	tst.w	sl, #16
9001d2fa:	d002      	beq.n	9001d302 <_vfiprintf_r+0x3aa>
9001d2fc:	9a02      	ldr	r2, [sp, #8]
9001d2fe:	601a      	str	r2, [r3, #0]
9001d300:	e68e      	b.n	9001d020 <_vfiprintf_r+0xc8>
9001d302:	f01a 0f40 	tst.w	sl, #64	; 0x40
9001d306:	d002      	beq.n	9001d30e <_vfiprintf_r+0x3b6>
9001d308:	9a02      	ldr	r2, [sp, #8]
9001d30a:	801a      	strh	r2, [r3, #0]
9001d30c:	e688      	b.n	9001d020 <_vfiprintf_r+0xc8>
9001d30e:	f41a 7f00 	tst.w	sl, #512	; 0x200
9001d312:	d0f3      	beq.n	9001d2fc <_vfiprintf_r+0x3a4>
9001d314:	9a02      	ldr	r2, [sp, #8]
9001d316:	701a      	strb	r2, [r3, #0]
9001d318:	e682      	b.n	9001d020 <_vfiprintf_r+0xc8>
9001d31a:	f04a 0a10 	orr.w	sl, sl, #16
9001d31e:	f01a 0f20 	tst.w	sl, #32
9001d322:	d01d      	beq.n	9001d360 <_vfiprintf_r+0x408>
9001d324:	3407      	adds	r4, #7
9001d326:	f024 0b07 	bic.w	fp, r4, #7
9001d32a:	e8fb 4502 	ldrd	r4, r5, [fp], #8
9001d32e:	f42a 6a80 	bic.w	sl, sl, #1024	; 0x400
9001d332:	2300      	movs	r3, #0
9001d334:	2200      	movs	r2, #0
9001d336:	f88d 202b 	strb.w	r2, [sp, #43]	; 0x2b
9001d33a:	9a00      	ldr	r2, [sp, #0]
9001d33c:	3201      	adds	r2, #1
9001d33e:	f000 8261 	beq.w	9001d804 <_vfiprintf_r+0x8ac>
9001d342:	f02a 0280 	bic.w	r2, sl, #128	; 0x80
9001d346:	9204      	str	r2, [sp, #16]
9001d348:	ea54 0205 	orrs.w	r2, r4, r5
9001d34c:	f040 8260 	bne.w	9001d810 <_vfiprintf_r+0x8b8>
9001d350:	9a00      	ldr	r2, [sp, #0]
9001d352:	2a00      	cmp	r2, #0
9001d354:	f000 8197 	beq.w	9001d686 <_vfiprintf_r+0x72e>
9001d358:	2b01      	cmp	r3, #1
9001d35a:	f040 825c 	bne.w	9001d816 <_vfiprintf_r+0x8be>
9001d35e:	e135      	b.n	9001d5cc <_vfiprintf_r+0x674>
9001d360:	f01a 0f10 	tst.w	sl, #16
9001d364:	f104 0b04 	add.w	fp, r4, #4
9001d368:	d001      	beq.n	9001d36e <_vfiprintf_r+0x416>
9001d36a:	6824      	ldr	r4, [r4, #0]
9001d36c:	e003      	b.n	9001d376 <_vfiprintf_r+0x41e>
9001d36e:	f01a 0f40 	tst.w	sl, #64	; 0x40
9001d372:	d002      	beq.n	9001d37a <_vfiprintf_r+0x422>
9001d374:	8824      	ldrh	r4, [r4, #0]
9001d376:	2500      	movs	r5, #0
9001d378:	e7d9      	b.n	9001d32e <_vfiprintf_r+0x3d6>
9001d37a:	f41a 7f00 	tst.w	sl, #512	; 0x200
9001d37e:	d0f4      	beq.n	9001d36a <_vfiprintf_r+0x412>
9001d380:	7824      	ldrb	r4, [r4, #0]
9001d382:	e7f8      	b.n	9001d376 <_vfiprintf_r+0x41e>
9001d384:	46a3      	mov	fp, r4
9001d386:	f647 0330 	movw	r3, #30768	; 0x7830
9001d38a:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
9001d38e:	f85b 4b04 	ldr.w	r4, [fp], #4
9001d392:	4b03      	ldr	r3, [pc, #12]	; (9001d3a0 <_vfiprintf_r+0x448>)
9001d394:	9305      	str	r3, [sp, #20]
9001d396:	2500      	movs	r5, #0
9001d398:	f04a 0a02 	orr.w	sl, sl, #2
9001d39c:	2302      	movs	r3, #2
9001d39e:	e7c9      	b.n	9001d334 <_vfiprintf_r+0x3dc>
9001d3a0:	90025354 	.word	0x90025354
9001d3a4:	9b00      	ldr	r3, [sp, #0]
9001d3a6:	46a3      	mov	fp, r4
9001d3a8:	2500      	movs	r5, #0
9001d3aa:	1c5c      	adds	r4, r3, #1
9001d3ac:	f85b 8b04 	ldr.w	r8, [fp], #4
9001d3b0:	f88d 502b 	strb.w	r5, [sp, #43]	; 0x2b
9001d3b4:	f000 80cf 	beq.w	9001d556 <_vfiprintf_r+0x5fe>
9001d3b8:	461a      	mov	r2, r3
9001d3ba:	4629      	mov	r1, r5
9001d3bc:	4640      	mov	r0, r8
9001d3be:	f7e4 ff07 	bl	900021d0 <memchr>
9001d3c2:	2800      	cmp	r0, #0
9001d3c4:	f000 8174 	beq.w	9001d6b0 <_vfiprintf_r+0x758>
9001d3c8:	eba0 0308 	sub.w	r3, r0, r8
9001d3cc:	9300      	str	r3, [sp, #0]
9001d3ce:	9b00      	ldr	r3, [sp, #0]
9001d3d0:	42ab      	cmp	r3, r5
9001d3d2:	bfb8      	it	lt
9001d3d4:	462b      	movlt	r3, r5
9001d3d6:	9304      	str	r3, [sp, #16]
9001d3d8:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
9001d3dc:	b113      	cbz	r3, 9001d3e4 <_vfiprintf_r+0x48c>
9001d3de:	9b04      	ldr	r3, [sp, #16]
9001d3e0:	3301      	adds	r3, #1
9001d3e2:	9304      	str	r3, [sp, #16]
9001d3e4:	f01a 0302 	ands.w	r3, sl, #2
9001d3e8:	9308      	str	r3, [sp, #32]
9001d3ea:	bf1e      	ittt	ne
9001d3ec:	9b04      	ldrne	r3, [sp, #16]
9001d3ee:	3302      	addne	r3, #2
9001d3f0:	9304      	strne	r3, [sp, #16]
9001d3f2:	f01a 0384 	ands.w	r3, sl, #132	; 0x84
9001d3f6:	9309      	str	r3, [sp, #36]	; 0x24
9001d3f8:	d11f      	bne.n	9001d43a <_vfiprintf_r+0x4e2>
9001d3fa:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
9001d3fe:	1a9c      	subs	r4, r3, r2
9001d400:	2c00      	cmp	r4, #0
9001d402:	dd1a      	ble.n	9001d43a <_vfiprintf_r+0x4e2>
9001d404:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
9001d408:	48b9      	ldr	r0, [pc, #740]	; (9001d6f0 <_vfiprintf_r+0x798>)
9001d40a:	6030      	str	r0, [r6, #0]
9001d40c:	2c10      	cmp	r4, #16
9001d40e:	f103 0301 	add.w	r3, r3, #1
9001d412:	f106 0108 	add.w	r1, r6, #8
9001d416:	f300 814d 	bgt.w	9001d6b4 <_vfiprintf_r+0x75c>
9001d41a:	6074      	str	r4, [r6, #4]
9001d41c:	2b07      	cmp	r3, #7
9001d41e:	4414      	add	r4, r2
9001d420:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
9001d424:	f340 8158 	ble.w	9001d6d8 <_vfiprintf_r+0x780>
9001d428:	aa0c      	add	r2, sp, #48	; 0x30
9001d42a:	4639      	mov	r1, r7
9001d42c:	4648      	mov	r0, r9
9001d42e:	f7ff fd61 	bl	9001cef4 <__sprint_r>
9001d432:	2800      	cmp	r0, #0
9001d434:	f040 81b8 	bne.w	9001d7a8 <_vfiprintf_r+0x850>
9001d438:	ae0f      	add	r6, sp, #60	; 0x3c
9001d43a:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
9001d43e:	b173      	cbz	r3, 9001d45e <_vfiprintf_r+0x506>
9001d440:	f10d 022b 	add.w	r2, sp, #43	; 0x2b
9001d444:	9b0d      	ldr	r3, [sp, #52]	; 0x34
9001d446:	6032      	str	r2, [r6, #0]
9001d448:	2201      	movs	r2, #1
9001d44a:	6072      	str	r2, [r6, #4]
9001d44c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
9001d44e:	3301      	adds	r3, #1
9001d450:	3201      	adds	r2, #1
9001d452:	2b07      	cmp	r3, #7
9001d454:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
9001d458:	f300 8140 	bgt.w	9001d6dc <_vfiprintf_r+0x784>
9001d45c:	3608      	adds	r6, #8
9001d45e:	9b08      	ldr	r3, [sp, #32]
9001d460:	b16b      	cbz	r3, 9001d47e <_vfiprintf_r+0x526>
9001d462:	aa0b      	add	r2, sp, #44	; 0x2c
9001d464:	9b0d      	ldr	r3, [sp, #52]	; 0x34
9001d466:	6032      	str	r2, [r6, #0]
9001d468:	2202      	movs	r2, #2
9001d46a:	6072      	str	r2, [r6, #4]
9001d46c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
9001d46e:	3301      	adds	r3, #1
9001d470:	3202      	adds	r2, #2
9001d472:	2b07      	cmp	r3, #7
9001d474:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
9001d478:	f300 8140 	bgt.w	9001d6fc <_vfiprintf_r+0x7a4>
9001d47c:	3608      	adds	r6, #8
9001d47e:	9b09      	ldr	r3, [sp, #36]	; 0x24
9001d480:	2b80      	cmp	r3, #128	; 0x80
9001d482:	d11f      	bne.n	9001d4c4 <_vfiprintf_r+0x56c>
9001d484:	e9dd 3203 	ldrd	r3, r2, [sp, #12]
9001d488:	1a9c      	subs	r4, r3, r2
9001d48a:	2c00      	cmp	r4, #0
9001d48c:	dd1a      	ble.n	9001d4c4 <_vfiprintf_r+0x56c>
9001d48e:	e9dd 320d 	ldrd	r3, r2, [sp, #52]	; 0x34
9001d492:	4898      	ldr	r0, [pc, #608]	; (9001d6f4 <_vfiprintf_r+0x79c>)
9001d494:	6030      	str	r0, [r6, #0]
9001d496:	2c10      	cmp	r4, #16
9001d498:	f103 0301 	add.w	r3, r3, #1
9001d49c:	f106 0108 	add.w	r1, r6, #8
9001d4a0:	f300 8135 	bgt.w	9001d70e <_vfiprintf_r+0x7b6>
9001d4a4:	6074      	str	r4, [r6, #4]
9001d4a6:	2b07      	cmp	r3, #7
9001d4a8:	4414      	add	r4, r2
9001d4aa:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
9001d4ae:	f340 8140 	ble.w	9001d732 <_vfiprintf_r+0x7da>
9001d4b2:	aa0c      	add	r2, sp, #48	; 0x30
9001d4b4:	4639      	mov	r1, r7
9001d4b6:	4648      	mov	r0, r9
9001d4b8:	f7ff fd1c 	bl	9001cef4 <__sprint_r>
9001d4bc:	2800      	cmp	r0, #0
9001d4be:	f040 8173 	bne.w	9001d7a8 <_vfiprintf_r+0x850>
9001d4c2:	ae0f      	add	r6, sp, #60	; 0x3c
9001d4c4:	9b00      	ldr	r3, [sp, #0]
9001d4c6:	1aec      	subs	r4, r5, r3
9001d4c8:	2c00      	cmp	r4, #0
9001d4ca:	dd1a      	ble.n	9001d502 <_vfiprintf_r+0x5aa>
9001d4cc:	4d89      	ldr	r5, [pc, #548]	; (9001d6f4 <_vfiprintf_r+0x79c>)
9001d4ce:	6035      	str	r5, [r6, #0]
9001d4d0:	e9dd 310d 	ldrd	r3, r1, [sp, #52]	; 0x34
9001d4d4:	2c10      	cmp	r4, #16
9001d4d6:	f103 0301 	add.w	r3, r3, #1
9001d4da:	f106 0208 	add.w	r2, r6, #8
9001d4de:	f300 812a 	bgt.w	9001d736 <_vfiprintf_r+0x7de>
9001d4e2:	6074      	str	r4, [r6, #4]
9001d4e4:	2b07      	cmp	r3, #7
9001d4e6:	440c      	add	r4, r1
9001d4e8:	e9cd 340d 	strd	r3, r4, [sp, #52]	; 0x34
9001d4ec:	f340 8134 	ble.w	9001d758 <_vfiprintf_r+0x800>
9001d4f0:	aa0c      	add	r2, sp, #48	; 0x30
9001d4f2:	4639      	mov	r1, r7
9001d4f4:	4648      	mov	r0, r9
9001d4f6:	f7ff fcfd 	bl	9001cef4 <__sprint_r>
9001d4fa:	2800      	cmp	r0, #0
9001d4fc:	f040 8154 	bne.w	9001d7a8 <_vfiprintf_r+0x850>
9001d500:	ae0f      	add	r6, sp, #60	; 0x3c
9001d502:	9b00      	ldr	r3, [sp, #0]
9001d504:	980e      	ldr	r0, [sp, #56]	; 0x38
9001d506:	6073      	str	r3, [r6, #4]
9001d508:	4418      	add	r0, r3
9001d50a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
9001d50c:	f8c6 8000 	str.w	r8, [r6]
9001d510:	3301      	adds	r3, #1
9001d512:	2b07      	cmp	r3, #7
9001d514:	900e      	str	r0, [sp, #56]	; 0x38
9001d516:	930d      	str	r3, [sp, #52]	; 0x34
9001d518:	f300 8120 	bgt.w	9001d75c <_vfiprintf_r+0x804>
9001d51c:	f106 0308 	add.w	r3, r6, #8
9001d520:	f01a 0f04 	tst.w	sl, #4
9001d524:	f040 8122 	bne.w	9001d76c <_vfiprintf_r+0x814>
9001d528:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
9001d52c:	9904      	ldr	r1, [sp, #16]
9001d52e:	428a      	cmp	r2, r1
9001d530:	bfac      	ite	ge
9001d532:	189b      	addge	r3, r3, r2
9001d534:	185b      	addlt	r3, r3, r1
9001d536:	9302      	str	r3, [sp, #8]
9001d538:	9b0e      	ldr	r3, [sp, #56]	; 0x38
9001d53a:	b13b      	cbz	r3, 9001d54c <_vfiprintf_r+0x5f4>
9001d53c:	aa0c      	add	r2, sp, #48	; 0x30
9001d53e:	4639      	mov	r1, r7
9001d540:	4648      	mov	r0, r9
9001d542:	f7ff fcd7 	bl	9001cef4 <__sprint_r>
9001d546:	2800      	cmp	r0, #0
9001d548:	f040 812e 	bne.w	9001d7a8 <_vfiprintf_r+0x850>
9001d54c:	2300      	movs	r3, #0
9001d54e:	930d      	str	r3, [sp, #52]	; 0x34
9001d550:	465c      	mov	r4, fp
9001d552:	ae0f      	add	r6, sp, #60	; 0x3c
9001d554:	e564      	b.n	9001d020 <_vfiprintf_r+0xc8>
9001d556:	4640      	mov	r0, r8
9001d558:	f7e4 fe8a 	bl	90002270 <strlen>
9001d55c:	9000      	str	r0, [sp, #0]
9001d55e:	e736      	b.n	9001d3ce <_vfiprintf_r+0x476>
9001d560:	f04a 0a10 	orr.w	sl, sl, #16
9001d564:	f01a 0f20 	tst.w	sl, #32
9001d568:	d006      	beq.n	9001d578 <_vfiprintf_r+0x620>
9001d56a:	3407      	adds	r4, #7
9001d56c:	f024 0b07 	bic.w	fp, r4, #7
9001d570:	e8fb 4502 	ldrd	r4, r5, [fp], #8
9001d574:	2301      	movs	r3, #1
9001d576:	e6dd      	b.n	9001d334 <_vfiprintf_r+0x3dc>
9001d578:	f01a 0f10 	tst.w	sl, #16
9001d57c:	f104 0b04 	add.w	fp, r4, #4
9001d580:	d001      	beq.n	9001d586 <_vfiprintf_r+0x62e>
9001d582:	6824      	ldr	r4, [r4, #0]
9001d584:	e003      	b.n	9001d58e <_vfiprintf_r+0x636>
9001d586:	f01a 0f40 	tst.w	sl, #64	; 0x40
9001d58a:	d002      	beq.n	9001d592 <_vfiprintf_r+0x63a>
9001d58c:	8824      	ldrh	r4, [r4, #0]
9001d58e:	2500      	movs	r5, #0
9001d590:	e7f0      	b.n	9001d574 <_vfiprintf_r+0x61c>
9001d592:	f41a 7f00 	tst.w	sl, #512	; 0x200
9001d596:	d0f4      	beq.n	9001d582 <_vfiprintf_r+0x62a>
9001d598:	7824      	ldrb	r4, [r4, #0]
9001d59a:	e7f8      	b.n	9001d58e <_vfiprintf_r+0x636>
9001d59c:	4a56      	ldr	r2, [pc, #344]	; (9001d6f8 <_vfiprintf_r+0x7a0>)
9001d59e:	e5d5      	b.n	9001d14c <_vfiprintf_r+0x1f4>
9001d5a0:	f01a 0f10 	tst.w	sl, #16
9001d5a4:	f104 0b04 	add.w	fp, r4, #4
9001d5a8:	d001      	beq.n	9001d5ae <_vfiprintf_r+0x656>
9001d5aa:	6824      	ldr	r4, [r4, #0]
9001d5ac:	e003      	b.n	9001d5b6 <_vfiprintf_r+0x65e>
9001d5ae:	f01a 0f40 	tst.w	sl, #64	; 0x40
9001d5b2:	d002      	beq.n	9001d5ba <_vfiprintf_r+0x662>
9001d5b4:	8824      	ldrh	r4, [r4, #0]
9001d5b6:	2500      	movs	r5, #0
9001d5b8:	e5d2      	b.n	9001d160 <_vfiprintf_r+0x208>
9001d5ba:	f41a 7f00 	tst.w	sl, #512	; 0x200
9001d5be:	d0f4      	beq.n	9001d5aa <_vfiprintf_r+0x652>
9001d5c0:	7824      	ldrb	r4, [r4, #0]
9001d5c2:	e7f8      	b.n	9001d5b6 <_vfiprintf_r+0x65e>
9001d5c4:	2d00      	cmp	r5, #0
9001d5c6:	bf08      	it	eq
9001d5c8:	2c0a      	cmpeq	r4, #10
9001d5ca:	d205      	bcs.n	9001d5d8 <_vfiprintf_r+0x680>
9001d5cc:	3430      	adds	r4, #48	; 0x30
9001d5ce:	f88d 40df 	strb.w	r4, [sp, #223]	; 0xdf
9001d5d2:	f10d 08df 	add.w	r8, sp, #223	; 0xdf
9001d5d6:	e13c      	b.n	9001d852 <_vfiprintf_r+0x8fa>
9001d5d8:	ab38      	add	r3, sp, #224	; 0xe0
9001d5da:	9308      	str	r3, [sp, #32]
9001d5dc:	9b04      	ldr	r3, [sp, #16]
9001d5de:	f403 6380 	and.w	r3, r3, #1024	; 0x400
9001d5e2:	f04f 0a00 	mov.w	sl, #0
9001d5e6:	9309      	str	r3, [sp, #36]	; 0x24
9001d5e8:	9b08      	ldr	r3, [sp, #32]
9001d5ea:	220a      	movs	r2, #10
9001d5ec:	f103 38ff 	add.w	r8, r3, #4294967295	; 0xffffffff
9001d5f0:	4620      	mov	r0, r4
9001d5f2:	2300      	movs	r3, #0
9001d5f4:	4629      	mov	r1, r5
9001d5f6:	f7e4 fe43 	bl	90002280 <__aeabi_uldivmod>
9001d5fa:	9b08      	ldr	r3, [sp, #32]
9001d5fc:	3230      	adds	r2, #48	; 0x30
9001d5fe:	f803 2c01 	strb.w	r2, [r3, #-1]
9001d602:	9b09      	ldr	r3, [sp, #36]	; 0x24
9001d604:	f10a 0a01 	add.w	sl, sl, #1
9001d608:	b1db      	cbz	r3, 9001d642 <_vfiprintf_r+0x6ea>
9001d60a:	9b06      	ldr	r3, [sp, #24]
9001d60c:	781b      	ldrb	r3, [r3, #0]
9001d60e:	4553      	cmp	r3, sl
9001d610:	d117      	bne.n	9001d642 <_vfiprintf_r+0x6ea>
9001d612:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
9001d616:	d014      	beq.n	9001d642 <_vfiprintf_r+0x6ea>
9001d618:	2d00      	cmp	r5, #0
9001d61a:	bf08      	it	eq
9001d61c:	2c0a      	cmpeq	r4, #10
9001d61e:	d310      	bcc.n	9001d642 <_vfiprintf_r+0x6ea>
9001d620:	9b07      	ldr	r3, [sp, #28]
9001d622:	eba8 0803 	sub.w	r8, r8, r3
9001d626:	461a      	mov	r2, r3
9001d628:	ee18 1a10 	vmov	r1, s16
9001d62c:	4640      	mov	r0, r8
9001d62e:	f7ff f94f 	bl	9001c8d0 <strncpy>
9001d632:	9b06      	ldr	r3, [sp, #24]
9001d634:	785b      	ldrb	r3, [r3, #1]
9001d636:	b1a3      	cbz	r3, 9001d662 <_vfiprintf_r+0x70a>
9001d638:	9b06      	ldr	r3, [sp, #24]
9001d63a:	3301      	adds	r3, #1
9001d63c:	9306      	str	r3, [sp, #24]
9001d63e:	f04f 0a00 	mov.w	sl, #0
9001d642:	220a      	movs	r2, #10
9001d644:	2300      	movs	r3, #0
9001d646:	4620      	mov	r0, r4
9001d648:	4629      	mov	r1, r5
9001d64a:	f7e4 fe19 	bl	90002280 <__aeabi_uldivmod>
9001d64e:	2d00      	cmp	r5, #0
9001d650:	bf08      	it	eq
9001d652:	2c0a      	cmpeq	r4, #10
9001d654:	f0c0 80fd 	bcc.w	9001d852 <_vfiprintf_r+0x8fa>
9001d658:	4604      	mov	r4, r0
9001d65a:	460d      	mov	r5, r1
9001d65c:	f8cd 8020 	str.w	r8, [sp, #32]
9001d660:	e7c2      	b.n	9001d5e8 <_vfiprintf_r+0x690>
9001d662:	469a      	mov	sl, r3
9001d664:	e7ed      	b.n	9001d642 <_vfiprintf_r+0x6ea>
9001d666:	9a05      	ldr	r2, [sp, #20]
9001d668:	f004 030f 	and.w	r3, r4, #15
9001d66c:	5cd3      	ldrb	r3, [r2, r3]
9001d66e:	f808 3d01 	strb.w	r3, [r8, #-1]!
9001d672:	0923      	lsrs	r3, r4, #4
9001d674:	ea43 7305 	orr.w	r3, r3, r5, lsl #28
9001d678:	092a      	lsrs	r2, r5, #4
9001d67a:	461c      	mov	r4, r3
9001d67c:	4615      	mov	r5, r2
9001d67e:	ea54 0305 	orrs.w	r3, r4, r5
9001d682:	d1f0      	bne.n	9001d666 <_vfiprintf_r+0x70e>
9001d684:	e0e5      	b.n	9001d852 <_vfiprintf_r+0x8fa>
9001d686:	b933      	cbnz	r3, 9001d696 <_vfiprintf_r+0x73e>
9001d688:	f01a 0f01 	tst.w	sl, #1
9001d68c:	d003      	beq.n	9001d696 <_vfiprintf_r+0x73e>
9001d68e:	2330      	movs	r3, #48	; 0x30
9001d690:	f88d 30df 	strb.w	r3, [sp, #223]	; 0xdf
9001d694:	e79d      	b.n	9001d5d2 <_vfiprintf_r+0x67a>
9001d696:	f10d 08e0 	add.w	r8, sp, #224	; 0xe0
9001d69a:	e0da      	b.n	9001d852 <_vfiprintf_r+0x8fa>
9001d69c:	2b00      	cmp	r3, #0
9001d69e:	f000 80a4 	beq.w	9001d7ea <_vfiprintf_r+0x892>
9001d6a2:	2100      	movs	r1, #0
9001d6a4:	f88d 307c 	strb.w	r3, [sp, #124]	; 0x7c
9001d6a8:	f88d 102b 	strb.w	r1, [sp, #43]	; 0x2b
9001d6ac:	46a3      	mov	fp, r4
9001d6ae:	e5e7      	b.n	9001d280 <_vfiprintf_r+0x328>
9001d6b0:	4605      	mov	r5, r0
9001d6b2:	e68c      	b.n	9001d3ce <_vfiprintf_r+0x476>
9001d6b4:	2010      	movs	r0, #16
9001d6b6:	4402      	add	r2, r0
9001d6b8:	2b07      	cmp	r3, #7
9001d6ba:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
9001d6be:	6070      	str	r0, [r6, #4]
9001d6c0:	dd07      	ble.n	9001d6d2 <_vfiprintf_r+0x77a>
9001d6c2:	aa0c      	add	r2, sp, #48	; 0x30
9001d6c4:	4639      	mov	r1, r7
9001d6c6:	4648      	mov	r0, r9
9001d6c8:	f7ff fc14 	bl	9001cef4 <__sprint_r>
9001d6cc:	2800      	cmp	r0, #0
9001d6ce:	d16b      	bne.n	9001d7a8 <_vfiprintf_r+0x850>
9001d6d0:	a90f      	add	r1, sp, #60	; 0x3c
9001d6d2:	3c10      	subs	r4, #16
9001d6d4:	460e      	mov	r6, r1
9001d6d6:	e695      	b.n	9001d404 <_vfiprintf_r+0x4ac>
9001d6d8:	460e      	mov	r6, r1
9001d6da:	e6ae      	b.n	9001d43a <_vfiprintf_r+0x4e2>
9001d6dc:	aa0c      	add	r2, sp, #48	; 0x30
9001d6de:	4639      	mov	r1, r7
9001d6e0:	4648      	mov	r0, r9
9001d6e2:	f7ff fc07 	bl	9001cef4 <__sprint_r>
9001d6e6:	2800      	cmp	r0, #0
9001d6e8:	d15e      	bne.n	9001d7a8 <_vfiprintf_r+0x850>
9001d6ea:	ae0f      	add	r6, sp, #60	; 0x3c
9001d6ec:	e6b7      	b.n	9001d45e <_vfiprintf_r+0x506>
9001d6ee:	bf00      	nop
9001d6f0:	900255ba 	.word	0x900255ba
9001d6f4:	900255ca 	.word	0x900255ca
9001d6f8:	90025365 	.word	0x90025365
9001d6fc:	aa0c      	add	r2, sp, #48	; 0x30
9001d6fe:	4639      	mov	r1, r7
9001d700:	4648      	mov	r0, r9
9001d702:	f7ff fbf7 	bl	9001cef4 <__sprint_r>
9001d706:	2800      	cmp	r0, #0
9001d708:	d14e      	bne.n	9001d7a8 <_vfiprintf_r+0x850>
9001d70a:	ae0f      	add	r6, sp, #60	; 0x3c
9001d70c:	e6b7      	b.n	9001d47e <_vfiprintf_r+0x526>
9001d70e:	2010      	movs	r0, #16
9001d710:	4402      	add	r2, r0
9001d712:	2b07      	cmp	r3, #7
9001d714:	e9cd 320d 	strd	r3, r2, [sp, #52]	; 0x34
9001d718:	6070      	str	r0, [r6, #4]
9001d71a:	dd07      	ble.n	9001d72c <_vfiprintf_r+0x7d4>
9001d71c:	aa0c      	add	r2, sp, #48	; 0x30
9001d71e:	4639      	mov	r1, r7
9001d720:	4648      	mov	r0, r9
9001d722:	f7ff fbe7 	bl	9001cef4 <__sprint_r>
9001d726:	2800      	cmp	r0, #0
9001d728:	d13e      	bne.n	9001d7a8 <_vfiprintf_r+0x850>
9001d72a:	a90f      	add	r1, sp, #60	; 0x3c
9001d72c:	3c10      	subs	r4, #16
9001d72e:	460e      	mov	r6, r1
9001d730:	e6ad      	b.n	9001d48e <_vfiprintf_r+0x536>
9001d732:	460e      	mov	r6, r1
9001d734:	e6c6      	b.n	9001d4c4 <_vfiprintf_r+0x56c>
9001d736:	2010      	movs	r0, #16
9001d738:	4401      	add	r1, r0
9001d73a:	2b07      	cmp	r3, #7
9001d73c:	e9cd 310d 	strd	r3, r1, [sp, #52]	; 0x34
9001d740:	6070      	str	r0, [r6, #4]
9001d742:	dd06      	ble.n	9001d752 <_vfiprintf_r+0x7fa>
9001d744:	aa0c      	add	r2, sp, #48	; 0x30
9001d746:	4639      	mov	r1, r7
9001d748:	4648      	mov	r0, r9
9001d74a:	f7ff fbd3 	bl	9001cef4 <__sprint_r>
9001d74e:	bb58      	cbnz	r0, 9001d7a8 <_vfiprintf_r+0x850>
9001d750:	aa0f      	add	r2, sp, #60	; 0x3c
9001d752:	3c10      	subs	r4, #16
9001d754:	4616      	mov	r6, r2
9001d756:	e6ba      	b.n	9001d4ce <_vfiprintf_r+0x576>
9001d758:	4616      	mov	r6, r2
9001d75a:	e6d2      	b.n	9001d502 <_vfiprintf_r+0x5aa>
9001d75c:	aa0c      	add	r2, sp, #48	; 0x30
9001d75e:	4639      	mov	r1, r7
9001d760:	4648      	mov	r0, r9
9001d762:	f7ff fbc7 	bl	9001cef4 <__sprint_r>
9001d766:	b9f8      	cbnz	r0, 9001d7a8 <_vfiprintf_r+0x850>
9001d768:	ab0f      	add	r3, sp, #60	; 0x3c
9001d76a:	e6d9      	b.n	9001d520 <_vfiprintf_r+0x5c8>
9001d76c:	e9dd 2103 	ldrd	r2, r1, [sp, #12]
9001d770:	1a54      	subs	r4, r2, r1
9001d772:	2c00      	cmp	r4, #0
9001d774:	f77f aed8 	ble.w	9001d528 <_vfiprintf_r+0x5d0>
9001d778:	4d3a      	ldr	r5, [pc, #232]	; (9001d864 <_vfiprintf_r+0x90c>)
9001d77a:	2610      	movs	r6, #16
9001d77c:	e9dd 210d 	ldrd	r2, r1, [sp, #52]	; 0x34
9001d780:	2c10      	cmp	r4, #16
9001d782:	f102 0201 	add.w	r2, r2, #1
9001d786:	601d      	str	r5, [r3, #0]
9001d788:	dc1d      	bgt.n	9001d7c6 <_vfiprintf_r+0x86e>
9001d78a:	605c      	str	r4, [r3, #4]
9001d78c:	2a07      	cmp	r2, #7
9001d78e:	440c      	add	r4, r1
9001d790:	e9cd 240d 	strd	r2, r4, [sp, #52]	; 0x34
9001d794:	f77f aec8 	ble.w	9001d528 <_vfiprintf_r+0x5d0>
9001d798:	aa0c      	add	r2, sp, #48	; 0x30
9001d79a:	4639      	mov	r1, r7
9001d79c:	4648      	mov	r0, r9
9001d79e:	f7ff fba9 	bl	9001cef4 <__sprint_r>
9001d7a2:	2800      	cmp	r0, #0
9001d7a4:	f43f aec0 	beq.w	9001d528 <_vfiprintf_r+0x5d0>
9001d7a8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
9001d7aa:	07d9      	lsls	r1, r3, #31
9001d7ac:	d405      	bmi.n	9001d7ba <_vfiprintf_r+0x862>
9001d7ae:	89bb      	ldrh	r3, [r7, #12]
9001d7b0:	059a      	lsls	r2, r3, #22
9001d7b2:	d402      	bmi.n	9001d7ba <_vfiprintf_r+0x862>
9001d7b4:	6db8      	ldr	r0, [r7, #88]	; 0x58
9001d7b6:	f7fe fabe 	bl	9001bd36 <__retarget_lock_release_recursive>
9001d7ba:	89bb      	ldrh	r3, [r7, #12]
9001d7bc:	065b      	lsls	r3, r3, #25
9001d7be:	f57f abfe 	bpl.w	9001cfbe <_vfiprintf_r+0x66>
9001d7c2:	f7ff bbf9 	b.w	9001cfb8 <_vfiprintf_r+0x60>
9001d7c6:	3110      	adds	r1, #16
9001d7c8:	2a07      	cmp	r2, #7
9001d7ca:	e9cd 210d 	strd	r2, r1, [sp, #52]	; 0x34
9001d7ce:	605e      	str	r6, [r3, #4]
9001d7d0:	dc02      	bgt.n	9001d7d8 <_vfiprintf_r+0x880>
9001d7d2:	3308      	adds	r3, #8
9001d7d4:	3c10      	subs	r4, #16
9001d7d6:	e7d1      	b.n	9001d77c <_vfiprintf_r+0x824>
9001d7d8:	aa0c      	add	r2, sp, #48	; 0x30
9001d7da:	4639      	mov	r1, r7
9001d7dc:	4648      	mov	r0, r9
9001d7de:	f7ff fb89 	bl	9001cef4 <__sprint_r>
9001d7e2:	2800      	cmp	r0, #0
9001d7e4:	d1e0      	bne.n	9001d7a8 <_vfiprintf_r+0x850>
9001d7e6:	ab0f      	add	r3, sp, #60	; 0x3c
9001d7e8:	e7f4      	b.n	9001d7d4 <_vfiprintf_r+0x87c>
9001d7ea:	9b0e      	ldr	r3, [sp, #56]	; 0x38
9001d7ec:	b913      	cbnz	r3, 9001d7f4 <_vfiprintf_r+0x89c>
9001d7ee:	2300      	movs	r3, #0
9001d7f0:	930d      	str	r3, [sp, #52]	; 0x34
9001d7f2:	e7d9      	b.n	9001d7a8 <_vfiprintf_r+0x850>
9001d7f4:	aa0c      	add	r2, sp, #48	; 0x30
9001d7f6:	4639      	mov	r1, r7
9001d7f8:	4648      	mov	r0, r9
9001d7fa:	f7ff fb7b 	bl	9001cef4 <__sprint_r>
9001d7fe:	2800      	cmp	r0, #0
9001d800:	d0f5      	beq.n	9001d7ee <_vfiprintf_r+0x896>
9001d802:	e7d1      	b.n	9001d7a8 <_vfiprintf_r+0x850>
9001d804:	ea54 0205 	orrs.w	r2, r4, r5
9001d808:	f8cd a010 	str.w	sl, [sp, #16]
9001d80c:	f43f ada4 	beq.w	9001d358 <_vfiprintf_r+0x400>
9001d810:	2b01      	cmp	r3, #1
9001d812:	f43f aed7 	beq.w	9001d5c4 <_vfiprintf_r+0x66c>
9001d816:	2b02      	cmp	r3, #2
9001d818:	f10d 08e0 	add.w	r8, sp, #224	; 0xe0
9001d81c:	f43f af23 	beq.w	9001d666 <_vfiprintf_r+0x70e>
9001d820:	08e2      	lsrs	r2, r4, #3
9001d822:	ea42 7245 	orr.w	r2, r2, r5, lsl #29
9001d826:	08e8      	lsrs	r0, r5, #3
9001d828:	f004 0307 	and.w	r3, r4, #7
9001d82c:	4605      	mov	r5, r0
9001d82e:	4614      	mov	r4, r2
9001d830:	3330      	adds	r3, #48	; 0x30
9001d832:	ea54 0205 	orrs.w	r2, r4, r5
9001d836:	4641      	mov	r1, r8
9001d838:	f808 3d01 	strb.w	r3, [r8, #-1]!
9001d83c:	d1f0      	bne.n	9001d820 <_vfiprintf_r+0x8c8>
9001d83e:	9a04      	ldr	r2, [sp, #16]
9001d840:	07d0      	lsls	r0, r2, #31
9001d842:	d506      	bpl.n	9001d852 <_vfiprintf_r+0x8fa>
9001d844:	2b30      	cmp	r3, #48	; 0x30
9001d846:	d004      	beq.n	9001d852 <_vfiprintf_r+0x8fa>
9001d848:	2330      	movs	r3, #48	; 0x30
9001d84a:	f808 3c01 	strb.w	r3, [r8, #-1]
9001d84e:	f1a1 0802 	sub.w	r8, r1, #2
9001d852:	ab38      	add	r3, sp, #224	; 0xe0
9001d854:	eba3 0308 	sub.w	r3, r3, r8
9001d858:	9d00      	ldr	r5, [sp, #0]
9001d85a:	f8dd a010 	ldr.w	sl, [sp, #16]
9001d85e:	9300      	str	r3, [sp, #0]
9001d860:	e5b5      	b.n	9001d3ce <_vfiprintf_r+0x476>
9001d862:	bf00      	nop
9001d864:	900255ba 	.word	0x900255ba

9001d868 <__sbprintf>:
9001d868:	b570      	push	{r4, r5, r6, lr}
9001d86a:	460c      	mov	r4, r1
9001d86c:	8989      	ldrh	r1, [r1, #12]
9001d86e:	f5ad 6d8e 	sub.w	sp, sp, #1136	; 0x470
9001d872:	f021 0102 	bic.w	r1, r1, #2
9001d876:	f8ad 1014 	strh.w	r1, [sp, #20]
9001d87a:	6e61      	ldr	r1, [r4, #100]	; 0x64
9001d87c:	911b      	str	r1, [sp, #108]	; 0x6c
9001d87e:	89e1      	ldrh	r1, [r4, #14]
9001d880:	f8ad 1016 	strh.w	r1, [sp, #22]
9001d884:	69e1      	ldr	r1, [r4, #28]
9001d886:	9109      	str	r1, [sp, #36]	; 0x24
9001d888:	6a61      	ldr	r1, [r4, #36]	; 0x24
9001d88a:	910b      	str	r1, [sp, #44]	; 0x2c
9001d88c:	a91c      	add	r1, sp, #112	; 0x70
9001d88e:	9102      	str	r1, [sp, #8]
9001d890:	9106      	str	r1, [sp, #24]
9001d892:	f44f 6180 	mov.w	r1, #1024	; 0x400
9001d896:	4606      	mov	r6, r0
9001d898:	9104      	str	r1, [sp, #16]
9001d89a:	9107      	str	r1, [sp, #28]
9001d89c:	a818      	add	r0, sp, #96	; 0x60
9001d89e:	2100      	movs	r1, #0
9001d8a0:	e9cd 3200 	strd	r3, r2, [sp]
9001d8a4:	9108      	str	r1, [sp, #32]
9001d8a6:	f7fe fa43 	bl	9001bd30 <__retarget_lock_init_recursive>
9001d8aa:	e9dd 3200 	ldrd	r3, r2, [sp]
9001d8ae:	a902      	add	r1, sp, #8
9001d8b0:	4630      	mov	r0, r6
9001d8b2:	f7ff fb51 	bl	9001cf58 <_vfiprintf_r>
9001d8b6:	1e05      	subs	r5, r0, #0
9001d8b8:	db07      	blt.n	9001d8ca <__sbprintf+0x62>
9001d8ba:	a902      	add	r1, sp, #8
9001d8bc:	4630      	mov	r0, r6
9001d8be:	f000 f90f 	bl	9001dae0 <_fflush_r>
9001d8c2:	2800      	cmp	r0, #0
9001d8c4:	bf18      	it	ne
9001d8c6:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
9001d8ca:	f8bd 3014 	ldrh.w	r3, [sp, #20]
9001d8ce:	9818      	ldr	r0, [sp, #96]	; 0x60
9001d8d0:	065b      	lsls	r3, r3, #25
9001d8d2:	bf42      	ittt	mi
9001d8d4:	89a3      	ldrhmi	r3, [r4, #12]
9001d8d6:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
9001d8da:	81a3      	strhmi	r3, [r4, #12]
9001d8dc:	f7fe fa29 	bl	9001bd32 <__retarget_lock_close_recursive>
9001d8e0:	4628      	mov	r0, r5
9001d8e2:	f50d 6d8e 	add.w	sp, sp, #1136	; 0x470
9001d8e6:	bd70      	pop	{r4, r5, r6, pc}

9001d8e8 <__ascii_wctomb>:
9001d8e8:	b149      	cbz	r1, 9001d8fe <__ascii_wctomb+0x16>
9001d8ea:	2aff      	cmp	r2, #255	; 0xff
9001d8ec:	bf85      	ittet	hi
9001d8ee:	238a      	movhi	r3, #138	; 0x8a
9001d8f0:	6003      	strhi	r3, [r0, #0]
9001d8f2:	700a      	strbls	r2, [r1, #0]
9001d8f4:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
9001d8f8:	bf98      	it	ls
9001d8fa:	2001      	movls	r0, #1
9001d8fc:	4770      	bx	lr
9001d8fe:	4608      	mov	r0, r1
9001d900:	4770      	bx	lr
	...

9001d904 <__swsetup_r>:
9001d904:	b538      	push	{r3, r4, r5, lr}
9001d906:	4b2a      	ldr	r3, [pc, #168]	; (9001d9b0 <__swsetup_r+0xac>)
9001d908:	4605      	mov	r5, r0
9001d90a:	6818      	ldr	r0, [r3, #0]
9001d90c:	460c      	mov	r4, r1
9001d90e:	b118      	cbz	r0, 9001d918 <__swsetup_r+0x14>
9001d910:	6b83      	ldr	r3, [r0, #56]	; 0x38
9001d912:	b90b      	cbnz	r3, 9001d918 <__swsetup_r+0x14>
9001d914:	f000 f950 	bl	9001dbb8 <__sinit>
9001d918:	89a3      	ldrh	r3, [r4, #12]
9001d91a:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
9001d91e:	0718      	lsls	r0, r3, #28
9001d920:	d422      	bmi.n	9001d968 <__swsetup_r+0x64>
9001d922:	06d9      	lsls	r1, r3, #27
9001d924:	d407      	bmi.n	9001d936 <__swsetup_r+0x32>
9001d926:	2309      	movs	r3, #9
9001d928:	602b      	str	r3, [r5, #0]
9001d92a:	f042 0340 	orr.w	r3, r2, #64	; 0x40
9001d92e:	81a3      	strh	r3, [r4, #12]
9001d930:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
9001d934:	e034      	b.n	9001d9a0 <__swsetup_r+0x9c>
9001d936:	0758      	lsls	r0, r3, #29
9001d938:	d512      	bpl.n	9001d960 <__swsetup_r+0x5c>
9001d93a:	6b21      	ldr	r1, [r4, #48]	; 0x30
9001d93c:	b141      	cbz	r1, 9001d950 <__swsetup_r+0x4c>
9001d93e:	f104 0340 	add.w	r3, r4, #64	; 0x40
9001d942:	4299      	cmp	r1, r3
9001d944:	d002      	beq.n	9001d94c <__swsetup_r+0x48>
9001d946:	4628      	mov	r0, r5
9001d948:	f7fe f92e 	bl	9001bba8 <_free_r>
9001d94c:	2300      	movs	r3, #0
9001d94e:	6323      	str	r3, [r4, #48]	; 0x30
9001d950:	89a3      	ldrh	r3, [r4, #12]
9001d952:	f023 0324 	bic.w	r3, r3, #36	; 0x24
9001d956:	81a3      	strh	r3, [r4, #12]
9001d958:	2300      	movs	r3, #0
9001d95a:	6063      	str	r3, [r4, #4]
9001d95c:	6923      	ldr	r3, [r4, #16]
9001d95e:	6023      	str	r3, [r4, #0]
9001d960:	89a3      	ldrh	r3, [r4, #12]
9001d962:	f043 0308 	orr.w	r3, r3, #8
9001d966:	81a3      	strh	r3, [r4, #12]
9001d968:	6923      	ldr	r3, [r4, #16]
9001d96a:	b94b      	cbnz	r3, 9001d980 <__swsetup_r+0x7c>
9001d96c:	89a3      	ldrh	r3, [r4, #12]
9001d96e:	f403 7320 	and.w	r3, r3, #640	; 0x280
9001d972:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
9001d976:	d003      	beq.n	9001d980 <__swsetup_r+0x7c>
9001d978:	4621      	mov	r1, r4
9001d97a:	4628      	mov	r0, r5
9001d97c:	f000 fb44 	bl	9001e008 <__smakebuf_r>
9001d980:	89a0      	ldrh	r0, [r4, #12]
9001d982:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
9001d986:	f010 0301 	ands.w	r3, r0, #1
9001d98a:	d00a      	beq.n	9001d9a2 <__swsetup_r+0x9e>
9001d98c:	2300      	movs	r3, #0
9001d98e:	60a3      	str	r3, [r4, #8]
9001d990:	6963      	ldr	r3, [r4, #20]
9001d992:	425b      	negs	r3, r3
9001d994:	61a3      	str	r3, [r4, #24]
9001d996:	6923      	ldr	r3, [r4, #16]
9001d998:	b943      	cbnz	r3, 9001d9ac <__swsetup_r+0xa8>
9001d99a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
9001d99e:	d1c4      	bne.n	9001d92a <__swsetup_r+0x26>
9001d9a0:	bd38      	pop	{r3, r4, r5, pc}
9001d9a2:	0781      	lsls	r1, r0, #30
9001d9a4:	bf58      	it	pl
9001d9a6:	6963      	ldrpl	r3, [r4, #20]
9001d9a8:	60a3      	str	r3, [r4, #8]
9001d9aa:	e7f4      	b.n	9001d996 <__swsetup_r+0x92>
9001d9ac:	2000      	movs	r0, #0
9001d9ae:	e7f7      	b.n	9001d9a0 <__swsetup_r+0x9c>
9001d9b0:	240007b4 	.word	0x240007b4

9001d9b4 <abort>:
9001d9b4:	b508      	push	{r3, lr}
9001d9b6:	2006      	movs	r0, #6
9001d9b8:	f000 fb90 	bl	9001e0dc <raise>
9001d9bc:	2001      	movs	r0, #1
9001d9be:	f7f7 ffff 	bl	900159c0 <_exit>
	...

9001d9c4 <__sflush_r>:
9001d9c4:	898b      	ldrh	r3, [r1, #12]
9001d9c6:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
9001d9ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
9001d9ce:	4605      	mov	r5, r0
9001d9d0:	0718      	lsls	r0, r3, #28
9001d9d2:	460c      	mov	r4, r1
9001d9d4:	d45f      	bmi.n	9001da96 <__sflush_r+0xd2>
9001d9d6:	684b      	ldr	r3, [r1, #4]
9001d9d8:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
9001d9dc:	2b00      	cmp	r3, #0
9001d9de:	818a      	strh	r2, [r1, #12]
9001d9e0:	dc05      	bgt.n	9001d9ee <__sflush_r+0x2a>
9001d9e2:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
9001d9e4:	2b00      	cmp	r3, #0
9001d9e6:	dc02      	bgt.n	9001d9ee <__sflush_r+0x2a>
9001d9e8:	2000      	movs	r0, #0
9001d9ea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
9001d9ee:	6aa6      	ldr	r6, [r4, #40]	; 0x28
9001d9f0:	2e00      	cmp	r6, #0
9001d9f2:	d0f9      	beq.n	9001d9e8 <__sflush_r+0x24>
9001d9f4:	2300      	movs	r3, #0
9001d9f6:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
9001d9fa:	682f      	ldr	r7, [r5, #0]
9001d9fc:	602b      	str	r3, [r5, #0]
9001d9fe:	d036      	beq.n	9001da6e <__sflush_r+0xaa>
9001da00:	6d20      	ldr	r0, [r4, #80]	; 0x50
9001da02:	89a3      	ldrh	r3, [r4, #12]
9001da04:	075a      	lsls	r2, r3, #29
9001da06:	d505      	bpl.n	9001da14 <__sflush_r+0x50>
9001da08:	6863      	ldr	r3, [r4, #4]
9001da0a:	1ac0      	subs	r0, r0, r3
9001da0c:	6b23      	ldr	r3, [r4, #48]	; 0x30
9001da0e:	b10b      	cbz	r3, 9001da14 <__sflush_r+0x50>
9001da10:	6be3      	ldr	r3, [r4, #60]	; 0x3c
9001da12:	1ac0      	subs	r0, r0, r3
9001da14:	2300      	movs	r3, #0
9001da16:	4602      	mov	r2, r0
9001da18:	6aa6      	ldr	r6, [r4, #40]	; 0x28
9001da1a:	69e1      	ldr	r1, [r4, #28]
9001da1c:	4628      	mov	r0, r5
9001da1e:	47b0      	blx	r6
9001da20:	1c43      	adds	r3, r0, #1
9001da22:	89a3      	ldrh	r3, [r4, #12]
9001da24:	d106      	bne.n	9001da34 <__sflush_r+0x70>
9001da26:	6829      	ldr	r1, [r5, #0]
9001da28:	291d      	cmp	r1, #29
9001da2a:	d830      	bhi.n	9001da8e <__sflush_r+0xca>
9001da2c:	4a2b      	ldr	r2, [pc, #172]	; (9001dadc <__sflush_r+0x118>)
9001da2e:	40ca      	lsrs	r2, r1
9001da30:	07d6      	lsls	r6, r2, #31
9001da32:	d52c      	bpl.n	9001da8e <__sflush_r+0xca>
9001da34:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
9001da38:	b21b      	sxth	r3, r3
9001da3a:	2200      	movs	r2, #0
9001da3c:	6062      	str	r2, [r4, #4]
9001da3e:	04d9      	lsls	r1, r3, #19
9001da40:	6922      	ldr	r2, [r4, #16]
9001da42:	81a3      	strh	r3, [r4, #12]
9001da44:	6022      	str	r2, [r4, #0]
9001da46:	d504      	bpl.n	9001da52 <__sflush_r+0x8e>
9001da48:	1c42      	adds	r2, r0, #1
9001da4a:	d101      	bne.n	9001da50 <__sflush_r+0x8c>
9001da4c:	682b      	ldr	r3, [r5, #0]
9001da4e:	b903      	cbnz	r3, 9001da52 <__sflush_r+0x8e>
9001da50:	6520      	str	r0, [r4, #80]	; 0x50
9001da52:	6b21      	ldr	r1, [r4, #48]	; 0x30
9001da54:	602f      	str	r7, [r5, #0]
9001da56:	2900      	cmp	r1, #0
9001da58:	d0c6      	beq.n	9001d9e8 <__sflush_r+0x24>
9001da5a:	f104 0340 	add.w	r3, r4, #64	; 0x40
9001da5e:	4299      	cmp	r1, r3
9001da60:	d002      	beq.n	9001da68 <__sflush_r+0xa4>
9001da62:	4628      	mov	r0, r5
9001da64:	f7fe f8a0 	bl	9001bba8 <_free_r>
9001da68:	2000      	movs	r0, #0
9001da6a:	6320      	str	r0, [r4, #48]	; 0x30
9001da6c:	e7bd      	b.n	9001d9ea <__sflush_r+0x26>
9001da6e:	69e1      	ldr	r1, [r4, #28]
9001da70:	2301      	movs	r3, #1
9001da72:	4628      	mov	r0, r5
9001da74:	47b0      	blx	r6
9001da76:	1c41      	adds	r1, r0, #1
9001da78:	d1c3      	bne.n	9001da02 <__sflush_r+0x3e>
9001da7a:	682b      	ldr	r3, [r5, #0]
9001da7c:	2b00      	cmp	r3, #0
9001da7e:	d0c0      	beq.n	9001da02 <__sflush_r+0x3e>
9001da80:	2b1d      	cmp	r3, #29
9001da82:	d001      	beq.n	9001da88 <__sflush_r+0xc4>
9001da84:	2b16      	cmp	r3, #22
9001da86:	d101      	bne.n	9001da8c <__sflush_r+0xc8>
9001da88:	602f      	str	r7, [r5, #0]
9001da8a:	e7ad      	b.n	9001d9e8 <__sflush_r+0x24>
9001da8c:	89a3      	ldrh	r3, [r4, #12]
9001da8e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
9001da92:	81a3      	strh	r3, [r4, #12]
9001da94:	e7a9      	b.n	9001d9ea <__sflush_r+0x26>
9001da96:	690f      	ldr	r7, [r1, #16]
9001da98:	2f00      	cmp	r7, #0
9001da9a:	d0a5      	beq.n	9001d9e8 <__sflush_r+0x24>
9001da9c:	079b      	lsls	r3, r3, #30
9001da9e:	680e      	ldr	r6, [r1, #0]
9001daa0:	bf08      	it	eq
9001daa2:	694b      	ldreq	r3, [r1, #20]
9001daa4:	600f      	str	r7, [r1, #0]
9001daa6:	bf18      	it	ne
9001daa8:	2300      	movne	r3, #0
9001daaa:	eba6 0807 	sub.w	r8, r6, r7
9001daae:	608b      	str	r3, [r1, #8]
9001dab0:	f1b8 0f00 	cmp.w	r8, #0
9001dab4:	dd98      	ble.n	9001d9e8 <__sflush_r+0x24>
9001dab6:	69e1      	ldr	r1, [r4, #28]
9001dab8:	6a66      	ldr	r6, [r4, #36]	; 0x24
9001daba:	4643      	mov	r3, r8
9001dabc:	463a      	mov	r2, r7
9001dabe:	4628      	mov	r0, r5
9001dac0:	47b0      	blx	r6
9001dac2:	2800      	cmp	r0, #0
9001dac4:	dc06      	bgt.n	9001dad4 <__sflush_r+0x110>
9001dac6:	89a3      	ldrh	r3, [r4, #12]
9001dac8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
9001dacc:	81a3      	strh	r3, [r4, #12]
9001dace:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
9001dad2:	e78a      	b.n	9001d9ea <__sflush_r+0x26>
9001dad4:	4407      	add	r7, r0
9001dad6:	eba8 0800 	sub.w	r8, r8, r0
9001dada:	e7e9      	b.n	9001dab0 <__sflush_r+0xec>
9001dadc:	20400001 	.word	0x20400001

9001dae0 <_fflush_r>:
9001dae0:	b538      	push	{r3, r4, r5, lr}
9001dae2:	460c      	mov	r4, r1
9001dae4:	4605      	mov	r5, r0
9001dae6:	b118      	cbz	r0, 9001daf0 <_fflush_r+0x10>
9001dae8:	6b83      	ldr	r3, [r0, #56]	; 0x38
9001daea:	b90b      	cbnz	r3, 9001daf0 <_fflush_r+0x10>
9001daec:	f000 f864 	bl	9001dbb8 <__sinit>
9001daf0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
9001daf4:	b1bb      	cbz	r3, 9001db26 <_fflush_r+0x46>
9001daf6:	6e62      	ldr	r2, [r4, #100]	; 0x64
9001daf8:	07d0      	lsls	r0, r2, #31
9001dafa:	d404      	bmi.n	9001db06 <_fflush_r+0x26>
9001dafc:	0599      	lsls	r1, r3, #22
9001dafe:	d402      	bmi.n	9001db06 <_fflush_r+0x26>
9001db00:	6da0      	ldr	r0, [r4, #88]	; 0x58
9001db02:	f7fe f917 	bl	9001bd34 <__retarget_lock_acquire_recursive>
9001db06:	4628      	mov	r0, r5
9001db08:	4621      	mov	r1, r4
9001db0a:	f7ff ff5b 	bl	9001d9c4 <__sflush_r>
9001db0e:	6e63      	ldr	r3, [r4, #100]	; 0x64
9001db10:	07da      	lsls	r2, r3, #31
9001db12:	4605      	mov	r5, r0
9001db14:	d405      	bmi.n	9001db22 <_fflush_r+0x42>
9001db16:	89a3      	ldrh	r3, [r4, #12]
9001db18:	059b      	lsls	r3, r3, #22
9001db1a:	d402      	bmi.n	9001db22 <_fflush_r+0x42>
9001db1c:	6da0      	ldr	r0, [r4, #88]	; 0x58
9001db1e:	f7fe f90a 	bl	9001bd36 <__retarget_lock_release_recursive>
9001db22:	4628      	mov	r0, r5
9001db24:	bd38      	pop	{r3, r4, r5, pc}
9001db26:	461d      	mov	r5, r3
9001db28:	e7fb      	b.n	9001db22 <_fflush_r+0x42>
	...

9001db2c <std>:
9001db2c:	2300      	movs	r3, #0
9001db2e:	b510      	push	{r4, lr}
9001db30:	4604      	mov	r4, r0
9001db32:	e9c0 3300 	strd	r3, r3, [r0]
9001db36:	e9c0 3304 	strd	r3, r3, [r0, #16]
9001db3a:	6083      	str	r3, [r0, #8]
9001db3c:	8181      	strh	r1, [r0, #12]
9001db3e:	6643      	str	r3, [r0, #100]	; 0x64
9001db40:	81c2      	strh	r2, [r0, #14]
9001db42:	6183      	str	r3, [r0, #24]
9001db44:	4619      	mov	r1, r3
9001db46:	2208      	movs	r2, #8
9001db48:	305c      	adds	r0, #92	; 0x5c
9001db4a:	f7fc f829 	bl	90019ba0 <memset>
9001db4e:	4b07      	ldr	r3, [pc, #28]	; (9001db6c <std+0x40>)
9001db50:	6223      	str	r3, [r4, #32]
9001db52:	4b07      	ldr	r3, [pc, #28]	; (9001db70 <std+0x44>)
9001db54:	6263      	str	r3, [r4, #36]	; 0x24
9001db56:	4b07      	ldr	r3, [pc, #28]	; (9001db74 <std+0x48>)
9001db58:	62a3      	str	r3, [r4, #40]	; 0x28
9001db5a:	4b07      	ldr	r3, [pc, #28]	; (9001db78 <std+0x4c>)
9001db5c:	61e4      	str	r4, [r4, #28]
9001db5e:	62e3      	str	r3, [r4, #44]	; 0x2c
9001db60:	f104 0058 	add.w	r0, r4, #88	; 0x58
9001db64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
9001db68:	f7fe b8e2 	b.w	9001bd30 <__retarget_lock_init_recursive>
9001db6c:	9001e115 	.word	0x9001e115
9001db70:	9001e137 	.word	0x9001e137
9001db74:	9001e16f 	.word	0x9001e16f
9001db78:	9001e193 	.word	0x9001e193

9001db7c <_cleanup_r>:
9001db7c:	4901      	ldr	r1, [pc, #4]	; (9001db84 <_cleanup_r+0x8>)
9001db7e:	f000 b9f9 	b.w	9001df74 <_fwalk_reent>
9001db82:	bf00      	nop
9001db84:	9001e29d 	.word	0x9001e29d

9001db88 <__sfp_lock_acquire>:
9001db88:	4801      	ldr	r0, [pc, #4]	; (9001db90 <__sfp_lock_acquire+0x8>)
9001db8a:	f7fe b8d3 	b.w	9001bd34 <__retarget_lock_acquire_recursive>
9001db8e:	bf00      	nop
9001db90:	2400b43c 	.word	0x2400b43c

9001db94 <__sfp_lock_release>:
9001db94:	4801      	ldr	r0, [pc, #4]	; (9001db9c <__sfp_lock_release+0x8>)
9001db96:	f7fe b8ce 	b.w	9001bd36 <__retarget_lock_release_recursive>
9001db9a:	bf00      	nop
9001db9c:	2400b43c 	.word	0x2400b43c

9001dba0 <__sinit_lock_acquire>:
9001dba0:	4801      	ldr	r0, [pc, #4]	; (9001dba8 <__sinit_lock_acquire+0x8>)
9001dba2:	f7fe b8c7 	b.w	9001bd34 <__retarget_lock_acquire_recursive>
9001dba6:	bf00      	nop
9001dba8:	2400b437 	.word	0x2400b437

9001dbac <__sinit_lock_release>:
9001dbac:	4801      	ldr	r0, [pc, #4]	; (9001dbb4 <__sinit_lock_release+0x8>)
9001dbae:	f7fe b8c2 	b.w	9001bd36 <__retarget_lock_release_recursive>
9001dbb2:	bf00      	nop
9001dbb4:	2400b437 	.word	0x2400b437

9001dbb8 <__sinit>:
9001dbb8:	b510      	push	{r4, lr}
9001dbba:	4604      	mov	r4, r0
9001dbbc:	f7ff fff0 	bl	9001dba0 <__sinit_lock_acquire>
9001dbc0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
9001dbc2:	b11a      	cbz	r2, 9001dbcc <__sinit+0x14>
9001dbc4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
9001dbc8:	f7ff bff0 	b.w	9001dbac <__sinit_lock_release>
9001dbcc:	4b0d      	ldr	r3, [pc, #52]	; (9001dc04 <__sinit+0x4c>)
9001dbce:	63e3      	str	r3, [r4, #60]	; 0x3c
9001dbd0:	2303      	movs	r3, #3
9001dbd2:	f8c4 32e4 	str.w	r3, [r4, #740]	; 0x2e4
9001dbd6:	f504 733b 	add.w	r3, r4, #748	; 0x2ec
9001dbda:	f8c4 32e8 	str.w	r3, [r4, #744]	; 0x2e8
9001dbde:	6860      	ldr	r0, [r4, #4]
9001dbe0:	f8c4 22e0 	str.w	r2, [r4, #736]	; 0x2e0
9001dbe4:	2104      	movs	r1, #4
9001dbe6:	f7ff ffa1 	bl	9001db2c <std>
9001dbea:	68a0      	ldr	r0, [r4, #8]
9001dbec:	2201      	movs	r2, #1
9001dbee:	2109      	movs	r1, #9
9001dbf0:	f7ff ff9c 	bl	9001db2c <std>
9001dbf4:	68e0      	ldr	r0, [r4, #12]
9001dbf6:	2202      	movs	r2, #2
9001dbf8:	2112      	movs	r1, #18
9001dbfa:	f7ff ff97 	bl	9001db2c <std>
9001dbfe:	2301      	movs	r3, #1
9001dc00:	63a3      	str	r3, [r4, #56]	; 0x38
9001dc02:	e7df      	b.n	9001dbc4 <__sinit+0xc>
9001dc04:	9001db7d 	.word	0x9001db7d

9001dc08 <__fputwc>:
9001dc08:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
9001dc0c:	4680      	mov	r8, r0
9001dc0e:	460e      	mov	r6, r1
9001dc10:	4615      	mov	r5, r2
9001dc12:	f7fe ff97 	bl	9001cb44 <__locale_mb_cur_max>
9001dc16:	2801      	cmp	r0, #1
9001dc18:	d11c      	bne.n	9001dc54 <__fputwc+0x4c>
9001dc1a:	1e73      	subs	r3, r6, #1
9001dc1c:	2bfe      	cmp	r3, #254	; 0xfe
9001dc1e:	d819      	bhi.n	9001dc54 <__fputwc+0x4c>
9001dc20:	f88d 6004 	strb.w	r6, [sp, #4]
9001dc24:	4604      	mov	r4, r0
9001dc26:	2700      	movs	r7, #0
9001dc28:	f10d 0904 	add.w	r9, sp, #4
9001dc2c:	42a7      	cmp	r7, r4
9001dc2e:	d020      	beq.n	9001dc72 <__fputwc+0x6a>
9001dc30:	68ab      	ldr	r3, [r5, #8]
9001dc32:	f817 1009 	ldrb.w	r1, [r7, r9]
9001dc36:	3b01      	subs	r3, #1
9001dc38:	2b00      	cmp	r3, #0
9001dc3a:	60ab      	str	r3, [r5, #8]
9001dc3c:	da04      	bge.n	9001dc48 <__fputwc+0x40>
9001dc3e:	69aa      	ldr	r2, [r5, #24]
9001dc40:	4293      	cmp	r3, r2
9001dc42:	db1a      	blt.n	9001dc7a <__fputwc+0x72>
9001dc44:	290a      	cmp	r1, #10
9001dc46:	d018      	beq.n	9001dc7a <__fputwc+0x72>
9001dc48:	682b      	ldr	r3, [r5, #0]
9001dc4a:	1c5a      	adds	r2, r3, #1
9001dc4c:	602a      	str	r2, [r5, #0]
9001dc4e:	7019      	strb	r1, [r3, #0]
9001dc50:	3701      	adds	r7, #1
9001dc52:	e7eb      	b.n	9001dc2c <__fputwc+0x24>
9001dc54:	4632      	mov	r2, r6
9001dc56:	f105 035c 	add.w	r3, r5, #92	; 0x5c
9001dc5a:	a901      	add	r1, sp, #4
9001dc5c:	4640      	mov	r0, r8
9001dc5e:	f000 fae5 	bl	9001e22c <_wcrtomb_r>
9001dc62:	1c42      	adds	r2, r0, #1
9001dc64:	4604      	mov	r4, r0
9001dc66:	d1de      	bne.n	9001dc26 <__fputwc+0x1e>
9001dc68:	89ab      	ldrh	r3, [r5, #12]
9001dc6a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
9001dc6e:	81ab      	strh	r3, [r5, #12]
9001dc70:	4606      	mov	r6, r0
9001dc72:	4630      	mov	r0, r6
9001dc74:	b003      	add	sp, #12
9001dc76:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
9001dc7a:	462a      	mov	r2, r5
9001dc7c:	4640      	mov	r0, r8
9001dc7e:	f000 fa8c 	bl	9001e19a <__swbuf_r>
9001dc82:	1c43      	adds	r3, r0, #1
9001dc84:	d1e4      	bne.n	9001dc50 <__fputwc+0x48>
9001dc86:	4606      	mov	r6, r0
9001dc88:	e7f3      	b.n	9001dc72 <__fputwc+0x6a>

9001dc8a <_fputwc_r>:
9001dc8a:	6e53      	ldr	r3, [r2, #100]	; 0x64
9001dc8c:	b537      	push	{r0, r1, r2, r4, r5, lr}
9001dc8e:	4614      	mov	r4, r2
9001dc90:	07da      	lsls	r2, r3, #31
9001dc92:	4605      	mov	r5, r0
9001dc94:	d407      	bmi.n	9001dca6 <_fputwc_r+0x1c>
9001dc96:	89a3      	ldrh	r3, [r4, #12]
9001dc98:	059b      	lsls	r3, r3, #22
9001dc9a:	d404      	bmi.n	9001dca6 <_fputwc_r+0x1c>
9001dc9c:	6da0      	ldr	r0, [r4, #88]	; 0x58
9001dc9e:	9101      	str	r1, [sp, #4]
9001dca0:	f7fe f848 	bl	9001bd34 <__retarget_lock_acquire_recursive>
9001dca4:	9901      	ldr	r1, [sp, #4]
9001dca6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
9001dcaa:	0498      	lsls	r0, r3, #18
9001dcac:	d406      	bmi.n	9001dcbc <_fputwc_r+0x32>
9001dcae:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
9001dcb2:	81a3      	strh	r3, [r4, #12]
9001dcb4:	6e63      	ldr	r3, [r4, #100]	; 0x64
9001dcb6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
9001dcba:	6663      	str	r3, [r4, #100]	; 0x64
9001dcbc:	4622      	mov	r2, r4
9001dcbe:	4628      	mov	r0, r5
9001dcc0:	f7ff ffa2 	bl	9001dc08 <__fputwc>
9001dcc4:	6e63      	ldr	r3, [r4, #100]	; 0x64
9001dcc6:	07da      	lsls	r2, r3, #31
9001dcc8:	4605      	mov	r5, r0
9001dcca:	d405      	bmi.n	9001dcd8 <_fputwc_r+0x4e>
9001dccc:	89a3      	ldrh	r3, [r4, #12]
9001dcce:	059b      	lsls	r3, r3, #22
9001dcd0:	d402      	bmi.n	9001dcd8 <_fputwc_r+0x4e>
9001dcd2:	6da0      	ldr	r0, [r4, #88]	; 0x58
9001dcd4:	f7fe f82f 	bl	9001bd36 <__retarget_lock_release_recursive>
9001dcd8:	4628      	mov	r0, r5
9001dcda:	b003      	add	sp, #12
9001dcdc:	bd30      	pop	{r4, r5, pc}
	...

9001dce0 <__sfvwrite_r>:
9001dce0:	6893      	ldr	r3, [r2, #8]
9001dce2:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
9001dce6:	4606      	mov	r6, r0
9001dce8:	460c      	mov	r4, r1
9001dcea:	4690      	mov	r8, r2
9001dcec:	b91b      	cbnz	r3, 9001dcf6 <__sfvwrite_r+0x16>
9001dcee:	2000      	movs	r0, #0
9001dcf0:	b003      	add	sp, #12
9001dcf2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
9001dcf6:	898b      	ldrh	r3, [r1, #12]
9001dcf8:	0718      	lsls	r0, r3, #28
9001dcfa:	d550      	bpl.n	9001dd9e <__sfvwrite_r+0xbe>
9001dcfc:	690b      	ldr	r3, [r1, #16]
9001dcfe:	2b00      	cmp	r3, #0
9001dd00:	d04d      	beq.n	9001dd9e <__sfvwrite_r+0xbe>
9001dd02:	89a3      	ldrh	r3, [r4, #12]
9001dd04:	f8d8 7000 	ldr.w	r7, [r8]
9001dd08:	f013 0902 	ands.w	r9, r3, #2
9001dd0c:	d16c      	bne.n	9001dde8 <__sfvwrite_r+0x108>
9001dd0e:	f013 0301 	ands.w	r3, r3, #1
9001dd12:	f000 809c 	beq.w	9001de4e <__sfvwrite_r+0x16e>
9001dd16:	4648      	mov	r0, r9
9001dd18:	46ca      	mov	sl, r9
9001dd1a:	46cb      	mov	fp, r9
9001dd1c:	f1bb 0f00 	cmp.w	fp, #0
9001dd20:	f000 8103 	beq.w	9001df2a <__sfvwrite_r+0x24a>
9001dd24:	b950      	cbnz	r0, 9001dd3c <__sfvwrite_r+0x5c>
9001dd26:	465a      	mov	r2, fp
9001dd28:	210a      	movs	r1, #10
9001dd2a:	4650      	mov	r0, sl
9001dd2c:	f7e4 fa50 	bl	900021d0 <memchr>
9001dd30:	2800      	cmp	r0, #0
9001dd32:	f000 80ff 	beq.w	9001df34 <__sfvwrite_r+0x254>
9001dd36:	3001      	adds	r0, #1
9001dd38:	eba0 090a 	sub.w	r9, r0, sl
9001dd3c:	6820      	ldr	r0, [r4, #0]
9001dd3e:	6921      	ldr	r1, [r4, #16]
9001dd40:	6963      	ldr	r3, [r4, #20]
9001dd42:	45d9      	cmp	r9, fp
9001dd44:	464a      	mov	r2, r9
9001dd46:	bf28      	it	cs
9001dd48:	465a      	movcs	r2, fp
9001dd4a:	4288      	cmp	r0, r1
9001dd4c:	f240 80f5 	bls.w	9001df3a <__sfvwrite_r+0x25a>
9001dd50:	68a5      	ldr	r5, [r4, #8]
9001dd52:	441d      	add	r5, r3
9001dd54:	42aa      	cmp	r2, r5
9001dd56:	f340 80f0 	ble.w	9001df3a <__sfvwrite_r+0x25a>
9001dd5a:	4651      	mov	r1, sl
9001dd5c:	462a      	mov	r2, r5
9001dd5e:	f7fe ff09 	bl	9001cb74 <memmove>
9001dd62:	6823      	ldr	r3, [r4, #0]
9001dd64:	442b      	add	r3, r5
9001dd66:	6023      	str	r3, [r4, #0]
9001dd68:	4621      	mov	r1, r4
9001dd6a:	4630      	mov	r0, r6
9001dd6c:	f7ff feb8 	bl	9001dae0 <_fflush_r>
9001dd70:	2800      	cmp	r0, #0
9001dd72:	d167      	bne.n	9001de44 <__sfvwrite_r+0x164>
9001dd74:	ebb9 0905 	subs.w	r9, r9, r5
9001dd78:	f040 80f7 	bne.w	9001df6a <__sfvwrite_r+0x28a>
9001dd7c:	4621      	mov	r1, r4
9001dd7e:	4630      	mov	r0, r6
9001dd80:	f7ff feae 	bl	9001dae0 <_fflush_r>
9001dd84:	2800      	cmp	r0, #0
9001dd86:	d15d      	bne.n	9001de44 <__sfvwrite_r+0x164>
9001dd88:	f8d8 2008 	ldr.w	r2, [r8, #8]
9001dd8c:	44aa      	add	sl, r5
9001dd8e:	ebab 0b05 	sub.w	fp, fp, r5
9001dd92:	1b55      	subs	r5, r2, r5
9001dd94:	f8c8 5008 	str.w	r5, [r8, #8]
9001dd98:	2d00      	cmp	r5, #0
9001dd9a:	d1bf      	bne.n	9001dd1c <__sfvwrite_r+0x3c>
9001dd9c:	e7a7      	b.n	9001dcee <__sfvwrite_r+0xe>
9001dd9e:	4621      	mov	r1, r4
9001dda0:	4630      	mov	r0, r6
9001dda2:	f7ff fdaf 	bl	9001d904 <__swsetup_r>
9001dda6:	2800      	cmp	r0, #0
9001dda8:	d0ab      	beq.n	9001dd02 <__sfvwrite_r+0x22>
9001ddaa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
9001ddae:	e79f      	b.n	9001dcf0 <__sfvwrite_r+0x10>
9001ddb0:	e9d7 b900 	ldrd	fp, r9, [r7]
9001ddb4:	3708      	adds	r7, #8
9001ddb6:	f1b9 0f00 	cmp.w	r9, #0
9001ddba:	d0f9      	beq.n	9001ddb0 <__sfvwrite_r+0xd0>
9001ddbc:	45d1      	cmp	r9, sl
9001ddbe:	464b      	mov	r3, r9
9001ddc0:	69e1      	ldr	r1, [r4, #28]
9001ddc2:	6a65      	ldr	r5, [r4, #36]	; 0x24
9001ddc4:	bf28      	it	cs
9001ddc6:	4653      	movcs	r3, sl
9001ddc8:	465a      	mov	r2, fp
9001ddca:	4630      	mov	r0, r6
9001ddcc:	47a8      	blx	r5
9001ddce:	2800      	cmp	r0, #0
9001ddd0:	dd38      	ble.n	9001de44 <__sfvwrite_r+0x164>
9001ddd2:	f8d8 3008 	ldr.w	r3, [r8, #8]
9001ddd6:	4483      	add	fp, r0
9001ddd8:	eba9 0900 	sub.w	r9, r9, r0
9001dddc:	1a18      	subs	r0, r3, r0
9001ddde:	f8c8 0008 	str.w	r0, [r8, #8]
9001dde2:	2800      	cmp	r0, #0
9001dde4:	d1e7      	bne.n	9001ddb6 <__sfvwrite_r+0xd6>
9001dde6:	e782      	b.n	9001dcee <__sfvwrite_r+0xe>
9001dde8:	f04f 0b00 	mov.w	fp, #0
9001ddec:	f8df a180 	ldr.w	sl, [pc, #384]	; 9001df70 <__sfvwrite_r+0x290>
9001ddf0:	46d9      	mov	r9, fp
9001ddf2:	e7e0      	b.n	9001ddb6 <__sfvwrite_r+0xd6>
9001ddf4:	e9d7 9a00 	ldrd	r9, sl, [r7]
9001ddf8:	3708      	adds	r7, #8
9001ddfa:	f1ba 0f00 	cmp.w	sl, #0
9001ddfe:	d0f9      	beq.n	9001ddf4 <__sfvwrite_r+0x114>
9001de00:	89a3      	ldrh	r3, [r4, #12]
9001de02:	68a2      	ldr	r2, [r4, #8]
9001de04:	6820      	ldr	r0, [r4, #0]
9001de06:	0599      	lsls	r1, r3, #22
9001de08:	d563      	bpl.n	9001ded2 <__sfvwrite_r+0x1f2>
9001de0a:	4552      	cmp	r2, sl
9001de0c:	d836      	bhi.n	9001de7c <__sfvwrite_r+0x19c>
9001de0e:	f413 6f90 	tst.w	r3, #1152	; 0x480
9001de12:	d033      	beq.n	9001de7c <__sfvwrite_r+0x19c>
9001de14:	6921      	ldr	r1, [r4, #16]
9001de16:	6965      	ldr	r5, [r4, #20]
9001de18:	eba0 0b01 	sub.w	fp, r0, r1
9001de1c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
9001de20:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
9001de24:	f10b 0201 	add.w	r2, fp, #1
9001de28:	106d      	asrs	r5, r5, #1
9001de2a:	4452      	add	r2, sl
9001de2c:	4295      	cmp	r5, r2
9001de2e:	bf38      	it	cc
9001de30:	4615      	movcc	r5, r2
9001de32:	055b      	lsls	r3, r3, #21
9001de34:	d53d      	bpl.n	9001deb2 <__sfvwrite_r+0x1d2>
9001de36:	4629      	mov	r1, r5
9001de38:	4630      	mov	r0, r6
9001de3a:	f7fd ff7d 	bl	9001bd38 <_malloc_r>
9001de3e:	b948      	cbnz	r0, 9001de54 <__sfvwrite_r+0x174>
9001de40:	230c      	movs	r3, #12
9001de42:	6033      	str	r3, [r6, #0]
9001de44:	89a3      	ldrh	r3, [r4, #12]
9001de46:	f043 0340 	orr.w	r3, r3, #64	; 0x40
9001de4a:	81a3      	strh	r3, [r4, #12]
9001de4c:	e7ad      	b.n	9001ddaa <__sfvwrite_r+0xca>
9001de4e:	4699      	mov	r9, r3
9001de50:	469a      	mov	sl, r3
9001de52:	e7d2      	b.n	9001ddfa <__sfvwrite_r+0x11a>
9001de54:	465a      	mov	r2, fp
9001de56:	6921      	ldr	r1, [r4, #16]
9001de58:	9001      	str	r0, [sp, #4]
9001de5a:	f7fb fe93 	bl	90019b84 <memcpy>
9001de5e:	89a2      	ldrh	r2, [r4, #12]
9001de60:	9b01      	ldr	r3, [sp, #4]
9001de62:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
9001de66:	f042 0280 	orr.w	r2, r2, #128	; 0x80
9001de6a:	81a2      	strh	r2, [r4, #12]
9001de6c:	6123      	str	r3, [r4, #16]
9001de6e:	6165      	str	r5, [r4, #20]
9001de70:	445b      	add	r3, fp
9001de72:	eba5 050b 	sub.w	r5, r5, fp
9001de76:	6023      	str	r3, [r4, #0]
9001de78:	4652      	mov	r2, sl
9001de7a:	60a5      	str	r5, [r4, #8]
9001de7c:	4552      	cmp	r2, sl
9001de7e:	bf28      	it	cs
9001de80:	4652      	movcs	r2, sl
9001de82:	6820      	ldr	r0, [r4, #0]
9001de84:	9201      	str	r2, [sp, #4]
9001de86:	4649      	mov	r1, r9
9001de88:	f7fe fe74 	bl	9001cb74 <memmove>
9001de8c:	68a3      	ldr	r3, [r4, #8]
9001de8e:	9a01      	ldr	r2, [sp, #4]
9001de90:	1a9b      	subs	r3, r3, r2
9001de92:	60a3      	str	r3, [r4, #8]
9001de94:	6823      	ldr	r3, [r4, #0]
9001de96:	441a      	add	r2, r3
9001de98:	4655      	mov	r5, sl
9001de9a:	6022      	str	r2, [r4, #0]
9001de9c:	f8d8 0008 	ldr.w	r0, [r8, #8]
9001dea0:	44a9      	add	r9, r5
9001dea2:	ebaa 0a05 	sub.w	sl, sl, r5
9001dea6:	1b45      	subs	r5, r0, r5
9001dea8:	f8c8 5008 	str.w	r5, [r8, #8]
9001deac:	2d00      	cmp	r5, #0
9001deae:	d1a4      	bne.n	9001ddfa <__sfvwrite_r+0x11a>
9001deb0:	e71d      	b.n	9001dcee <__sfvwrite_r+0xe>
9001deb2:	462a      	mov	r2, r5
9001deb4:	4630      	mov	r0, r6
9001deb6:	f7fe fe77 	bl	9001cba8 <_realloc_r>
9001deba:	4603      	mov	r3, r0
9001debc:	2800      	cmp	r0, #0
9001debe:	d1d5      	bne.n	9001de6c <__sfvwrite_r+0x18c>
9001dec0:	6921      	ldr	r1, [r4, #16]
9001dec2:	4630      	mov	r0, r6
9001dec4:	f7fd fe70 	bl	9001bba8 <_free_r>
9001dec8:	89a3      	ldrh	r3, [r4, #12]
9001deca:	f023 0380 	bic.w	r3, r3, #128	; 0x80
9001dece:	81a3      	strh	r3, [r4, #12]
9001ded0:	e7b6      	b.n	9001de40 <__sfvwrite_r+0x160>
9001ded2:	6923      	ldr	r3, [r4, #16]
9001ded4:	4283      	cmp	r3, r0
9001ded6:	d302      	bcc.n	9001dede <__sfvwrite_r+0x1fe>
9001ded8:	6961      	ldr	r1, [r4, #20]
9001deda:	4551      	cmp	r1, sl
9001dedc:	d915      	bls.n	9001df0a <__sfvwrite_r+0x22a>
9001dede:	4552      	cmp	r2, sl
9001dee0:	bf28      	it	cs
9001dee2:	4652      	movcs	r2, sl
9001dee4:	4649      	mov	r1, r9
9001dee6:	4615      	mov	r5, r2
9001dee8:	f7fe fe44 	bl	9001cb74 <memmove>
9001deec:	68a3      	ldr	r3, [r4, #8]
9001deee:	6822      	ldr	r2, [r4, #0]
9001def0:	1b5b      	subs	r3, r3, r5
9001def2:	442a      	add	r2, r5
9001def4:	60a3      	str	r3, [r4, #8]
9001def6:	6022      	str	r2, [r4, #0]
9001def8:	2b00      	cmp	r3, #0
9001defa:	d1cf      	bne.n	9001de9c <__sfvwrite_r+0x1bc>
9001defc:	4621      	mov	r1, r4
9001defe:	4630      	mov	r0, r6
9001df00:	f7ff fdee 	bl	9001dae0 <_fflush_r>
9001df04:	2800      	cmp	r0, #0
9001df06:	d0c9      	beq.n	9001de9c <__sfvwrite_r+0x1bc>
9001df08:	e79c      	b.n	9001de44 <__sfvwrite_r+0x164>
9001df0a:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
9001df0e:	459a      	cmp	sl, r3
9001df10:	bf38      	it	cc
9001df12:	4653      	movcc	r3, sl
9001df14:	6a65      	ldr	r5, [r4, #36]	; 0x24
9001df16:	fb93 f3f1 	sdiv	r3, r3, r1
9001df1a:	464a      	mov	r2, r9
9001df1c:	434b      	muls	r3, r1
9001df1e:	4630      	mov	r0, r6
9001df20:	69e1      	ldr	r1, [r4, #28]
9001df22:	47a8      	blx	r5
9001df24:	1e05      	subs	r5, r0, #0
9001df26:	dcb9      	bgt.n	9001de9c <__sfvwrite_r+0x1bc>
9001df28:	e78c      	b.n	9001de44 <__sfvwrite_r+0x164>
9001df2a:	e9d7 ab00 	ldrd	sl, fp, [r7]
9001df2e:	2000      	movs	r0, #0
9001df30:	3708      	adds	r7, #8
9001df32:	e6f3      	b.n	9001dd1c <__sfvwrite_r+0x3c>
9001df34:	f10b 0901 	add.w	r9, fp, #1
9001df38:	e700      	b.n	9001dd3c <__sfvwrite_r+0x5c>
9001df3a:	4293      	cmp	r3, r2
9001df3c:	dc08      	bgt.n	9001df50 <__sfvwrite_r+0x270>
9001df3e:	6a65      	ldr	r5, [r4, #36]	; 0x24
9001df40:	69e1      	ldr	r1, [r4, #28]
9001df42:	4652      	mov	r2, sl
9001df44:	4630      	mov	r0, r6
9001df46:	47a8      	blx	r5
9001df48:	1e05      	subs	r5, r0, #0
9001df4a:	f73f af13 	bgt.w	9001dd74 <__sfvwrite_r+0x94>
9001df4e:	e779      	b.n	9001de44 <__sfvwrite_r+0x164>
9001df50:	4651      	mov	r1, sl
9001df52:	9201      	str	r2, [sp, #4]
9001df54:	f7fe fe0e 	bl	9001cb74 <memmove>
9001df58:	9a01      	ldr	r2, [sp, #4]
9001df5a:	68a3      	ldr	r3, [r4, #8]
9001df5c:	1a9b      	subs	r3, r3, r2
9001df5e:	60a3      	str	r3, [r4, #8]
9001df60:	6823      	ldr	r3, [r4, #0]
9001df62:	4413      	add	r3, r2
9001df64:	6023      	str	r3, [r4, #0]
9001df66:	4615      	mov	r5, r2
9001df68:	e704      	b.n	9001dd74 <__sfvwrite_r+0x94>
9001df6a:	2001      	movs	r0, #1
9001df6c:	e70c      	b.n	9001dd88 <__sfvwrite_r+0xa8>
9001df6e:	bf00      	nop
9001df70:	7ffffc00 	.word	0x7ffffc00

9001df74 <_fwalk_reent>:
9001df74:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
9001df78:	4606      	mov	r6, r0
9001df7a:	4688      	mov	r8, r1
9001df7c:	f500 7438 	add.w	r4, r0, #736	; 0x2e0
9001df80:	2700      	movs	r7, #0
9001df82:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
9001df86:	f1b9 0901 	subs.w	r9, r9, #1
9001df8a:	d505      	bpl.n	9001df98 <_fwalk_reent+0x24>
9001df8c:	6824      	ldr	r4, [r4, #0]
9001df8e:	2c00      	cmp	r4, #0
9001df90:	d1f7      	bne.n	9001df82 <_fwalk_reent+0xe>
9001df92:	4638      	mov	r0, r7
9001df94:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
9001df98:	89ab      	ldrh	r3, [r5, #12]
9001df9a:	2b01      	cmp	r3, #1
9001df9c:	d907      	bls.n	9001dfae <_fwalk_reent+0x3a>
9001df9e:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
9001dfa2:	3301      	adds	r3, #1
9001dfa4:	d003      	beq.n	9001dfae <_fwalk_reent+0x3a>
9001dfa6:	4629      	mov	r1, r5
9001dfa8:	4630      	mov	r0, r6
9001dfaa:	47c0      	blx	r8
9001dfac:	4307      	orrs	r7, r0
9001dfae:	3568      	adds	r5, #104	; 0x68
9001dfb0:	e7e9      	b.n	9001df86 <_fwalk_reent+0x12>

9001dfb2 <__swhatbuf_r>:
9001dfb2:	b570      	push	{r4, r5, r6, lr}
9001dfb4:	460e      	mov	r6, r1
9001dfb6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
9001dfba:	2900      	cmp	r1, #0
9001dfbc:	b096      	sub	sp, #88	; 0x58
9001dfbe:	4614      	mov	r4, r2
9001dfc0:	461d      	mov	r5, r3
9001dfc2:	da09      	bge.n	9001dfd8 <__swhatbuf_r+0x26>
9001dfc4:	89b3      	ldrh	r3, [r6, #12]
9001dfc6:	2200      	movs	r2, #0
9001dfc8:	f013 0080 	ands.w	r0, r3, #128	; 0x80
9001dfcc:	602a      	str	r2, [r5, #0]
9001dfce:	d116      	bne.n	9001dffe <__swhatbuf_r+0x4c>
9001dfd0:	f44f 6380 	mov.w	r3, #1024	; 0x400
9001dfd4:	6023      	str	r3, [r4, #0]
9001dfd6:	e015      	b.n	9001e004 <__swhatbuf_r+0x52>
9001dfd8:	466a      	mov	r2, sp
9001dfda:	f000 f9b7 	bl	9001e34c <_fstat_r>
9001dfde:	2800      	cmp	r0, #0
9001dfe0:	dbf0      	blt.n	9001dfc4 <__swhatbuf_r+0x12>
9001dfe2:	9a01      	ldr	r2, [sp, #4]
9001dfe4:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
9001dfe8:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
9001dfec:	425a      	negs	r2, r3
9001dfee:	415a      	adcs	r2, r3
9001dff0:	f44f 6380 	mov.w	r3, #1024	; 0x400
9001dff4:	602a      	str	r2, [r5, #0]
9001dff6:	f44f 6000 	mov.w	r0, #2048	; 0x800
9001dffa:	6023      	str	r3, [r4, #0]
9001dffc:	e002      	b.n	9001e004 <__swhatbuf_r+0x52>
9001dffe:	2340      	movs	r3, #64	; 0x40
9001e000:	6023      	str	r3, [r4, #0]
9001e002:	4610      	mov	r0, r2
9001e004:	b016      	add	sp, #88	; 0x58
9001e006:	bd70      	pop	{r4, r5, r6, pc}

9001e008 <__smakebuf_r>:
9001e008:	898b      	ldrh	r3, [r1, #12]
9001e00a:	b573      	push	{r0, r1, r4, r5, r6, lr}
9001e00c:	079d      	lsls	r5, r3, #30
9001e00e:	4606      	mov	r6, r0
9001e010:	460c      	mov	r4, r1
9001e012:	d507      	bpl.n	9001e024 <__smakebuf_r+0x1c>
9001e014:	f104 0343 	add.w	r3, r4, #67	; 0x43
9001e018:	6023      	str	r3, [r4, #0]
9001e01a:	6123      	str	r3, [r4, #16]
9001e01c:	2301      	movs	r3, #1
9001e01e:	6163      	str	r3, [r4, #20]
9001e020:	b002      	add	sp, #8
9001e022:	bd70      	pop	{r4, r5, r6, pc}
9001e024:	ab01      	add	r3, sp, #4
9001e026:	466a      	mov	r2, sp
9001e028:	f7ff ffc3 	bl	9001dfb2 <__swhatbuf_r>
9001e02c:	9900      	ldr	r1, [sp, #0]
9001e02e:	4605      	mov	r5, r0
9001e030:	4630      	mov	r0, r6
9001e032:	f7fd fe81 	bl	9001bd38 <_malloc_r>
9001e036:	b948      	cbnz	r0, 9001e04c <__smakebuf_r+0x44>
9001e038:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
9001e03c:	059a      	lsls	r2, r3, #22
9001e03e:	d4ef      	bmi.n	9001e020 <__smakebuf_r+0x18>
9001e040:	f023 0303 	bic.w	r3, r3, #3
9001e044:	f043 0302 	orr.w	r3, r3, #2
9001e048:	81a3      	strh	r3, [r4, #12]
9001e04a:	e7e3      	b.n	9001e014 <__smakebuf_r+0xc>
9001e04c:	4b0d      	ldr	r3, [pc, #52]	; (9001e084 <__smakebuf_r+0x7c>)
9001e04e:	63f3      	str	r3, [r6, #60]	; 0x3c
9001e050:	89a3      	ldrh	r3, [r4, #12]
9001e052:	6020      	str	r0, [r4, #0]
9001e054:	f043 0380 	orr.w	r3, r3, #128	; 0x80
9001e058:	81a3      	strh	r3, [r4, #12]
9001e05a:	9b00      	ldr	r3, [sp, #0]
9001e05c:	6163      	str	r3, [r4, #20]
9001e05e:	9b01      	ldr	r3, [sp, #4]
9001e060:	6120      	str	r0, [r4, #16]
9001e062:	b15b      	cbz	r3, 9001e07c <__smakebuf_r+0x74>
9001e064:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
9001e068:	4630      	mov	r0, r6
9001e06a:	f000 f981 	bl	9001e370 <_isatty_r>
9001e06e:	b128      	cbz	r0, 9001e07c <__smakebuf_r+0x74>
9001e070:	89a3      	ldrh	r3, [r4, #12]
9001e072:	f023 0303 	bic.w	r3, r3, #3
9001e076:	f043 0301 	orr.w	r3, r3, #1
9001e07a:	81a3      	strh	r3, [r4, #12]
9001e07c:	89a0      	ldrh	r0, [r4, #12]
9001e07e:	4305      	orrs	r5, r0
9001e080:	81a5      	strh	r5, [r4, #12]
9001e082:	e7cd      	b.n	9001e020 <__smakebuf_r+0x18>
9001e084:	9001db7d 	.word	0x9001db7d

9001e088 <_raise_r>:
9001e088:	291f      	cmp	r1, #31
9001e08a:	b538      	push	{r3, r4, r5, lr}
9001e08c:	4604      	mov	r4, r0
9001e08e:	460d      	mov	r5, r1
9001e090:	d904      	bls.n	9001e09c <_raise_r+0x14>
9001e092:	2316      	movs	r3, #22
9001e094:	6003      	str	r3, [r0, #0]
9001e096:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
9001e09a:	bd38      	pop	{r3, r4, r5, pc}
9001e09c:	f8d0 22dc 	ldr.w	r2, [r0, #732]	; 0x2dc
9001e0a0:	b112      	cbz	r2, 9001e0a8 <_raise_r+0x20>
9001e0a2:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
9001e0a6:	b94b      	cbnz	r3, 9001e0bc <_raise_r+0x34>
9001e0a8:	4620      	mov	r0, r4
9001e0aa:	f000 f831 	bl	9001e110 <_getpid_r>
9001e0ae:	462a      	mov	r2, r5
9001e0b0:	4601      	mov	r1, r0
9001e0b2:	4620      	mov	r0, r4
9001e0b4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
9001e0b8:	f000 b818 	b.w	9001e0ec <_kill_r>
9001e0bc:	2b01      	cmp	r3, #1
9001e0be:	d00a      	beq.n	9001e0d6 <_raise_r+0x4e>
9001e0c0:	1c59      	adds	r1, r3, #1
9001e0c2:	d103      	bne.n	9001e0cc <_raise_r+0x44>
9001e0c4:	2316      	movs	r3, #22
9001e0c6:	6003      	str	r3, [r0, #0]
9001e0c8:	2001      	movs	r0, #1
9001e0ca:	e7e6      	b.n	9001e09a <_raise_r+0x12>
9001e0cc:	2400      	movs	r4, #0
9001e0ce:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
9001e0d2:	4628      	mov	r0, r5
9001e0d4:	4798      	blx	r3
9001e0d6:	2000      	movs	r0, #0
9001e0d8:	e7df      	b.n	9001e09a <_raise_r+0x12>
	...

9001e0dc <raise>:
9001e0dc:	4b02      	ldr	r3, [pc, #8]	; (9001e0e8 <raise+0xc>)
9001e0de:	4601      	mov	r1, r0
9001e0e0:	6818      	ldr	r0, [r3, #0]
9001e0e2:	f7ff bfd1 	b.w	9001e088 <_raise_r>
9001e0e6:	bf00      	nop
9001e0e8:	240007b4 	.word	0x240007b4

9001e0ec <_kill_r>:
9001e0ec:	b538      	push	{r3, r4, r5, lr}
9001e0ee:	4d07      	ldr	r5, [pc, #28]	; (9001e10c <_kill_r+0x20>)
9001e0f0:	2300      	movs	r3, #0
9001e0f2:	4604      	mov	r4, r0
9001e0f4:	4608      	mov	r0, r1
9001e0f6:	4611      	mov	r1, r2
9001e0f8:	602b      	str	r3, [r5, #0]
9001e0fa:	f7f7 fc51 	bl	900159a0 <_kill>
9001e0fe:	1c43      	adds	r3, r0, #1
9001e100:	d102      	bne.n	9001e108 <_kill_r+0x1c>
9001e102:	682b      	ldr	r3, [r5, #0]
9001e104:	b103      	cbz	r3, 9001e108 <_kill_r+0x1c>
9001e106:	6023      	str	r3, [r4, #0]
9001e108:	bd38      	pop	{r3, r4, r5, pc}
9001e10a:	bf00      	nop
9001e10c:	2400b440 	.word	0x2400b440

9001e110 <_getpid_r>:
9001e110:	f7f7 bc3e 	b.w	90015990 <_getpid>

9001e114 <__sread>:
9001e114:	b510      	push	{r4, lr}
9001e116:	460c      	mov	r4, r1
9001e118:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
9001e11c:	f000 f94a 	bl	9001e3b4 <_read_r>
9001e120:	2800      	cmp	r0, #0
9001e122:	bfab      	itete	ge
9001e124:	6d23      	ldrge	r3, [r4, #80]	; 0x50
9001e126:	89a3      	ldrhlt	r3, [r4, #12]
9001e128:	181b      	addge	r3, r3, r0
9001e12a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
9001e12e:	bfac      	ite	ge
9001e130:	6523      	strge	r3, [r4, #80]	; 0x50
9001e132:	81a3      	strhlt	r3, [r4, #12]
9001e134:	bd10      	pop	{r4, pc}

9001e136 <__swrite>:
9001e136:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
9001e13a:	461f      	mov	r7, r3
9001e13c:	898b      	ldrh	r3, [r1, #12]
9001e13e:	05db      	lsls	r3, r3, #23
9001e140:	4605      	mov	r5, r0
9001e142:	460c      	mov	r4, r1
9001e144:	4616      	mov	r6, r2
9001e146:	d505      	bpl.n	9001e154 <__swrite+0x1e>
9001e148:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
9001e14c:	2302      	movs	r3, #2
9001e14e:	2200      	movs	r2, #0
9001e150:	f000 f91e 	bl	9001e390 <_lseek_r>
9001e154:	89a3      	ldrh	r3, [r4, #12]
9001e156:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
9001e15a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
9001e15e:	81a3      	strh	r3, [r4, #12]
9001e160:	4632      	mov	r2, r6
9001e162:	463b      	mov	r3, r7
9001e164:	4628      	mov	r0, r5
9001e166:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
9001e16a:	f000 b875 	b.w	9001e258 <_write_r>

9001e16e <__sseek>:
9001e16e:	b510      	push	{r4, lr}
9001e170:	460c      	mov	r4, r1
9001e172:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
9001e176:	f000 f90b 	bl	9001e390 <_lseek_r>
9001e17a:	1c43      	adds	r3, r0, #1
9001e17c:	89a3      	ldrh	r3, [r4, #12]
9001e17e:	bf15      	itete	ne
9001e180:	6520      	strne	r0, [r4, #80]	; 0x50
9001e182:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
9001e186:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
9001e18a:	81a3      	strheq	r3, [r4, #12]
9001e18c:	bf18      	it	ne
9001e18e:	81a3      	strhne	r3, [r4, #12]
9001e190:	bd10      	pop	{r4, pc}

9001e192 <__sclose>:
9001e192:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
9001e196:	f000 b871 	b.w	9001e27c <_close_r>

9001e19a <__swbuf_r>:
9001e19a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9001e19c:	460e      	mov	r6, r1
9001e19e:	4614      	mov	r4, r2
9001e1a0:	4605      	mov	r5, r0
9001e1a2:	b118      	cbz	r0, 9001e1ac <__swbuf_r+0x12>
9001e1a4:	6b83      	ldr	r3, [r0, #56]	; 0x38
9001e1a6:	b90b      	cbnz	r3, 9001e1ac <__swbuf_r+0x12>
9001e1a8:	f7ff fd06 	bl	9001dbb8 <__sinit>
9001e1ac:	69a3      	ldr	r3, [r4, #24]
9001e1ae:	60a3      	str	r3, [r4, #8]
9001e1b0:	89a3      	ldrh	r3, [r4, #12]
9001e1b2:	0719      	lsls	r1, r3, #28
9001e1b4:	d529      	bpl.n	9001e20a <__swbuf_r+0x70>
9001e1b6:	6923      	ldr	r3, [r4, #16]
9001e1b8:	b33b      	cbz	r3, 9001e20a <__swbuf_r+0x70>
9001e1ba:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
9001e1be:	b2f6      	uxtb	r6, r6
9001e1c0:	049a      	lsls	r2, r3, #18
9001e1c2:	4637      	mov	r7, r6
9001e1c4:	d52a      	bpl.n	9001e21c <__swbuf_r+0x82>
9001e1c6:	6823      	ldr	r3, [r4, #0]
9001e1c8:	6920      	ldr	r0, [r4, #16]
9001e1ca:	1a18      	subs	r0, r3, r0
9001e1cc:	6963      	ldr	r3, [r4, #20]
9001e1ce:	4283      	cmp	r3, r0
9001e1d0:	dc04      	bgt.n	9001e1dc <__swbuf_r+0x42>
9001e1d2:	4621      	mov	r1, r4
9001e1d4:	4628      	mov	r0, r5
9001e1d6:	f7ff fc83 	bl	9001dae0 <_fflush_r>
9001e1da:	b9e0      	cbnz	r0, 9001e216 <__swbuf_r+0x7c>
9001e1dc:	68a3      	ldr	r3, [r4, #8]
9001e1de:	3b01      	subs	r3, #1
9001e1e0:	60a3      	str	r3, [r4, #8]
9001e1e2:	6823      	ldr	r3, [r4, #0]
9001e1e4:	1c5a      	adds	r2, r3, #1
9001e1e6:	6022      	str	r2, [r4, #0]
9001e1e8:	701e      	strb	r6, [r3, #0]
9001e1ea:	6962      	ldr	r2, [r4, #20]
9001e1ec:	1c43      	adds	r3, r0, #1
9001e1ee:	429a      	cmp	r2, r3
9001e1f0:	d004      	beq.n	9001e1fc <__swbuf_r+0x62>
9001e1f2:	89a3      	ldrh	r3, [r4, #12]
9001e1f4:	07db      	lsls	r3, r3, #31
9001e1f6:	d506      	bpl.n	9001e206 <__swbuf_r+0x6c>
9001e1f8:	2e0a      	cmp	r6, #10
9001e1fa:	d104      	bne.n	9001e206 <__swbuf_r+0x6c>
9001e1fc:	4621      	mov	r1, r4
9001e1fe:	4628      	mov	r0, r5
9001e200:	f7ff fc6e 	bl	9001dae0 <_fflush_r>
9001e204:	b938      	cbnz	r0, 9001e216 <__swbuf_r+0x7c>
9001e206:	4638      	mov	r0, r7
9001e208:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
9001e20a:	4621      	mov	r1, r4
9001e20c:	4628      	mov	r0, r5
9001e20e:	f7ff fb79 	bl	9001d904 <__swsetup_r>
9001e212:	2800      	cmp	r0, #0
9001e214:	d0d1      	beq.n	9001e1ba <__swbuf_r+0x20>
9001e216:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
9001e21a:	e7f4      	b.n	9001e206 <__swbuf_r+0x6c>
9001e21c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
9001e220:	81a3      	strh	r3, [r4, #12]
9001e222:	6e63      	ldr	r3, [r4, #100]	; 0x64
9001e224:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
9001e228:	6663      	str	r3, [r4, #100]	; 0x64
9001e22a:	e7cc      	b.n	9001e1c6 <__swbuf_r+0x2c>

9001e22c <_wcrtomb_r>:
9001e22c:	b5f0      	push	{r4, r5, r6, r7, lr}
9001e22e:	4c09      	ldr	r4, [pc, #36]	; (9001e254 <_wcrtomb_r+0x28>)
9001e230:	b085      	sub	sp, #20
9001e232:	f8d4 70e0 	ldr.w	r7, [r4, #224]	; 0xe0
9001e236:	4605      	mov	r5, r0
9001e238:	461e      	mov	r6, r3
9001e23a:	b909      	cbnz	r1, 9001e240 <_wcrtomb_r+0x14>
9001e23c:	460a      	mov	r2, r1
9001e23e:	a901      	add	r1, sp, #4
9001e240:	47b8      	blx	r7
9001e242:	1c43      	adds	r3, r0, #1
9001e244:	bf01      	itttt	eq
9001e246:	2300      	moveq	r3, #0
9001e248:	6033      	streq	r3, [r6, #0]
9001e24a:	238a      	moveq	r3, #138	; 0x8a
9001e24c:	602b      	streq	r3, [r5, #0]
9001e24e:	b005      	add	sp, #20
9001e250:	bdf0      	pop	{r4, r5, r6, r7, pc}
9001e252:	bf00      	nop
9001e254:	24000ff4 	.word	0x24000ff4

9001e258 <_write_r>:
9001e258:	b538      	push	{r3, r4, r5, lr}
9001e25a:	4d07      	ldr	r5, [pc, #28]	; (9001e278 <_write_r+0x20>)
9001e25c:	4604      	mov	r4, r0
9001e25e:	4608      	mov	r0, r1
9001e260:	4611      	mov	r1, r2
9001e262:	2200      	movs	r2, #0
9001e264:	602a      	str	r2, [r5, #0]
9001e266:	461a      	mov	r2, r3
9001e268:	f7f7 fbb4 	bl	900159d4 <_write>
9001e26c:	1c43      	adds	r3, r0, #1
9001e26e:	d102      	bne.n	9001e276 <_write_r+0x1e>
9001e270:	682b      	ldr	r3, [r5, #0]
9001e272:	b103      	cbz	r3, 9001e276 <_write_r+0x1e>
9001e274:	6023      	str	r3, [r4, #0]
9001e276:	bd38      	pop	{r3, r4, r5, pc}
9001e278:	2400b440 	.word	0x2400b440

9001e27c <_close_r>:
9001e27c:	b538      	push	{r3, r4, r5, lr}
9001e27e:	4d06      	ldr	r5, [pc, #24]	; (9001e298 <_close_r+0x1c>)
9001e280:	2300      	movs	r3, #0
9001e282:	4604      	mov	r4, r0
9001e284:	4608      	mov	r0, r1
9001e286:	602b      	str	r3, [r5, #0]
9001e288:	f7f7 fbc0 	bl	90015a0c <_close>
9001e28c:	1c43      	adds	r3, r0, #1
9001e28e:	d102      	bne.n	9001e296 <_close_r+0x1a>
9001e290:	682b      	ldr	r3, [r5, #0]
9001e292:	b103      	cbz	r3, 9001e296 <_close_r+0x1a>
9001e294:	6023      	str	r3, [r4, #0]
9001e296:	bd38      	pop	{r3, r4, r5, pc}
9001e298:	2400b440 	.word	0x2400b440

9001e29c <_fclose_r>:
9001e29c:	b570      	push	{r4, r5, r6, lr}
9001e29e:	4606      	mov	r6, r0
9001e2a0:	460c      	mov	r4, r1
9001e2a2:	b911      	cbnz	r1, 9001e2aa <_fclose_r+0xe>
9001e2a4:	2500      	movs	r5, #0
9001e2a6:	4628      	mov	r0, r5
9001e2a8:	bd70      	pop	{r4, r5, r6, pc}
9001e2aa:	b118      	cbz	r0, 9001e2b4 <_fclose_r+0x18>
9001e2ac:	6b83      	ldr	r3, [r0, #56]	; 0x38
9001e2ae:	b90b      	cbnz	r3, 9001e2b4 <_fclose_r+0x18>
9001e2b0:	f7ff fc82 	bl	9001dbb8 <__sinit>
9001e2b4:	6e63      	ldr	r3, [r4, #100]	; 0x64
9001e2b6:	07d8      	lsls	r0, r3, #31
9001e2b8:	d405      	bmi.n	9001e2c6 <_fclose_r+0x2a>
9001e2ba:	89a3      	ldrh	r3, [r4, #12]
9001e2bc:	0599      	lsls	r1, r3, #22
9001e2be:	d402      	bmi.n	9001e2c6 <_fclose_r+0x2a>
9001e2c0:	6da0      	ldr	r0, [r4, #88]	; 0x58
9001e2c2:	f7fd fd37 	bl	9001bd34 <__retarget_lock_acquire_recursive>
9001e2c6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
9001e2ca:	b93b      	cbnz	r3, 9001e2dc <_fclose_r+0x40>
9001e2cc:	6e65      	ldr	r5, [r4, #100]	; 0x64
9001e2ce:	f015 0501 	ands.w	r5, r5, #1
9001e2d2:	d1e7      	bne.n	9001e2a4 <_fclose_r+0x8>
9001e2d4:	6da0      	ldr	r0, [r4, #88]	; 0x58
9001e2d6:	f7fd fd2e 	bl	9001bd36 <__retarget_lock_release_recursive>
9001e2da:	e7e4      	b.n	9001e2a6 <_fclose_r+0xa>
9001e2dc:	4621      	mov	r1, r4
9001e2de:	4630      	mov	r0, r6
9001e2e0:	f7ff fb70 	bl	9001d9c4 <__sflush_r>
9001e2e4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
9001e2e6:	4605      	mov	r5, r0
9001e2e8:	b133      	cbz	r3, 9001e2f8 <_fclose_r+0x5c>
9001e2ea:	69e1      	ldr	r1, [r4, #28]
9001e2ec:	4630      	mov	r0, r6
9001e2ee:	4798      	blx	r3
9001e2f0:	2800      	cmp	r0, #0
9001e2f2:	bfb8      	it	lt
9001e2f4:	f04f 35ff 	movlt.w	r5, #4294967295	; 0xffffffff
9001e2f8:	89a3      	ldrh	r3, [r4, #12]
9001e2fa:	061a      	lsls	r2, r3, #24
9001e2fc:	d503      	bpl.n	9001e306 <_fclose_r+0x6a>
9001e2fe:	6921      	ldr	r1, [r4, #16]
9001e300:	4630      	mov	r0, r6
9001e302:	f7fd fc51 	bl	9001bba8 <_free_r>
9001e306:	6b21      	ldr	r1, [r4, #48]	; 0x30
9001e308:	b141      	cbz	r1, 9001e31c <_fclose_r+0x80>
9001e30a:	f104 0340 	add.w	r3, r4, #64	; 0x40
9001e30e:	4299      	cmp	r1, r3
9001e310:	d002      	beq.n	9001e318 <_fclose_r+0x7c>
9001e312:	4630      	mov	r0, r6
9001e314:	f7fd fc48 	bl	9001bba8 <_free_r>
9001e318:	2300      	movs	r3, #0
9001e31a:	6323      	str	r3, [r4, #48]	; 0x30
9001e31c:	6c61      	ldr	r1, [r4, #68]	; 0x44
9001e31e:	b121      	cbz	r1, 9001e32a <_fclose_r+0x8e>
9001e320:	4630      	mov	r0, r6
9001e322:	f7fd fc41 	bl	9001bba8 <_free_r>
9001e326:	2300      	movs	r3, #0
9001e328:	6463      	str	r3, [r4, #68]	; 0x44
9001e32a:	f7ff fc2d 	bl	9001db88 <__sfp_lock_acquire>
9001e32e:	2300      	movs	r3, #0
9001e330:	81a3      	strh	r3, [r4, #12]
9001e332:	6e63      	ldr	r3, [r4, #100]	; 0x64
9001e334:	07db      	lsls	r3, r3, #31
9001e336:	d402      	bmi.n	9001e33e <_fclose_r+0xa2>
9001e338:	6da0      	ldr	r0, [r4, #88]	; 0x58
9001e33a:	f7fd fcfc 	bl	9001bd36 <__retarget_lock_release_recursive>
9001e33e:	6da0      	ldr	r0, [r4, #88]	; 0x58
9001e340:	f7fd fcf7 	bl	9001bd32 <__retarget_lock_close_recursive>
9001e344:	f7ff fc26 	bl	9001db94 <__sfp_lock_release>
9001e348:	e7ad      	b.n	9001e2a6 <_fclose_r+0xa>
	...

9001e34c <_fstat_r>:
9001e34c:	b538      	push	{r3, r4, r5, lr}
9001e34e:	4d07      	ldr	r5, [pc, #28]	; (9001e36c <_fstat_r+0x20>)
9001e350:	2300      	movs	r3, #0
9001e352:	4604      	mov	r4, r0
9001e354:	4608      	mov	r0, r1
9001e356:	4611      	mov	r1, r2
9001e358:	602b      	str	r3, [r5, #0]
9001e35a:	f7f7 fb63 	bl	90015a24 <_fstat>
9001e35e:	1c43      	adds	r3, r0, #1
9001e360:	d102      	bne.n	9001e368 <_fstat_r+0x1c>
9001e362:	682b      	ldr	r3, [r5, #0]
9001e364:	b103      	cbz	r3, 9001e368 <_fstat_r+0x1c>
9001e366:	6023      	str	r3, [r4, #0]
9001e368:	bd38      	pop	{r3, r4, r5, pc}
9001e36a:	bf00      	nop
9001e36c:	2400b440 	.word	0x2400b440

9001e370 <_isatty_r>:
9001e370:	b538      	push	{r3, r4, r5, lr}
9001e372:	4d06      	ldr	r5, [pc, #24]	; (9001e38c <_isatty_r+0x1c>)
9001e374:	2300      	movs	r3, #0
9001e376:	4604      	mov	r4, r0
9001e378:	4608      	mov	r0, r1
9001e37a:	602b      	str	r3, [r5, #0]
9001e37c:	f7f7 fb62 	bl	90015a44 <_isatty>
9001e380:	1c43      	adds	r3, r0, #1
9001e382:	d102      	bne.n	9001e38a <_isatty_r+0x1a>
9001e384:	682b      	ldr	r3, [r5, #0]
9001e386:	b103      	cbz	r3, 9001e38a <_isatty_r+0x1a>
9001e388:	6023      	str	r3, [r4, #0]
9001e38a:	bd38      	pop	{r3, r4, r5, pc}
9001e38c:	2400b440 	.word	0x2400b440

9001e390 <_lseek_r>:
9001e390:	b538      	push	{r3, r4, r5, lr}
9001e392:	4d07      	ldr	r5, [pc, #28]	; (9001e3b0 <_lseek_r+0x20>)
9001e394:	4604      	mov	r4, r0
9001e396:	4608      	mov	r0, r1
9001e398:	4611      	mov	r1, r2
9001e39a:	2200      	movs	r2, #0
9001e39c:	602a      	str	r2, [r5, #0]
9001e39e:	461a      	mov	r2, r3
9001e3a0:	f7f7 fb5b 	bl	90015a5a <_lseek>
9001e3a4:	1c43      	adds	r3, r0, #1
9001e3a6:	d102      	bne.n	9001e3ae <_lseek_r+0x1e>
9001e3a8:	682b      	ldr	r3, [r5, #0]
9001e3aa:	b103      	cbz	r3, 9001e3ae <_lseek_r+0x1e>
9001e3ac:	6023      	str	r3, [r4, #0]
9001e3ae:	bd38      	pop	{r3, r4, r5, pc}
9001e3b0:	2400b440 	.word	0x2400b440

9001e3b4 <_read_r>:
9001e3b4:	b538      	push	{r3, r4, r5, lr}
9001e3b6:	4d07      	ldr	r5, [pc, #28]	; (9001e3d4 <_read_r+0x20>)
9001e3b8:	4604      	mov	r4, r0
9001e3ba:	4608      	mov	r0, r1
9001e3bc:	4611      	mov	r1, r2
9001e3be:	2200      	movs	r2, #0
9001e3c0:	602a      	str	r2, [r5, #0]
9001e3c2:	461a      	mov	r2, r3
9001e3c4:	f7f7 fb56 	bl	90015a74 <_read>
9001e3c8:	1c43      	adds	r3, r0, #1
9001e3ca:	d102      	bne.n	9001e3d2 <_read_r+0x1e>
9001e3cc:	682b      	ldr	r3, [r5, #0]
9001e3ce:	b103      	cbz	r3, 9001e3d2 <_read_r+0x1e>
9001e3d0:	6023      	str	r3, [r4, #0]
9001e3d2:	bd38      	pop	{r3, r4, r5, pc}
9001e3d4:	2400b440 	.word	0x2400b440

9001e3d8 <checkint>:
9001e3d8:	f3c0 53c7 	ubfx	r3, r0, #23, #8
9001e3dc:	2b7e      	cmp	r3, #126	; 0x7e
9001e3de:	dd10      	ble.n	9001e402 <checkint+0x2a>
9001e3e0:	2b96      	cmp	r3, #150	; 0x96
9001e3e2:	dc0c      	bgt.n	9001e3fe <checkint+0x26>
9001e3e4:	2201      	movs	r2, #1
9001e3e6:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
9001e3ea:	fa02 f303 	lsl.w	r3, r2, r3
9001e3ee:	1e5a      	subs	r2, r3, #1
9001e3f0:	4202      	tst	r2, r0
9001e3f2:	d106      	bne.n	9001e402 <checkint+0x2a>
9001e3f4:	4203      	tst	r3, r0
9001e3f6:	bf0c      	ite	eq
9001e3f8:	2002      	moveq	r0, #2
9001e3fa:	2001      	movne	r0, #1
9001e3fc:	4770      	bx	lr
9001e3fe:	2002      	movs	r0, #2
9001e400:	4770      	bx	lr
9001e402:	2000      	movs	r0, #0
9001e404:	4770      	bx	lr
	...

9001e408 <powf>:
9001e408:	b5f0      	push	{r4, r5, r6, r7, lr}
9001e40a:	ee10 1a10 	vmov	r1, s0
9001e40e:	ee10 6a90 	vmov	r6, s1
9001e412:	f5a1 0300 	sub.w	r3, r1, #8388608	; 0x800000
9001e416:	0072      	lsls	r2, r6, #1
9001e418:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
9001e41c:	b085      	sub	sp, #20
9001e41e:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
9001e422:	f06f 7380 	mvn.w	r3, #16777216	; 0x1000000
9001e426:	d256      	bcs.n	9001e4d6 <powf+0xce>
9001e428:	4298      	cmp	r0, r3
9001e42a:	d256      	bcs.n	9001e4da <powf+0xd2>
9001e42c:	2000      	movs	r0, #0
9001e42e:	f101 4240 	add.w	r2, r1, #3221225472	; 0xc0000000
9001e432:	4ea3      	ldr	r6, [pc, #652]	; (9001e6c0 <powf+0x2b8>)
9001e434:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
9001e438:	f502 024d 	add.w	r2, r2, #13434880	; 0xcd0000
9001e43c:	f3c2 47c3 	ubfx	r7, r2, #19, #4
9001e440:	0dd2      	lsrs	r2, r2, #23
9001e442:	eb06 1707 	add.w	r7, r6, r7, lsl #4
9001e446:	05d2      	lsls	r2, r2, #23
9001e448:	1a8b      	subs	r3, r1, r2
9001e44a:	ed97 5b00 	vldr	d5, [r7]
9001e44e:	ee07 3a90 	vmov	s15, r3
9001e452:	15d2      	asrs	r2, r2, #23
9001e454:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
9001e458:	eea5 6b07 	vfma.f64	d6, d5, d7
9001e45c:	ed97 5b02 	vldr	d5, [r7, #8]
9001e460:	ee26 2b06 	vmul.f64	d2, d6, d6
9001e464:	ee22 1b02 	vmul.f64	d1, d2, d2
9001e468:	ee07 2a90 	vmov	s15, r2
9001e46c:	ed96 4b40 	vldr	d4, [r6, #256]	; 0x100
9001e470:	eeb8 7be7 	vcvt.f64.s32	d7, s15
9001e474:	ee37 7b05 	vadd.f64	d7, d7, d5
9001e478:	ed96 5b42 	vldr	d5, [r6, #264]	; 0x108
9001e47c:	ed96 3b44 	vldr	d3, [r6, #272]	; 0x110
9001e480:	eea6 5b04 	vfma.f64	d5, d6, d4
9001e484:	ed96 4b46 	vldr	d4, [r6, #280]	; 0x118
9001e488:	eea6 4b03 	vfma.f64	d4, d6, d3
9001e48c:	ed96 3b48 	vldr	d3, [r6, #288]	; 0x120
9001e490:	eeb7 0ae0 	vcvt.f64.f32	d0, s1
9001e494:	eea6 7b03 	vfma.f64	d7, d6, d3
9001e498:	eea2 7b04 	vfma.f64	d7, d2, d4
9001e49c:	eea5 7b01 	vfma.f64	d7, d5, d1
9001e4a0:	ee20 0b07 	vmul.f64	d0, d0, d7
9001e4a4:	ee10 1a90 	vmov	r1, s1
9001e4a8:	2300      	movs	r3, #0
9001e4aa:	2700      	movs	r7, #0
9001e4ac:	f3c1 32cf 	ubfx	r2, r1, #15, #16
9001e4b0:	f248 06be 	movw	r6, #32958	; 0x80be
9001e4b4:	429f      	cmp	r7, r3
9001e4b6:	bf08      	it	eq
9001e4b8:	4296      	cmpeq	r6, r2
9001e4ba:	f080 80b1 	bcs.w	9001e620 <powf+0x218>
9001e4be:	ed9f 7b78 	vldr	d7, [pc, #480]	; 9001e6a0 <powf+0x298>
9001e4c2:	eeb4 0bc7 	vcmpe.f64	d0, d7
9001e4c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001e4ca:	dd79      	ble.n	9001e5c0 <powf+0x1b8>
9001e4cc:	b005      	add	sp, #20
9001e4ce:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
9001e4d2:	f000 b945 	b.w	9001e760 <__math_oflowf>
9001e4d6:	4298      	cmp	r0, r3
9001e4d8:	d32d      	bcc.n	9001e536 <powf+0x12e>
9001e4da:	b952      	cbnz	r2, 9001e4f2 <powf+0xea>
9001e4dc:	f481 0380 	eor.w	r3, r1, #4194304	; 0x400000
9001e4e0:	005b      	lsls	r3, r3, #1
9001e4e2:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
9001e4e6:	f240 80cd 	bls.w	9001e684 <powf+0x27c>
9001e4ea:	ee30 0a20 	vadd.f32	s0, s0, s1
9001e4ee:	b005      	add	sp, #20
9001e4f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
9001e4f2:	f1b1 5f7e 	cmp.w	r1, #1065353216	; 0x3f800000
9001e4f6:	d105      	bne.n	9001e504 <powf+0xfc>
9001e4f8:	f486 0680 	eor.w	r6, r6, #4194304	; 0x400000
9001e4fc:	0076      	lsls	r6, r6, #1
9001e4fe:	f516 0f00 	cmn.w	r6, #8388608	; 0x800000
9001e502:	e7f0      	b.n	9001e4e6 <powf+0xde>
9001e504:	004b      	lsls	r3, r1, #1
9001e506:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
9001e50a:	d8ee      	bhi.n	9001e4ea <powf+0xe2>
9001e50c:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
9001e510:	d1eb      	bne.n	9001e4ea <powf+0xe2>
9001e512:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
9001e516:	f000 80b5 	beq.w	9001e684 <powf+0x27c>
9001e51a:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
9001e51e:	ea6f 0606 	mvn.w	r6, r6
9001e522:	bf34      	ite	cc
9001e524:	2300      	movcc	r3, #0
9001e526:	2301      	movcs	r3, #1
9001e528:	0ff6      	lsrs	r6, r6, #31
9001e52a:	42b3      	cmp	r3, r6
9001e52c:	f040 80ad 	bne.w	9001e68a <powf+0x282>
9001e530:	ee20 0aa0 	vmul.f32	s0, s1, s1
9001e534:	e7db      	b.n	9001e4ee <powf+0xe6>
9001e536:	004f      	lsls	r7, r1, #1
9001e538:	1e7a      	subs	r2, r7, #1
9001e53a:	429a      	cmp	r2, r3
9001e53c:	d31c      	bcc.n	9001e578 <powf+0x170>
9001e53e:	2900      	cmp	r1, #0
9001e540:	ee20 0a00 	vmul.f32	s0, s0, s0
9001e544:	da0f      	bge.n	9001e566 <powf+0x15e>
9001e546:	ee10 0a90 	vmov	r0, s1
9001e54a:	f7ff ff45 	bl	9001e3d8 <checkint>
9001e54e:	2801      	cmp	r0, #1
9001e550:	d109      	bne.n	9001e566 <powf+0x15e>
9001e552:	eeb1 0a40 	vneg.f32	s0, s0
9001e556:	b947      	cbnz	r7, 9001e56a <powf+0x162>
9001e558:	2e00      	cmp	r6, #0
9001e55a:	dac8      	bge.n	9001e4ee <powf+0xe6>
9001e55c:	b005      	add	sp, #20
9001e55e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
9001e562:	f000 b903 	b.w	9001e76c <__math_divzerof>
9001e566:	2000      	movs	r0, #0
9001e568:	e7f5      	b.n	9001e556 <powf+0x14e>
9001e56a:	2e00      	cmp	r6, #0
9001e56c:	dabf      	bge.n	9001e4ee <powf+0xe6>
9001e56e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
9001e572:	ee87 0a80 	vdiv.f32	s0, s15, s0
9001e576:	e7ba      	b.n	9001e4ee <powf+0xe6>
9001e578:	2900      	cmp	r1, #0
9001e57a:	da1f      	bge.n	9001e5bc <powf+0x1b4>
9001e57c:	ee10 0a90 	vmov	r0, s1
9001e580:	f7ff ff2a 	bl	9001e3d8 <checkint>
9001e584:	b920      	cbnz	r0, 9001e590 <powf+0x188>
9001e586:	b005      	add	sp, #20
9001e588:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
9001e58c:	f000 b8fe 	b.w	9001e78c <__math_invalidf>
9001e590:	2801      	cmp	r0, #1
9001e592:	bf14      	ite	ne
9001e594:	2000      	movne	r0, #0
9001e596:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
9001e59a:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
9001e59e:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
9001e5a2:	f4bf af44 	bcs.w	9001e42e <powf+0x26>
9001e5a6:	eddf 7a47 	vldr	s15, [pc, #284]	; 9001e6c4 <powf+0x2bc>
9001e5aa:	ee20 0a27 	vmul.f32	s0, s0, s15
9001e5ae:	ee10 3a10 	vmov	r3, s0
9001e5b2:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
9001e5b6:	f1a3 6138 	sub.w	r1, r3, #192937984	; 0xb800000
9001e5ba:	e738      	b.n	9001e42e <powf+0x26>
9001e5bc:	2000      	movs	r0, #0
9001e5be:	e7ee      	b.n	9001e59e <powf+0x196>
9001e5c0:	ed9f 7b39 	vldr	d7, [pc, #228]	; 9001e6a8 <powf+0x2a0>
9001e5c4:	eeb4 0bc7 	vcmpe.f64	d0, d7
9001e5c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001e5cc:	dd10      	ble.n	9001e5f0 <powf+0x1e8>
9001e5ce:	f04f 534c 	mov.w	r3, #855638016	; 0x33000000
9001e5d2:	2800      	cmp	r0, #0
9001e5d4:	d15c      	bne.n	9001e690 <powf+0x288>
9001e5d6:	9302      	str	r3, [sp, #8]
9001e5d8:	eddd 7a02 	vldr	s15, [sp, #8]
9001e5dc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
9001e5e0:	ee77 7a87 	vadd.f32	s15, s15, s14
9001e5e4:	eef4 7a47 	vcmp.f32	s15, s14
9001e5e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001e5ec:	f47f af6e 	bne.w	9001e4cc <powf+0xc4>
9001e5f0:	ed9f 7b2f 	vldr	d7, [pc, #188]	; 9001e6b0 <powf+0x2a8>
9001e5f4:	eeb4 0bc7 	vcmpe.f64	d0, d7
9001e5f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001e5fc:	d804      	bhi.n	9001e608 <powf+0x200>
9001e5fe:	b005      	add	sp, #20
9001e600:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
9001e604:	f000 b8a0 	b.w	9001e748 <__math_uflowf>
9001e608:	ed9f 7b2b 	vldr	d7, [pc, #172]	; 9001e6b8 <powf+0x2b0>
9001e60c:	eeb4 0bc7 	vcmpe.f64	d0, d7
9001e610:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001e614:	d504      	bpl.n	9001e620 <powf+0x218>
9001e616:	b005      	add	sp, #20
9001e618:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
9001e61c:	f000 b89a 	b.w	9001e754 <__math_may_uflowf>
9001e620:	4b29      	ldr	r3, [pc, #164]	; (9001e6c8 <powf+0x2c0>)
9001e622:	ed93 7b40 	vldr	d7, [r3, #256]	; 0x100
9001e626:	ee30 6b07 	vadd.f64	d6, d0, d7
9001e62a:	ed8d 6b00 	vstr	d6, [sp]
9001e62e:	ee36 7b47 	vsub.f64	d7, d6, d7
9001e632:	ee30 7b47 	vsub.f64	d7, d0, d7
9001e636:	e9dd 6700 	ldrd	r6, r7, [sp]
9001e63a:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
9001e63e:	f006 011f 	and.w	r1, r6, #31
9001e642:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
9001e646:	e9d1 ce00 	ldrd	ip, lr, [r1]
9001e64a:	ed93 5b42 	vldr	d5, [r3, #264]	; 0x108
9001e64e:	ed93 6b44 	vldr	d6, [r3, #272]	; 0x110
9001e652:	ed93 4b46 	vldr	d4, [r3, #280]	; 0x118
9001e656:	eea7 6b05 	vfma.f64	d6, d7, d5
9001e65a:	ee27 5b07 	vmul.f64	d5, d7, d7
9001e65e:	1836      	adds	r6, r6, r0
9001e660:	2300      	movs	r3, #0
9001e662:	eb13 040c 	adds.w	r4, r3, ip
9001e666:	ea4f 31c6 	mov.w	r1, r6, lsl #15
9001e66a:	eb41 050e 	adc.w	r5, r1, lr
9001e66e:	eea7 0b04 	vfma.f64	d0, d7, d4
9001e672:	ec45 4b17 	vmov	d7, r4, r5
9001e676:	eea6 0b05 	vfma.f64	d0, d6, d5
9001e67a:	ee20 0b07 	vmul.f64	d0, d0, d7
9001e67e:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
9001e682:	e734      	b.n	9001e4ee <powf+0xe6>
9001e684:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
9001e688:	e731      	b.n	9001e4ee <powf+0xe6>
9001e68a:	ed9f 0a10 	vldr	s0, [pc, #64]	; 9001e6cc <powf+0x2c4>
9001e68e:	e72e      	b.n	9001e4ee <powf+0xe6>
9001e690:	9303      	str	r3, [sp, #12]
9001e692:	eddd 7a03 	vldr	s15, [sp, #12]
9001e696:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
9001e69a:	ee77 7a67 	vsub.f32	s15, s14, s15
9001e69e:	e7a1      	b.n	9001e5e4 <powf+0x1dc>
9001e6a0:	ffd1d571 	.word	0xffd1d571
9001e6a4:	405fffff 	.word	0x405fffff
9001e6a8:	ffa3aae2 	.word	0xffa3aae2
9001e6ac:	405fffff 	.word	0x405fffff
9001e6b0:	00000000 	.word	0x00000000
9001e6b4:	c062c000 	.word	0xc062c000
9001e6b8:	00000000 	.word	0x00000000
9001e6bc:	c062a000 	.word	0xc062a000
9001e6c0:	900256e0 	.word	0x900256e0
9001e6c4:	4b000000 	.word	0x4b000000
9001e6c8:	90025808 	.word	0x90025808
9001e6cc:	00000000 	.word	0x00000000

9001e6d0 <roundf>:
9001e6d0:	ee10 0a10 	vmov	r0, s0
9001e6d4:	f3c0 53c7 	ubfx	r3, r0, #23, #8
9001e6d8:	f1a3 027f 	sub.w	r2, r3, #127	; 0x7f
9001e6dc:	2a16      	cmp	r2, #22
9001e6de:	dc15      	bgt.n	9001e70c <roundf+0x3c>
9001e6e0:	2a00      	cmp	r2, #0
9001e6e2:	da08      	bge.n	9001e6f6 <roundf+0x26>
9001e6e4:	3201      	adds	r2, #1
9001e6e6:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
9001e6ea:	d101      	bne.n	9001e6f0 <roundf+0x20>
9001e6ec:	f043 537e 	orr.w	r3, r3, #1065353216	; 0x3f800000
9001e6f0:	ee00 3a10 	vmov	s0, r3
9001e6f4:	4770      	bx	lr
9001e6f6:	4908      	ldr	r1, [pc, #32]	; (9001e718 <roundf+0x48>)
9001e6f8:	4111      	asrs	r1, r2
9001e6fa:	4208      	tst	r0, r1
9001e6fc:	d0fa      	beq.n	9001e6f4 <roundf+0x24>
9001e6fe:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
9001e702:	4113      	asrs	r3, r2
9001e704:	4403      	add	r3, r0
9001e706:	ea23 0301 	bic.w	r3, r3, r1
9001e70a:	e7f1      	b.n	9001e6f0 <roundf+0x20>
9001e70c:	2a80      	cmp	r2, #128	; 0x80
9001e70e:	d1f1      	bne.n	9001e6f4 <roundf+0x24>
9001e710:	ee30 0a00 	vadd.f32	s0, s0, s0
9001e714:	4770      	bx	lr
9001e716:	bf00      	nop
9001e718:	007fffff 	.word	0x007fffff

9001e71c <with_errnof>:
9001e71c:	b513      	push	{r0, r1, r4, lr}
9001e71e:	4604      	mov	r4, r0
9001e720:	ed8d 0a01 	vstr	s0, [sp, #4]
9001e724:	f7fb fa04 	bl	90019b30 <__errno>
9001e728:	ed9d 0a01 	vldr	s0, [sp, #4]
9001e72c:	6004      	str	r4, [r0, #0]
9001e72e:	b002      	add	sp, #8
9001e730:	bd10      	pop	{r4, pc}

9001e732 <xflowf>:
9001e732:	b130      	cbz	r0, 9001e742 <xflowf+0x10>
9001e734:	eef1 7a40 	vneg.f32	s15, s0
9001e738:	ee27 0a80 	vmul.f32	s0, s15, s0
9001e73c:	2022      	movs	r0, #34	; 0x22
9001e73e:	f7ff bfed 	b.w	9001e71c <with_errnof>
9001e742:	eef0 7a40 	vmov.f32	s15, s0
9001e746:	e7f7      	b.n	9001e738 <xflowf+0x6>

9001e748 <__math_uflowf>:
9001e748:	ed9f 0a01 	vldr	s0, [pc, #4]	; 9001e750 <__math_uflowf+0x8>
9001e74c:	f7ff bff1 	b.w	9001e732 <xflowf>
9001e750:	10000000 	.word	0x10000000

9001e754 <__math_may_uflowf>:
9001e754:	ed9f 0a01 	vldr	s0, [pc, #4]	; 9001e75c <__math_may_uflowf+0x8>
9001e758:	f7ff bfeb 	b.w	9001e732 <xflowf>
9001e75c:	1a200000 	.word	0x1a200000

9001e760 <__math_oflowf>:
9001e760:	ed9f 0a01 	vldr	s0, [pc, #4]	; 9001e768 <__math_oflowf+0x8>
9001e764:	f7ff bfe5 	b.w	9001e732 <xflowf>
9001e768:	70000000 	.word	0x70000000

9001e76c <__math_divzerof>:
9001e76c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
9001e770:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
9001e774:	2800      	cmp	r0, #0
9001e776:	fe40 7a27 	vseleq.f32	s15, s0, s15
9001e77a:	ed9f 0a03 	vldr	s0, [pc, #12]	; 9001e788 <__math_divzerof+0x1c>
9001e77e:	2022      	movs	r0, #34	; 0x22
9001e780:	ee87 0a80 	vdiv.f32	s0, s15, s0
9001e784:	f7ff bfca 	b.w	9001e71c <with_errnof>
9001e788:	00000000 	.word	0x00000000

9001e78c <__math_invalidf>:
9001e78c:	eef0 7a40 	vmov.f32	s15, s0
9001e790:	ee30 7a40 	vsub.f32	s14, s0, s0
9001e794:	eef4 7a67 	vcmp.f32	s15, s15
9001e798:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
9001e79c:	ee87 0a07 	vdiv.f32	s0, s14, s14
9001e7a0:	d602      	bvs.n	9001e7a8 <__math_invalidf+0x1c>
9001e7a2:	2021      	movs	r0, #33	; 0x21
9001e7a4:	f7ff bfba 	b.w	9001e71c <with_errnof>
9001e7a8:	4770      	bx	lr
	...

9001e7ac <_init>:
9001e7ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9001e7ae:	bf00      	nop
9001e7b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
9001e7b2:	bc08      	pop	{r3}
9001e7b4:	469e      	mov	lr, r3
9001e7b6:	4770      	bx	lr

9001e7b8 <_fini>:
9001e7b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
9001e7ba:	bf00      	nop
9001e7bc:	bcf8      	pop	{r3, r4, r5, r6, r7}
9001e7be:	bc08      	pop	{r3}
9001e7c0:	469e      	mov	lr, r3
9001e7c2:	4770      	bx	lr
