/*!
 \file gpio.cpp

 \authors Androshchuk A.V.

 \code
    GPIOInit();

    ...

 \endcode



*/
#include "gpio.h"
#include "i2c.h"
#include <algorithm>
#include <cstring>
#include "rs232.h"
#include "rs232_printf.h"
#include "tlv320aic3254.h"
#include "aic3254_reg.h"

bool volUpPressed;
bool volDownPressed;
bool sensUpPressed;
bool sensDownPressed;
bool signalMaxMin = false;
extern uint8_t pinNormaState;

extern SAI_HandleTypeDef audioTxSai;
extern uint8_t boardType;
static const uint16_t ring_length = 5136;
alignas(4) static uint8_t ring_raw[] = {

    0x7d, 0x0a, 0x50, 0x0c, 0x86, 0x04, 0x91, 0x0a, 0x42, 0xfc, 0xbd, 0x02,
    0xec, 0xf8, 0x0d, 0xff, 0x23, 0xf9, 0x36, 0xfa, 0x4b, 0xf8, 0x58, 0xf7,
    0x75, 0xeb, 0xb8, 0xe7, 0xa1, 0xf0, 0x08, 0xed, 0x57, 0xf1, 0x24, 0xf6,
    0xb7, 0xf1, 0x73, 0xf7, 0xf9, 0xef, 0x60, 0xf4, 0x53, 0xe5, 0x4b, 0xe4,
    0xd3, 0xe9, 0x2b, 0xe5, 0x53, 0xef, 0x3c, 0xed, 0xb3, 0xf0, 0x24, 0xf0,
    0x1f, 0xec, 0x73, 0xec, 0x00, 0xe9, 0x55, 0xe9, 0x96, 0x04, 0xbe, 0x04,
    0x46, 0x05, 0x68, 0x05, 0x83, 0x02, 0x98, 0xfe, 0xdd, 0x06, 0x85, 0x06,
    0x9c, 0xfe, 0xe8, 0x02, 0x22, 0x01, 0x37, 0xfd, 0x8c, 0x0a, 0x0f, 0x03,
    0x69, 0x0d, 0xf2, 0x07, 0x78, 0x0d, 0x19, 0x0b, 0x0c, 0x0c, 0x55, 0x0a,
    0xc1, 0x11, 0x0c, 0x0f, 0xec, 0x16, 0xcd, 0x19, 0xdf, 0x0a, 0x22, 0x10,
    0xde, 0x08, 0xfe, 0x05, 0xea, 0x0f, 0x0c, 0x0b, 0x4c, 0x17, 0xaf, 0x15,
    0x9b, 0x08, 0x20, 0x0c, 0xb4, 0x01, 0xf5, 0x05, 0xc3, 0x08, 0xd3, 0x0a,
    0xe3, 0x05, 0x02, 0x06, 0xb3, 0x08, 0x29, 0x02, 0xe3, 0x15, 0x63, 0x13,
    0xb5, 0x08, 0xa5, 0x0e, 0x46, 0xfd, 0x45, 0x04, 0x3d, 0xfa, 0x45, 0x01,
    0x5f, 0xf8, 0x81, 0xfc, 0xdd, 0xfb, 0xbf, 0xfb, 0x9b, 0xed, 0x28, 0xeb,
    0x7c, 0xec, 0x19, 0xe8, 0xd9, 0xf0, 0xba, 0xf4, 0x53, 0xf1, 0xf7, 0xf8,
    0x3d, 0xf2, 0x45, 0xf7, 0xf9, 0xe6, 0xc1, 0xe8, 0x58, 0xe5, 0x4c, 0xe0,
    0x36, 0xee, 0x76, 0xe8, 0xa3, 0xef, 0x60, 0xed, 0x31, 0xee, 0xba, 0xee,
    0x33, 0xe3, 0x75, 0xe5, 0x9e, 0xfc, 0x45, 0xfd, 0x61, 0x09, 0xe8, 0x08,
    0x96, 0x01, 0x7a, 0xfe, 0x6b, 0x07, 0xcf, 0x04, 0xe1, 0x00, 0x3f, 0x05,
    0x0c, 0xff, 0x97, 0xfd, 0x13, 0x08, 0x37, 0x00, 0xb7, 0x0d, 0xef, 0x06,
    0x81, 0x0d, 0x2d, 0x0a, 0x03, 0x0c, 0x64, 0x0b, 0xfe, 0x0e, 0xf0, 0x0c,
    0xb9, 0x19, 0xa2, 0x19, 0x85, 0x0f, 0x2f, 0x14, 0xa5, 0x07, 0x7c, 0x08,
    0xd1, 0x0c, 0x7c, 0x0a, 0x74, 0x18, 0x86, 0x15, 0x47, 0x0f, 0x53, 0x0e,
    0x1b, 0x03, 0xdd, 0x06, 0xf9, 0x08, 0x51, 0x0c, 0x76, 0x07, 0xe0, 0x08,
    0xb4, 0x06, 0xb4, 0x00, 0xa4, 0x15, 0xa8, 0x10, 0x90, 0x0e, 0x91, 0x13,
    0x6c, 0xfe, 0x89, 0x05, 0xba, 0xfb, 0x32, 0x02, 0xda, 0xf5, 0x70, 0xfb,
    0x85, 0xfb, 0x57, 0xfc, 0x65, 0xf0, 0xc7, 0xef, 0x92, 0xea, 0x96, 0xe6,
    0xb7, 0xef, 0x46, 0xf0, 0x03, 0xf0, 0xf7, 0xf5, 0xc7, 0xf2, 0xab, 0xf7,
    0xd8, 0xe8, 0x29, 0xed, 0x68, 0xe1, 0x19, 0xde, 0xd3, 0xea, 0xf4, 0xe3,
    0x95, 0xee, 0xda, 0xea, 0x0a, 0xf0, 0xa7, 0xef, 0xe4, 0xe2, 0x3e, 0xe5,
    0xb7, 0xf4, 0xed, 0xf6, 0xc8, 0x0b, 0x72, 0x0c, 0x02, 0x02, 0x88, 0xff,
    0x02, 0x07, 0x50, 0x02, 0xfc, 0x02, 0x4e, 0x07, 0x9e, 0xfd, 0x0b, 0x00,
    0x3e, 0x05, 0x2f, 0xff, 0x8c, 0x0d, 0x84, 0x06, 0x5e, 0x0f, 0xeb, 0x0a,
    0x28, 0x0f, 0xa1, 0x0c, 0x73, 0x0d, 0x56, 0x0a, 0x1a, 0x17, 0xd7, 0x16,
    0x2e, 0x12, 0x46, 0x16, 0x22, 0x08, 0xff, 0x09, 0x21, 0x0b, 0xed, 0x08,
    0xe5, 0x16, 0x21, 0x14, 0x3f, 0x14, 0x5d, 0x12, 0xb3, 0x04, 0x76, 0x07,
    0x05, 0x08, 0x7f, 0x0b, 0x7b, 0x08, 0x32, 0x0c, 0x4f, 0x04, 0x1a, 0x01,
    0x1c, 0x11, 0xd0, 0x0a, 0x3d, 0x12, 0xae, 0x13, 0xbd, 0x00, 0xa2, 0x06,
    0xe5, 0xfc, 0x9a, 0x03, 0x7d, 0xf5, 0x59, 0xfc, 0x0a, 0xfb, 0x2a, 0xfd,
    0xd0, 0xf4, 0xd4, 0xf5, 0x86, 0xe9, 0x4c, 0xe7, 0xe3, 0xee, 0x64, 0xec,
    0xea, 0xef, 0x8d, 0xf3, 0x68, 0xf2, 0x0f, 0xf6, 0xaf, 0xec, 0x06, 0xf1,
    0xa3, 0xe2, 0xde, 0xe0, 0x14, 0xe9, 0x82, 0xe2, 0x1a, 0xed, 0xdd, 0xe8,
    0xa0, 0xef, 0x12, 0xf0, 0x6d, 0xe6, 0xbb, 0xe8, 0xb0, 0xed, 0xc8, 0xee,
    0x35, 0x0a, 0xa5, 0x0a, 0xed, 0x04, 0x98, 0x04, 0xf0, 0x05, 0x5b, 0x01,
    0x09, 0x05, 0x75, 0x06, 0xd0, 0xfc, 0x8e, 0x00, 0x41, 0x02, 0xee, 0xfe,
    0xf4, 0x0c, 0xee, 0x04, 0xe7, 0x0f, 0xfc, 0x08, 0x29, 0x0f, 0x2e, 0x0d,
    0xca, 0x0b, 0xd5, 0x08, 0xca, 0x13, 0x9b, 0x13, 0x9a, 0x13, 0x59, 0x19,
    0x65, 0x08, 0xc2, 0x0c, 0xfc, 0x08, 0xd9, 0x05, 0x18, 0x14, 0xbd, 0x0f,
    0xfd, 0x17, 0xf5, 0x16, 0xdb, 0x06, 0xd3, 0x0a, 0xc4, 0x06, 0xc7, 0x09,
    0xb6, 0x0a, 0xf3, 0x0d, 0x01, 0x05, 0x4c, 0x03, 0x56, 0x0d, 0xb7, 0x06,
    0xb1, 0x14, 0xeb, 0x15, 0x0f, 0x04, 0xdc, 0x09, 0x93, 0xfe, 0x03, 0x02,
    0x6b, 0xf8, 0x8d, 0xfd, 0x41, 0xfa, 0xea, 0xfd, 0xba, 0xf8, 0xa1, 0xf9,
    0x96, 0xe9, 0x31, 0xe8, 0x4c, 0xec, 0x82, 0xe9, 0x7b, 0xee, 0xbe, 0xf2,
    0xb0, 0xf1, 0x59, 0xf4, 0x8d, 0xef, 0x45, 0xf3, 0x53, 0xe4, 0x74, 0xe5,
    0x99, 0xe7, 0x9d, 0xe0, 0x84, 0xeb, 0xb2, 0xe5, 0xef, 0xee, 0x8b, 0xef,
    0x65, 0xea, 0x38, 0xec, 0x8c, 0xe8, 0x39, 0xe7, 0xb7, 0x06, 0x08, 0x05,
    0xd3, 0x05, 0x8f, 0x07, 0x97, 0x02, 0x47, 0x00, 0xac, 0x06, 0x1c, 0x07,
    0x1a, 0xfd, 0xdd, 0x02, 0xfc, 0xff, 0x45, 0xfe, 0x3b, 0x0a, 0x39, 0x03,
    0x90, 0x0f, 0xe3, 0x07, 0x60, 0x10, 0x15, 0x0d, 0xa1, 0x0c, 0x01, 0x08,
    0xcc, 0x11, 0xbf, 0x0f, 0x66, 0x17, 0xb1, 0x1c, 0xc5, 0x0c, 0x61, 0x11,
    0x92, 0x08, 0xb5, 0x06, 0x56, 0x10, 0x0f, 0x0e, 0x8f, 0x19, 0xfd, 0x18,
    0x65, 0x0a, 0xaf, 0x0d, 0xeb, 0x05, 0x37, 0x09, 0x49, 0x0b, 0x17, 0x0e,
    0xa3, 0x04, 0xeb, 0x04, 0x75, 0x09, 0xc4, 0x03, 0xda, 0x14, 0x38, 0x15,
    0x5d, 0x06, 0xda, 0x0c, 0xf8, 0xfc, 0x92, 0x01, 0xb0, 0xf8, 0xd4, 0xfc,
    0x6f, 0xf8, 0x33, 0xfc, 0xbc, 0xfb, 0x09, 0xfd, 0x79, 0xea, 0x2b, 0xea,
    0x2d, 0xeb, 0xe1, 0xe5, 0x61, 0xef, 0x63, 0xef, 0x53, 0xf1, 0x0c, 0xf4,
    0x44, 0xf2, 0xfa, 0xf4, 0x71, 0xe6, 0xd4, 0xe6, 0xa3, 0xe4, 0xd3, 0xdf,
    0x2e, 0xeb, 0xc0, 0xe6, 0x0c, 0xef, 0xf0, 0xec, 0x5b, 0xec, 0x00, 0xee,
    0x0e, 0xe6, 0x60, 0xe7, 0xfe, 0x00, 0xea, 0xff, 0x1e, 0x08, 0xcd, 0x08,
    0x19, 0x02, 0x2c, 0x00, 0xc1, 0x07, 0x65, 0x07, 0xa5, 0xff, 0x92, 0x04,
    0xf9, 0xfe, 0xf4, 0xfd, 0xdc, 0x07, 0x85, 0x03, 0x4b, 0x10, 0x33, 0x08,
    0x3b, 0x10, 0x44, 0x0c, 0xcd, 0x0d, 0x74, 0x0a, 0xd3, 0x11, 0x4d, 0x0d,
    0x41, 0x19, 0xda, 0x1b, 0x42, 0x0f, 0x48, 0x14, 0x71, 0x08, 0x93, 0x0a,
    0x87, 0x0d, 0x6c, 0x0c, 0x51, 0x17, 0x08, 0x16, 0x2d, 0x0c, 0x60, 0x10,
    0xa9, 0x03, 0xc0, 0x07, 0x81, 0x09, 0x4d, 0x0c, 0x43, 0x05, 0x06, 0x07,
    0x29, 0x06, 0x58, 0x01, 0xe9, 0x12, 0x8e, 0x11, 0x46, 0x0b, 0x31, 0x0e,
    0x12, 0xfd, 0x39, 0x00, 0xcd, 0xf8, 0xaf, 0xfc, 0x1a, 0xf4, 0x0e, 0xfa,
    0x1c, 0xfb, 0xbb, 0xfe, 0x1b, 0xf0, 0xf7, 0xef, 0x4e, 0xeb, 0xa3, 0xe5,
    0x85, 0xf0, 0xab, 0xed, 0x8e, 0xf1, 0x8a, 0xf4, 0x71, 0xf2, 0xb5, 0xf7,
    0x59, 0xe8, 0x06, 0xec, 0xbe, 0xe4, 0xab, 0xdf, 0x5f, 0xed, 0xc3, 0xe5,
    0x3a, 0xef, 0x2a, 0xec, 0x36, 0xee, 0xac, 0xef, 0x90, 0xe6, 0xcd, 0xe7,
    0x26, 0xfa, 0x98, 0xf8, 0x8b, 0x0a, 0x1b, 0x0a, 0xc1, 0x02, 0x38, 0x01,
    0x2e, 0x0a, 0xda, 0x04, 0x85, 0x02, 0x81, 0x05, 0xaf, 0xfb, 0x19, 0xfe,
    0xec, 0x06, 0x9a, 0x03, 0xee, 0x0f, 0xee, 0x09, 0xd4, 0x11, 0xfe, 0x0b,
    0x1c, 0x0f, 0x94, 0x0c, 0x82, 0x0d, 0x91, 0x0b, 0xc9, 0x16, 0x7c, 0x19,
    0x72, 0x10, 0x03, 0x18, 0xb3, 0x09, 0x73, 0x0b, 0x02, 0x0c, 0xeb, 0x07,
    0x77, 0x14, 0x89, 0x12, 0x94, 0x0e, 0x47, 0x12, 0x6a, 0x00, 0xc9, 0x07,
    0x8b, 0x06, 0xf4, 0x09, 0xf6, 0x06, 0x28, 0x08, 0x19, 0x05, 0xd3, 0x00,
    0x5d, 0x10, 0x81, 0x0c, 0x2a, 0x0d, 0x97, 0x0f, 0x59, 0xfd, 0x87, 0x01,
    0x9d, 0xfa, 0x2e, 0xfe, 0x9f, 0xf5, 0xdc, 0xf9, 0x1d, 0xfb, 0x8c, 0xfd,
    0x73, 0xf4, 0x29, 0xf4, 0x45, 0xec, 0xaf, 0xe6, 0x60, 0xf1, 0x34, 0xed,
    0x4c, 0xf0, 0x2a, 0xf4, 0x7e, 0xf1, 0x69, 0xf6, 0x1d, 0xeb, 0xa3, 0xed,
    0x99, 0xe4, 0x17, 0xe1, 0x7a, 0xeb, 0x7a, 0xe6, 0x9a, 0xee, 0x26, 0xec,
    0x49, 0xf0, 0x9a, 0xf0, 0x42, 0xe9, 0x25, 0xea, 0x81, 0xf5, 0x29, 0xf5,
    0x2f, 0x0a, 0xd0, 0x09, 0x9e, 0x02, 0x18, 0x02, 0x88, 0x07, 0xc6, 0x04,
    0x0b, 0x05, 0x00, 0x08, 0xb6, 0xfc, 0xcd, 0xff, 0xbc, 0x05, 0x1f, 0x02,
    0x63, 0x10, 0x95, 0x0a, 0x88, 0x10, 0xd3, 0x0c, 0x47, 0x0e, 0x1f, 0x0b,
    0x0b, 0x0e, 0x65, 0x09, 0xf2, 0x14, 0x4f, 0x16, 0x3a, 0x11, 0xf8, 0x16,
    0x45, 0x08, 0xd7, 0x0b, 0xfa, 0x09, 0x04, 0x07, 0xe1, 0x11, 0xcd, 0x0e,
    0xc7, 0x10, 0x8e, 0x12, 0x2b, 0x05, 0x6b, 0x08, 0x3e, 0x06, 0x55, 0x09,
    0x0e, 0x07, 0x00, 0x0a, 0x88, 0x04, 0x2f, 0x01, 0x14, 0x0d, 0x5e, 0x09,
    0x9e, 0x0f, 0xe4, 0x11, 0x3e, 0xff, 0x4a, 0x03, 0xa4, 0xfa, 0x4e, 0xff,
    0x29, 0xf7, 0xcb, 0xfb, 0x9d, 0xf8, 0x80, 0xfc, 0xa4, 0xf5, 0x8e, 0xf7,
    0x0d, 0xed, 0xe4, 0xe7, 0x7f, 0xf2, 0xfc, 0xea, 0x10, 0xf1, 0x3c, 0xf2,
    0x50, 0xf0, 0xad, 0xf5, 0x39, 0xed, 0x63, 0xf1, 0x40, 0xe6, 0xc5, 0xe2,
    0xa7, 0xed, 0xb8, 0xe7, 0xbc, 0xee, 0xc6, 0xec, 0x1d, 0xef, 0xa9, 0xef,
    0xb2, 0xea, 0x99, 0xed, 0x84, 0xef, 0x19, 0xf1, 0xcf, 0x08, 0x70, 0x09,
    0xd6, 0x04, 0xb9, 0x03, 0x97, 0x05, 0x5f, 0x00, 0xfa, 0x06, 0x2c, 0x07,
    0x9a, 0xfd, 0x7c, 0x00, 0x2b, 0x03, 0xcd, 0xff, 0x62, 0x0a, 0x04, 0x05,
    0x8b, 0x0e, 0x3b, 0x09, 0x2a, 0x0e, 0xe4, 0x0b, 0xcc, 0x0e, 0x63, 0x0a,
    0xee, 0x15, 0x6b, 0x13, 0x7d, 0x11, 0x15, 0x17, 0x27, 0x09, 0x11, 0x0e,
    0x85, 0x0a, 0xbe, 0x09, 0xc1, 0x10, 0x05, 0x0f, 0x95, 0x11, 0x0a, 0x14,
    0xeb, 0x05, 0x7d, 0x09, 0x4e, 0x04, 0xb6, 0x07, 0x2e, 0x09, 0xbd, 0x0d,
    0xd2, 0x04, 0xd4, 0x03, 0xc4, 0x0a, 0x7c, 0x05, 0x95, 0x11, 0x8b, 0x11,
    0x10, 0x01, 0x94, 0x06, 0x8e, 0xfb, 0xd0, 0x00, 0x7c, 0xf8, 0x09, 0xfb,
    0xf3, 0xf8, 0x0f, 0xfa, 0x3f, 0xf9, 0x9e, 0xf9, 0x22, 0xee, 0x83, 0xec,
    0x2e, 0xed, 0xb3, 0xe7, 0x3f, 0xec, 0x35, 0xec, 0xf5, 0xf8, 0x17, 0xfe,
    0x07, 0xfa, 0x92, 0xfe, 0x49, 0xe6, 0xb1, 0xe7, 0x16, 0xef, 0x65, 0xe9,
    0xec, 0xf3, 0x93, 0xf2, 0x91, 0xe9, 0x76, 0xea, 0x5b, 0xe7, 0x17, 0xe4,
    0x14, 0xe8, 0x6c, 0xe5, 0x15, 0xf8, 0x9d, 0xf5, 0x78, 0x00, 0xfa, 0xfe,
    0x5c, 0x01, 0xc1, 0xfc, 0x56, 0x01, 0x5d, 0xfe, 0x13, 0xfa, 0x96, 0xfd,
    0xd0, 0x02, 0xe6, 0x02, 0x9a, 0x14, 0xe7, 0x12, 0xe3, 0x0e, 0xa7, 0x0e,
    0x0d, 0x09, 0x5f, 0x06, 0x0b, 0x13, 0xb7, 0x0e, 0x94, 0x15, 0x69, 0x11,
    0x08, 0x12, 0x98, 0x11, 0x0b, 0x1b, 0x8f, 0x1d, 0x25, 0x27, 0x57, 0x2b,
    0xe7, 0x1f, 0xdb, 0x24, 0x51, 0x13, 0xfd, 0x14, 0x24, 0x0b, 0x4d, 0x0c,
    0xe6, 0x0a, 0xf1, 0x0e, 0x4a, 0x06, 0xb2, 0x0a, 0x5f, 0x03, 0x29, 0x01,
    0x30, 0x08, 0xb5, 0x04, 0x53, 0xfa, 0xc1, 0xfc, 0x27, 0xf3, 0xf8, 0xf5,
    0xaa, 0xf9, 0xaa, 0xfd, 0x23, 0xec, 0xe8, 0xf1, 0x12, 0xe8, 0xaa, 0xe9,
    0xbd, 0xf1, 0x02, 0xf3, 0x68, 0xee, 0xbf, 0xef, 0xc0, 0xdd, 0x16, 0xdb,
    0x93, 0xd7, 0xcf, 0xd0, 0x45, 0xe0, 0xdb, 0xdb, 0x0f, 0xea, 0x3c, 0xea,
    0xfd, 0xf3, 0x4b, 0xf2, 0x76, 0xf6, 0xe7, 0xf2, 0x33, 0xf7, 0xfb, 0xf5,
    0xd3, 0xf0, 0x78, 0xf3, 0x16, 0xf8, 0x75, 0xf8, 0x45, 0x02, 0x49, 0x03,
    0xaf, 0x00, 0xe9, 0x00, 0x7a, 0x0f, 0xb9, 0x0a, 0x29, 0x16, 0x7b, 0x11,
    0xc2, 0x0b, 0x81, 0x07, 0xbc, 0x09, 0x36, 0x03, 0x48, 0x1c, 0x8c, 0x1a,
    0x46, 0x30, 0xdf, 0x36, 0x57, 0x25, 0x50, 0x2a, 0x34, 0x16, 0x02, 0x17,
    0x4a, 0x0d, 0x20, 0x0e, 0xab, 0x08, 0x77, 0x0a, 0x08, 0x0e, 0x1a, 0x0d,
    0xe8, 0x13, 0x48, 0x10, 0x68, 0x12, 0xd0, 0x12, 0x49, 0x01, 0x32, 0x05,
    0x5a, 0x00, 0xba, 0x02, 0x43, 0xfc, 0xe6, 0x01, 0x27, 0xec, 0x62, 0xf0,
    0x66, 0xf3, 0xa4, 0xf5, 0xc4, 0xfb, 0x2a, 0x00, 0xb5, 0xec, 0xf9, 0xef,
    0x89, 0xd6, 0x90, 0xd3, 0x6c, 0xd4, 0x5f, 0xce, 0x25, 0xe4, 0xaa, 0xe3,
    0x86, 0xf1, 0xcb, 0xf2, 0x93, 0xf7, 0xf1, 0xf4, 0xdd, 0xf7, 0x4b, 0xf5,
    0x9f, 0xf0, 0xd1, 0xf3, 0xc5, 0xec, 0xa5, 0xee, 0x35, 0xfb, 0x43, 0xf8,
    0x95, 0xfe, 0x16, 0xf9, 0x88, 0xfa, 0x4a, 0xf6, 0x01, 0x0c, 0xf2, 0x07,
    0x71, 0x0c, 0x1e, 0x0a, 0x02, 0x00, 0x31, 0xfe, 0xff, 0x06, 0xa6, 0x03,
    0x17, 0x21, 0xe7, 0x22, 0x38, 0x2a, 0xf7, 0x2f, 0x0c, 0x1c, 0x53, 0x1e,
    0xa8, 0x10, 0x2d, 0x0f, 0x9d, 0x08, 0xdc, 0x09, 0x96, 0x07, 0x4e, 0x0b,
    0xec, 0x0b, 0xb5, 0x09, 0x2c, 0x15, 0x46, 0x10, 0x86, 0x0d, 0xff, 0x0e,
    0xbb, 0x00, 0x86, 0x02, 0x1d, 0x06, 0x11, 0x08, 0x0f, 0xfa, 0xeb, 0xfd,
    0x48, 0xf0, 0xbc, 0xf2, 0x30, 0xfd, 0x14, 0xfe, 0x2b, 0xfd, 0x53, 0x00,
    0x3e, 0xe8, 0x96, 0xea, 0xbc, 0xd7, 0xac, 0xd5, 0x94, 0xe3, 0xda, 0xe0,
    0xeb, 0xf0, 0xad, 0xf1, 0x2b, 0xf7, 0xc1, 0xf6, 0xbc, 0xfa, 0x47, 0xf6,
    0x7d, 0xf8, 0xfc, 0xfa, 0xba, 0xf1, 0xe2, 0xf8, 0x69, 0xf3, 0xb1, 0xf5,
    0x92, 0x00, 0x82, 0xfc, 0x5d, 0xf9, 0xe3, 0xf4, 0xe0, 0xff, 0xfc, 0xf9,
    0xb3, 0x10, 0x5a, 0x0b, 0xfd, 0x05, 0xdb, 0x04, 0x47, 0xfe, 0x32, 0xfb,
    0xde, 0x0e, 0xd5, 0x0c, 0xea, 0x24, 0x6f, 0x29, 0x81, 0x1d, 0xcf, 0x22,
    0x1b, 0x0c, 0xae, 0x0c, 0x4f, 0x06, 0x39, 0x05, 0x86, 0x03, 0x43, 0x06,
    0x57, 0x05, 0x35, 0x08, 0x88, 0x0a, 0x20, 0x06, 0xf8, 0x0e, 0x39, 0x0a,
    0x64, 0x00, 0x46, 0x01, 0x66, 0x00, 0xd8, 0x04, 0x5f, 0x05, 0xfb, 0x0b,
    0xb1, 0xf2, 0x70, 0xf7, 0xd3, 0xf4, 0x0a, 0xf5, 0x09, 0xff, 0xa2, 0x00,
    0x09, 0xf7, 0xf4, 0xf8, 0x9b, 0xe1, 0xde, 0xde, 0x1e, 0xde, 0xc8, 0xd7,
    0x16, 0xed, 0xfa, 0xe9, 0xb0, 0xf7, 0x54, 0xf7, 0x33, 0xfd, 0x0a, 0xf9,
    0x26, 0xfc, 0xa2, 0xfa, 0x3e, 0xfa, 0x33, 0xfe, 0x25, 0xf6, 0x5c, 0xfa,
    0xab, 0x00, 0x85, 0x00, 0xc0, 0x05, 0x37, 0x03, 0xae, 0xfc, 0x7c, 0xf8,
    0xc7, 0x0a, 0x35, 0x05, 0xfa, 0x0e, 0x6c, 0x0d, 0xae, 0x02, 0xbf, 0x02,
    0xa8, 0x05, 0x97, 0x04, 0xe0, 0x1a, 0x14, 0x1c, 0x1c, 0x24, 0xf6, 0x28,
    0xcb, 0x12, 0xf0, 0x14, 0x02, 0x09, 0x31, 0x06, 0x51, 0x03, 0x5b, 0x04,
    0x90, 0x01, 0xa7, 0x07, 0xfb, 0x05, 0x46, 0x05, 0x86, 0x0c, 0xd9, 0x05,
    0xf1, 0x04, 0x69, 0x04, 0x82, 0xf6, 0xca, 0xfa, 0x9e, 0xfe, 0x8d, 0x04,
    0xc5, 0xf8, 0x6c, 0xfe, 0xa8, 0xec, 0x34, 0xee, 0x7b, 0xf7, 0x45, 0xfa,
    0x22, 0xfa, 0x9b, 0xff, 0x98, 0xe8, 0x5e, 0xe9, 0x28, 0xd9, 0x8b, 0xd3,
    0xd4, 0xe1, 0x20, 0xdc, 0x39, 0xf2, 0x1c, 0xf3, 0x7f, 0xfb, 0x77, 0xfb,
    0x0b, 0x01, 0xe0, 0xfb, 0x27, 0xfe, 0xf5, 0xfc, 0xfc, 0xf6, 0x5d, 0xfb,
    0x1e, 0xfb, 0x55, 0xfb, 0x75, 0x09, 0x0f, 0x06, 0x1f, 0x04, 0x18, 0x01,
    0xb7, 0x05, 0x1f, 0xfe, 0xc5, 0x13, 0x1e, 0x0e, 0x99, 0x0a, 0x2f, 0x0a,
    0xfc, 0x02, 0x1d, 0x00, 0xe4, 0x13, 0x9d, 0x0f, 0x33, 0x29, 0xb2, 0x2c,
    0x58, 0x23, 0x0f, 0x2a, 0x92, 0x0f, 0xad, 0x10, 0x9e, 0x05, 0x4a, 0x04,
    0x7b, 0x01, 0x8f, 0x06, 0xf5, 0x02, 0xf6, 0x07, 0xb1, 0x09, 0x2d, 0x05,
    0x90, 0x0b, 0x3b, 0x08, 0x24, 0xfb, 0x06, 0xfe, 0x61, 0xf6, 0x77, 0xf9,
    0xc0, 0xfd, 0x9c, 0x01, 0x90, 0xef, 0xd9, 0xf3, 0xda, 0xee, 0x48, 0xef,
    0x02, 0xfb, 0x41, 0xfd, 0x9e, 0xf2, 0xcf, 0xf6, 0xd7, 0xdb, 0x2f, 0xdb,
    0x39, 0xd6, 0xd7, 0xcf, 0x67, 0xe6, 0x50, 0xe3, 0xac, 0xf3, 0x32, 0xf5,
    0x64, 0xfb, 0x6c, 0xf9, 0xc3, 0xfc, 0x6f, 0xf9, 0xd9, 0xf7, 0x11, 0xfc,
    0xc0, 0xf2, 0x5a, 0xf8, 0x16, 0x00, 0xf0, 0xff, 0x9e, 0x0a, 0xd6, 0x08,
    0xcd, 0x01, 0xb6, 0xfd, 0x77, 0x0c, 0x5a, 0x07, 0xd3, 0x14, 0xa1, 0x13,
    0x31, 0x09, 0x21, 0x08, 0x60, 0x09, 0x11, 0x03, 0x31, 0x1e, 0xe8, 0x1c,
    0x28, 0x2c, 0x8e, 0x32, 0x42, 0x1d, 0x15, 0x22, 0xdb, 0x0f, 0xcb, 0x0c,
    0x92, 0x06, 0x9c, 0x06, 0x4f, 0x01, 0xd3, 0x08, 0x14, 0x08, 0xa2, 0x07,
    0xc1, 0x0f, 0x8b, 0x07, 0x25, 0x09, 0xfa, 0x06, 0x40, 0xf7, 0xe2, 0xf9,
    0x22, 0xfc, 0xfa, 0xfd, 0x15, 0xf9, 0x2c, 0xfe, 0x05, 0xeb, 0xe9, 0xed,
    0xef, 0xf3, 0x76, 0xf3, 0x3a, 0xf9, 0xa0, 0xfa, 0x04, 0xe9, 0x8f, 0xea,
    0xf1, 0xd3, 0xb5, 0xd1, 0x01, 0xd9, 0x39, 0xd4, 0x27, 0xed, 0x6e, 0xea,
    0x47, 0xf7, 0xb3, 0xf6, 0x6c, 0xfb, 0x5e, 0xf7, 0x13, 0xfa, 0x01, 0xf9,
    0x5e, 0xf4, 0x67, 0xf9, 0xa2, 0xf5, 0x40, 0xf8, 0x88, 0x05, 0x31, 0x05,
    0x75, 0x03, 0x7e, 0x03, 0x1e, 0x01, 0x29, 0xfd, 0x3e, 0x13, 0x66, 0x0e,
    0x5a, 0x0f, 0x92, 0x11, 0x14, 0x04, 0x2a, 0x04, 0xef, 0x0d, 0xa3, 0x0b,
    0x7d, 0x26, 0xb6, 0x29, 0x96, 0x29, 0x31, 0x31, 0x66, 0x16, 0xea, 0x18,
    0x64, 0x0b, 0x73, 0x09, 0xd6, 0x05, 0x41, 0x09, 0x59, 0x07, 0xfa, 0x0b,
    0x92, 0x0d, 0xa6, 0x09, 0x36, 0x11, 0x54, 0x0a, 0x3d, 0x02, 0x8d, 0x01,
    0x1f, 0xf8, 0x6c, 0xf8, 0x67, 0x01, 0x94, 0x03, 0xb9, 0xf3, 0xec, 0xf8,
    0xac, 0xeb, 0x02, 0xec, 0xbd, 0xf7, 0xcf, 0xf6, 0x39, 0xf5, 0xab, 0xf7,
    0xe5, 0xe0, 0xb0, 0xe0, 0x2b, 0xd4, 0xe6, 0xce, 0x5c, 0xe1, 0xd1, 0xdc,
    0x4a, 0xf0, 0xee, 0xf0, 0xc8, 0xf9, 0xac, 0xf7, 0x27, 0xfc, 0x34, 0xf8,
    0xee, 0xf6, 0x91, 0xf9, 0x74, 0xf0, 0xfd, 0xf5, 0x24, 0xf9, 0x00, 0xfa,
    0x30, 0x07, 0xb4, 0x06, 0x52, 0xfe, 0x64, 0xfd, 0x4e, 0x06, 0xd2, 0xff,
    0xb9, 0x14, 0xf5, 0x10, 0x38, 0x09, 0x2f, 0x0a, 0x8f, 0x05, 0x4f, 0x04,
    0x13, 0x18, 0xf7, 0x16, 0x71, 0x2b, 0xf0, 0x2f, 0x85, 0x20, 0x94, 0x25,
    0x31, 0x0f, 0xb5, 0x0e, 0x3d, 0x08, 0xf2, 0x08, 0x4e, 0x04, 0x51, 0x09,
    0xdd, 0x09, 0x17, 0x0a, 0x81, 0x0f, 0xa5, 0x09, 0xad, 0x0b, 0xdc, 0x09,
    0x68, 0xfb, 0xd5, 0xfc, 0x0b, 0xff, 0xc8, 0xfe, 0xce, 0x00, 0x32, 0x05,
    0xaf, 0xed, 0xf3, 0xf2, 0xaf, 0xf2, 0x9d, 0xf2, 0x43, 0xfc, 0x58, 0xfd,
    0xc0, 0xef, 0x65, 0xf1, 0x62, 0xda, 0x12, 0xd7, 0x67, 0xd9, 0x7a, 0xd3,
    0xe0, 0xe9, 0xe1, 0xe8, 0x95, 0xf5, 0x07, 0xf6, 0x89, 0xfc, 0x1e, 0xf8,
    0x2d, 0xf9, 0x75, 0xf7, 0xfc, 0xf2, 0xd2, 0xf7, 0xec, 0xf3, 0x2a, 0xf7,
    0xcc, 0x02, 0xe6, 0x01, 0xe2, 0x03, 0x27, 0x04, 0x4e, 0xfc, 0xf3, 0xf8,
    0x5c, 0x0e, 0xd1, 0x06, 0x8c, 0x10, 0xee, 0x0e, 0x1d, 0x03, 0x68, 0x04,
    0xce, 0x08, 0x06, 0x07, 0x0e, 0x1f, 0xce, 0x1f, 0xd1, 0x26, 0xeb, 0x2c,
    0x4f, 0x16, 0x7f, 0x1a, 0xa4, 0x0a, 0x95, 0x0a, 0x00, 0x04, 0x5b, 0x06,
    0x5f, 0x05, 0x7e, 0x08, 0xb5, 0x0b, 0xa4, 0x09, 0xd0, 0x0e, 0xc0, 0x0b,
    0xc5, 0x04, 0x3c, 0x05, 0x57, 0xfa, 0xdc, 0xf9, 0xb1, 0x02, 0xbf, 0x02,
    0xde, 0xf7, 0x2a, 0xfe, 0xca, 0xec, 0x4c, 0xf1, 0xa1, 0xf8, 0x93, 0xf8,
    0x56, 0xfa, 0x3e, 0xfb, 0x60, 0xe7, 0x4c, 0xe7, 0x25, 0xd8, 0x95, 0xd3,
    0x88, 0xe3, 0xf9, 0xde, 0x6c, 0xf2, 0x21, 0xf2, 0x5b, 0xfb, 0x0c, 0xf9,
    0xae, 0xfd, 0x6f, 0xf9, 0x13, 0xf9, 0x79, 0xfa, 0x8d, 0xf5, 0x03, 0xf9,
    0x29, 0xfb, 0x03, 0xfa, 0x7b, 0x07, 0x81, 0x05, 0x12, 0xff, 0xd3, 0xfe,
    0x5a, 0x03, 0xb2, 0xfd, 0x31, 0x14, 0x3b, 0x0d, 0x89, 0x0a, 0x63, 0x09,
    0xbc, 0x01, 0x43, 0x00, 0xeb, 0x0f, 0xcc, 0x0d, 0x07, 0x25, 0xee, 0x28,
    0x22, 0x1e, 0xbe, 0x25, 0x51, 0x0d, 0xbc, 0x0f, 0xd5, 0x05, 0xc4, 0x06,
    0x68, 0x01, 0xf1, 0x06, 0xaa, 0x05, 0xb0, 0x08, 0xb0, 0x09, 0xce, 0x07,
    0x35, 0x09, 0x20, 0x09, 0x5b, 0xfb, 0x85, 0xfd, 0x55, 0xfb, 0x61, 0xfc,
    0x12, 0x01, 0x3b, 0x05, 0x49, 0xf0, 0xa9, 0xf6, 0x02, 0xf1, 0xd1, 0xf1,
    0xc1, 0xfc, 0x04, 0xfd, 0x9d, 0xf5, 0x07, 0xf8, 0xa1, 0xe0, 0x13, 0xde,
    0xc4, 0xdc, 0x4a, 0xd5, 0x42, 0xec, 0xd5, 0xe7, 0xbb, 0xf7, 0x09, 0xf7,
    0x1f, 0xff, 0xd4, 0xfa, 0x5d, 0xfc, 0xfc, 0xf9, 0x75, 0xf7, 0x49, 0xfa,
    0x50, 0xf6, 0xd8, 0xf6, 0x6c, 0x02, 0x06, 0x00, 0x8b, 0x08, 0x47, 0x07,
    0xe1, 0xfe, 0x70, 0xfb, 0x7a, 0x0b, 0x66, 0x03, 0x3d, 0x12, 0x07, 0x0f,
    0xa8, 0x05, 0x62, 0x06, 0x86, 0x05, 0x3b, 0x03, 0x1a, 0x19, 0xff, 0x18,
    0x9e, 0x24, 0xec, 0x2a, 0x5c, 0x16, 0xde, 0x1b, 0x75, 0x09, 0x81, 0x0a,
    0x2e, 0x02, 0x0f, 0x06, 0x1a, 0x03, 0x57, 0x07, 0xaf, 0x08, 0x77, 0x06,
    0x09, 0x0b, 0x9f, 0x07, 0xc2, 0x04, 0x53, 0x05, 0x74, 0xf7, 0xa9, 0xf9,
    0x59, 0xfe, 0x72, 0x00, 0x21, 0xfb, 0x28, 0x00, 0x81, 0xed, 0xc6, 0xf1,
    0xb5, 0xf6, 0xa1, 0xf7, 0x68, 0xfb, 0x66, 0xfe, 0x6e, 0xec, 0x55, 0xee,
    0xf1, 0xda, 0x3a, 0xd7, 0xa6, 0xe1, 0x85, 0xdc, 0xae, 0xf1, 0xb4, 0xf0,
    0x01, 0xfb, 0x34, 0xf9, 0x97, 0xfd, 0x19, 0xf9, 0x0d, 0xf9, 0x4d, 0xfa,
    0xe5, 0xf6, 0xda, 0xfa, 0x4a, 0xfa, 0xd6, 0xf9, 0x27, 0x08, 0xa1, 0x04,
    0x3a, 0x04, 0x37, 0x01, 0x1b, 0x00, 0x0f, 0xfb, 0xaf, 0x11, 0xc4, 0x0a,
    0xe2, 0x0e, 0x8c, 0x0c, 0x43, 0x02, 0xc8, 0x01, 0xc5, 0x09, 0x34, 0x08,
    0x4a, 0x20, 0xf7, 0x22, 0xb9, 0x22, 0x5d, 0x29, 0x6c, 0x10, 0x75, 0x13,
    0x90, 0x06, 0x68, 0x07, 0x8c, 0x01, 0xd9, 0x06, 0x4e, 0x06, 0x8c, 0x08,
    0x59, 0x0b, 0x37, 0x07, 0x9b, 0x0b, 0x42, 0x09, 0x14, 0xfe, 0x39, 0x00,
    0xc2, 0xf6, 0x25, 0xf9, 0xb4, 0x01, 0xe1, 0x04, 0xcb, 0xf5, 0x43, 0xfb,
    0x22, 0xf0, 0x37, 0xf2, 0xf1, 0xfa, 0x49, 0xfa, 0xaf, 0xf8, 0x7e, 0xf9,
    0xbb, 0xe4, 0x7e, 0xe4, 0xd3, 0xd9, 0x82, 0xd5, 0x2a, 0xe7, 0xb5, 0xe4,
    0x4d, 0xf4, 0xd8, 0xf3, 0x7c, 0xfc, 0x65, 0xf9, 0x19, 0xfb, 0xa0, 0xf9,
    0x25, 0xf7, 0x6d, 0xfb, 0x5a, 0xf5, 0xae, 0xf7, 0x9e, 0xfc, 0x01, 0xfb,
    0xd7, 0x09, 0xe8, 0x06, 0xd3, 0x00, 0xce, 0xfc, 0x19, 0x06, 0x9a, 0xff,
    0x23, 0x12, 0x26, 0x0d, 0x18, 0x08, 0x0d, 0x07, 0x8a, 0x04, 0xeb, 0x01,
    0xf3, 0x14, 0x05, 0x14, 0xb7, 0x28, 0xf9, 0x2a, 0x6c, 0x1c, 0x3a, 0x20,
    0x57, 0x0b, 0xe2, 0x0c, 0xb9, 0x04, 0xf8, 0x07, 0x1e, 0x04, 0x40, 0x08,
    0xf8, 0x08, 0x3f, 0x09, 0x63, 0x09, 0x59, 0x07, 0xed, 0x06, 0xfd, 0x06,
    0x27, 0xfa, 0x37, 0xfc, 0x10, 0xfc, 0xe2, 0xff, 0xf6, 0xff, 0x8c, 0x05,
    0xb5, 0xf0, 0xd3, 0xf5, 0xc6, 0xf2, 0xac, 0xf5, 0x3a, 0xfd, 0xc1, 0xfd,
    0xdb, 0xf2, 0x02, 0xf4, 0xdd, 0xdc, 0xc6, 0xda, 0x8c, 0xda, 0x82, 0xd7,
    0x52, 0xec, 0xb7, 0xea, 0x2d, 0xf9, 0xe1, 0xf6, 0xb1, 0xfd, 0xfd, 0xf7,
    0x7b, 0xfa, 0xe8, 0xf6, 0x7e, 0xf6, 0x19, 0xf8, 0x60, 0xf4, 0x3d, 0xf6,
    0xa0, 0x01, 0xf1, 0x00, 0xb5, 0x05, 0xd3, 0x02, 0xc2, 0xfc, 0xbb, 0xf7,
    0x63, 0x0a, 0x2d, 0x05, 0xf7, 0x0f, 0x8f, 0x0f, 0x6d, 0x04, 0xba, 0x04,
    0x0c, 0x07, 0x8e, 0x04, 0x07, 0x1e, 0x3e, 0x1e, 0xf7, 0x27, 0x18, 0x2e,
    0x3f, 0x18, 0x5e, 0x1c, 0x26, 0x0a, 0x45, 0x0b, 0xd0, 0x03, 0x90, 0x07,
    0x56, 0x06, 0xa7, 0x0a, 0xb4, 0x0b, 0x56, 0x0a, 0x85, 0x0d, 0x9a, 0x0a,
    0xf0, 0x06, 0x3b, 0x06, 0x84, 0xfa, 0x38, 0xfa, 0x79, 0x01, 0xf7, 0x03,
    0xe9, 0xfa, 0x17, 0x00, 0xd3, 0xec, 0xfa, 0xef, 0x2d, 0xf7, 0xa9, 0xf7,
    0xd4, 0xf9, 0xd0, 0xfc, 0x0f, 0xe8, 0xc3, 0xe8, 0xa1, 0xd6, 0x5f, 0xd0,
    0x33, 0xdf, 0xda, 0xd9, 0xfc, 0xef, 0xfb, 0xee, 0x7b, 0xfa, 0xc0, 0xf7,
    0x91, 0xfd, 0xc2, 0xf7, 0x47, 0xf8, 0x41, 0xf7, 0x5e, 0xf3, 0x90, 0xf6,
    0x64, 0xf6, 0xa9, 0xf7, 0x7d, 0x04, 0xc1, 0x04, 0x1a, 0x01, 0xc7, 0xfe,
    0x01, 0x01, 0xb0, 0xfa, 0x74, 0x13, 0xe7, 0x0d, 0x76, 0x0c, 0x02, 0x0d,
    0x8f, 0x02, 0xd2, 0x02, 0x0b, 0x11, 0x57, 0x0f, 0xc3, 0x26, 0x3e, 0x2c,
    0xc7, 0x24, 0x87, 0x2c, 0x0c, 0x11, 0x6b, 0x13, 0xac, 0x06, 0x7c, 0x08,
    0x4f, 0x02, 0x93, 0x08, 0x91, 0x07, 0x3e, 0x0b, 0xe4, 0x0c, 0x6a, 0x09,
    0x14, 0x0c, 0xea, 0x09, 0xf2, 0xfe, 0x7a, 0xff, 0x82, 0xfc, 0x9e, 0xfc,
    0x8f, 0x03, 0xcd, 0x06, 0x47, 0xf1, 0x6b, 0xf6, 0x8f, 0xed, 0x4f, 0xee,
    0x6c, 0xfb, 0xea, 0xfa, 0xb4, 0xf6, 0xce, 0xf9, 0x70, 0xdf, 0x58, 0xde,
    0x90, 0xd5, 0x0a, 0xce, 0x94, 0xe6, 0xe5, 0xe2, 0xe4, 0xf5, 0xb4, 0xf4,
    0xdd, 0xfd, 0x06, 0xf8, 0xf6, 0xfc, 0x72, 0xf7, 0x3c, 0xf7, 0xe2, 0xf8,
    0xca, 0xf2, 0x45, 0xf5, 0xf2, 0xfa, 0xdb, 0xfb, 0xd3, 0x06, 0x78, 0x07,
    0x9f, 0xfe, 0xf3, 0xfb, 0x79, 0x07, 0x87, 0x02, 0x0b, 0x13, 0x06, 0x0f,
    0xce, 0x05, 0x51, 0x07, 0x13, 0x05, 0xdb, 0x04, 0x1e, 0x19, 0x71, 0x1a,
    0x1c, 0x2a, 0x1c, 0x30, 0xd8, 0x1e, 0x35, 0x22, 0x64, 0x0c, 0xd2, 0x0b,
    0xa0, 0x05, 0x77, 0x06, 0x49, 0x05, 0xb9, 0x09, 0xc4, 0x08, 0xe2, 0x08,
    0xd8, 0x0c, 0xa2, 0x08, 0xab, 0x09, 0x77, 0x07, 0x03, 0xfc, 0x02, 0xfc,
    0x22, 0xff, 0xee, 0x00, 0xdd, 0xfc, 0xe5, 0x01, 0x46, 0xed, 0x53, 0xf1,
    0x29, 0xf3, 0xcd, 0xf5, 0xb4, 0xfc, 0x94, 0xfc, 0x1d, 0xee, 0x2e, 0xef,
    0x36, 0xd6, 0x19, 0xd4, 0xcc, 0xd9, 0x20, 0xd5, 0x0b, 0xed, 0x4c, 0xec,
    0x68, 0xf7, 0xd6, 0xf7, 0x78, 0xfc, 0x32, 0xf8, 0x1a, 0xfa, 0xe4, 0xf6,
    0xe1, 0xf5, 0xdb, 0xf9, 0x8e, 0xf4, 0x80, 0xf7, 0x91, 0x01, 0xf2, 0x01,
    0xb7, 0x03, 0x36, 0x01, 0x39, 0xff, 0x0f, 0xfb, 0x5b, 0x12, 0xfe, 0x0b,
    0xac, 0x10, 0xc8, 0x0e, 0xc1, 0x01, 0xf4, 0x02, 0x4f, 0x09, 0xbd, 0x09,
    0xab, 0x24, 0xa0, 0x27, 0xcd, 0x2b, 0x84, 0x30, 0x13, 0x17, 0x11, 0x1a,
    0x48, 0x0a, 0x22, 0x0b, 0x0e, 0x03, 0x20, 0x07, 0xf3, 0x04, 0xe6, 0x09,
    0x8c, 0x0b, 0xf4, 0x08, 0xa9, 0x0d, 0x0c, 0x09, 0x55, 0x02, 0xaa, 0x01,
    0xdd, 0xf8, 0xd9, 0xf8, 0x07, 0x02, 0xba, 0x04, 0xac, 0xf5, 0x77, 0xfa,
    0xd0, 0xea, 0xd9, 0xec, 0x86, 0xf9, 0x05, 0xf7, 0x63, 0xf9, 0x9a, 0xf8,
    0x7a, 0xe4, 0xe2, 0xe1, 0xca, 0xd3, 0x92, 0xce, 0x17, 0xdf, 0x3f, 0xdd,
    0x5e, 0xf0, 0x5d, 0xef, 0x5b, 0xfa, 0xcc, 0xf7, 0x40, 0xfd, 0xef, 0xf8,
    0xd8, 0xf8, 0xe1, 0xf8, 0x1d, 0xf5, 0x96, 0xf9, 0xc9, 0xfa, 0x74, 0xfc,
    0x02, 0x08, 0x68, 0x06, 0x91, 0x00, 0xe9, 0xfe, 0x6a, 0x04, 0x18, 0x02,
    0xe8, 0x14, 0x97, 0x10, 0x38, 0x0a, 0x10, 0x0a, 0x29, 0x03, 0xbd, 0x03,
    0xb1, 0x15, 0xba, 0x15, 0x91, 0x2a, 0x83, 0x2d, 0x97, 0x24, 0xe4, 0x25,
    0x42, 0x10, 0xd3, 0x0f, 0x76, 0x05, 0xe9, 0x07, 0x6c, 0x02, 0x84, 0x09,
    0xd3, 0x07, 0x4f, 0x0a, 0x36, 0x0c, 0xd7, 0x08, 0x95, 0x0b, 0x8a, 0x08,
    0xd2, 0xfd, 0x1a, 0xfe, 0xd6, 0xfc, 0x1d, 0xff, 0xec, 0xfe, 0xfb, 0x03,
    0x13, 0xec, 0xef, 0xf2, 0x93, 0xef, 0x9c, 0xf1, 0x16, 0xfc, 0xf4, 0xf9,
    0xe5, 0xf2, 0x0b, 0xf3, 0xbc, 0xd8, 0x20, 0xd6, 0xed, 0xd6, 0xfd, 0xcf,
    0x62, 0xe9, 0xf8, 0xe6, 0xe4, 0xf4, 0xed, 0xf3, 0xc3, 0xfc, 0x8f, 0xf7,
    0xc3, 0xfb, 0x53, 0xf9, 0x96, 0xf6, 0x2c, 0xfb, 0xf1, 0xf2, 0x7f, 0xf6,
    0x4f, 0x00, 0x59, 0x00, 0x47, 0x06, 0xa7, 0x05, 0x31, 0xfd, 0x7c, 0xfb,
    0x38, 0x0d, 0x23, 0x08, 0xd9, 0x13, 0xcc, 0x12, 0x31, 0x05, 0x11, 0x07,
    0xe1, 0x07, 0x37, 0x07, 0x9b, 0x1d, 0x0c, 0x1f, 0xcc, 0x2b, 0x6a, 0x2f,
    0x1a, 0x1b, 0xa2, 0x1d, 0x57, 0x0a, 0x3a, 0x0c, 0x29, 0x03, 0x03, 0x07,
    0xef, 0x03, 0x44, 0x07, 0x03, 0x0c, 0xee, 0x08, 0x82, 0x0e, 0xe4, 0x0a,
    0x13, 0x08, 0x92, 0x07, 0x78, 0xff, 0x4f, 0xfe, 0xeb, 0xf9, 0x4b, 0xfa,
    0xcf, 0xee, 0xf2, 0xf1, 0x5a, 0xec, 0x7e, 0xeb, 0xd8, 0xf3, 0x77, 0xee,
    0xf5, 0xf7, 0xf3, 0xf4, 0x0e, 0xf1, 0xa6, 0xf0, 0x0b, 0xdc, 0x52, 0xdc,
    0xca, 0xe3, 0x7a, 0xe1, 0x27, 0x00, 0xde, 0x00, 0x97, 0x00, 0x50, 0x01,
    0x64, 0xfd, 0x9b, 0xfd, 0x88, 0xfc, 0x8c, 0x00, 0xe4, 0xfa, 0x78, 0xfe,
    0xd6, 0xf5, 0x1e, 0xf4, 0xde, 0xf7, 0x6e, 0xf1, 0xcf, 0xfe, 0x0e, 0xfc,
    0xdd, 0x05, 0x4a, 0x04, 0x8a, 0x0b, 0x93, 0x09, 0x37, 0x06, 0x5b, 0x0a,
    0x53, 0xfe, 0x78, 0x05, 0x14, 0xf8, 0x8c, 0xfb, 0x7e, 0x07, 0xa6, 0x03,
    0x88, 0x12, 0xf1, 0x0e, 0x37, 0x0f, 0x6a, 0x12, 0x3e, 0x03, 0xc7, 0x07,
    0xa1, 0xfc, 0xcd, 0x01, 0x7e, 0x0c, 0x37, 0x0b, 0xe8, 0x0f, 0x04, 0x0c,
    0x2e, 0x11, 0xac, 0x0a, 0x0f, 0x1b, 0xeb, 0x15, 0x49, 0x11, 0x5b, 0x10,
    0x82, 0x09, 0x09, 0x0a, 0xa2, 0xff, 0xb7, 0x08, 0xf0, 0xfe, 0x50, 0x04,
    0x8d, 0x08, 0x58, 0x08, 0x11, 0xfb, 0x11, 0xf9, 0x97, 0xf5, 0x7e, 0xf0,
    0x76, 0xf6, 0xcb, 0xf4, 0xce, 0xf7, 0x11, 0xfa, 0xa7, 0xfc, 0x9b, 0xff,
    0x4b, 0xf1, 0x46, 0xf2, 0x22, 0xea, 0x33, 0xe6, 0x10, 0xee, 0x45, 0xed,
    0x7a, 0xf1, 0x84, 0xf2, 0x32, 0xf1, 0xc2, 0xf2, 0x44, 0xe8, 0x31, 0xec,
    0xfb, 0xfa, 0xbc, 0xfa, 0x41, 0x02, 0x23, 0x02, 0x1c, 0xfb, 0xa4, 0xfa,
    0x67, 0xfd, 0xdf, 0x02, 0x75, 0xf5, 0x19, 0xff, 0x28, 0xf7, 0xc6, 0xf4,
    0x5d, 0xff, 0x5b, 0xf8, 0xb6, 0x02, 0xa8, 0xfd, 0x2e, 0x02, 0xba, 0xfc,
    0x57, 0x03, 0xf2, 0x02, 0x1a, 0x0a, 0x79, 0x09, 0x1f, 0x12, 0xe8, 0x11,
    0xa1, 0x07, 0x13, 0x09, 0xce, 0xff, 0x7b, 0xfc, 0xab, 0x06, 0xbc, 0x02,
    0xfd, 0x15, 0xb4, 0x12, 0x8c, 0x12, 0x39, 0x13, 0x01, 0x07, 0xea, 0x09,
    0xb2, 0x0b, 0xd4, 0x0a, 0xa2, 0x0c, 0xb3, 0x07, 0x5e, 0x0b, 0x4a, 0x05,
    0x33, 0x15, 0xba, 0x12, 0xb8, 0x14, 0xdb, 0x16, 0xe8, 0x0a, 0xfe, 0x0d,
    0x21, 0x06, 0xea, 0x08, 0x77, 0xfe, 0x3b, 0x00, 0xc4, 0xfe, 0xea, 0x00,
    0xc1, 0xf7, 0x03, 0xfa, 0x01, 0xf4, 0x67, 0xf3, 0x65, 0xf7, 0xa2, 0xfa,
    0xcc, 0xf5, 0x67, 0xfe, 0xf9, 0xf4, 0x1a, 0xfb, 0x0d, 0xee, 0x81, 0xef,
    0x28, 0xe6, 0x07, 0xe5, 0x60, 0xea, 0x7d, 0xe9, 0x9b, 0xed, 0xcd, 0xee,
    0x6a, 0xf0, 0x4b, 0xf1, 0x02, 0xe6, 0xad, 0xe8, 0xdf, 0xf0, 0xbd, 0xf0,
    0x5d, 0xfe, 0xb9, 0xff, 0x03, 0xfa, 0xfa, 0xfa, 0xa2, 0x04, 0xcd, 0x02,
    0x57, 0xfe, 0x1b, 0x03, 0x74, 0xf3, 0xac, 0xf5, 0x06, 0xf7, 0x8e, 0xf3,
    0xc1, 0x04, 0x5f, 0xfe, 0x7b, 0x0b, 0x2a, 0x06, 0x81, 0x0b, 0xb7, 0x06,
    0x9f, 0x0b, 0xe6, 0x06, 0xbf, 0x13, 0x49, 0x11, 0x8b, 0x0e, 0xed, 0x0e,
    0x61, 0x04, 0x97, 0x04, 0x9e, 0x07, 0x73, 0x02, 0xb4, 0x14, 0x8e, 0x11,
    0x38, 0x17, 0x96, 0x17, 0x6e, 0x0d, 0xb6, 0x0b, 0xfd, 0x0b, 0x04, 0x0e,
    0x03, 0x0a, 0xb5, 0x0a, 0x8b, 0x07, 0x4d, 0x02, 0x4a, 0x15, 0xf4, 0x10,
    0x21, 0x1b, 0xd4, 0x1b, 0x19, 0x09, 0xd3, 0x0b, 0x8f, 0x00, 0xcc, 0x02,
    0xf2, 0xf9, 0xf3, 0xff, 0x35, 0xfe, 0x3c, 0x04, 0xe3, 0xf8, 0x17, 0xfc,
    0x19, 0xf0, 0x45, 0xee, 0x61, 0xf5, 0x10, 0xf6, 0xb0, 0xf4, 0x44, 0xfa,
    0x24, 0xf3, 0xad, 0xf6, 0x0c, 0xec, 0x0b, 0xf0, 0x03, 0xe3, 0x48, 0xe6,
    0xae, 0xec, 0x9a, 0xe8, 0x3e, 0xee, 0x2f, 0xea, 0x68, 0xea, 0x23, 0xeb,
    0x11, 0xe4, 0x0b, 0xe7, 0xf2, 0xed, 0x66, 0xee, 0x3d, 0x03, 0xd2, 0x00,
    0xa8, 0xfc, 0xff, 0xfb, 0xfb, 0x02, 0xd3, 0xfe, 0x3c, 0x02, 0x6c, 0x05,
    0x82, 0xf7, 0x38, 0xfd, 0xcb, 0xf8, 0xd7, 0xf4, 0x91, 0x03, 0x9e, 0xfb,
    0x7f, 0x0b, 0x2a, 0x05, 0x93, 0x0d, 0x63, 0x0a, 0x31, 0x0c, 0x14, 0x0a,
    0xce, 0x10, 0x8c, 0x11, 0x3d, 0x0d, 0x40, 0x12, 0x30, 0x07, 0x5c, 0x08,
    0x05, 0x0c, 0x87, 0x07, 0x00, 0x16, 0xd0, 0x12, 0x8f, 0x16, 0x97, 0x16,
    0xd9, 0x08, 0xfa, 0x0c, 0xbc, 0x0a, 0xd6, 0x10, 0x96, 0x0a, 0xb9, 0x0f,
    0xe2, 0x06, 0x16, 0x03, 0x36, 0x11, 0x0c, 0x0b, 0x71, 0x1c, 0x31, 0x1d,
    0x22, 0x0e, 0x0f, 0x10, 0x54, 0xff, 0xe7, 0x03, 0xce, 0xf7, 0x97, 0xff,
    0x9c, 0xfd, 0xfd, 0xff, 0x00, 0xff, 0xe9, 0xfb, 0x85, 0xf0, 0x49, 0xee,
    0xae, 0xee, 0xe5, 0xed, 0x1d, 0xf1, 0x49, 0xf1, 0x62, 0xf3, 0x22, 0xf5,
    0x7e, 0xf1, 0x90, 0xf2, 0x6e, 0xe4, 0xbc, 0xe4, 0xad, 0xe8, 0xe1, 0xe3,
    0x8c, 0xef, 0xed, 0xea, 0x47, 0xed, 0x11, 0xee, 0x3f, 0xe8, 0xd6, 0xe6,
    0x03, 0xe7, 0x0d, 0xe7, 0x20, 0x00, 0xc2, 0xff, 0x21, 0x01, 0x22, 0x00,
    0xf7, 0xfd, 0x23, 0xf9, 0x07, 0xff, 0x21, 0x00, 0xa6, 0xf8, 0xeb, 0x00,
    0x54, 0xfb, 0x6f, 0xfb, 0xe1, 0x05, 0x42, 0x01, 0x63, 0x0c, 0x10, 0x06,
    0x4d, 0x0c, 0x80, 0x09, 0x1e, 0x0c, 0x2e, 0x0c, 0x8e, 0x11, 0xcf, 0x12,
    0x72, 0x11, 0xc0, 0x14, 0x08, 0x08, 0x70, 0x0b, 0x4d, 0x0c, 0x4d, 0x0b,
    0xb9, 0x15, 0x6f, 0x14, 0x7c, 0x19, 0x65, 0x1b, 0x2c, 0x0b, 0x84, 0x0d,
    0x14, 0x08, 0xdb, 0x0b, 0xc4, 0x0d, 0xa1, 0x11, 0xe4, 0x08, 0x76, 0x06,
    0xfc, 0x09, 0xbe, 0x04, 0xff, 0x14, 0x25, 0x15, 0x27, 0x0e, 0x8c, 0x0f,
    0xa0, 0x04, 0xe8, 0x04, 0x06, 0xfc, 0x52, 0xfe, 0x3a, 0xf7, 0x07, 0xfb,
    0x7d, 0xfc, 0xa7, 0xfe, 0xe4, 0xf2, 0x57, 0xf3, 0x7d, 0xed, 0x65, 0xeb,
    0x66, 0xee, 0x63, 0xed, 0x18, 0xf2, 0xee, 0xf2, 0x7d, 0xf1, 0x69, 0xf4,
    0x03, 0xe6, 0xb0, 0xe8, 0x5f, 0xe7, 0xb8, 0xe3, 0x6a, 0xeb, 0xad, 0xe7,
    0x73, 0xec, 0x3f, 0xeb, 0x20, 0xec, 0x31, 0xec, 0xcc, 0xe4, 0xeb, 0xe6,
    0x7a, 0xfb, 0x7a, 0xfc, 0x4c, 0x02, 0x62, 0x04, 0x8b, 0xfe, 0x69, 0xfa,
    0x5e, 0x04, 0x45, 0x01, 0xd0, 0xfc, 0x52, 0x00, 0x02, 0xfd, 0xa9, 0xfa,
    0x10, 0x07, 0x13, 0x04, 0xd1, 0x0d, 0x38, 0x09, 0x17, 0x0e, 0x80, 0x0b,
    0x26, 0x0d, 0x37, 0x0b, 0x55, 0x11, 0xcc, 0x0d, 0x79, 0x17, 0x15, 0x18,
    0x60, 0x0c, 0x07, 0x11, 0xce, 0x07, 0xd0, 0x08, 0xa8, 0x10, 0xd2, 0x0b,
    0x86, 0x1b, 0x6f, 0x19, 0x55, 0x0f, 0x8f, 0x10, 0xf3, 0x04, 0xd7, 0x06,
    0xa3, 0x0b, 0x45, 0x0e, 0xc5, 0x08, 0x91, 0x0a, 0x96, 0x07, 0xda, 0x02,
    0xc8, 0x10, 0xd7, 0x0e, 0xf4, 0x0c, 0x64, 0x11, 0x6c, 0x02, 0x22, 0x07,
    0x18, 0xfd, 0x83, 0x02, 0xc7, 0xf8, 0xa2, 0xfa, 0x12, 0xfb, 0xbf, 0xfb,
    0x0a, 0xef, 0x96, 0xf1, 0x3d, 0xeb, 0xa0, 0xe9, 0x0c, 0xf0, 0x15, 0xf1,
    0x7c, 0xef, 0x33, 0xf4, 0xd4, 0xf1, 0x3b, 0xf6, 0xb3, 0xe7, 0xff, 0xed,
    0xaa, 0xe5, 0xbc, 0xe2, 0x84, 0xec, 0xb4, 0xe5, 0x32, 0xed, 0x37, 0xea,
    0x1f, 0xf1, 0xe5, 0xef, 0xa3, 0xe5, 0xfd, 0xe7, 0x0c, 0xf8, 0xfd, 0xf7,
    0x94, 0x08, 0x7e, 0x07, 0x93, 0xff, 0x87, 0xfc, 0x76, 0x06, 0x68, 0x03,
    0x0f, 0x02, 0x9e, 0x05, 0xc7, 0xfc, 0x6b, 0xfc, 0x41, 0x04, 0xd7, 0xff,
    0xd2, 0x0c, 0x71, 0x07, 0xd0, 0x0f, 0xbc, 0x0a, 0x74, 0x0d, 0x7f, 0x09,
    0x8c, 0x0d, 0x31, 0x0a, 0xaf, 0x17, 0xc4, 0x18, 0x81, 0x0f, 0x9e, 0x14,
    0x95, 0x05, 0x8c, 0x07, 0xf3, 0x09, 0x96, 0x06, 0x4d, 0x16, 0x53, 0x15,
    0xdc, 0x12, 0xb7, 0x13, 0xa3, 0x03, 0x79, 0x06, 0x63, 0x07, 0x81, 0x09,
    0x4b, 0x08, 0xcb, 0x08, 0x66, 0x05, 0xe6, 0x00, 0xe0, 0x11, 0x68, 0x0d,
    0x5a, 0x11, 0xe4, 0x15, 0xea, 0x01, 0x8c, 0x07, 0x69, 0xfe, 0xd0, 0x03,
    0x5b, 0xf8, 0x81, 0xfd, 0xa3, 0xfb, 0x7d, 0xfd, 0x65, 0xf4, 0xd5, 0xf5,
    0x1d, 0xeb, 0x27, 0xe9, 0xde, 0xf2, 0x3b, 0xf0, 0x80, 0xf2, 0xe1, 0xf5,
    0x67, 0xf4, 0xc0, 0xf7, 0x88, 0xeb, 0x4b, 0xef, 0x74, 0xe2, 0x46, 0xe2,
    0xbc, 0xec, 0xc0, 0xe7, 0xb7, 0xed, 0x7c, 0xea, 0x0b, 0xef, 0x99, 0xee,
    0x64, 0xe4, 0x06, 0xe7, 0xcf, 0xf0, 0xdc, 0xf0, 0x00, 0x0a, 0x69, 0x08,
    0x10, 0x02, 0x8b, 0xfe, 0xb7, 0x04, 0xc1, 0x00, 0xb8, 0x03, 0xe8, 0x06,
    0x49, 0xfa, 0x3a, 0xfd, 0x83, 0xfe, 0xa6, 0xfb, 0xff, 0x09, 0xec, 0x03,
    0x80, 0x0d, 0x4e, 0x09, 0x22, 0x0d, 0xd0, 0x0b, 0x50, 0x0c, 0xf7, 0x08,
    0xc2, 0x15, 0xe1, 0x13, 0x9c, 0x12, 0x71, 0x17, 0x6b, 0x06, 0x93, 0x0b,
    0xab, 0x08, 0xcd, 0x05, 0xa3, 0x14, 0x4a, 0x10, 0x01, 0x17, 0x6e, 0x15,
    0xde, 0x06, 0xda, 0x09, 0x41, 0x06, 0x2d, 0x0b, 0x1e, 0x0a, 0xe9, 0x0c,
    0xe6, 0x06, 0x09, 0x02, 0xbb, 0x12, 0x08, 0x0c, 0x64, 0x19, 0xc6, 0x1b,
    0xea, 0x06, 0xc6, 0x0b, 0xa6, 0xff, 0xdb, 0x03, 0xa9, 0xf9, 0x75, 0xfe,
    0x58, 0xf9, 0xf8, 0xfd, 0x82, 0xf8, 0x14, 0xfc, 0xab, 0xea, 0x7c, 0xe9,
    0xaa, 0xee, 0x36, 0xea, 0xe4, 0xf1, 0x6f, 0xf4, 0x7b, 0xf1, 0xbd, 0xf7,
    0x1f, 0xec, 0x7b, 0xf0, 0x5f, 0xe1, 0x41, 0xe0, 0xa6, 0xe7, 0x9a, 0xe1,
    0x85, 0xeb, 0xe0, 0xe7, 0x1c, 0xed, 0xd2, 0xeb, 0xee, 0xe3, 0xb6, 0xe5,
    0x37, 0xe8, 0x5c, 0xe9, 0xb1, 0x05, 0xdc, 0x05, 0x66, 0x03, 0x53, 0x01,
    0x00, 0x05, 0xee, 0xfd, 0x38, 0x06, 0x15, 0x06, 0xe1, 0xfb, 0xa7, 0xff
};


#ifdef __cplusplus
extern "C" {
#endif

osTimerDef(timer7, timerCallback); /*!< Define the attributes of the timer */
extern uint8_t LinkStatus;
extern uint8_t inMcastGroup;
//osMessageQDef(message_q, 1, uint16_t); // Declare a message queue
osMutexDef (mutexRingBufferRx);
osMutexDef (mutexBoard);
osMutexDef (mutexButtons);

// max address number of TLC59116F chips
extern uint8_t TLC59116F_max_address;
// TLC59116F chips addresses
const uint8_t TLC59116F_address[] = {0xC0,0xC2,0xC4,0xC6,0xC8,0xCA};
// TLC59116F chip button registers
const uint8_t TLC59116F_registerLED[] = {0x14,0x15,0x16,0x17};
// Регистры индивидуальной яркости каждого светодиода
const uint8_t TLC59116F_registerBright[] = {0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x10,0x11};
// TLC59116F chip setup registers values

// max address number of MCP23017 chips
extern uint8_t MCP23017_max_address;
extern bool telephoneButtons;
// MCP23017 chips addresses
const uint8_t MCP23017_address[] = {0x40,0x42,0x44,0x4E};
// MCP23017 chip LEDs registers
const uint8_t MCP23017_register[] = {0x12,0x13};
// MCP23017 chip setup registers values
const uint8_t MCP23017_Init_Val[] = {
            //  Reg    Data
                0x04 , 0xFF,	// GPINTENA
                0x05 , 0xFF,	// GPINTENB
                0x0A , 0x42,	// IOCON
                0x0C , 0xFF,	// GPPUA
                0x0D , 0xFF,	// GPPUB
             };

const uint8_t MCP23017_Init_PAD[] = {//Номеронабиратель SC2
            //  Reg    Data
                0x04 , 0xFF,	// GPINTENA
                0x05 , 0xFF,	// GPINTENB
                0x0A , 0x42,	// IOCON
                0x0C , 0xFF,	// GPPUA
                0x0D , 0xFF,	// GPPUB
             };

extern osSemaphoreId Netif_LinkSemaphore;
static osTimerId timerId7; /*!< The thread ID of the timer */
constexpr static uint8_t timerDelay = 50;

static GPIO_InitTypeDef GPIO_InitStruct;

void GPIOInit(void)
{

// timerCallback  каллбек
    timerId7 = osTimerCreate( osTimer(timer7), osTimerPeriodic, nullptr); // create timer thread
    if (timerId7)
    {
        osStatus status = osTimerStart (timerId7, timerDelay);   // start timer
        if (status != osOK)  {
            RS232::getInstance().term << "Failed to start [timer]" << "\n";
            while(1);
        }
    }

    HAL_GPIO_WritePin(TEST_LED_GPIO_Port, TEST_LED_Pin, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_6, GPIO_PIN_RESET); //Пин Норма
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); //Пин МК Вкл
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET); //Пин UPR1_SP - Включение усилителя

    if (boardType == sl1)
    {
        GPIO_InitTypeDef GPIO_InitStruct = {0};

        /*Configure GPIO pins : IN1 - IN4 */
        GPIO_InitStruct.Pin = GPIO_PIN_9;  //Пины 6 - 8 уже установлены как входы в самом начале
        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

        /*Configure GPIO pins : IN5 - IN8 */
        GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_11|GPIO_PIN_10|GPIO_PIN_9;
        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

        /*Configure GPIO pins : UPR1 - UPR8 */  //PG8 PG9 которые были входами и использовались для определения типа платы теперь выходы
        GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14;
        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
        HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);

        //Выходы - инверсные поэтому устанавливаем их (на SL1 - выходы в нуле)
        HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14, GPIO_PIN_SET);
    }
}

#ifdef __cplusplus
}
#endif

GPIO::GPIO()
{
    gpioInit = & GPIO_InitStruct;
    if (boardType == sc2)
        initLEDS_SC2();
    if (boardType == sl1)
        initLEDS_SL1();

    mutexRingBufferRx_id = osMutexCreate(osMutex(mutexRingBufferRx));
    mutexBoard_id = osMutexCreate(osMutex(mutexBoard));
    mutexButtons_id = osMutexCreate(osMutex(mutexButtons));
    if (mutexRingBufferRx_id == nullptr)
    {
        while(1)
            RS232::getInstance().term << "Failed to create [mutexRingBufferRx]" << "\n";
    }

//    message_q_id = osMessageCreate(osMessageQ(message_q), NULL);

    if (boardType == sc2)
    {
        initBUTTONS_SC2();
    }
    if (boardType == sl1)
    {
        initBUTTONS_SL1();
    }
//    if (boardType == sc4)
//    {
//    }
    i2cInitBoard();
    EXTI_IRQHandler_Config();
}

void GPIO::initBUTTONS_SL1()
{
    if (boardType == sl1)
    {
        buttonArray[0].i = 1;     buttonArray[0].n = GPIO_PIN_9;
        buttonArray[1].i = 2;     buttonArray[1].n = GPIO_PIN_8;
        buttonArray[2].i = 3;     buttonArray[2].n = GPIO_PIN_7;
        buttonArray[3].i = 4;     buttonArray[3].n = GPIO_PIN_6;
        buttonArray[4].i = 5;     buttonArray[4].n = GPIO_PIN_12;
        buttonArray[5].i = 6;     buttonArray[5].n = GPIO_PIN_11;
        buttonArray[6].i = 7;     buttonArray[6].n = GPIO_PIN_10;
        buttonArray[7].i = 8;     buttonArray[7].n = GPIO_PIN_9;
    }
}

GPIO *GPIO::getInstance()
{
    if (!p_instance) p_instance = new GPIO();
    return p_instance;
}

GPIO *GPIO::p_instance = nullptr;

struct Aic3254Configs ConfigureDAC_VOL[] {
    {TLV320AIC3254_REG_PAGE_SELECT, 0x01},
    {TLV320AIC3254_REG_CM_CR, 0x0B},
    {TLV320AIC3254_REG_LOL_SEL, 0x08},
    {TLV320AIC3254_REG_LOR_SEL, 0x08},
    {TLV320AIC3254_REG_OUTDRV_PWR_CR, 0x0C},
    {TLV320AIC3254_REG_LOL_GAIN, 0x0A},
    {TLV320AIC3254_REG_LOR_GAIN, 0x0A},
    // Select Page 0
    {TLV320AIC3254_REG_PAGE_SELECT, 0x00},
    // DAC => 0dB
    {TLV320AIC3254_REG_LDAC_DVOL_CR, 0xC8},   // ГРОМКОСТЬ -28dB
    {TLV320AIC3254_REG_RDAC_DVOL_CR, 0xC0},   // ГРОМКОСТЬ -32dB
    // Powerup LDAC/RDAC
    {TLV320AIC3254_REG_DAC_SETUP1, 0xd4},
    // UnmuteLDAC/RDAC
    {TLV320AIC3254_REG_DAC_SETUP2, 0x00},
};

constexpr static uint32_t I2C_ADDRESS = 49;
void GPIO::upVolume(void)
{
    ConfigureDAC_VOL[8].regVal = GPIO::getInstance()->dacDriverGainValue;

    for (uint32_t i = 0; i < sizeof(ConfigureDAC_VOL) / sizeof(struct Aic3254Configs); i++)
    {
        osMutexWait(GPIO::getInstance()->mutexButtons_id, osWaitForever);
        I2C::getInstance()->writeRegister(I2C_ADDRESS, ConfigureDAC_VOL[i].regOffset, ConfigureDAC_VOL[i].regVal, true);
        osMutexRelease(GPIO::getInstance()->mutexButtons_id);

        HAL_SAI_Transmit_IT(&audioTxSai, ring_raw, ring_length/2);
    }

}
void GPIO::downVolume(void)
{
    ConfigureDAC_VOL[8].regVal = GPIO::getInstance()->dacDriverGainValue;

    for (uint32_t i = 0; i < sizeof(ConfigureDAC_VOL) / sizeof(struct Aic3254Configs); i++)
    {
        osMutexWait(GPIO::getInstance()->mutexButtons_id, osWaitForever);
        I2C::getInstance()->writeRegister(I2C_ADDRESS, ConfigureDAC_VOL[i].regOffset, ConfigureDAC_VOL[i].regVal, true);
        osMutexRelease(GPIO::getInstance()->mutexButtons_id);
        HAL_SAI_Transmit_IT(&audioTxSai, ring_raw, ring_length/2);

    }

}
void GPIO::upSens(void)
{
    I2C::getInstance()->writeRegister(TLV320AIC3254::I2C_ADDRESS, 0x00, 0x00, true);
    I2C::getInstance()->writeRegister(TLV320AIC3254::I2C_ADDRESS, 0x53, GPIO::getInstance()->dacDriverSensValue, true);

    HAL_SAI_Transmit_IT(&audioTxSai, ring_raw, ring_length/2);
}
void GPIO::downSens(void)
{
    I2C::getInstance()->writeRegister(TLV320AIC3254::I2C_ADDRESS, 0x00, 0x00, true);
    I2C::getInstance()->writeRegister(TLV320AIC3254::I2C_ADDRESS, 0x53, GPIO::getInstance()->dacDriverSensValue, true);

    HAL_SAI_Transmit_IT(&audioTxSai, ring_raw, ring_length/2);
}
void GPIO::signalMaxMin(void)
{
    term2("signalMaxMin")
    HAL_SAI_Transmit_IT(&audioTxSai, ring_raw, ring_length);
    HAL_SAI_Transmit_IT(&audioTxSai, ring_raw, ring_length);
}

void GPIO::test(void)
{

}

void GPIO::configLed(uint8_t ledNumber, bool ledOn, uint32_t timeOn, uint32_t timeOff, uint8_t repeatNum, Color color)
{
     --ledNumber;
    aLeds[ledNumber].colour = color;
    if (timeOn < 50 && timeOff < 50)
    {
        aLeds[ledNumber].ledState = ledOn;
        aLeds[ledNumber].timeStart = false;
        aLeds[ledNumber].timeOn = timeOn;
        aLeds[ledNumber].timeOff = timeOff;
    } else
    {
        aLeds[ledNumber].timeOn = timeOn;
        aLeds[ledNumber].timeOff = timeOff;
        aLeds[ledNumber].timeStart = ledOn;
        aLeds[ledNumber].ledState = ledOn;
        if (repeatNum > 0)
            aLeds[ledNumber].reiterationNum = repeatNum * 2;
    }
}

#ifdef __cplusplus
extern "C" {
#endif

void timerCallback(void const *arg)
{
    (void)arg;
    for (uint8_t i = 0; i < keysNum; i++)
    {
        if (GPIO::getInstance()->aLeds[i].timeStart)
        {
            GPIO::getInstance()->aLeds[i].count += 1;
            if(GPIO::getInstance()->aLeds[i].ledState == false && GPIO::getInstance()->aLeds[i].count >= GPIO::getInstance()->aLeds[i].timeOff/timerDelay)
            {
                GPIO::getInstance()->aLeds[i].ledState = true;
                GPIO::getInstance()->aLeds[i].count = 0;
                if (GPIO::getInstance()->aLeds[i].reiterationNum > 0)
                    GPIO::getInstance()->aLeds[i].reiterationNum -= 1;
                if (GPIO::getInstance()->aLeds[i].reiterationNum == 0) {
                    GPIO::getInstance()->aLeds[i].timeStart = false;
                    GPIO::getInstance()->aLeds[i].reiterationNum -= 1;
                }
            } else if (GPIO::getInstance()->aLeds[i].ledState == true && GPIO::getInstance()->aLeds[i].count >= GPIO::getInstance()->aLeds[i].timeOn/timerDelay)
            {
                GPIO::getInstance()->aLeds[i].ledState = false;
                GPIO::getInstance()->aLeds[i].count = 0;
                if (GPIO::getInstance()->aLeds[i].reiterationNum > 0)
                    GPIO::getInstance()->aLeds[i].reiterationNum -= 1;
                if (GPIO::getInstance()->aLeds[i].reiterationNum == 0) {
                    GPIO::getInstance()->aLeds[i].timeStart = false;
                    GPIO::getInstance()->aLeds[i].reiterationNum -= 1;
                }
            }
        }
    }
}


[[ noreturn ]]
void switchLEDsThread(void const *arg)
{
    osDelay(4000);
    if (boardType == sc2)
    {
        (void)arg;
        osDelay(200);
        term("--- switchLEDsThread_SC2 ---")
        while(true)
        {
            if(pinNormaState != pinNormaBlink)
            {
                for(uint8_t i = 0; i < 6; ++i)
                {
                    if (GPIO::getInstance()->aLeds[i].ledState) // Включаем пин
                    {
                        if(i == 0) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
                        if(i == 1) HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10, GPIO_PIN_SET);
                        if(i == 2) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
                        if(i == 3) HAL_GPIO_WritePin(GPIOC, GPIO_PIN_11, GPIO_PIN_SET);
                        if(i == 4) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_8, GPIO_PIN_SET);
                        if(i == 5) HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_SET);
                    } else
                    {
                        if(i == 0) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);
                        if(i == 1) HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10, GPIO_PIN_RESET);
                        if(i == 2) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_RESET);
                        if(i == 3) HAL_GPIO_WritePin(GPIOC, GPIO_PIN_11, GPIO_PIN_RESET);
                        if(i == 4) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_8, GPIO_PIN_RESET);
                        if(i == 5) HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_RESET);
                    }
                }
            }
            osDelay(1);
        }
    }
    if (boardType == sc4)
    {
        (void)arg;
        GPIO::getInstance()->initLEDS_SC4();
        GPIO::getInstance()->testLed();

        while(true)
        {
            uint8_t adr, reg, numON, numOFF;
            for(uint8_t i = 0; i < TLC59116F_max_address * 8; ++i)
            {
                if (GPIO::getInstance()->aLeds[i].ledState)
                {// Включаем пин
                    if (GPIO::getInstance()->aLeds[i].colour == GPIO::getInstance()->GREEN)
                    {
                        std::tie (adr, reg, numON, numOFF)  = GPIO::getInstance()->fromIndexToReg(i, GPIO::getInstance()->GREEN);
                    }
                    else
                    {
                        std::tie (adr, reg, numON, numOFF)  = GPIO::getInstance()->fromIndexToReg(i, GPIO::getInstance()->RED);
                    }
                    I2C::getInstance()->writeRegister(adr, reg, numON, false);
                } else
                {// Гасим пин
                    std::tie (adr, reg, numON, numOFF)  = GPIO::getInstance()->fromIndexToReg(i, GPIO::getInstance()->RED); //Тут может быть и GREEN
                    I2C::getInstance()->writeRegister(adr, reg, numOFF, false);
                }
            }
            if (pinNormaState != pinNormaBlink)
            {
                if ((LinkStatus == 1) && (inMcastGroup == 1))
                {
                    pinNormaState = pinNormaSet;
//                    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_6, GPIO_PIN_SET); //Пин Норма
                }
                else
                {
                    pinNormaState = pinNormaReset;
//                    HAL_GPIO_WritePin(GPIOD, GPIO_PIN_6, GPIO_PIN_RESET);
                }
            }
            osDelay(1);
        }
    }
    if (boardType == sl1)
    {
        (void)arg;
        while(true)
        {
            for(uint8_t i = 0; i < 8; ++i)
            {
                if (GPIO::getInstance()->aLeds[i].ledState) // Включаем пин
                {//Выходы - Перепутан порядок нумерации
                    if(i == 7) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_RESET);
                    if(i == 6) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_8, GPIO_PIN_RESET);
                    if(i == 5) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_9, GPIO_PIN_RESET);
                    if(i == 4) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_RESET);
                    if(i == 3) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_11, GPIO_PIN_RESET);
                    if(i == 2) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_12, GPIO_PIN_RESET);
                    if(i == 1) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_RESET);
                    if(i == 0) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_14, GPIO_PIN_RESET);
                } else
                {
                    if(i == 7) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
                    if(i == 6) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_8, GPIO_PIN_SET);
                    if(i == 5) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_9, GPIO_PIN_SET);
                    if(i == 4) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
                    if(i == 3) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_11, GPIO_PIN_SET);
                    if(i == 2) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_12, GPIO_PIN_SET);
                    if(i == 1) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_SET);
                    if(i == 0) HAL_GPIO_WritePin(GPIOG, GPIO_PIN_14, GPIO_PIN_SET);
                }
                if (pinNormaState != pinNormaBlink)
                {

                    if ((LinkStatus == 1) && (inMcastGroup == 1))
                    {
                        pinNormaState = pinNormaSet;
//                        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_6, GPIO_PIN_SET); //Пин Норма
                    }
                    else
                    {
                        pinNormaState = pinNormaReset;
//                        HAL_GPIO_WritePin(GPIOD, GPIO_PIN_6, GPIO_PIN_RESET);
                    }
                }
            }
            osDelay(1);
        }
    }
}


[[ noreturn ]]
void readButtonThread(void const *arg)
{
    osDelay(4000);
    if (boardType == sl1)
    {
        (void)arg;
        PackageRx tempPack;
        uint8_t readPAD = 0, temp = 0;
        tempPack.packetType = GPIO::getInstance()->button;
        GPIO::getInstance()->initPAD();


        while(true)
        {
            //Сканируем входы
            for (uint8_t i = 0; i < 4 ; ++i)
            {
                uint16_t n = GPIO::getInstance()->buttonArray[i].n;
                if (HAL_GPIO_ReadPin(GPIOC, GPIO::getInstance()->buttonArray[i].n) == GPIO_PIN_RESET)
                {
                    osDelay(50);
                    if (HAL_GPIO_ReadPin(GPIOC, GPIO::getInstance()->buttonArray[i].n)  == GPIO_PIN_RESET)
                    {
                        n = GPIO::getInstance()->buttonArray[i].i;
                        tempPack.payloadData = n;
                        osMutexWait(GPIO::getInstance()->mutexRingBufferRx_id, osWaitForever);
                        GPIO::getInstance()->ringBufferRx.push(tempPack);
                        osMutexRelease(GPIO::getInstance()->mutexRingBufferRx_id);
                    }
                }
            }
            for (uint8_t i = 4; i < 8 ; ++i)
            {
                uint16_t n = GPIO::getInstance()->buttonArray[i].n;
                   if (HAL_GPIO_ReadPin(GPIOA, GPIO::getInstance()->buttonArray[i].n) == GPIO_PIN_RESET)
                {
                    osDelay(50);
                    if (HAL_GPIO_ReadPin(GPIOA, GPIO::getInstance()->buttonArray[i].n)  == GPIO_PIN_RESET)
                    {
                        n = GPIO::getInstance()->buttonArray[i].i;
                        tempPack.payloadData = n;
                        osMutexWait(GPIO::getInstance()->mutexRingBufferRx_id, osWaitForever);
                        GPIO::getInstance()->ringBufferRx.push(tempPack);
                        osMutexRelease(GPIO::getInstance()->mutexRingBufferRx_id);
                    }
                }
            }
            osDelay(1);
        }
    }
    if (boardType == sc2)
    {
        (void)arg;
        PackageRx tempPack;
        uint8_t readPAD = 0, temp = 0;
        tempPack.packetType = GPIO::getInstance()->button;
        GPIO::getInstance()->initPAD();
        osDelay(4000);

        while(true)
        {
            //Сканируем рычаги
            for (uint8_t i = 0; i < 6 ; ++i)
            {
                uint16_t n = GPIO::getInstance()->buttonArray[i].n;
                if (HAL_GPIO_ReadPin(GPIOG, GPIO::getInstance()->buttonArray[i].n) == GPIO_PIN_SET)
                {
                    osDelay(50);
                    if (HAL_GPIO_ReadPin(GPIOG, GPIO::getInstance()->buttonArray[i].n)  == GPIO_PIN_SET)
                    {
                        n = GPIO::getInstance()->buttonArray[i].i;
                        tempPack.payloadData = n;

                        osMutexWait(GPIO::getInstance()->mutexRingBufferRx_id, osWaitForever);
                        GPIO::getInstance()->ringBufferRx.push(tempPack);
                        osMutexRelease(GPIO::getInstance()->mutexRingBufferRx_id);
                    }
                }
            }
#ifdef enablePAD
            //Сканируем PAD
            uint8_t j;
            for (j = 0; j < 2; ++j)
            {
                readPAD = I2C::getInstance()->readRegister(0x40, MCP23017_register[j], false);
                if (readPAD != 255)
                {
                    term2(readPAD)
                    osDelay(100);
                }

            }
#endif

            osDelay(1);
        }
    }
    if (boardType == sc4)
    {
        (void)arg;
        PackageRx tempPack;
        tempPack.packetType = GPIO::getInstance()->button;
        GPIO::getInstance()->initBUTTONS_SC4();
        uint8_t readBoard = 0;
        uint8_t numButton = 0;
        uint32_t tickstart = HAL_GetTick();
        bool keySendingFlag = false;

        while(true)
        {
            //Повторное нажатие воспринимается
            if (HAL_GetTick() - 50 > tickstart)
            {
                keySendingFlag = false;
                numButton = 0;
            }

            for (uint8_t i = 0; i < MCP23017_max_address; ++i)
            {
                for (uint8_t j = 0; j < 2; ++j)
                {
                    readBoard = I2C::getInstance()->readRegister(MCP23017_address[i], MCP23017_register[j], false);
                    if (readBoard != 255)
                    {
                        numButton = GPIO::getInstance()->findBUTTONS_SC4(readBoard, i, j);
                    }
                }
            }//Просканировали основные клавиши

            if (telephoneButtons && readBoard == 255)
            {
                for (uint8_t j = 0; j < 2; ++j)
                {
                    readBoard = I2C::getInstance()->readRegister(0x4E, MCP23017_register[j], false);
                    if (readBoard != 255)
                    {
                        numButton = GPIO::getInstance()->findTelephoneBUTTONS(readBoard, j);

                    }
                }
            }//Просканировали клавиши номеронабирателя


//            for (uint8_t i = 0; i < TLC59116F_max_address * 8 ; ++i)
//            {
//                if ((numButton-1) == GPIO::getInstance()->buttonArray[i].i) //Похоже здесь buttonArray не нужен
//                {

                    if ((!keySendingFlag) && (numButton != 0))
                    {
                    //Передача кнопки в основной код
                        tempPack.payloadData = numButton;
                    osMutexWait(GPIO::getInstance()->mutexRingBufferRx_id, osWaitForever);
                        GPIO::getInstance()->ringBufferRx.push(tempPack);
                    osMutexRelease(GPIO::getInstance()->mutexRingBufferRx_id);
                        tickstart = HAL_GetTick();
                        keySendingFlag = true;

                    }

//                }
//                else
//                {
//                    GPIO::getInstance()->buttonArray[i].n = 0;
//                }

//            }

            if(volDownPressed)
            {
                GPIO::getInstance()->downVolume();
                volDownPressed = false;
            }
            if(volUpPressed)
            {
                GPIO::getInstance()->upVolume();
                volUpPressed = false;
            }
            if(sensDownPressed)
            {
                GPIO::getInstance()->downSens();
                sensDownPressed = false;
            }
            if(sensUpPressed)
            {
                GPIO::getInstance()->upSens();
                sensUpPressed = false;
            }
            if(signalMaxMin)
            {
                GPIO::getInstance()->signalMaxMin();
                signalMaxMin = false;
            }

             osDelay(50); //Возможно нужно убрать

            osDelay(1);
        }
    }
}


#ifdef __cplusplus
}
#endif

void GPIO::initLEDS_SC2()
{
    if (boardType == sc2)
    {
        aLeds[0].ledPin = GPIO_PIN_6;
        aLeds[1].ledPin = GPIO_PIN_10;
        aLeds[2].ledPin = GPIO_PIN_7;
        aLeds[3].ledPin = GPIO_PIN_11;
        aLeds[4].ledPin = GPIO_PIN_8;
        aLeds[5].ledPin = GPIO_PIN_12;
    }
}

void GPIO::initLEDS_SL1()
{
    if (boardType == sl1)
    {
        aLeds[0].ledPin = GPIO_PIN_7;
        aLeds[1].ledPin = GPIO_PIN_8;
        aLeds[2].ledPin = GPIO_PIN_9;
        aLeds[3].ledPin = GPIO_PIN_10;
        aLeds[4].ledPin = GPIO_PIN_11;
        aLeds[5].ledPin = GPIO_PIN_12;
        aLeds[6].ledPin = GPIO_PIN_13;
        aLeds[7].ledPin = GPIO_PIN_14;
    }
}

void GPIO::initBUTTONS_SC2()
{
    if (boardType == sc2)
    {
//#ifndef enablePAD
        buttonArray[0].i = 1;     buttonArray[0].n = GPIO_PIN_11;
        buttonArray[1].i = 2;     buttonArray[1].n = GPIO_PIN_12;
//#endif
        buttonArray[2].i = 3;     buttonArray[2].n = GPIO_PIN_10;
        buttonArray[3].i = 4;     buttonArray[3].n = GPIO_PIN_13;
        buttonArray[4].i = 5;     buttonArray[4].n = GPIO_PIN_9;
        buttonArray[5].i = 6;     buttonArray[5].n = GPIO_PIN_14;
    }
}


#ifdef __cplusplus
extern "C" {
#endif
    auto timeVolPlus = HAL_GetTick();
    void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
    {

        if (GPIO_Pin == GPIO_PIN_5)
        {
            if (HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_5))
            {
                RS232Puts("Release TEST button\r\n");
            }
            else
            {
                RS232Puts("Pressed TEST button\r\n");
            }
        }
        else if (GPIO_Pin == GPIO_PIN_9)
        {
            if (!HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_9) && (timeVolPlus + 300 < HAL_GetTick()))
            {
                RS232Puts("Pressed VOL+ button\r\n");
                if (GPIO::getInstance()->dacDriverGainValue < GPIO::getInstance()->dacDriverGainValueMax)
                {
                    GPIO::getInstance()->dacDriverGainValue = GPIO::getInstance()->dacDriverGainValue + GPIO::getInstance()->dacDriverGainValueStep;
                    volUpPressed = true;
                    timeVolPlus = HAL_GetTick();
                }
                else
                {
                    signalMaxMin = true;
                }

                term2(GPIO::getInstance()->dacDriverGainValue / 2)
            }
        }
        else if (GPIO_Pin == GPIO_PIN_10)
        {
            if (!HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_10))
            {
                RS232Puts("Pressed VOL- button\r\n");
                if (GPIO::getInstance()->dacDriverGainValue > GPIO::getInstance()->dacDriverGainValueMin)
                {
                    GPIO::getInstance()->dacDriverGainValue = GPIO::getInstance()->dacDriverGainValue - GPIO::getInstance()->dacDriverGainValueStep;
                    volDownPressed = true;
                }
                else
                {
                    signalMaxMin = true;
                }

                term2(GPIO::getInstance()->dacDriverGainValue / 2 )
            }
        }
        else if (GPIO_Pin == GPIO_PIN_11)
        {
            RS232Puts("Pressed SENS+ button\r\n");
            if (GPIO::getInstance()->dacDriverSensValue < GPIO::getInstance()->dacDriverSensValueMax)
            {
                GPIO::getInstance()->dacDriverSensValue = GPIO::getInstance()->dacDriverSensValue + GPIO::getInstance()->dacDriverSensValueStep;
                sensUpPressed = true;
            }
            else
            {
                signalMaxMin = true;
            }
                term2(GPIO::getInstance()->dacDriverSensValue / 2 )
        }
        else if (GPIO_Pin == GPIO_PIN_12)
        {
            RS232Puts("Pressed SENS- button\r\n");
            if (GPIO::getInstance()->dacDriverSensValue > GPIO::getInstance()->dacDriverSensValueMin)
            {
                GPIO::getInstance()->dacDriverSensValue = GPIO::getInstance()->dacDriverSensValue - GPIO::getInstance()->dacDriverSensValueStep;
                sensDownPressed = true;
            }
            else
            {
                signalMaxMin = true;
            }
                term2(GPIO::getInstance()->dacDriverSensValue / 2)
        }
    }

void EXTI2_IRQHandler(void)
{
RS232Puts("--- EXTI2_IRQHandler ---\r\n");
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2);
}

void EXTI4_IRQHandler(void)
{
    term("Interrupt UI board")
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);
}

void EXTI9_5_IRQHandler()
{
    if (boardType == sc2)
        HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8);
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_5);
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_9);
}

void EXTI15_10_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_10);
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_11);
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
}

void GPIO::EXTI_IRQHandler_Config()
{
    GPIO_InitTypeDef   GPIO_InitStructure;

    //button TEST interrupt pin setup
    GPIO_InitStructure.Mode = GPIO_MODE_IT_RISING_FALLING;
    GPIO_InitStructure.Pull = GPIO_PULLUP;
    GPIO_InitStructure.Pin = TEST_BUT_Pin;
    HAL_GPIO_Init(TEST_BUT_GPIO_Port, &GPIO_InitStructure);

    if (boardType == sc4)
    {
        //button UI board interrupt pin setup
        GPIO_InitStructure.Mode = GPIO_MODE_IT_RISING;
        GPIO_InitStructure.Pull = GPIO_PULLUP;
        GPIO_InitStructure.Pin = GPIO_PIN_4;
        HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);

        // Configure GPIO for volume and sens buttons ######################*/
        GPIO_InitStructure.Pin       = GPIO_PIN_9| GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
        GPIO_InitStructure.Mode      = GPIO_MODE_IT_FALLING;
        GPIO_InitStructure.Pull      = GPIO_PULLUP;
        HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);

        HAL_NVIC_SetPriority(EXTI15_10_IRQn, 5, 0);
        HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
    }

    if (boardType == sc2)
    {
        //button UI board interrupt pin setup
        GPIO_InitStructure.Mode = GPIO_MODE_IT_RISING;
        GPIO_InitStructure.Pull = GPIO_PULLUP;
        GPIO_InitStructure.Pin = GPIO_PIN_8;
        HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
    }


    HAL_NVIC_SetPriority(EXTI9_5_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
}

#ifdef __cplusplus
}
#endif

std::tuple<u_int8_t, u_int8_t, u_int8_t, u_int8_t> GPIO::fromIndexToReg(u_int8_t i, GPIO::Color color)
{
    uint8_t reg = 0;
    uint8_t regON = 0;
    uint8_t regOFF = 0;

    switch (i)
    { //Возвращаем адрес микросхемы  номер регистра значение для установки и для сброса
        case 0: //Пишем в младшие 4 бита
            reg = I2C::getInstance()->readRegister(TLC59116F_address[0], TLC59116F_registerLED[0], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[0], TLC59116F_registerLED[0], regON, regOFF );
        case 1: //Пишем в старшие 4 бита
            reg = I2C::getInstance()->readRegister(TLC59116F_address[0], TLC59116F_registerLED[0], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[0], TLC59116F_registerLED[0], regON, regOFF );
        case 2:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[0], TLC59116F_registerLED[1], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[0], TLC59116F_registerLED[1], regON, regOFF );
        case 3:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[0], TLC59116F_registerLED[1], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[0], TLC59116F_registerLED[1], regON, regOFF );
        case 4:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[0], TLC59116F_registerLED[2], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[0], TLC59116F_registerLED[2], regON, regOFF );
        case 5:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[0], TLC59116F_registerLED[2], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[0], TLC59116F_registerLED[2], regON, regOFF );
        case 6:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[0], TLC59116F_registerLED[3], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[0], TLC59116F_registerLED[3], regON, regOFF );
        case 7:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[0], TLC59116F_registerLED[3], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[0], TLC59116F_registerLED[3], regON, regOFF );

        case 8: //Пишем в младшие 4 бита
            reg = I2C::getInstance()->readRegister(TLC59116F_address[1], TLC59116F_registerLED[0], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[1], TLC59116F_registerLED[0], regON, regOFF );
        case 9: //Пишем в старшие 4 бита
            reg = I2C::getInstance()->readRegister(TLC59116F_address[1], TLC59116F_registerLED[0], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[1], TLC59116F_registerLED[0], regON, regOFF );
        case 10:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[1], TLC59116F_registerLED[1], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[1], TLC59116F_registerLED[1], regON, regOFF );
        case 11:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[1], TLC59116F_registerLED[1], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[1], TLC59116F_registerLED[1], regON, regOFF );
        case 12:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[1], TLC59116F_registerLED[2], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[1], TLC59116F_registerLED[2], regON, regOFF );
        case 13:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[1], TLC59116F_registerLED[2], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[1], TLC59116F_registerLED[2], regON, regOFF );
        case 14:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[1], TLC59116F_registerLED[3], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[1], TLC59116F_registerLED[3], regON, regOFF );
        case 15:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[1], TLC59116F_registerLED[3], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[1], TLC59116F_registerLED[3], regON, regOFF );

        case 16: //Пишем в младшие 4 бита
            reg = I2C::getInstance()->readRegister(TLC59116F_address[2], TLC59116F_registerLED[0], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[2], TLC59116F_registerLED[0], regON, regOFF );
        case 17: //Пишем в старшие 4 бита
            reg = I2C::getInstance()->readRegister(TLC59116F_address[2], TLC59116F_registerLED[0], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[2], TLC59116F_registerLED[0], regON, regOFF );
        case 18:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[2], TLC59116F_registerLED[1], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[2], TLC59116F_registerLED[1], regON, regOFF );
        case 19:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[2], TLC59116F_registerLED[1], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[2], TLC59116F_registerLED[1], regON, regOFF );
        case 20:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[2], TLC59116F_registerLED[2], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[2], TLC59116F_registerLED[2], regON, regOFF );
        case 21:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[2], TLC59116F_registerLED[2], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[2], TLC59116F_registerLED[2], regON, regOFF );
        case 22:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[2], TLC59116F_registerLED[3], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[2], TLC59116F_registerLED[3], regON, regOFF );
        case 23:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[2], TLC59116F_registerLED[3], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[2], TLC59116F_registerLED[3], regON, regOFF );

        case 24: //Пишем в младшие 4 бита
            reg = I2C::getInstance()->readRegister(TLC59116F_address[3], TLC59116F_registerLED[0], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[3], TLC59116F_registerLED[0], regON, regOFF );
        case 25: //Пишем в старшие 4 бита
            reg = I2C::getInstance()->readRegister(TLC59116F_address[3], TLC59116F_registerLED[0], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[3], TLC59116F_registerLED[0], regON, regOFF );
        case 26:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[3], TLC59116F_registerLED[1], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[3], TLC59116F_registerLED[1], regON, regOFF );
        case 27:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[3], TLC59116F_registerLED[1], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[3], TLC59116F_registerLED[1], regON, regOFF );
        case 28:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[3], TLC59116F_registerLED[2], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[3], TLC59116F_registerLED[2], regON, regOFF );
        case 29:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[3], TLC59116F_registerLED[2], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[3], TLC59116F_registerLED[2], regON, regOFF );
        case 30:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[3], TLC59116F_registerLED[3], false); regOFF = reg & 0xF0; regON = reg & 0xF0; color == GPIO::GREEN ? regON |=0x08 : regON  |=0x01;
            return std::make_tuple(TLC59116F_address[3], TLC59116F_registerLED[3], regON, regOFF );
        case 31:
            reg = I2C::getInstance()->readRegister(TLC59116F_address[3], TLC59116F_registerLED[3], false); regOFF = reg & 0x0F; regON = reg & 0x0F; color == GPIO::GREEN ? regON |=0x80 : regON  |=0x10;
            return std::make_tuple(TLC59116F_address[3], TLC59116F_registerLED[3], regON, regOFF );
        }

}

void GPIO::testLed()
{
    uint8_t testBlink = 0;
    uint8_t testRun = 0;

    while(testBlink < 2)
    {//Тестовое попеременное моргание
        for (uint8_t i = 0; i < TLC59116F_max_address; i++)
        {
            for (uint8_t j = 0; j < 4; j++)
            { // красный

            I2C::getInstance()->writeRegister(TLC59116F_address[i], TLC59116F_registerLED[j], 0x11, false);
            //                               4 столбца LED (для 32)  4 регистра по 2*2 светодиода
            }
        }
        osDelay(150);
        for (uint8_t i = 0; i < TLC59116F_max_address; i++)
        {
            for (uint8_t j = 0; j < 4; j++)
            { // зеленый  TLC59116F_registerBright

            I2C::getInstance()->writeRegister(TLC59116F_address[i], TLC59116F_registerLED[j], 0x88, false);
            }
        }
        osDelay(150);
        ++testBlink;
    }//end тестовое моргание


    while(testRun < 1)
    { //Бегущий огонек
        uint8_t adr, reg, numON, numOFF;
        for (uint8_t i = 0; i < TLC59116F_max_address * 8; i++)
        {
           std::tie (adr, reg, numON, numOFF)  = GPIO::getInstance()->fromIndexToReg(i, GPIO::getInstance()->RED);
           I2C::getInstance()->writeRegister(adr, reg, numON, false);
           osDelay(30);
        }
        for (uint8_t i = 0; i < TLC59116F_max_address * 8; i++)
        {
           std::tie (adr, reg, numON, numOFF)  = GPIO::getInstance()->fromIndexToReg(i, GPIO::getInstance()->GREEN);
           I2C::getInstance()->writeRegister(adr, reg, numON, false);
           osDelay(30);
        }
        ++testRun;
    }//End Бегущий огонек

    //Гасим все
    for (uint8_t i = 0; i < TLC59116F_max_address; i++)
    {
        for (uint8_t j = 0; j < 4; j++)
        {
            I2C::getInstance()->writeRegister(TLC59116F_address[i], TLC59116F_registerLED[j], 0x00, false);
        }
    }
}

void GPIO::initLEDS_SC4()
{
    if (boardType == sc4)
    {
        for (uint8_t i = 0; i < TLC59116F_max_address; i++)
        {
            I2C::getInstance()->writeRegister(TLC59116F_address[i], 0x00, 0x00, false);
        }

        //Яркость
        for (uint8_t i = 0; i < TLC59116F_max_address; i++)
        {
           // зеленый  TLC59116F_registerBright
             for (uint8_t j = 0; j < 16; j++)
             {//Индивидуальная яркость
                 I2C::getInstance()->writeRegister(TLC59116F_address[i], TLC59116F_registerBright[j], 0x30, false);
             }
        }
    }
}

void GPIO::initBUTTONS_SC4()
{
    if (boardType == sc4)
    {
        for (uint8_t i = 0; i < MCP23017_max_address * 16; ++i)
        {
            buttonArray[i].i = i;
            buttonArray[i].n = 0;
        }

        for (uint8_t i = 0; i < MCP23017_max_address; ++i)
        {
            for (uint8_t j = 0; j < sizeof(MCP23017_Init_Val); j += 2)
            {
                I2C::getInstance()->writeRegister(MCP23017_address[i], MCP23017_Init_Val[j] , MCP23017_Init_Val[j+1], false);
            }
        }

        //Инициализация регистров телефонного номера
        if (telephoneButtons)
        {
            for (uint8_t j = 0; j < sizeof(MCP23017_Init_Val); j += 2)
            {
                I2C::getInstance()->writeRegister(0x4E, MCP23017_Init_Val[j] , MCP23017_Init_Val[j+1], false);
            }
        }
    }
}

void GPIO::initPAD()
{
#ifdef enablePAD
    if (boardType == sc2)
    {
        for (uint8_t j = 0; j < sizeof(MCP23017_Init_PAD); j += 2)
        {
            I2C::getInstance()->writeRegister(0x40, MCP23017_Init_PAD[j] , MCP23017_Init_PAD[j+1], false);
        }
    }
    term2("initPAD OK")
#endif
}

uint8_t GPIO::findTelephoneBUTTONS(uint8_t num, uint8_t reg)
{
    uint8_t ret = 0;
    if (boardType == sc4)
    {
        switch (num)
        {
            case 254: reg == 0? ret = 51:ret = 59;  break; //1  //9
            case 253: reg == 0? ret = 52:ret = 61; break; //2  //*
            case 251: reg == 0? ret = 53:ret = 60;  break; //3  //0
            case 247: reg == 0? ret = 54:ret = 62; break; //4  //#
            case 239: ret = 55; break; //5
            case 223: ret = 56; break; //6
            case 191: ret = 57; break; //7
            case 127: ret = 58; break; //8
            default: ret = 1; break;
        }
    }
    return ret;
}

uint8_t GPIO::findBUTTONS_SC4(uint8_t num, uint8_t adr, uint8_t reg)
{
    uint8_t ret = 0;
    if (boardType == sc4)
    {
        switch (num)
        {
            case 254: if(adr == 0) reg == 0? ret = 1:ret = 9;
                      if(adr == 1) reg == 0? ret = 17:ret = 25;
                      break;
            case 253: if(adr == 0) reg == 0? ret = 2:ret = 10;
                      if(adr == 1) reg == 0? ret = 18:ret = 26;
                      break;
            case 251: if(adr == 0) reg == 0? ret = 3:ret = 11;
                      if(adr == 1) reg == 0? ret = 19:ret = 27;
                      break;
            case 247: if(adr == 0) reg == 0? ret = 4:ret = 12;
                      if(adr == 1) reg == 0? ret = 20:ret = 28;
                      break;
            case 239: if(adr == 0) reg == 0? ret = 5:ret = 13;
                      if(adr == 1) reg == 0? ret = 21:ret = 29;
                      break;
            case 223: if(adr == 0) reg == 0? ret = 6:ret = 14;
                      if(adr == 1) reg == 0? ret = 22:ret = 30;
                      break;
            case 191: if(adr == 0) reg == 0? ret = 7:ret = 15;
                      if(adr == 1) reg == 0? ret = 23:ret = 31;
                      break;
            case 127: if(adr == 0) reg == 0? ret = 8:ret = 16;
                      if(adr == 1) reg == 0? ret = 24:ret = 32;
                      break;

            default : if(adr == 0) reg == 0? ret = 1:ret = 9;
                      if(adr == 1) reg == 0? ret = 17:ret = 25;
                      break;
        }
    }
    return ret;
}

