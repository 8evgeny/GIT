//Пример программы для вывода картинки на индикаторы MT-12232A, MT-12232C, MT-12232D

void main(void) {
byte	p;//Номер текущей страницы индикатора
byte	c;//Позиция по горизонтали выводимого байта

	LCDinit();
	for(p=0; p<4; p++) {//Цикл по всем 4-м страницам индикатора
		WriteCodeL(p|0xB8);//Установка текущей страницы для левого кристалла индикатора
		WriteCodeL(0x13);//Установка текущего адреса для записи данных в левую отображаемую позицию левой половины индикатора
		for(c=0; c<61; c++) {//Цикл вывода данных в левую половину индикатора
			WriteDataL(Logo122[p][c]);//Вывод очередного байта в индикатор
		}
		WriteCodeR(p|0xB8);//Установка текущей страницы для правого кристалла индикатора
		WriteCodeR(0x00);//Установка текущего адреса для записи данных в левую отображаемую позицию правой половины индикатора
		for(c=61; c<122; c++) {//Цикл вывода данных в правую половину индикатора
			WriteDataR(Logo122[p][c]);//Вывод очередного байта в индикатор
		}
	}
}

//Процедура программной инициализации индикатора
void LCDinit(void) {
	LCD.E=1;//Начальное значение сигнала индикатору
	LCD.RES=0;//Выдать сигнал RES=0 индикатору
	Delay(>10us);//Задержка на время больше 10 мкс
	LCD.RES=1;//Снять сигнал RES
	Delay(>1ms);//Задержка на время больше 1 мс
	WriteCodeL(0xE2);//Reset
	WriteCodeR(0xE2);//Reset
	WriteCodeL(0xEE);//ReadModifyWrite off
	WriteCodeR(0xEE);//ReadModifyWrite off
	WriteCodeL(0xA4);//Включить обычный режим
	WriteCodeR(0xA4);//Включить обычный режим
	WriteCodeL(0xA9);//Мультиплекс 1/32
	WriteCodeR(0xA9);//Мультиплекс 1/32
	WriteCodeL(0xC0);//Верхнюю строку на 0
	WriteCodeR(0xC0);//Верхнюю строку на 0
	WriteCodeL(0xA1);//Invert scan RAM
	WriteCodeR(0xA0);//NonInvert scan RAM
	WriteCodeL(0xAF);//Display on
	WriteCodeR(0xAF);//Display on
}

void Pset(byte x, byte y, bit c) {//Записать одну точку в индикатор (координата 0,0 в левом верхнем углу индикатора)
byte c8;//Временное хранение считаного из индикатора байта
byte m8;//Маска нужного бита в байте
	if ((x>121)||(y>31)) return;//Выход за пределы индикатора
	if (x<61) {//Выводить в левую половину индикатора
		WriteCodeL(0xB8|(y>>3));//Установить нужную страницу индикатора
		WriteCodeL(0x13+x);//Установить адрес нужного байта
		c8=ReadDataL();//Фиктивное чтение
		c8=ReadDataL();//Чтение нужного байта из индикатора
		m8=1<<(y&0x07);//Вычислить маску нужного бита в байте
		if (c==1)	//Зажигать точку?
			c8|=m8//Установить нужный бит в байте
		else		//Или гасить точку?
			c8&=~m8;//Сбросить нужный бит в байте
		WriteCodeL(0x13+x);//Снова установить адрес нужного байта
		WriteDataL(c8);//Записать изменённый байт обратно в индикатор
	} else {//Выводить в правую половину индикатора
		WriteCodeR(0xB8|(y>>3));//Установить нужную страницу индикатора
		WriteCodeR(x-61);//Установить адрес нужного байта
		c8=ReadDataR();//Фиктивное чтение
		c8=ReadDataR();//Чтение нужного байта из индикатора
		m8=1<<(y&0x07);//Вычислить маску нужного бита в байте
		if (c==1)	//Зажигать точку?
			c8|=m8//Установить нужный бит в байте
		else		//Или гасить точку?
			c8&=~m8;//Сбросить нужный бит в байте
		WriteCodeR(x-61);//Снова установить адрес нужного байта
		WriteDataR(c8);//Записать изменённый байт обратно в индикатор
	}
}

void WriteCodeL(byte b) { WriteByte(b,0,1); }//Команду в левый кристалл индикатора
void WriteCodeR(byte b) { WriteByte(b,0,0); }//Команду в правый кристалл индикатора

void WriteDataL(byte b) { WriteByte(b,1,1); }//Данные в левую половину индикатора
void WriteDataR(byte b) { WriteByte(b,1,0); }//Данные в правую половину индикатора

byte ReadDataL(void) { return ReadByte(1,1); }//Прочитать байт данных из левой половины индикатора
byte ReadDataR(void) { return ReadByte(1,0); }//Прочитать байт данных из правой половины индикатора

//Процедура выдачи байта в индикатор
void WriteByte(byte b, bit cd, bit lr) {
//При необходимости настроить здесь шину данных на вывод
	LCD.RW=0; LCD.A0=cd;	//Выдача байта в индикатор как данных или команды
	LCD.CS=lr; LCD.D=b;	//Выбрать кристалл индикатора и выдать байт на шину данных индикатора
	Delay(>40ns);		//Это время предустановки адреса (tAW)
	LCD.E=0; Delay(>160ns);	//Длительность сигнала E=0 (время предустановки данных попало сюда (tDS))
	LCD.E=1;		//Сбросить сигнал E индикатору
	Delay(>(2000ns-40ns-160ns));	//Минимально допустимый интервал между сигналами E=0
}

byte ReadByte(bit cd, bit lr) {
byte b;
//При необходимости настроить здесь шину данных на ввод
	LCD.RW=1; LCD.A0=cd;	//Будем читать байт как команду или данные
	LCD.CS=lr;		//Выбрать нужный кристалл индикатора
	Delay(>40ns);		//Это время предустановки адреса (tAW)
	LCD.E=0; Delay(>300ns);	//Минимально допустимая длительность сигнала E=0 (время доступа (tACC) попало сюда)
	b=LCD.D;		//Прочитать данные с шины индикатора (они на ней уже минимум 120нс)
	LCD.E=1;		//Сбросить сигнал E индикатору
	Delay(>(2000ns-40ns-300ns));	//Минимально допустимый интервал между сигналами E=0
	return b;		//Вернуть прочитанный байт
}

//Данные изображения, побитые по строкам и байты будут на индикаторе вертикально.
//Это просто последовательность байт для записи в индикатор начиная с верхней страницы.
//Полностью соответствуют картинке распределения ОЗУ в документации на модуль.
const byte Logo122[4][122]=//122x32 pixel, каждые 8 вертикальных точек собраны в байт
{
	{	0xFF,0x01,0x01,0x01,0x01,0xC1,0xE1,0xB1,0x11,0x1D,0x1D,0x7F,0x7F,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFD,0xFD,0xF9,0xB1,
		0xF1,0xE1,0x81,0x01,0x01,0x01,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
		0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
		0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
		0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
		0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
		0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xFF
	},
	{	0xFF,0xE0,0x7C,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0x6F,0x6F,0x07,
		0x07,0x06,0x00,0x00,0x03,0x03,0x0F,0x3F,0x07,0x07,0x07,0x03,0x03,0x07,0x0F,0x3B,
		0x13,0x80,0x80,0x23,0x9E,0xF8,0xF8,0xF8,0xFC,0xFE,0xFE,0xFE,0xFC,0x00,0x00,0x00,
		0x80,0x80,0xE0,0xF8,0xFC,0xFE,0xFE,0xFE,0xFC,0x00,0x00,0x00,0x60,0xF0,0xF8,0xF8,
		0x7C,0x3E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x3E,0x3E,0x7E,0xFC,0xF8,0xF0,0xE0,
		0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF8,0xFC,0xFE,
		0xFE,0xFE,0xFE,0xFC,0x00,0x1C,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0xFE,0xFE,0xFE,
		0xFE,0xFE,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x1C,0xFF
	},
	{	0xFF,0x07,0x7C,0xE0,0x80,0x00,0x1F,0x3F,0xFF,0xFF,0xFF,0xFF,0x0F,0x30,0x38,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
		0xE0,0xF0,0xFC,0xFF,0xFF,0x3F,0x0F,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0xFE,0xFF,
		0x7F,0x7F,0x1F,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x18,0x3C,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x3C,0x3C,0x18,0x00,0x00,0x01,0xFF,
		0xFF,0xFF,0xFF,0x00,0x00,0x80,0xE0,0xF0,0xFC,0xFE,0xFF,0x7F,0x1F,0x07,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,
		0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF
	},
		0xFF,0x80,0x80,0x80,0x80,0x83,0x86,0x8C,0x98,0xB0,0xB0,0xE0,0xC0,0xC0,0x80,0x80,
		0x80,0x80,0x80,0x80,0x80,0x80,0xC0,0xC0,0xC0,0xC0,0xC0,0xE0,0xF8,0xFC,0xFF,0xFF,
		0xBF,0x8F,0x87,0x81,0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0x9F,0x83,0x80,
		0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x80,0x80,0x86,0x8F,0x9F,0xBF,
		0xFE,0xFC,0xF8,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF8,0xF8,0xFC,0xFE,0xBF,0x9F,0x8F,
		0x87,0xE3,0xF9,0xFC,0xFF,0xFF,0xBF,0x9F,0x87,0x81,0x80,0x80,0x80,0x80,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,
		0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF
	}
};
