//******************************************************************************
//  Секция include: здесь подключается заголовочный файл к модулю
//******************************************************************************
#include  <stdint.h>
#include "RCC_HSE_Init.h"      // Включаем файл заголовка для нашего модуля

//******************************************************************************
//  Секция определения переменных, используемых в модуле
//******************************************************************************
//
//------------------------------------------------------------------------------
// Глобальные
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Локальные
//------------------------------------------------------------------------------
//******************************************************************************
//  Секция прототипов локальных функций
//******************************************************************************

//******************************************************************************
//  Секция описания глобальных функций
//******************************************************************************

/*
 * Настройка внутреннего генератора на масимальную частоту.
 * Запуск идёт от внешнего кварцевого резонатора
 */
void SystemClock_Config(uint8_t Quartz)
{
  uint8_t
    Div_HSE,
    Mul_PLL;

  RCC->APB1ENR |= RCC_APB1ENR_PWREN;
  RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
  uint32_t StartUpCounter;

  RCC->CR |= RCC_CR_HSEON;                                                      // Запускаем генератор HSE
  for (StartUpCounter = 0;; StartUpCounter++)                                   // В цикле ждём определённое время ожидая запуска
  {
    if(RCC->CR & RCC_CR_HSERDY) break;                                          // Запуск есть, выходим из цикла
    if(StartUpCounter > 0x1000)
    {
      RCC->CR &= ~RCC_CR_HSEON;                                                 // Отключаем HSE
      return;                                                                   // Запуска нет, выходим из функции
    }
  }

  switch (Quartz)
  {
    case Quartz_8:
      Div_HSE = HSE_Div_1;
      Mul_PLL = PLL_Mul_9;
      HSE_Value = 8000000;
      break;
    case Quartz_12:
      Div_HSE = HSE_Div_2;
      Mul_PLL = PLL_Mul_12;
      HSE_Value = 12000000;
      break;
    case Quartz_16:
      Div_HSE = HSE_Div_2;
      Mul_PLL = PLL_Mul_9;
      HSE_Value = 16000000;
      break;
    case Quartz_24:
      Div_HSE = HSE_Div_3;
      Mul_PLL = PLL_Mul_9;
      HSE_Value = 24000000;
      break;
    case Quartz_32:
      Div_HSE = HSE_Div_4;
      Mul_PLL = PLL_Mul_9;
      HSE_Value = 32000000;
      break;
    default:
      Div_HSE = HSE_Div_1;
      Mul_PLL = PLL_Mul_9;
      HSE_Value = 8000000;
      break;
  }

  RCC->CFGR2  &= ~RCC_CFGR2_PREDIV;                                             // Обнуляем предделитель HSE
  RCC->CFGR2  |= Div_HSE;                                                       // Устанавливаем предделитель HSE
  RCC->CFGR   &= ~RCC_CFGR_PLLMUL;                                              // Сбрасываем умножитель PLL
  RCC->CFGR   |= Mul_PLL;                                                       // Устанавливаем множитель PLL
  RCC->CFGR   &= ~RCC_CFGR_USBPRE;                                              // Сбрасываем бит делителя USB для установки деления на 1.5

  RCC->CR |= RCC_CR_PLLON;                                                      // Включаем PLL

  for (StartUpCounter = 0;; StartUpCounter++)
  {
    if(RCC->CR & RCC_CR_PLLRDY) break;                                          // Запустился, вываливаемся из цикла
    if(StartUpCounter > 0x1000)                                                 // Не запустился гад
    {
      RCC->CR &= ~RCC_CR_HSEON;                                                 // Отключаем HSE
      RCC->CR &= ~RCC_CR_PLLON;                                                 //Останавливаем PLL
      return;
    }
  }

  FLASH->ACR |= (0x02 << FLASH_ACR_LATENCY_Pos);                                // Таймаут FLASH=2, т.к. частота задающего генератора 72 МГц

  //Делители для шин
  RCC->CFGR |= (0x00 << RCC_CFGR_PPRE2_Pos)                                     //Делитель шины APB2 равен 2
            |  (0x04 << RCC_CFGR_PPRE1_Pos)                                     //Делитель нишы APB1 равен 4
            |  (0x00 << RCC_CFGR_HPRE_Pos);                                     //Делитель AHB отключен (оставляем 0 по умолчанию)

  RCC->CFGR |= (0x02 << RCC_CFGR_SW_Pos);                                       // Переключаемся на работу от PLL

  while ((RCC->CFGR & RCC_CFGR_SWS_Msk) != (0x02 << RCC_CFGR_SWS_Pos))          // Ждём переключения
  {
  }

    SysTickConfig();                                                            // Вызываем настройку системного таймера SysTick
}

//******************************************************************************
//  Секция описания локальных функций
//******************************************************************************
//******************************************************************************
//  ENF OF FILE
//******************************************************************************

